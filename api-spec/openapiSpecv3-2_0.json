/**
 * This file is for to generate and manipulate restapi v2 spec file through sofaapi.
 */
import { makeExecutableSchema } from '@graphql-tools/schema';
import { getOpenAPISpec } from '@thoughtspot/graph-to-openapi';
import { GraphQLSchema, GraphQLObjectType } from 'graphql';
import fs from 'fs';
import path from 'path';
import { getDirective } from '@graphql-tools/utils';
import * as yaml from 'js-yaml';
import { resolvers } from '../src/apis/restapi-resolvers';
import typeDefsBeta from '../src/apis/restapi/restapi-schema.graphql';
import typeDefs from '../src/public-apis/api-schema.graphql';
import { logger } from '../src/common/logger';
import {
  modifyFieldWithEnum,
  responseAsFileOperationIds,
  unAuthenticatedEndPoints,
  addOrModifySchemas,
  multiPartFormDataApis,
} from './generate-restapi-v2-spec-config';

/**
 * This function pares and returns data from files mapped to the fileName
 * @param allPaths - Paths to all files
 * @param extension - Extension of the files to be considered
 * @returns
 */
const parseContentFromFiles = (allPaths: string[], extension: string) => {
  const dataObject: {
    [key: string]: string;
  } = {};
  allPaths
    .filter(filePath => path.extname(filePath) === extension)
    .forEach(filePath => {
      const data = fs.readFileSync(filePath).toString();
      const fileName = path.parse(filePath).name;
      dataObject[fileName] = data;
    });
  return dataObject;
};

/**
 * Function to get all paths in a folder
 * @param basePath - base path of the folder
 * @returns returns path of all files in the folder
 */
function getAllFiles(basePath: string): string[] {
  let files: string[] = [];
  try {
    if (fs.existsSync(basePath)) {
      fs.readdirSync(basePath).forEach(file => {
        const filePath = path.join(basePath, file);
        const fileStat = fs.statSync(filePath);
        if (fileStat.isFile()) {
          files.push(filePath);
        } else if (fileStat.isDirectory()) {
          const subFolderFiles = getAllFiles(filePath);
          files = [...files, ...subFolderFiles];
        }
      });
    }
  } catch (e) {
    console.error(e);
  }
  return files;
}
/**
 *
 * @param operationId - OperationId to get the operation from the spec
 * @param spec - OpenAPI spec
 * @returns
 */
function getOperationFromOperationId(operationId: string, spec: any) {
  const paths = Object.keys(spec.paths);

  for (let pathItr = 0; pathItr < paths.length; pathItr++) {
    const specPath = paths[pathItr];
    const methods = Object.keys(spec.paths[specPath]);

    for (let methodItr = 0; methodItr < methods.length; methodItr++) {
      const method = methods[methodItr];
      if (spec.paths[specPath][method].operationId === operationId) {
        return {
          path: specPath,
          method,
          operation: spec.paths[specPath][method],
        };
      }
    }
  }

  return null;
}

type FieldDoc = Record<string, { text: string; tags?: string[] }>;
/**
 * Parses the provided file content to extract fields and their associated tags.
 *
 * @param fileContent - The content of the file to be parsed.
 * The content should include fields marked by `# field_start` and `# field_end` tags.
 * The `# field_start` tag can also include optional tags prefixed with `@`.
 *
 * @returns - An object where each key is the field name and the value is an object containing
 * the field's text and an array of associated tags (if any).
 */
function parseFieldDocs(fileContent: string): FieldDoc {
  const fields: FieldDoc = {};
  const regex = /# field_start (\w+)(.*?)\n([\s\S]*?)# field_end \1/g;

  const matches = fileContent.matchAll(regex);
  Array.from(matches).forEach(match => {
    const fieldName = match[1];
    const tagsString: string = match[2].trim();
    const tags = tagsString ? tagsString.split(/\s+/) : [];
    const fieldText = match[3].trim();
    fields[fieldName] = {
      text: fieldText,
      tags,
    };
  });

  return fields;
}

/**
 * Updates the description of the fields in the provided component based on the content of the
 * field documentation.
 *
 * @param fieldContent - field content to be updated
 * @param component - component to be updated
 * @returns
 */
function updateComponentField(fieldContent: string, component: any, componentName = 'Component') {
  const updatedComponent = { ...component };
  if (fieldContent && component) {
    const fieldDocs = parseFieldDocs(fieldContent);
    Object.keys(fieldDocs).forEach(field => {
      const { tags: fieldTag = [] } = fieldDocs[field];
      const isRequired = component.required?.includes(field);

      const tags = fieldTag.map(tag => {
        const [name, value] = tag.slice(1).split('=');
        return value ? { name: name.trim(), value } : { name };
      });

      const hiddenTag = tags.find(t => t.name === 'hidden');
      if (hiddenTag) {
        if (!isRequired) {
          delete updatedComponent.properties[field];
          logger.info(`Removed field: ${componentName} field ${field} description`);
          return;
        }
        logger.info(`Skipped hiding field: ${componentName} field ${field} since it is required`);
      }

      let fieldText = fieldDocs[field].text;

      const versionTag = tags.find(t => t.name === 'version');
      if (versionTag) {
        fieldText += `\n<span class="since-beta-tag">Version: ${versionTag.value ||
          ''} or later</span>\n`;
      }

      const deprecatedTag = tags.find(t => t.name === 'deprecated');
      if (deprecatedTag) {
        fieldText += `\n<span class="since-beta-tag">Deprecated from: ${deprecatedTag.value ||
          ''} and later</span>\n`;
      }

      updatedComponent.properties[field].description = fieldText;
      logger.info(`Updated ${componentName} field ${field} description`);
    });
  }
  return updatedComponent;
}

/**
 *
 * @param schema - GraphQL schema
 * @param fileName -file name to save the spec
 */
async function generateSpecFile(
  schema: GraphQLSchema,
  basePath: string,
  fileName: string,
  version: string,
  // This flag is used to add custom documentation and examples
  updateDocAndExample = true,
) {
  const { spec } = getOpenAPISpec({
    schema,
    info: {
      title: 'ThoughtSpot Public REST API',
      version,
    },
    basePath,
  });
  spec.servers = [
    {
      url: '{base-url}',
      variables: {
        'base-url': {
          default: 'https://localhost:443',
        },
      },
    },
  ];
  spec.security = [
    {
      bearerAuth: [],
    },
  ];
  spec.components.securitySchemes = {
    bearerAuth: { type: 'http', scheme: 'bearer' },
  };

  if (updateDocAndExample) {
    const BACKEND_YAML_FILEPATH =
      '../callosum/server/src/main/java/com/thoughtspot/callosum/server/services/api/rest/v2/openapi.yaml';

    // doc folder where docs and examples are kept
    const REST_API_DOC_FOLDER = 'src/public-apis/docs';

    // collect all files in doc
    const allFiles = getAllFiles(REST_API_DOC_FOLDER);

    // parse all doc data from md files
    const docs = parseContentFromFiles(allFiles, '.md');
    // parse all examples from json files
    const examples = parseContentFromFiles(allFiles, '.json');

    // parse the backend yaml spec
    const backendSpec: any = yaml.load(fs.readFileSync(BACKEND_YAML_FILEPATH).toString());

    // using the schema to map the frontend path with backend path
    const { Query, Mutation } = schema.getTypeMap();
    const schemaOperations = {
      ...(Query as GraphQLObjectType).getFields(),
      ...(Mutation as GraphQLObjectType).getFields(),
    };

    // this the common ErrorResponse used for all 4xx and 5xx responses
    // const errorResponseContent = {
    //   'application/json': {
    //     schema: {
    //       $ref: '#/components/schemas/ErrorResponse',
    //     },
    //   },
    // };

    // all the paths in graphqlSpec
    const paths = Object.keys(spec.paths);
    paths.forEach((graphqlPath: any) => {
      // methods available for our path
      const methods = Object.keys(spec.paths[graphqlPath]);

      // For each method we need to update the doc and responses
      methods.forEach((method: any) => {
        const operation = spec.paths[graphqlPath][method];

        // we need the backend path that the current operation points to , to get the responses available
        const currentSchemaOperation = schemaOperations[operation.operationId];
        const callosumDirective: any = getDirective(
          schema,
          currentSchemaOperation,
          'callosum',
        )?.[0];
        // we need to convert paths from "/path/{pathParam}?query=value" to "/path"
        const backendSpecPath = callosumDirective.path.split('?')[0].replace(/\$([^/]+)/g, '{$1}');

        // updating responses
        const backendSpecOperation =
          backendSpec.paths[backendSpecPath][callosumDirective.method.toLowerCase()];

        // need to update spec based on backendSpec
        // for 200
        // take schema from currentSpec rest from backend spec
        const backendSpecResponses = Object.keys(backendSpecOperation.responses);
        const updatedResponseObject = backendSpecResponses.reduce((acc, code) => {
          // we need to copy the description
          acc[code] = {
            description: backendSpecOperation.responses[code].description,
          };

          if (code.startsWith('4') || code.startsWith('5')) {
            acc[code].content = {
              'application/json': {
                schema: {
                  $ref: '#/components/schemas/ErrorResponse',
                },
              },
            };
          } else if (code !== '204') {
            // we only copy the content from current spec
            // If code is 204 there is no content set
            acc[code].content = operation.responses[code].content;
          }

          return acc;
        }, {} as any);

        // according to openapi specifications file content transferred in binary (octet-stream) MAY omit schema
        if (responseAsFileOperationIds.includes(operation.operationId)) {
          updatedResponseObject['200'].content = {
            'application/octet-stream': {},
          };
        }
        // replace the responses generated by getOpenApiSpec with the updated
        operation.responses = updatedResponseObject;

        // TODO : remove the below quick fix once the issue is fixed
        // Quick fix for SCAL-158578
        if (operation.requestBody) {
          operation.requestBody.required = true;
        }

        // if a doc file is found for our operationId i.e login.md for login
        if (docs[operation.operationId]) {
          const docContent = docs[operation.operationId];
          // we prepend the description using the md file data
          operation.description = `\n${operation.description || ''}\n\n${docContent ||
            ''}\n\n\n\n#### Endpoint URL\n`;
          logger.info(`Updated ${operation.operationId} documentation`);
        }

        // update field descriptions
        const fieldContent = docs[`${operation.operationId}.fields`];
        if (operation?.requestBody?.content?.['application/json']?.schema) {
          operation.requestBody.content['application/json'].schema = updateComponentField(
            fieldContent,
            operation.requestBody.content['application/json'].schema,
            operation.operationId,
          );
        }

        // update all fields to allOf
        Object.keys(
          operation.requestBody?.content?.['application/json'].schema.properties || {},
        ).forEach(field => {
          if (
            operation.requestBody?.content?.['application/json']?.schema.properties[field]?.$ref
          ) {
            operation.requestBody.content['application/json'].schema.properties[field].allOf = [
              {
                $ref:
                  operation.requestBody.content['application/json'].schema.properties[field].$ref,
              },
            ];
            delete operation.requestBody.content['application/json'].schema.properties[field].$ref;
          }
        });

        // if an example file is found for our operationId i.e login.json for login
        if (examples[operation.operationId]) {
          const docExamples = JSON.parse(examples[operation.operationId]);
          // response code that our apis send
          const responseCodes = Object.keys(operation.responses);
          // examples data passed in file
          const responseCodesInExamples = Object.keys(docExamples);
          // the responses to update
          const responseToUpdate = responseCodes.filter(code =>
            responseCodesInExamples.includes(code),
          );
          responseToUpdate.forEach(code => {
            operation.responses[code].content['application/json'].examples = docExamples[code];
          });
          logger.info(`Updated ${operation.operationId} examples for ${responseToUpdate}`);
        }
      });
    });

    const components = Object.keys(spec.components.schemas);
    components.forEach(schemaName => {
      if (docs[schemaName]) {
        const component = spec.components.schemas[schemaName];
        spec.components.schemas[schemaName].description = docs[schemaName];
        logger.info(`Updated ${schemaName} documentation`);

        const fieldContent = docs[`${schemaName}.fields`];
        spec.components.schemas[schemaName] = updateComponentField(
          fieldContent,
          component,
          schemaName,
        );
      }
    });

    // make all optional fields nullable
    const schemas = Object.keys(spec.components.schemas);
    schemas.forEach(schemaName => {
      const reqFields = spec.components.schemas[schemaName].required || [];
      const { properties } = spec.components.schemas[schemaName];
      Object.keys(properties).forEach(propertyName => {
        if (!reqFields.includes(propertyName)) {
          properties[propertyName].nullable = true;
        }
      });
      spec.components.schemas[schemaName].properties = properties;
    });
  }

  await unAuthenticatedEndPoints.forEach(d => {
    if (spec.paths[d?.path] && spec.paths[d?.path][d?.method?.toLowerCase()]) {
      spec.paths[d?.path][d?.method?.toLowerCase()].security = [];
    }
  });

  await modifyFieldWithEnum.forEach(d => {
    if (spec.paths[d?.path] && spec.paths[d?.path][d?.method?.toLowerCase()]) {
      spec.paths[d?.path][d?.method?.toLowerCase()].requestBody.content[
        'application/json'
      ].schema.properties[d?.field].enum = d.enum;
    }
  });

  await addOrModifySchemas.forEach(d => {
    if (spec.components.schemas[d?.schema]) {
      spec.components.schemas[d?.schema].properties[d?.field] = d.value;
      d?.refSchemas.forEach((item: any) => {
        const key = Object.keys(item)[0];
        const value = item[key];
        spec.components.schemas[key] = value;
      });
    }
  });

  // File uploading paths
  const fileUploadPaths = [
    '/api/rest/2.0/dbt/dbt-connection',
    '/api/rest/2.0/dbt/generate-tml',
    '/api/rest/2.0/dbt/generate-sync-tml',
    '/api/rest/2.0/dbt/update-dbt-connection',
  ];

  // The below loop will add format: binary to show up file upload feature in v2 playground
  fileUploadPaths.forEach((fileUploadPath: string) => {
    if (spec.paths[fileUploadPath]) {
      const requestBody =
        spec.paths[fileUploadPath].post.requestBody.content['application/json'].schema.properties;
      requestBody.file_content = {
        ...requestBody.file_content,
        format: 'binary',
      };
    }
  });

  multiPartFormDataApis.forEach(api => {
    const match = getOperationFromOperationId(api, spec);

    if (!match) {
      return;
    }

    const { path: specPath, method } = match;

    if (spec.paths[specPath][method].requestBody.content['application/json']) {
      spec.paths[specPath][method].requestBody.content['multipart/form-data'] =
        spec.paths[specPath][method].requestBody.content['application/json'];
      delete spec.paths[specPath][method].requestBody.content['application/json'];
    }
  });

  await fs.promises.writeFile(`${fileName}`, JSON.stringify(spec, null, 2));
  logger.info(`${fileName} generated`);
}

const schemaBeta: GraphQLSchema = makeExecutableSchema({
  typeDefs: typeDefsBeta,
  resolvers: resolvers as any,
});
// generateSpecFile(schemaBeta, '/tspublic/rest', 'openapiSpecv3.json', '2-beta');

const schema: GraphQLSchema = makeExecutableSchema({
  typeDefs,
});

generateSpecFile(schema, '/api/rest/2.0', 'openapiSpecv3-2_0.json', '2.0');
