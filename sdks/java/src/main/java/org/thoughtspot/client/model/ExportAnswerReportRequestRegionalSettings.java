/*
 * ThoughtSpot Public REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.thoughtspot.client.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import org.openapitools.jackson.nullable.JsonNullable;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonDeserializationContext;
import com.google.gson.JsonDeserializer;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.reflect.TypeToken;
import com.google.gson.TypeAdapter;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;

import java.lang.reflect.Type;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import org.thoughtspot.client.JSON;

/**
 * Options for specific region speciic overrides to support date/number/string/currency formatting.
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-03-13T10:56:34.609498487Z[Etc/UTC]")
public class ExportAnswerReportRequestRegionalSettings {
  /**
   * ISO code to be appended with currency values.
   */
  @JsonAdapter(CurrencyFormatEnum.Adapter.class)
  public enum CurrencyFormatEnum {
    ADP("ADP"),
    
    AED("AED"),
    
    AFN("AFN"),
    
    ALL("ALL"),
    
    AMD("AMD"),
    
    ANG("ANG"),
    
    AOA("AOA"),
    
    ARA("ARA"),
    
    ARS("ARS"),
    
    ATS("ATS"),
    
    AUD("AUD"),
    
    AWG("AWG"),
    
    AZN("AZN"),
    
    BAM("BAM"),
    
    BBD("BBD"),
    
    BDT("BDT"),
    
    BEF("BEF"),
    
    BGL("BGL"),
    
    BGM("BGM"),
    
    BGN("BGN"),
    
    BHD("BHD"),
    
    BIF("BIF"),
    
    BMD("BMD"),
    
    BND("BND"),
    
    BOB("BOB"),
    
    BOP("BOP"),
    
    BOV("BOV"),
    
    BRL("BRL"),
    
    BSD("BSD"),
    
    BTN("BTN"),
    
    BUK("BUK"),
    
    BWP("BWP"),
    
    BYN("BYN"),
    
    BZD("BZD"),
    
    CAD("CAD"),
    
    CDF("CDF"),
    
    CHE("CHE"),
    
    CHF("CHF"),
    
    CHW("CHW"),
    
    CLE("CLE"),
    
    CLP("CLP"),
    
    CNX("CNX"),
    
    CNY("CNY"),
    
    COP("COP"),
    
    COU("COU"),
    
    CRC("CRC"),
    
    CSK("CSK"),
    
    CUC("CUC"),
    
    CUP("CUP"),
    
    CVE("CVE"),
    
    CYP("CYP"),
    
    CZK("CZK"),
    
    DDM("DDM"),
    
    DEM("DEM"),
    
    DJF("DJF"),
    
    DKK("DKK"),
    
    DOP("DOP"),
    
    DZD("DZD"),
    
    ECS("ECS"),
    
    ECV("ECV"),
    
    EEK("EEK"),
    
    EGP("EGP"),
    
    ERN("ERN"),
    
    ESP("ESP"),
    
    ETB("ETB"),
    
    EUR("EUR"),
    
    FIM("FIM"),
    
    FJD("FJD"),
    
    FKP("FKP"),
    
    FRF("FRF"),
    
    GBP("GBP"),
    
    GEK("GEK"),
    
    GEL("GEL"),
    
    GHS("GHS"),
    
    GIP("GIP"),
    
    GMD("GMD"),
    
    GNF("GNF"),
    
    GNS("GNS"),
    
    GQE("GQE"),
    
    GRD("GRD"),
    
    GTQ("GTQ"),
    
    GWE("GWE"),
    
    GWP("GWP"),
    
    GYD("GYD"),
    
    HKD("HKD"),
    
    HNL("HNL"),
    
    HRD("HRD"),
    
    HRK("HRK"),
    
    HTG("HTG"),
    
    HUF("HUF"),
    
    IDR("IDR"),
    
    IEP("IEP"),
    
    ILP("ILP"),
    
    ILS("ILS"),
    
    INR("INR"),
    
    IQD("IQD"),
    
    IRR("IRR"),
    
    ISK("ISK"),
    
    ITL("ITL"),
    
    JMD("JMD"),
    
    JOD("JOD"),
    
    JPY("JPY"),
    
    KES("KES"),
    
    KGS("KGS"),
    
    KHR("KHR"),
    
    KMF("KMF"),
    
    KPW("KPW"),
    
    KRW("KRW"),
    
    KWD("KWD"),
    
    KYD("KYD"),
    
    KZT("KZT"),
    
    LAK("LAK"),
    
    LBP("LBP"),
    
    LKR("LKR"),
    
    LRD("LRD"),
    
    LSL("LSL"),
    
    LTL("LTL"),
    
    LTT("LTT"),
    
    LUC("LUC"),
    
    LUF("LUF"),
    
    LUL("LUL"),
    
    LVL("LVL"),
    
    LVR("LVR"),
    
    LYD("LYD"),
    
    MAD("MAD"),
    
    MAF("MAF"),
    
    MCF("MCF"),
    
    MDC("MDC"),
    
    MDL("MDL"),
    
    MGA("MGA"),
    
    MGF("MGF"),
    
    MKD("MKD"),
    
    MLF("MLF"),
    
    MMK("MMK"),
    
    MNT("MNT"),
    
    MOP("MOP"),
    
    MRU("MRU"),
    
    MTL("MTL"),
    
    MTP("MTP"),
    
    MUR("MUR"),
    
    MVR("MVR"),
    
    MWK("MWK"),
    
    MXN("MXN"),
    
    MXV("MXV"),
    
    MYR("MYR"),
    
    MZE("MZE"),
    
    MZN("MZN"),
    
    NAD("NAD"),
    
    NGN("NGN"),
    
    NIO("NIO"),
    
    NLG("NLG"),
    
    NOK("NOK"),
    
    NPR("NPR"),
    
    NZD("NZD"),
    
    OMR("OMR"),
    
    PAB("PAB"),
    
    PEI("PEI"),
    
    PEN("PEN"),
    
    PGK("PGK"),
    
    PHP("PHP"),
    
    PKR("PKR"),
    
    PLN("PLN"),
    
    PTE("PTE"),
    
    PYG("PYG"),
    
    QAR("QAR"),
    
    RHD("RHD"),
    
    RON("RON"),
    
    RSD("RSD"),
    
    RUB("RUB"),
    
    RWF("RWF"),
    
    SAR("SAR"),
    
    SBD("SBD"),
    
    SCR("SCR"),
    
    SDG("SDG"),
    
    SEK("SEK"),
    
    SGD("SGD"),
    
    SHP("SHP"),
    
    SIT("SIT"),
    
    SKK("SKK"),
    
    SLL("SLL"),
    
    SOS("SOS"),
    
    SRD("SRD"),
    
    SRG("SRG"),
    
    SSP("SSP"),
    
    STN("STN"),
    
    SUR("SUR"),
    
    SVC("SVC"),
    
    SYP("SYP"),
    
    SZL("SZL"),
    
    THB("THB"),
    
    TJR("TJR"),
    
    TJS("TJS"),
    
    TMT("TMT"),
    
    TND("TND"),
    
    TOP("TOP"),
    
    TPE("TPE"),
    
    TRY("TRY"),
    
    TTD("TTD"),
    
    TWD("TWD"),
    
    TZS("TZS"),
    
    UAH("UAH"),
    
    UAK("UAK"),
    
    UGX("UGX"),
    
    USD("USD"),
    
    UYU("UYU"),
    
    UYW("UYW"),
    
    UZS("UZS"),
    
    VES("VES"),
    
    VND("VND"),
    
    VUV("VUV"),
    
    WST("WST"),
    
    XAF("XAF"),
    
    XAG("XAG"),
    
    XAU("XAU"),
    
    XBA("XBA"),
    
    XBB("XBB"),
    
    XCD("XCD"),
    
    XDR("XDR"),
    
    XEU("XEU"),
    
    XFO("XFO"),
    
    XFU("XFU"),
    
    XOF("XOF"),
    
    XPD("XPD"),
    
    XPF("XPF"),
    
    XPT("XPT"),
    
    XRE("XRE"),
    
    XSU("XSU"),
    
    XTS("XTS"),
    
    XUA("XUA"),
    
    XXX("XXX"),
    
    YDD("YDD"),
    
    YER("YER"),
    
    ZAR("ZAR"),
    
    ZMW("ZMW");

    private String value;

    CurrencyFormatEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static CurrencyFormatEnum fromValue(String value) {
      for (CurrencyFormatEnum b : CurrencyFormatEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<CurrencyFormatEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final CurrencyFormatEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public CurrencyFormatEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return CurrencyFormatEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_CURRENCY_FORMAT = "currency_format";
  @SerializedName(SERIALIZED_NAME_CURRENCY_FORMAT)
  private CurrencyFormatEnum currencyFormat;

  /**
   * Indicates the locale to be used for all formattings.
   */
  @JsonAdapter(UserLocaleEnum.Adapter.class)
  public enum UserLocaleEnum {
    EN_CA("en-CA"),
    
    EN_GB("en-GB"),
    
    EN_US("en-US"),
    
    DE_DE("de-DE"),
    
    JA_JP("ja-JP"),
    
    ZH_CN("zh-CN"),
    
    PT_BR("pt-BR"),
    
    FR_FR("fr-FR"),
    
    FR_CA("fr-CA"),
    
    ES_US("es-US"),
    
    DA_DK("da-DK"),
    
    ES_ES("es-ES"),
    
    FI_FI("fi-FI"),
    
    SV_SE("sv-SE"),
    
    NB_NO("nb-NO"),
    
    PT_PT("pt-PT"),
    
    NL_NL("nl-NL"),
    
    IT_IT("it-IT"),
    
    RU_RU("ru-RU"),
    
    EN_IN("en-IN");

    private String value;

    UserLocaleEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static UserLocaleEnum fromValue(String value) {
      for (UserLocaleEnum b : UserLocaleEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<UserLocaleEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final UserLocaleEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public UserLocaleEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return UserLocaleEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_USER_LOCALE = "user_locale";
  @SerializedName(SERIALIZED_NAME_USER_LOCALE)
  private UserLocaleEnum userLocale;

  /**
   * Indicates the locale to be used for number formatting.
   */
  @JsonAdapter(NumberFormatLocaleEnum.Adapter.class)
  public enum NumberFormatLocaleEnum {
    EN_CA("en-CA"),
    
    EN_GB("en-GB"),
    
    EN_US("en-US"),
    
    DE_DE("de-DE"),
    
    JA_JP("ja-JP"),
    
    ZH_CN("zh-CN"),
    
    PT_BR("pt-BR"),
    
    FR_FR("fr-FR"),
    
    FR_CA("fr-CA"),
    
    ES_US("es-US"),
    
    DA_DK("da-DK"),
    
    ES_ES("es-ES"),
    
    FI_FI("fi-FI"),
    
    SV_SE("sv-SE"),
    
    NB_NO("nb-NO"),
    
    PT_PT("pt-PT"),
    
    NL_NL("nl-NL"),
    
    IT_IT("it-IT"),
    
    RU_RU("ru-RU"),
    
    EN_IN("en-IN");

    private String value;

    NumberFormatLocaleEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static NumberFormatLocaleEnum fromValue(String value) {
      for (NumberFormatLocaleEnum b : NumberFormatLocaleEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<NumberFormatLocaleEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final NumberFormatLocaleEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public NumberFormatLocaleEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return NumberFormatLocaleEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_NUMBER_FORMAT_LOCALE = "number_format_locale";
  @SerializedName(SERIALIZED_NAME_NUMBER_FORMAT_LOCALE)
  private NumberFormatLocaleEnum numberFormatLocale;

  /**
   * Indicates the locale to be used for date formatting.
   */
  @JsonAdapter(DateFormatLocaleEnum.Adapter.class)
  public enum DateFormatLocaleEnum {
    EN_CA("en-CA"),
    
    EN_GB("en-GB"),
    
    EN_US("en-US"),
    
    DE_DE("de-DE"),
    
    JA_JP("ja-JP"),
    
    ZH_CN("zh-CN"),
    
    PT_BR("pt-BR"),
    
    FR_FR("fr-FR"),
    
    FR_CA("fr-CA"),
    
    ES_US("es-US"),
    
    DA_DK("da-DK"),
    
    ES_ES("es-ES"),
    
    FI_FI("fi-FI"),
    
    SV_SE("sv-SE"),
    
    NB_NO("nb-NO"),
    
    PT_PT("pt-PT"),
    
    NL_NL("nl-NL"),
    
    IT_IT("it-IT"),
    
    RU_RU("ru-RU"),
    
    EN_IN("en-IN");

    private String value;

    DateFormatLocaleEnum(String value) {
      this.value = value;
    }

    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    public static DateFormatLocaleEnum fromValue(String value) {
      for (DateFormatLocaleEnum b : DateFormatLocaleEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      return null;
    }

    public static class Adapter extends TypeAdapter<DateFormatLocaleEnum> {
      @Override
      public void write(final JsonWriter jsonWriter, final DateFormatLocaleEnum enumeration) throws IOException {
        jsonWriter.value(enumeration.getValue());
      }

      @Override
      public DateFormatLocaleEnum read(final JsonReader jsonReader) throws IOException {
        String value =  jsonReader.nextString();
        return DateFormatLocaleEnum.fromValue(value);
      }
    }
  }

  public static final String SERIALIZED_NAME_DATE_FORMAT_LOCALE = "date_format_locale";
  @SerializedName(SERIALIZED_NAME_DATE_FORMAT_LOCALE)
  private DateFormatLocaleEnum dateFormatLocale;

  public ExportAnswerReportRequestRegionalSettings() {
  }

  public ExportAnswerReportRequestRegionalSettings currencyFormat(CurrencyFormatEnum currencyFormat) {
    
    this.currencyFormat = currencyFormat;
    return this;
  }

   /**
   * ISO code to be appended with currency values.
   * @return currencyFormat
  **/
  @javax.annotation.Nullable
  public CurrencyFormatEnum getCurrencyFormat() {
    return currencyFormat;
  }


  public void setCurrencyFormat(CurrencyFormatEnum currencyFormat) {
    this.currencyFormat = currencyFormat;
  }


  public ExportAnswerReportRequestRegionalSettings userLocale(UserLocaleEnum userLocale) {
    
    this.userLocale = userLocale;
    return this;
  }

   /**
   * Indicates the locale to be used for all formattings.
   * @return userLocale
  **/
  @javax.annotation.Nullable
  public UserLocaleEnum getUserLocale() {
    return userLocale;
  }


  public void setUserLocale(UserLocaleEnum userLocale) {
    this.userLocale = userLocale;
  }


  public ExportAnswerReportRequestRegionalSettings numberFormatLocale(NumberFormatLocaleEnum numberFormatLocale) {
    
    this.numberFormatLocale = numberFormatLocale;
    return this;
  }

   /**
   * Indicates the locale to be used for number formatting.
   * @return numberFormatLocale
  **/
  @javax.annotation.Nullable
  public NumberFormatLocaleEnum getNumberFormatLocale() {
    return numberFormatLocale;
  }


  public void setNumberFormatLocale(NumberFormatLocaleEnum numberFormatLocale) {
    this.numberFormatLocale = numberFormatLocale;
  }


  public ExportAnswerReportRequestRegionalSettings dateFormatLocale(DateFormatLocaleEnum dateFormatLocale) {
    
    this.dateFormatLocale = dateFormatLocale;
    return this;
  }

   /**
   * Indicates the locale to be used for date formatting.
   * @return dateFormatLocale
  **/
  @javax.annotation.Nullable
  public DateFormatLocaleEnum getDateFormatLocale() {
    return dateFormatLocale;
  }


  public void setDateFormatLocale(DateFormatLocaleEnum dateFormatLocale) {
    this.dateFormatLocale = dateFormatLocale;
  }



  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExportAnswerReportRequestRegionalSettings exportAnswerReportRequestRegionalSettings = (ExportAnswerReportRequestRegionalSettings) o;
    return Objects.equals(this.currencyFormat, exportAnswerReportRequestRegionalSettings.currencyFormat) &&
        Objects.equals(this.userLocale, exportAnswerReportRequestRegionalSettings.userLocale) &&
        Objects.equals(this.numberFormatLocale, exportAnswerReportRequestRegionalSettings.numberFormatLocale) &&
        Objects.equals(this.dateFormatLocale, exportAnswerReportRequestRegionalSettings.dateFormatLocale);
  }

  private static <T> boolean equalsNullable(JsonNullable<T> a, JsonNullable<T> b) {
    return a == b || (a != null && b != null && a.isPresent() && b.isPresent() && Objects.deepEquals(a.get(), b.get()));
  }

  @Override
  public int hashCode() {
    return Objects.hash(currencyFormat, userLocale, numberFormatLocale, dateFormatLocale);
  }

  private static <T> int hashCodeNullable(JsonNullable<T> a) {
    if (a == null) {
      return 1;
    }
    return a.isPresent() ? Arrays.deepHashCode(new Object[]{a.get()}) : 31;
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExportAnswerReportRequestRegionalSettings {\n");
    sb.append("    currencyFormat: ").append(toIndentedString(currencyFormat)).append("\n");
    sb.append("    userLocale: ").append(toIndentedString(userLocale)).append("\n");
    sb.append("    numberFormatLocale: ").append(toIndentedString(numberFormatLocale)).append("\n");
    sb.append("    dateFormatLocale: ").append(toIndentedString(dateFormatLocale)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }


  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("currency_format");
    openapiFields.add("user_locale");
    openapiFields.add("number_format_locale");
    openapiFields.add("date_format_locale");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
  }

 /**
  * Validates the JSON Object and throws an exception if issues found
  *
  * @param jsonObj JSON Object
  * @throws IOException if the JSON Object is invalid with respect to ExportAnswerReportRequestRegionalSettings
  */
  public static void validateJsonObject(JsonObject jsonObj) throws IOException {
      if (jsonObj == null) {
        if (!ExportAnswerReportRequestRegionalSettings.openapiRequiredFields.isEmpty()) { // has required fields but JSON object is null
          throw new IllegalArgumentException(String.format("The required field(s) %s in ExportAnswerReportRequestRegionalSettings is not found in the empty JSON string", ExportAnswerReportRequestRegionalSettings.openapiRequiredFields.toString()));
        }
      }

      Set<Entry<String, JsonElement>> entries = jsonObj.entrySet();
      // check to see if the JSON string contains additional fields
      for (Entry<String, JsonElement> entry : entries) {
        if (!ExportAnswerReportRequestRegionalSettings.openapiFields.contains(entry.getKey())) {
          throw new IllegalArgumentException(String.format("The field `%s` in the JSON string is not defined in the `ExportAnswerReportRequestRegionalSettings` properties. JSON: %s", entry.getKey(), jsonObj.toString()));
        }
      }
      if ((jsonObj.get("currency_format") != null && !jsonObj.get("currency_format").isJsonNull()) && !jsonObj.get("currency_format").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `currency_format` to be a primitive type in the JSON string but got `%s`", jsonObj.get("currency_format").toString()));
      }
      if ((jsonObj.get("user_locale") != null && !jsonObj.get("user_locale").isJsonNull()) && !jsonObj.get("user_locale").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `user_locale` to be a primitive type in the JSON string but got `%s`", jsonObj.get("user_locale").toString()));
      }
      if ((jsonObj.get("number_format_locale") != null && !jsonObj.get("number_format_locale").isJsonNull()) && !jsonObj.get("number_format_locale").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `number_format_locale` to be a primitive type in the JSON string but got `%s`", jsonObj.get("number_format_locale").toString()));
      }
      if ((jsonObj.get("date_format_locale") != null && !jsonObj.get("date_format_locale").isJsonNull()) && !jsonObj.get("date_format_locale").isJsonPrimitive()) {
        throw new IllegalArgumentException(String.format("Expected the field `date_format_locale` to be a primitive type in the JSON string but got `%s`", jsonObj.get("date_format_locale").toString()));
      }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
       if (!ExportAnswerReportRequestRegionalSettings.class.isAssignableFrom(type.getRawType())) {
         return null; // this class only serializes 'ExportAnswerReportRequestRegionalSettings' and its subtypes
       }
       final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
       final TypeAdapter<ExportAnswerReportRequestRegionalSettings> thisAdapter
                        = gson.getDelegateAdapter(this, TypeToken.get(ExportAnswerReportRequestRegionalSettings.class));

       return (TypeAdapter<T>) new TypeAdapter<ExportAnswerReportRequestRegionalSettings>() {
           @Override
           public void write(JsonWriter out, ExportAnswerReportRequestRegionalSettings value) throws IOException {
             JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
             elementAdapter.write(out, obj);
           }

           @Override
           public ExportAnswerReportRequestRegionalSettings read(JsonReader in) throws IOException {
             JsonObject jsonObj = elementAdapter.read(in).getAsJsonObject();
             validateJsonObject(jsonObj);
             return thisAdapter.fromJsonTree(jsonObj);
           }

       }.nullSafe();
    }
  }

 /**
  * Create an instance of ExportAnswerReportRequestRegionalSettings given an JSON string
  *
  * @param jsonString JSON string
  * @return An instance of ExportAnswerReportRequestRegionalSettings
  * @throws IOException if the JSON string is invalid with respect to ExportAnswerReportRequestRegionalSettings
  */
  public static ExportAnswerReportRequestRegionalSettings fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ExportAnswerReportRequestRegionalSettings.class);
  }

 /**
  * Convert an instance of ExportAnswerReportRequestRegionalSettings to an JSON string
  *
  * @return JSON string
  */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}

