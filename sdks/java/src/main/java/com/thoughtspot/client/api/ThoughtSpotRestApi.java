/*
 * NOTE: This class is auto generated. Do not edit the class manually.
 */

package com.thoughtspot.client.api;

import com.google.gson.reflect.TypeToken;
import com.thoughtspot.client.ApiCallback;
import com.thoughtspot.client.ApiClient;
import com.thoughtspot.client.ApiClientConfiguration;
import com.thoughtspot.client.ApiException;
import com.thoughtspot.client.ApiResponse;
import com.thoughtspot.client.Configuration;
import com.thoughtspot.client.Pair;
import com.thoughtspot.client.model.AccessToken;
import com.thoughtspot.client.model.ActivateUserRequest;
import com.thoughtspot.client.model.AnswerDataResponse;
import com.thoughtspot.client.model.AssignChangeAuthorRequest;
import com.thoughtspot.client.model.AssignTagRequest;
import com.thoughtspot.client.model.CalendarResponse;
import com.thoughtspot.client.model.ChangeUserPasswordRequest;
import com.thoughtspot.client.model.ColumnSecurityRuleResponse;
import com.thoughtspot.client.model.CommitBranchRequest;
import com.thoughtspot.client.model.CommitHistoryResponse;
import com.thoughtspot.client.model.CommitResponse;
import com.thoughtspot.client.model.ConnectionConfigurationResponse;
import com.thoughtspot.client.model.ConnectionConfigurationSearchRequest;
import com.thoughtspot.client.model.Conversation;
import com.thoughtspot.client.model.ConvertWorksheetToModelRequest;
import com.thoughtspot.client.model.CopyObjectRequest;
import com.thoughtspot.client.model.CreateCalendarRequest;
import com.thoughtspot.client.model.CreateConfigRequest;
import com.thoughtspot.client.model.CreateConnectionConfigurationRequest;
import com.thoughtspot.client.model.CreateConnectionRequest;
import com.thoughtspot.client.model.CreateConnectionResponse;
import com.thoughtspot.client.model.CreateConversationRequest;
import com.thoughtspot.client.model.CreateCustomActionRequest;
import com.thoughtspot.client.model.CreateEmailCustomizationRequest;
import com.thoughtspot.client.model.CreateEmailCustomizationResponse;
import com.thoughtspot.client.model.CreateOrgRequest;
import com.thoughtspot.client.model.CreateRoleRequest;
import com.thoughtspot.client.model.CreateScheduleRequest;
import com.thoughtspot.client.model.CreateTagRequest;
import com.thoughtspot.client.model.CreateUserGroupRequest;
import com.thoughtspot.client.model.CreateUserRequest;
import com.thoughtspot.client.model.CreateVariableRequest;
import com.thoughtspot.client.model.DbtSearchResponse;
import com.thoughtspot.client.model.DeactivateUserRequest;
import com.thoughtspot.client.model.DeleteConfigRequest;
import com.thoughtspot.client.model.DeleteConnectionConfigurationRequest;
import com.thoughtspot.client.model.DeleteConnectionRequest;
import com.thoughtspot.client.model.DeleteMetadataRequest;
import com.thoughtspot.client.model.DeleteOrgEmailCustomizationRequest;
import com.thoughtspot.client.model.DeployCommitRequest;
import com.thoughtspot.client.model.DeployResponse;
import com.thoughtspot.client.model.EurekaDecomposeQueryResponse;
import com.thoughtspot.client.model.ExportAnswerReportRequest;
import com.thoughtspot.client.model.ExportLiveboardReportRequest;
import com.thoughtspot.client.model.ExportMetadataTMLBatchedRequest;
import com.thoughtspot.client.model.ExportMetadataTMLRequest;
import com.thoughtspot.client.model.FetchAnswerDataRequest;
import com.thoughtspot.client.model.FetchAnswerSqlQueryRequest;
import com.thoughtspot.client.model.FetchAsyncImportTaskStatusRequest;
import com.thoughtspot.client.model.FetchColumnSecurityRulesRequest;
import com.thoughtspot.client.model.FetchConnectionDiffStatusResponse;
import com.thoughtspot.client.model.FetchLiveboardDataRequest;
import com.thoughtspot.client.model.FetchLiveboardSqlQueryRequest;
import com.thoughtspot.client.model.FetchLogsRequest;
import com.thoughtspot.client.model.FetchPermissionsOfPrincipalsRequest;
import com.thoughtspot.client.model.FetchPermissionsOnMetadataRequest;
import com.thoughtspot.client.model.ForceLogoutUsersRequest;
import com.thoughtspot.client.model.GenerateCSVRequest;
import com.thoughtspot.client.model.GetAsyncImportStatusResponse;
import com.thoughtspot.client.model.GetCustomAccessTokenRequest;
import com.thoughtspot.client.model.GetFullAccessTokenRequest;
import com.thoughtspot.client.model.GetObjectAccessTokenRequest;
import com.thoughtspot.client.model.GetTokenResponse;
import com.thoughtspot.client.model.ImportEPackAsyncTaskStatus;
import com.thoughtspot.client.model.ImportMetadataTMLAsyncRequest;
import com.thoughtspot.client.model.ImportMetadataTMLRequest;
import com.thoughtspot.client.model.ImportUserGroupsRequest;
import com.thoughtspot.client.model.ImportUserGroupsResponse;
import com.thoughtspot.client.model.ImportUsersRequest;
import com.thoughtspot.client.model.ImportUsersResponse;
import com.thoughtspot.client.model.LiveboardDataResponse;
import com.thoughtspot.client.model.LogResponse;
import com.thoughtspot.client.model.LoginRequest;
import com.thoughtspot.client.model.MetadataSearchResponse;
import com.thoughtspot.client.model.OrgResponse;
import com.thoughtspot.client.model.ParameterizeMetadataRequest;
import com.thoughtspot.client.model.PermissionOfMetadataResponse;
import com.thoughtspot.client.model.PermissionOfPrincipalsResponse;
import com.thoughtspot.client.model.PublishMetadataRequest;
import com.thoughtspot.client.model.QueryGetDecomposedQueryRequest;
import com.thoughtspot.client.model.RepoConfigObject;
import com.thoughtspot.client.model.ResetUserPasswordRequest;
import com.thoughtspot.client.model.ResponseActivationURL;
import com.thoughtspot.client.model.ResponseCopyObject;
import com.thoughtspot.client.model.ResponseCustomAction;
import com.thoughtspot.client.model.ResponseMessage;
import com.thoughtspot.client.model.ResponseSchedule;
import com.thoughtspot.client.model.ResponseWorksheetToModelConversion;
import com.thoughtspot.client.model.RevertCommitRequest;
import com.thoughtspot.client.model.RevertResponse;
import com.thoughtspot.client.model.RevokeTokenRequest;
import com.thoughtspot.client.model.RoleResponse;
import com.thoughtspot.client.model.SearchCalendarsRequest;
import com.thoughtspot.client.model.SearchCommitsRequest;
import com.thoughtspot.client.model.SearchConfigRequest;
import com.thoughtspot.client.model.SearchConnectionRequest;
import com.thoughtspot.client.model.SearchConnectionResponse;
import com.thoughtspot.client.model.SearchCustomActionsRequest;
import com.thoughtspot.client.model.SearchDataRequest;
import com.thoughtspot.client.model.SearchDataResponse;
import com.thoughtspot.client.model.SearchEmailCustomizationRequest;
import com.thoughtspot.client.model.SearchMetadataRequest;
import com.thoughtspot.client.model.SearchOrgsRequest;
import com.thoughtspot.client.model.SearchRoleResponse;
import com.thoughtspot.client.model.SearchRolesRequest;
import com.thoughtspot.client.model.SearchSchedulesRequest;
import com.thoughtspot.client.model.SearchTagsRequest;
import com.thoughtspot.client.model.SearchUserGroupsRequest;
import com.thoughtspot.client.model.SearchUsersRequest;
import com.thoughtspot.client.model.SearchVariablesRequest;
import com.thoughtspot.client.model.SendMessageRequest;
import com.thoughtspot.client.model.ShareMetadataRequest;
import com.thoughtspot.client.model.SingleAnswerRequest;
import com.thoughtspot.client.model.SqlQueryResponse;
import com.thoughtspot.client.model.SystemConfig;
import com.thoughtspot.client.model.SystemInfo;
import com.thoughtspot.client.model.SystemOverrideInfo;
import com.thoughtspot.client.model.Tag;
import com.thoughtspot.client.model.Token;
import com.thoughtspot.client.model.TokenValidationResponse;
import com.thoughtspot.client.model.UnparameterizeMetadataRequest;
import com.thoughtspot.client.model.UnpublishMetadataRequest;
import com.thoughtspot.client.model.UpdateCalendarRequest;
import com.thoughtspot.client.model.UpdateColumnSecurityRulesRequest;
import com.thoughtspot.client.model.UpdateConfigRequest;
import com.thoughtspot.client.model.UpdateConnectionConfigurationRequest;
import com.thoughtspot.client.model.UpdateConnectionRequest;
import com.thoughtspot.client.model.UpdateConnectionV2Request;
import com.thoughtspot.client.model.UpdateCustomActionRequest;
import com.thoughtspot.client.model.UpdateEmailCustomizationRequest;
import com.thoughtspot.client.model.UpdateMetadataHeaderRequest;
import com.thoughtspot.client.model.UpdateMetadataObjIdRequest;
import com.thoughtspot.client.model.UpdateOrgRequest;
import com.thoughtspot.client.model.UpdateRoleRequest;
import com.thoughtspot.client.model.UpdateScheduleRequest;
import com.thoughtspot.client.model.UpdateSystemConfigRequest;
import com.thoughtspot.client.model.UpdateTagRequest;
import com.thoughtspot.client.model.UpdateUserGroupRequest;
import com.thoughtspot.client.model.UpdateUserRequest;
import com.thoughtspot.client.model.UpdateVariableRequest;
import com.thoughtspot.client.model.UpdateVariableValuesRequest;
import com.thoughtspot.client.model.User;
import com.thoughtspot.client.model.UserGroupResponse;
import com.thoughtspot.client.model.ValidateMergeRequest;
import com.thoughtspot.client.model.ValidateTokenRequest;
import com.thoughtspot.client.model.Variable;
import java.io.File;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@javax.annotation.Generated(
        value = "org.openapitools.codegen.languages.JavaClientCodegen",
        comments = "Generator version: 7.12.0")
public class ThoughtSpotRestApi {
    private ApiClient localVarApiClient;
    private ApiClientConfiguration localVarApiClientConfiguration;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public ThoughtSpotRestApi() {
        this(Configuration.getDefaultApiClient());
    }

    public ThoughtSpotRestApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ThoughtSpotRestApi(ApiClientConfiguration apiClientConfiguration) {
        this.localVarApiClientConfiguration = apiClientConfiguration;
        this.localVarApiClient = new ApiClient(apiClientConfiguration);
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClientConfiguration getApiClientConfiguration() {
        return localVarApiClientConfiguration;
    }

    public void applyApiClientConfiguration(ApiClientConfiguration apiClientConfiguration) {
        this.localVarApiClientConfiguration = apiClientConfiguration;
        if (localVarApiClient != null) {
            localVarApiClient.applyApiClientConfiguration(apiClientConfiguration);
        } else {
            localVarApiClient = new ApiClient(apiClientConfiguration);
        }
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for activateUser
     *
     * @param activateUserRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User activated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call activateUserCall(
            ActivateUserRequest activateUserRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = activateUserRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/users/activate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call activateUserValidateBeforeCall(
            ActivateUserRequest activateUserRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'activateUserRequest' is set
        if (activateUserRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'activateUserRequest' when calling"
                            + " activateUser(Async)");
        }

        return activateUserCall(activateUserRequest, _callback);
    }

    /**
     * Version: 9.7.0.cl or later Activates a deactivated user account. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer Thoughtspot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required. To activate
     * an inactive user account, the API request body must include the following information: -
     * Username or the GUID of the user account. - Auth token generated for the deactivated user.
     * The auth token is sent in the API response when a user is deactivated. - Password for the
     * user account.
     *
     * @param activateUserRequest (required)
     * @return User
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User activated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public User activateUser(ActivateUserRequest activateUserRequest) throws ApiException {
        ApiResponse<User> localVarResp = activateUserWithHttpInfo(activateUserRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.7.0.cl or later Activates a deactivated user account. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer Thoughtspot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required. To activate
     * an inactive user account, the API request body must include the following information: -
     * Username or the GUID of the user account. - Auth token generated for the deactivated user.
     * The auth token is sent in the API response when a user is deactivated. - Password for the
     * user account.
     *
     * @param activateUserRequest (required)
     * @return ApiResponse&lt;User&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User activated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<User> activateUserWithHttpInfo(ActivateUserRequest activateUserRequest)
            throws ApiException {
        okhttp3.Call localVarCall = activateUserValidateBeforeCall(activateUserRequest, null);
        Type localVarReturnType = new TypeToken<User>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.7.0.cl or later Activates a deactivated user account. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer Thoughtspot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required. To activate
     * an inactive user account, the API request body must include the following information: -
     * Username or the GUID of the user account. - Auth token generated for the deactivated user.
     * The auth token is sent in the API response when a user is deactivated. - Password for the
     * user account.
     *
     * @param activateUserRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User activated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call activateUserAsync(
            ActivateUserRequest activateUserRequest, final ApiCallback<User> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = activateUserValidateBeforeCall(activateUserRequest, _callback);
        Type localVarReturnType = new TypeToken<User>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for assignChangeAuthor
     *
     * @param assignChangeAuthorRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Author assignment for given metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call assignChangeAuthorCall(
            AssignChangeAuthorRequest assignChangeAuthorRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = assignChangeAuthorRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/security/metadata/assign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call assignChangeAuthorValidateBeforeCall(
            AssignChangeAuthorRequest assignChangeAuthorRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'assignChangeAuthorRequest' is set
        if (assignChangeAuthorRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'assignChangeAuthorRequest' when calling"
                            + " assignChangeAuthor(Async)");
        }

        return assignChangeAuthorCall(assignChangeAuthorRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Transfers the ownership of one or several objects from one user to
     * another. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege and
     * edit access to the objects are required.
     *
     * @param assignChangeAuthorRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Author assignment for given metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void assignChangeAuthor(AssignChangeAuthorRequest assignChangeAuthorRequest)
            throws ApiException {
        assignChangeAuthorWithHttpInfo(assignChangeAuthorRequest);
    }

    /**
     * Version: 9.0.0.cl or later Transfers the ownership of one or several objects from one user to
     * another. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege and
     * edit access to the objects are required.
     *
     * @param assignChangeAuthorRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Author assignment for given metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> assignChangeAuthorWithHttpInfo(
            AssignChangeAuthorRequest assignChangeAuthorRequest) throws ApiException {
        okhttp3.Call localVarCall =
                assignChangeAuthorValidateBeforeCall(assignChangeAuthorRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Transfers the ownership of one or several objects
     * from one user to another. Requires &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege and edit access to the
     * objects are required.
     *
     * @param assignChangeAuthorRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Author assignment for given metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call assignChangeAuthorAsync(
            AssignChangeAuthorRequest assignChangeAuthorRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                assignChangeAuthorValidateBeforeCall(assignChangeAuthorRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for assignTag
     *
     * @param assignTagRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tags successfully assigned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call assignTagCall(
            AssignTagRequest assignTagRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = assignTagRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/tags/assign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call assignTagValidateBeforeCall(
            AssignTagRequest assignTagRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'assignTagRequest' is set
        if (assignTagRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'assignTagRequest' when calling"
                            + " assignTag(Async)");
        }

        return assignTagCall(assignTagRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Assigns tags to Liveboards, Answers, Tables, and Worksheets.
     * Requires edit access to the metadata object.
     *
     * @param assignTagRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tags successfully assigned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void assignTag(AssignTagRequest assignTagRequest) throws ApiException {
        assignTagWithHttpInfo(assignTagRequest);
    }

    /**
     * Version: 9.0.0.cl or later Assigns tags to Liveboards, Answers, Tables, and Worksheets.
     * Requires edit access to the metadata object.
     *
     * @param assignTagRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tags successfully assigned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> assignTagWithHttpInfo(AssignTagRequest assignTagRequest)
            throws ApiException {
        okhttp3.Call localVarCall = assignTagValidateBeforeCall(assignTagRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Assigns tags to Liveboards, Answers, Tables, and
     * Worksheets. Requires edit access to the metadata object.
     *
     * @param assignTagRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tags successfully assigned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call assignTagAsync(
            AssignTagRequest assignTagRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = assignTagValidateBeforeCall(assignTagRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for changeUserPassword
     *
     * @param changeUserPasswordRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User password change operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call changeUserPasswordCall(
            ChangeUserPasswordRequest changeUserPasswordRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = changeUserPasswordRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/users/change-password";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call changeUserPasswordValidateBeforeCall(
            ChangeUserPasswordRequest changeUserPasswordRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'changeUserPasswordRequest' is set
        if (changeUserPasswordRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'changeUserPasswordRequest' when calling"
                            + " changeUserPassword(Async)");
        }

        return changeUserPasswordCall(changeUserPasswordRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Updates the current password of the user. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param changeUserPasswordRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User password change operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void changeUserPassword(ChangeUserPasswordRequest changeUserPasswordRequest)
            throws ApiException {
        changeUserPasswordWithHttpInfo(changeUserPasswordRequest);
    }

    /**
     * Version: 9.0.0.cl or later Updates the current password of the user. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param changeUserPasswordRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User password change operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> changeUserPasswordWithHttpInfo(
            ChangeUserPasswordRequest changeUserPasswordRequest) throws ApiException {
        okhttp3.Call localVarCall =
                changeUserPasswordValidateBeforeCall(changeUserPasswordRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Updates the current password of the user.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is
     * required.
     *
     * @param changeUserPasswordRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User password change operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call changeUserPasswordAsync(
            ChangeUserPasswordRequest changeUserPasswordRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                changeUserPasswordValidateBeforeCall(changeUserPasswordRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for commitBranch
     *
     * @param commitBranchRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully committed the metadata objects </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call commitBranchCall(
            CommitBranchRequest commitBranchRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = commitBranchRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/vcs/git/branches/commit";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call commitBranchValidateBeforeCall(
            CommitBranchRequest commitBranchRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'commitBranchRequest' is set
        if (commitBranchRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'commitBranchRequest' when calling"
                            + " commitBranch(Async)");
        }

        return commitBranchCall(commitBranchRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Commits TML files of metadata objects to the Git branch configured
     * on your instance. Requires at least edit access to objects used in the commit operation.
     * Before using this endpoint to push your commits: * Enable Git integration on your instance. *
     * Make sure the Git repository and branch details are configured on your instance. For more
     * information, see [Git integration
     * documentation](https://developers.thoughtspot.com/docs/git-integration).
     *
     * @param commitBranchRequest (required)
     * @return CommitResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully committed the metadata objects </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public CommitResponse commitBranch(CommitBranchRequest commitBranchRequest)
            throws ApiException {
        ApiResponse<CommitResponse> localVarResp = commitBranchWithHttpInfo(commitBranchRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Commits TML files of metadata objects to the Git branch configured
     * on your instance. Requires at least edit access to objects used in the commit operation.
     * Before using this endpoint to push your commits: * Enable Git integration on your instance. *
     * Make sure the Git repository and branch details are configured on your instance. For more
     * information, see [Git integration
     * documentation](https://developers.thoughtspot.com/docs/git-integration).
     *
     * @param commitBranchRequest (required)
     * @return ApiResponse&lt;CommitResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully committed the metadata objects </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CommitResponse> commitBranchWithHttpInfo(
            CommitBranchRequest commitBranchRequest) throws ApiException {
        okhttp3.Call localVarCall = commitBranchValidateBeforeCall(commitBranchRequest, null);
        Type localVarReturnType = new TypeToken<CommitResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Commits TML files of metadata objects to the Git
     * branch configured on your instance. Requires at least edit access to objects used in the
     * commit operation. Before using this endpoint to push your commits: * Enable Git integration
     * on your instance. * Make sure the Git repository and branch details are configured on your
     * instance. For more information, see [Git integration
     * documentation](https://developers.thoughtspot.com/docs/git-integration).
     *
     * @param commitBranchRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully committed the metadata objects </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call commitBranchAsync(
            CommitBranchRequest commitBranchRequest, final ApiCallback<CommitResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = commitBranchValidateBeforeCall(commitBranchRequest, _callback);
        Type localVarReturnType = new TypeToken<CommitResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for connectionConfigurationSearch
     *
     * @param connectionConfigurationSearchRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Configuration fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call connectionConfigurationSearchCall(
            ConnectionConfigurationSearchRequest connectionConfigurationSearchRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = connectionConfigurationSearchRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/connection-configurations/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call connectionConfigurationSearchValidateBeforeCall(
            ConnectionConfigurationSearchRequest connectionConfigurationSearchRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'connectionConfigurationSearchRequest' is set
        if (connectionConfigurationSearchRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'connectionConfigurationSearchRequest' when"
                            + " calling connectionConfigurationSearch(Async)");
        }

        return connectionConfigurationSearchCall(connectionConfigurationSearchRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Gets connection configuration objects. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. #### Usage guidelines * To get a list of all
     * configurations available in the ThoughtSpot system, send the API request with only the
     * connection name or GUID in the request body. * To fetch details of a configuration object,
     * specify the configuration object name or GUID.
     *
     * @param connectionConfigurationSearchRequest (required)
     * @return List&lt;ConnectionConfigurationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Configuration fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<ConnectionConfigurationResponse> connectionConfigurationSearch(
            ConnectionConfigurationSearchRequest connectionConfigurationSearchRequest)
            throws ApiException {
        ApiResponse<List<ConnectionConfigurationResponse>> localVarResp =
                connectionConfigurationSearchWithHttpInfo(connectionConfigurationSearchRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.12.0.cl or later Gets connection configuration objects. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. #### Usage guidelines * To get a list of all
     * configurations available in the ThoughtSpot system, send the API request with only the
     * connection name or GUID in the request body. * To fetch details of a configuration object,
     * specify the configuration object name or GUID.
     *
     * @param connectionConfigurationSearchRequest (required)
     * @return ApiResponse&lt;List&lt;ConnectionConfigurationResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Configuration fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<ConnectionConfigurationResponse>>
            connectionConfigurationSearchWithHttpInfo(
                    ConnectionConfigurationSearchRequest connectionConfigurationSearchRequest)
                    throws ApiException {
        okhttp3.Call localVarCall =
                connectionConfigurationSearchValidateBeforeCall(
                        connectionConfigurationSearchRequest, null);
        Type localVarReturnType =
                new TypeToken<List<ConnectionConfigurationResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Gets connection configuration objects. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. #### Usage guidelines * To get a list of all
     * configurations available in the ThoughtSpot system, send the API request with only the
     * connection name or GUID in the request body. * To fetch details of a configuration object,
     * specify the configuration object name or GUID.
     *
     * @param connectionConfigurationSearchRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Configuration fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call connectionConfigurationSearchAsync(
            ConnectionConfigurationSearchRequest connectionConfigurationSearchRequest,
            final ApiCallback<List<ConnectionConfigurationResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                connectionConfigurationSearchValidateBeforeCall(
                        connectionConfigurationSearchRequest, _callback);
        Type localVarReturnType =
                new TypeToken<List<ConnectionConfigurationResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for convertWorksheetToModel
     *
     * @param convertWorksheetToModelRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Conversion of worksheets to model done successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call convertWorksheetToModelCall(
            ConvertWorksheetToModelRequest convertWorksheetToModelRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = convertWorksheetToModelRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/worksheets/convert";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call convertWorksheetToModelValidateBeforeCall(
            ConvertWorksheetToModelRequest convertWorksheetToModelRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'convertWorksheetToModelRequest' is set
        if (convertWorksheetToModelRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'convertWorksheetToModelRequest' when calling"
                            + " convertWorksheetToModel(Async)");
        }

        return convertWorksheetToModelCall(convertWorksheetToModelRequest, _callback);
    }

    /**
     * Convert worksheets to models Version: 10.6.0.cl or later ## Prerequisites - **Privileges
     * Required:** - &#x60;DATAMANAGEMENT&#x60; (Can manage data) or &#x60;ADMINISTRATION&#x60; (Can
     * administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):** -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (Can manage data models). --- ## Usage
     * Guidelines ### Parameters 1. **worksheet_ids** - **Description:** A comma-separated list of
     * GUIDs (Globally Unique Identifiers) specifying the Worksheets to be converted. - **Usage:** -
     * Used only when &#x60;convert_all&#x60; is set to &#x60;false&#x60;. - Leave empty or omit
     * when &#x60;convert_all&#x60; is set to &#x60;true&#x60;. 2. **exclude_worksheet_ids** -
     * **Description:** A comma-separated list of GUIDs specifying Worksheets to be excluded from
     * conversion. - **Usage:** - Useful when &#x60;convert_all&#x60; is set to &#x60;true&#x60; and
     * specific Worksheets should not be converted. 3. **convert_all** - **Description:** Sets the
     * scope of conversion. - **Options:** - &#x60;true&#x60;: Converts all Worksheets in the
     * system, except those specified in &#x60;exclude_worksheet_ids&#x60;. - &#x60;false&#x60;:
     * Converts only the Worksheets listed in &#x60;worksheet_ids&#x60;. 4. **apply_changes** -
     * **Description:** Specifies whether to apply changes directly to ThoughtSpot or to generate a
     * preview before applying any changes.Used for validation of conversion. - **Options:** -
     * &#x60;true&#x60;: Applies conversion changes directly to ThoughtSpot. - &#x60;false&#x60;:
     * Generates only a preview of the changes and does not apply any changes to ThoughtSpot --- ##
     * Best Practices 1. **Backup Before Conversion:** Always export metadata as a backup before
     * initiating the conversion process 2. **Partial Conversion for Testing:** Test the conversion
     * process by setting &#x60;convert_all&#x60; to &#x60;false&#x60; and specifying a small number
     * of &#x60;worksheet_ids&#x60;. 3. **Verify Dependencies:** Check for dependent objects, such
     * as Tables and Connections, to avoid invalid references. 4. **Review Changes:** Use
     * &#x60;apply_changes: false&#x60; to preview the impact of the conversion before applying
     * changes. --- ## Examples ### Convert Specific Worksheets &#x60;&#x60;&#x60;json {
     * \&quot;worksheet_ids\&quot;: [\&quot;guid1\&quot;, \&quot;guid2\&quot;, \&quot;guid3\&quot;],
     * \&quot;exclude_worksheet_ids\&quot;: [], \&quot;convert_all\&quot;: false,
     * \&quot;apply_changes\&quot;: true } &#x60;&#x60;&#x60; ### Convert All Accessible Worksheets
     * &#x60;&#x60;&#x60;json { \&quot;worksheet_ids\&quot;: [],
     * \&quot;exclude_worksheet_ids\&quot;: [], \&quot;convert_all\&quot;: true,
     * \&quot;apply_changes\&quot;: true } &#x60;&#x60;&#x60; ### Exclude Specific Worksheets While
     * Converting All Accessible Worksheets &#x60;&#x60;&#x60;json { \&quot;worksheet_ids\&quot;:
     * [], \&quot;exclude_worksheet_ids\&quot;: [\&quot;abc\&quot;], \&quot;convert_all\&quot;:
     * true, \&quot;apply_changes\&quot;: true } &#x60;&#x60;&#x60;
     *
     * @param convertWorksheetToModelRequest (required)
     * @return ResponseWorksheetToModelConversion
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Conversion of worksheets to model done successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ResponseWorksheetToModelConversion convertWorksheetToModel(
            ConvertWorksheetToModelRequest convertWorksheetToModelRequest) throws ApiException {
        ApiResponse<ResponseWorksheetToModelConversion> localVarResp =
                convertWorksheetToModelWithHttpInfo(convertWorksheetToModelRequest);
        return localVarResp.getData();
    }

    /**
     * Convert worksheets to models Version: 10.6.0.cl or later ## Prerequisites - **Privileges
     * Required:** - &#x60;DATAMANAGEMENT&#x60; (Can manage data) or &#x60;ADMINISTRATION&#x60; (Can
     * administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):** -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (Can manage data models). --- ## Usage
     * Guidelines ### Parameters 1. **worksheet_ids** - **Description:** A comma-separated list of
     * GUIDs (Globally Unique Identifiers) specifying the Worksheets to be converted. - **Usage:** -
     * Used only when &#x60;convert_all&#x60; is set to &#x60;false&#x60;. - Leave empty or omit
     * when &#x60;convert_all&#x60; is set to &#x60;true&#x60;. 2. **exclude_worksheet_ids** -
     * **Description:** A comma-separated list of GUIDs specifying Worksheets to be excluded from
     * conversion. - **Usage:** - Useful when &#x60;convert_all&#x60; is set to &#x60;true&#x60; and
     * specific Worksheets should not be converted. 3. **convert_all** - **Description:** Sets the
     * scope of conversion. - **Options:** - &#x60;true&#x60;: Converts all Worksheets in the
     * system, except those specified in &#x60;exclude_worksheet_ids&#x60;. - &#x60;false&#x60;:
     * Converts only the Worksheets listed in &#x60;worksheet_ids&#x60;. 4. **apply_changes** -
     * **Description:** Specifies whether to apply changes directly to ThoughtSpot or to generate a
     * preview before applying any changes.Used for validation of conversion. - **Options:** -
     * &#x60;true&#x60;: Applies conversion changes directly to ThoughtSpot. - &#x60;false&#x60;:
     * Generates only a preview of the changes and does not apply any changes to ThoughtSpot --- ##
     * Best Practices 1. **Backup Before Conversion:** Always export metadata as a backup before
     * initiating the conversion process 2. **Partial Conversion for Testing:** Test the conversion
     * process by setting &#x60;convert_all&#x60; to &#x60;false&#x60; and specifying a small number
     * of &#x60;worksheet_ids&#x60;. 3. **Verify Dependencies:** Check for dependent objects, such
     * as Tables and Connections, to avoid invalid references. 4. **Review Changes:** Use
     * &#x60;apply_changes: false&#x60; to preview the impact of the conversion before applying
     * changes. --- ## Examples ### Convert Specific Worksheets &#x60;&#x60;&#x60;json {
     * \&quot;worksheet_ids\&quot;: [\&quot;guid1\&quot;, \&quot;guid2\&quot;, \&quot;guid3\&quot;],
     * \&quot;exclude_worksheet_ids\&quot;: [], \&quot;convert_all\&quot;: false,
     * \&quot;apply_changes\&quot;: true } &#x60;&#x60;&#x60; ### Convert All Accessible Worksheets
     * &#x60;&#x60;&#x60;json { \&quot;worksheet_ids\&quot;: [],
     * \&quot;exclude_worksheet_ids\&quot;: [], \&quot;convert_all\&quot;: true,
     * \&quot;apply_changes\&quot;: true } &#x60;&#x60;&#x60; ### Exclude Specific Worksheets While
     * Converting All Accessible Worksheets &#x60;&#x60;&#x60;json { \&quot;worksheet_ids\&quot;:
     * [], \&quot;exclude_worksheet_ids\&quot;: [\&quot;abc\&quot;], \&quot;convert_all\&quot;:
     * true, \&quot;apply_changes\&quot;: true } &#x60;&#x60;&#x60;
     *
     * @param convertWorksheetToModelRequest (required)
     * @return ApiResponse&lt;ResponseWorksheetToModelConversion&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Conversion of worksheets to model done successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ResponseWorksheetToModelConversion> convertWorksheetToModelWithHttpInfo(
            ConvertWorksheetToModelRequest convertWorksheetToModelRequest) throws ApiException {
        okhttp3.Call localVarCall =
                convertWorksheetToModelValidateBeforeCall(convertWorksheetToModelRequest, null);
        Type localVarReturnType = new TypeToken<ResponseWorksheetToModelConversion>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Convert worksheets to models Version: 10.6.0.cl or later ## Prerequisites -
     * **Privileges Required:** - &#x60;DATAMANAGEMENT&#x60; (Can manage data) or
     * &#x60;ADMINISTRATION&#x60; (Can administer ThoughtSpot). - **Additional Privileges (if RBAC
     * is enabled):** - &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (Can manage data models). ---
     * ## Usage Guidelines ### Parameters 1. **worksheet_ids** - **Description:** A comma-separated
     * list of GUIDs (Globally Unique Identifiers) specifying the Worksheets to be converted. -
     * **Usage:** - Used only when &#x60;convert_all&#x60; is set to &#x60;false&#x60;. - Leave
     * empty or omit when &#x60;convert_all&#x60; is set to &#x60;true&#x60;. 2.
     * **exclude_worksheet_ids** - **Description:** A comma-separated list of GUIDs specifying
     * Worksheets to be excluded from conversion. - **Usage:** - Useful when &#x60;convert_all&#x60;
     * is set to &#x60;true&#x60; and specific Worksheets should not be converted. 3.
     * **convert_all** - **Description:** Sets the scope of conversion. - **Options:** -
     * &#x60;true&#x60;: Converts all Worksheets in the system, except those specified in
     * &#x60;exclude_worksheet_ids&#x60;. - &#x60;false&#x60;: Converts only the Worksheets listed
     * in &#x60;worksheet_ids&#x60;. 4. **apply_changes** - **Description:** Specifies whether to
     * apply changes directly to ThoughtSpot or to generate a preview before applying any
     * changes.Used for validation of conversion. - **Options:** - &#x60;true&#x60;: Applies
     * conversion changes directly to ThoughtSpot. - &#x60;false&#x60;: Generates only a preview of
     * the changes and does not apply any changes to ThoughtSpot --- ## Best Practices 1. **Backup
     * Before Conversion:** Always export metadata as a backup before initiating the conversion
     * process 2. **Partial Conversion for Testing:** Test the conversion process by setting
     * &#x60;convert_all&#x60; to &#x60;false&#x60; and specifying a small number of
     * &#x60;worksheet_ids&#x60;. 3. **Verify Dependencies:** Check for dependent objects, such as
     * Tables and Connections, to avoid invalid references. 4. **Review Changes:** Use
     * &#x60;apply_changes: false&#x60; to preview the impact of the conversion before applying
     * changes. --- ## Examples ### Convert Specific Worksheets &#x60;&#x60;&#x60;json {
     * \&quot;worksheet_ids\&quot;: [\&quot;guid1\&quot;, \&quot;guid2\&quot;, \&quot;guid3\&quot;],
     * \&quot;exclude_worksheet_ids\&quot;: [], \&quot;convert_all\&quot;: false,
     * \&quot;apply_changes\&quot;: true } &#x60;&#x60;&#x60; ### Convert All Accessible Worksheets
     * &#x60;&#x60;&#x60;json { \&quot;worksheet_ids\&quot;: [],
     * \&quot;exclude_worksheet_ids\&quot;: [], \&quot;convert_all\&quot;: true,
     * \&quot;apply_changes\&quot;: true } &#x60;&#x60;&#x60; ### Exclude Specific Worksheets While
     * Converting All Accessible Worksheets &#x60;&#x60;&#x60;json { \&quot;worksheet_ids\&quot;:
     * [], \&quot;exclude_worksheet_ids\&quot;: [\&quot;abc\&quot;], \&quot;convert_all\&quot;:
     * true, \&quot;apply_changes\&quot;: true } &#x60;&#x60;&#x60;
     *
     * @param convertWorksheetToModelRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Conversion of worksheets to model done successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call convertWorksheetToModelAsync(
            ConvertWorksheetToModelRequest convertWorksheetToModelRequest,
            final ApiCallback<ResponseWorksheetToModelConversion> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                convertWorksheetToModelValidateBeforeCall(
                        convertWorksheetToModelRequest, _callback);
        Type localVarReturnType = new TypeToken<ResponseWorksheetToModelConversion>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for copyObject
     *
     * @param copyObjectRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully created a copy of the object </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Object not found </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call copyObjectCall(
            CopyObjectRequest copyObjectRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = copyObjectRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/copyobject";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call copyObjectValidateBeforeCall(
            CopyObjectRequest copyObjectRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'copyObjectRequest' is set
        if (copyObjectRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'copyObjectRequest' when calling"
                            + " copyObject(Async)");
        }

        return copyObjectCall(copyObjectRequest, _callback);
    }

    /**
     * Makes a copy of an Answer or Liveboard saved in Atlas Version: 10.3.0.cl or later Creates a
     * copy of a metadata object. Requires at least view access to the metadata object being copied.
     * Upon successful execution, the API creates a copy of the metadata object specified in the API
     * request and returns the ID of the new object.
     *
     * @param copyObjectRequest (required)
     * @return ResponseCopyObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully created a copy of the object </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Object not found </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ResponseCopyObject copyObject(CopyObjectRequest copyObjectRequest) throws ApiException {
        ApiResponse<ResponseCopyObject> localVarResp = copyObjectWithHttpInfo(copyObjectRequest);
        return localVarResp.getData();
    }

    /**
     * Makes a copy of an Answer or Liveboard saved in Atlas Version: 10.3.0.cl or later Creates a
     * copy of a metadata object. Requires at least view access to the metadata object being copied.
     * Upon successful execution, the API creates a copy of the metadata object specified in the API
     * request and returns the ID of the new object.
     *
     * @param copyObjectRequest (required)
     * @return ApiResponse&lt;ResponseCopyObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully created a copy of the object </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Object not found </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ResponseCopyObject> copyObjectWithHttpInfo(
            CopyObjectRequest copyObjectRequest) throws ApiException {
        okhttp3.Call localVarCall = copyObjectValidateBeforeCall(copyObjectRequest, null);
        Type localVarReturnType = new TypeToken<ResponseCopyObject>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Makes a copy of an Answer or Liveboard saved in Atlas Version: 10.3.0.cl or
     * later Creates a copy of a metadata object. Requires at least view access to the metadata
     * object being copied. Upon successful execution, the API creates a copy of the metadata object
     * specified in the API request and returns the ID of the new object.
     *
     * @param copyObjectRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully created a copy of the object </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 404 </td><td> Object not found </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call copyObjectAsync(
            CopyObjectRequest copyObjectRequest, final ApiCallback<ResponseCopyObject> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = copyObjectValidateBeforeCall(copyObjectRequest, _callback);
        Type localVarReturnType = new TypeToken<ResponseCopyObject>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createCalendar
     *
     * @param createCalendarRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom calendar created successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createCalendarCall(
            CreateCalendarRequest createCalendarRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createCalendarRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/calendars/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createCalendarValidateBeforeCall(
            CreateCalendarRequest createCalendarRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createCalendarRequest' is set
        if (createCalendarRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createCalendarRequest' when calling"
                            + " createCalendar(Async)");
        }

        return createCalendarCall(createCalendarRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Creates a new [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines You can create a custom calendar from scratch or
     * an existing Table in ThoughtSpot. For both methods of calendar creation, the following
     * parameters are required: * Name of the custom calendar. * Calendar creation method. To create
     * a calendar from an existing table, specify the method: - &#x60;FROM_EXISTING_TABLE&#x60; -
     * Creates calendar from the table reference provided in the API request. -
     * &#x60;FROM_INPUT_PARAMS&#x60; - Creates a calendar from the parameters defined in the API
     * request. * Connection ID and Table name * Database and schema name attributes: For most Cloud
     * Data Warehouse (CDW) connectors, both &#x60;database_name&#x60; and &#x60;schema_name&#x60;
     * attributes are required. However, the attribute requirements are conditional and vary based
     * on the connector type and its metadata structure. For example, for connectors such as
     * Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL,
     * the &#x60;schema_name&#x60; is required, whereas the &#x60;database_name&#x60; attribute is
     * not. Similarly, connectors such as ClickHouse require you to specify the
     * &#x60;database_name&#x60; and the schema specification in such cases is optional. **NOTE**:
     * If you are creating a calendar from an existing table, ensure that the referenced table
     * matches the required DDL for custom calendars. If the schema does not match, the API returns
     * an error. ##### Calendar type The API allows you to create the following types of calendars:
     * * &#x60;MONTH_OFFSET&#x60;. The default calendar type. A &#x60;MONTH_OFFSET&#x60; calendar is
     * offset by a few months from the standard calendar months (January to December) and the year
     * begins with the month defined in the request. For example, if the &#x60;month_offset&#x60;
     * value is set as &#x60;April&#x60;, the calendar year begins in April. * &#x60;4-4-5&#x60;.
     * Each quarter in the calendar will include two 4-week months followed by one 5-week month. *
     * &#x60;4-5-4&#x60;. Each quarter in the calendar will include two 4-week months with a 5-week
     * month between. * &#x60;5-4-4&#x60;. Each quarter begins with a 5-week month, followed by two
     * 4-week months. To start and end the calendar on a specific date, specify the dates in the
     * &#x60;MM/DD/YYYY&#x60; format. For &#x60;MONTH_OFFSET&#x60; calendars, ensure that the
     * &#x60;start_date&#x60; matches the month specified in the &#x60;month_offset&#x60; attribute.
     * You can also set the starting day of the week and customize the prefixes for year and quarter
     * labels. #### Examples To create a calendar from an existing table: &#x60;&#x60;&#x60; {
     * \&quot;name\&quot;: \&quot;MyCustomCalendar1\&quot;, \&quot;table_reference\&quot;: {
     * \&quot;connection_identifier\&quot;: \&quot;4db8ea22-2ff4-4224-b05a-26674717e468\&quot;,
     * \&quot;table_name\&quot;: \&quot;MyCalendarTable\&quot;, \&quot;database_name\&quot;:
     * \&quot;RETAILAPPAREL\&quot;, \&quot;schema_name\&quot;: \&quot;PUBLIC\&quot; },
     * \&quot;creation_method\&quot;: \&quot;FROM_EXISTING_TABLE\&quot;, } &#x60;&#x60;&#x60; To
     * create a calendar from scratch: &#x60;&#x60;&#x60; { \&quot;name\&quot;:
     * \&quot;MyCustomCalendar1\&quot;, \&quot;table_reference\&quot;: {
     * \&quot;connection_identifier\&quot;: \&quot;4db8ea22-2ff4-4224-b05a-26674717e468\&quot;,
     * \&quot;table_name\&quot;: \&quot;MyCalendarTable\&quot;, \&quot;database_name\&quot;:
     * \&quot;RETAILAPPAREL\&quot;, \&quot;schema_name\&quot;: \&quot;PUBLIC\&quot; },
     * \&quot;creation_method\&quot;: \&quot;FROM_INPUT_PARAMS\&quot;, \&quot;calendar_type\&quot;:
     * \&quot;MONTH_OFFSET\&quot;, \&quot;month_offset\&quot;: \&quot;April\&quot;,
     * \&quot;start_day_of_week\&quot;: \&quot;Monday\&quot;, \&quot;quarter_name_prefix\&quot;:
     * \&quot;Q\&quot;, \&quot;year_name_prefix\&quot;: \&quot;FY\&quot;, \&quot;start_date\&quot;:
     * \&quot;04/01/2025\&quot;, \&quot;end_date\&quot;: \&quot;04/31/2025\&quot; }
     * &#x60;&#x60;&#x60;
     *
     * @param createCalendarRequest (required)
     * @return CalendarResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom calendar created successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public CalendarResponse createCalendar(CreateCalendarRequest createCalendarRequest)
            throws ApiException {
        ApiResponse<CalendarResponse> localVarResp =
                createCalendarWithHttpInfo(createCalendarRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.12.0.cl or later Creates a new [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines You can create a custom calendar from scratch or
     * an existing Table in ThoughtSpot. For both methods of calendar creation, the following
     * parameters are required: * Name of the custom calendar. * Calendar creation method. To create
     * a calendar from an existing table, specify the method: - &#x60;FROM_EXISTING_TABLE&#x60; -
     * Creates calendar from the table reference provided in the API request. -
     * &#x60;FROM_INPUT_PARAMS&#x60; - Creates a calendar from the parameters defined in the API
     * request. * Connection ID and Table name * Database and schema name attributes: For most Cloud
     * Data Warehouse (CDW) connectors, both &#x60;database_name&#x60; and &#x60;schema_name&#x60;
     * attributes are required. However, the attribute requirements are conditional and vary based
     * on the connector type and its metadata structure. For example, for connectors such as
     * Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL,
     * the &#x60;schema_name&#x60; is required, whereas the &#x60;database_name&#x60; attribute is
     * not. Similarly, connectors such as ClickHouse require you to specify the
     * &#x60;database_name&#x60; and the schema specification in such cases is optional. **NOTE**:
     * If you are creating a calendar from an existing table, ensure that the referenced table
     * matches the required DDL for custom calendars. If the schema does not match, the API returns
     * an error. ##### Calendar type The API allows you to create the following types of calendars:
     * * &#x60;MONTH_OFFSET&#x60;. The default calendar type. A &#x60;MONTH_OFFSET&#x60; calendar is
     * offset by a few months from the standard calendar months (January to December) and the year
     * begins with the month defined in the request. For example, if the &#x60;month_offset&#x60;
     * value is set as &#x60;April&#x60;, the calendar year begins in April. * &#x60;4-4-5&#x60;.
     * Each quarter in the calendar will include two 4-week months followed by one 5-week month. *
     * &#x60;4-5-4&#x60;. Each quarter in the calendar will include two 4-week months with a 5-week
     * month between. * &#x60;5-4-4&#x60;. Each quarter begins with a 5-week month, followed by two
     * 4-week months. To start and end the calendar on a specific date, specify the dates in the
     * &#x60;MM/DD/YYYY&#x60; format. For &#x60;MONTH_OFFSET&#x60; calendars, ensure that the
     * &#x60;start_date&#x60; matches the month specified in the &#x60;month_offset&#x60; attribute.
     * You can also set the starting day of the week and customize the prefixes for year and quarter
     * labels. #### Examples To create a calendar from an existing table: &#x60;&#x60;&#x60; {
     * \&quot;name\&quot;: \&quot;MyCustomCalendar1\&quot;, \&quot;table_reference\&quot;: {
     * \&quot;connection_identifier\&quot;: \&quot;4db8ea22-2ff4-4224-b05a-26674717e468\&quot;,
     * \&quot;table_name\&quot;: \&quot;MyCalendarTable\&quot;, \&quot;database_name\&quot;:
     * \&quot;RETAILAPPAREL\&quot;, \&quot;schema_name\&quot;: \&quot;PUBLIC\&quot; },
     * \&quot;creation_method\&quot;: \&quot;FROM_EXISTING_TABLE\&quot;, } &#x60;&#x60;&#x60; To
     * create a calendar from scratch: &#x60;&#x60;&#x60; { \&quot;name\&quot;:
     * \&quot;MyCustomCalendar1\&quot;, \&quot;table_reference\&quot;: {
     * \&quot;connection_identifier\&quot;: \&quot;4db8ea22-2ff4-4224-b05a-26674717e468\&quot;,
     * \&quot;table_name\&quot;: \&quot;MyCalendarTable\&quot;, \&quot;database_name\&quot;:
     * \&quot;RETAILAPPAREL\&quot;, \&quot;schema_name\&quot;: \&quot;PUBLIC\&quot; },
     * \&quot;creation_method\&quot;: \&quot;FROM_INPUT_PARAMS\&quot;, \&quot;calendar_type\&quot;:
     * \&quot;MONTH_OFFSET\&quot;, \&quot;month_offset\&quot;: \&quot;April\&quot;,
     * \&quot;start_day_of_week\&quot;: \&quot;Monday\&quot;, \&quot;quarter_name_prefix\&quot;:
     * \&quot;Q\&quot;, \&quot;year_name_prefix\&quot;: \&quot;FY\&quot;, \&quot;start_date\&quot;:
     * \&quot;04/01/2025\&quot;, \&quot;end_date\&quot;: \&quot;04/31/2025\&quot; }
     * &#x60;&#x60;&#x60;
     *
     * @param createCalendarRequest (required)
     * @return ApiResponse&lt;CalendarResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom calendar created successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CalendarResponse> createCalendarWithHttpInfo(
            CreateCalendarRequest createCalendarRequest) throws ApiException {
        okhttp3.Call localVarCall = createCalendarValidateBeforeCall(createCalendarRequest, null);
        Type localVarReturnType = new TypeToken<CalendarResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Creates a new [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines You can create a custom calendar from scratch or
     * an existing Table in ThoughtSpot. For both methods of calendar creation, the following
     * parameters are required: * Name of the custom calendar. * Calendar creation method. To create
     * a calendar from an existing table, specify the method: - &#x60;FROM_EXISTING_TABLE&#x60; -
     * Creates calendar from the table reference provided in the API request. -
     * &#x60;FROM_INPUT_PARAMS&#x60; - Creates a calendar from the parameters defined in the API
     * request. * Connection ID and Table name * Database and schema name attributes: For most Cloud
     * Data Warehouse (CDW) connectors, both &#x60;database_name&#x60; and &#x60;schema_name&#x60;
     * attributes are required. However, the attribute requirements are conditional and vary based
     * on the connector type and its metadata structure. For example, for connectors such as
     * Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL,
     * the &#x60;schema_name&#x60; is required, whereas the &#x60;database_name&#x60; attribute is
     * not. Similarly, connectors such as ClickHouse require you to specify the
     * &#x60;database_name&#x60; and the schema specification in such cases is optional. **NOTE**:
     * If you are creating a calendar from an existing table, ensure that the referenced table
     * matches the required DDL for custom calendars. If the schema does not match, the API returns
     * an error. ##### Calendar type The API allows you to create the following types of calendars:
     * * &#x60;MONTH_OFFSET&#x60;. The default calendar type. A &#x60;MONTH_OFFSET&#x60; calendar is
     * offset by a few months from the standard calendar months (January to December) and the year
     * begins with the month defined in the request. For example, if the &#x60;month_offset&#x60;
     * value is set as &#x60;April&#x60;, the calendar year begins in April. * &#x60;4-4-5&#x60;.
     * Each quarter in the calendar will include two 4-week months followed by one 5-week month. *
     * &#x60;4-5-4&#x60;. Each quarter in the calendar will include two 4-week months with a 5-week
     * month between. * &#x60;5-4-4&#x60;. Each quarter begins with a 5-week month, followed by two
     * 4-week months. To start and end the calendar on a specific date, specify the dates in the
     * &#x60;MM/DD/YYYY&#x60; format. For &#x60;MONTH_OFFSET&#x60; calendars, ensure that the
     * &#x60;start_date&#x60; matches the month specified in the &#x60;month_offset&#x60; attribute.
     * You can also set the starting day of the week and customize the prefixes for year and quarter
     * labels. #### Examples To create a calendar from an existing table: &#x60;&#x60;&#x60; {
     * \&quot;name\&quot;: \&quot;MyCustomCalendar1\&quot;, \&quot;table_reference\&quot;: {
     * \&quot;connection_identifier\&quot;: \&quot;4db8ea22-2ff4-4224-b05a-26674717e468\&quot;,
     * \&quot;table_name\&quot;: \&quot;MyCalendarTable\&quot;, \&quot;database_name\&quot;:
     * \&quot;RETAILAPPAREL\&quot;, \&quot;schema_name\&quot;: \&quot;PUBLIC\&quot; },
     * \&quot;creation_method\&quot;: \&quot;FROM_EXISTING_TABLE\&quot;, } &#x60;&#x60;&#x60; To
     * create a calendar from scratch: &#x60;&#x60;&#x60; { \&quot;name\&quot;:
     * \&quot;MyCustomCalendar1\&quot;, \&quot;table_reference\&quot;: {
     * \&quot;connection_identifier\&quot;: \&quot;4db8ea22-2ff4-4224-b05a-26674717e468\&quot;,
     * \&quot;table_name\&quot;: \&quot;MyCalendarTable\&quot;, \&quot;database_name\&quot;:
     * \&quot;RETAILAPPAREL\&quot;, \&quot;schema_name\&quot;: \&quot;PUBLIC\&quot; },
     * \&quot;creation_method\&quot;: \&quot;FROM_INPUT_PARAMS\&quot;, \&quot;calendar_type\&quot;:
     * \&quot;MONTH_OFFSET\&quot;, \&quot;month_offset\&quot;: \&quot;April\&quot;,
     * \&quot;start_day_of_week\&quot;: \&quot;Monday\&quot;, \&quot;quarter_name_prefix\&quot;:
     * \&quot;Q\&quot;, \&quot;year_name_prefix\&quot;: \&quot;FY\&quot;, \&quot;start_date\&quot;:
     * \&quot;04/01/2025\&quot;, \&quot;end_date\&quot;: \&quot;04/31/2025\&quot; }
     * &#x60;&#x60;&#x60;
     *
     * @param createCalendarRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom calendar created successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createCalendarAsync(
            CreateCalendarRequest createCalendarRequest,
            final ApiCallback<CalendarResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createCalendarValidateBeforeCall(createCalendarRequest, _callback);
        Type localVarReturnType = new TypeToken<CalendarResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createConfig
     *
     * @param createConfigRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully configured local repository </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createConfigCall(
            CreateConfigRequest createConfigRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createConfigRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/vcs/git/config/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createConfigValidateBeforeCall(
            CreateConfigRequest createConfigRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createConfigRequest' is set
        if (createConfigRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createConfigRequest' when calling"
                            + " createConfig(Async)");
        }

        return createConfigCall(createConfigRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Allows you to connect a ThoughtSpot instance to a Git repository.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance on your instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up
     * version control**) privilege. You can use this API endpoint to connect your ThoughtSpot
     * development and production environments to the development and production branches of a Git
     * repository. Before using this endpoint to connect your ThoughtSpot instance to a Git
     * repository, check the following prerequisites: * You have a Git repository. If you are using
     * GitHub, make sure you have a valid account and an access token to connect ThoughtSpot to
     * GitHub. For information about generating a token, see [GitHub
     * Documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).
     * * Your access token has &#x60;repo&#x60; scope that grants full access to public and private
     * repositories. * Your Git repository has a branch that can be configured as a default branch
     * in ThoughtSpot. For more information, see [Git integration
     * documentation](https://developers.thoughtspot.com/docs/?pageid&#x3D;git-integration).
     * **Note**: ThoughtSpot supports only GitHub / itHub Enterprise for CI/CD.
     *
     * @param createConfigRequest (required)
     * @return RepoConfigObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully configured local repository </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public RepoConfigObject createConfig(CreateConfigRequest createConfigRequest)
            throws ApiException {
        ApiResponse<RepoConfigObject> localVarResp = createConfigWithHttpInfo(createConfigRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Allows you to connect a ThoughtSpot instance to a Git repository.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance on your instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up
     * version control**) privilege. You can use this API endpoint to connect your ThoughtSpot
     * development and production environments to the development and production branches of a Git
     * repository. Before using this endpoint to connect your ThoughtSpot instance to a Git
     * repository, check the following prerequisites: * You have a Git repository. If you are using
     * GitHub, make sure you have a valid account and an access token to connect ThoughtSpot to
     * GitHub. For information about generating a token, see [GitHub
     * Documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).
     * * Your access token has &#x60;repo&#x60; scope that grants full access to public and private
     * repositories. * Your Git repository has a branch that can be configured as a default branch
     * in ThoughtSpot. For more information, see [Git integration
     * documentation](https://developers.thoughtspot.com/docs/?pageid&#x3D;git-integration).
     * **Note**: ThoughtSpot supports only GitHub / itHub Enterprise for CI/CD.
     *
     * @param createConfigRequest (required)
     * @return ApiResponse&lt;RepoConfigObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully configured local repository </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<RepoConfigObject> createConfigWithHttpInfo(
            CreateConfigRequest createConfigRequest) throws ApiException {
        okhttp3.Call localVarCall = createConfigValidateBeforeCall(createConfigRequest, null);
        Type localVarReturnType = new TypeToken<RepoConfigObject>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Allows you to connect a ThoughtSpot instance to a
     * Git repository. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your
     * instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up version control**)
     * privilege. You can use this API endpoint to connect your ThoughtSpot development and
     * production environments to the development and production branches of a Git repository.
     * Before using this endpoint to connect your ThoughtSpot instance to a Git repository, check
     * the following prerequisites: * You have a Git repository. If you are using GitHub, make sure
     * you have a valid account and an access token to connect ThoughtSpot to GitHub. For
     * information about generating a token, see [GitHub
     * Documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).
     * * Your access token has &#x60;repo&#x60; scope that grants full access to public and private
     * repositories. * Your Git repository has a branch that can be configured as a default branch
     * in ThoughtSpot. For more information, see [Git integration
     * documentation](https://developers.thoughtspot.com/docs/?pageid&#x3D;git-integration).
     * **Note**: ThoughtSpot supports only GitHub / itHub Enterprise for CI/CD.
     *
     * @param createConfigRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully configured local repository </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createConfigAsync(
            CreateConfigRequest createConfigRequest, final ApiCallback<RepoConfigObject> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = createConfigValidateBeforeCall(createConfigRequest, _callback);
        Type localVarReturnType = new TypeToken<RepoConfigObject>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createConnection
     *
     * @param createConnectionRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Connection to the datasource successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createConnectionCall(
            CreateConnectionRequest createConnectionRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createConnectionRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/connection/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createConnectionValidateBeforeCall(
            CreateConnectionRequest createConnectionRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createConnectionRequest' is set
        if (createConnectionRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createConnectionRequest' when calling"
                            + " createConnection(Async)");
        }

        return createConnectionCall(createConnectionRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Creates a connection to a data warehouse for live query services.
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60;
     * (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required. #### Create a connection without tables To create a connection without tables: 1.
     * Pass these parameters in your API request. * Name of the connection. * Type of the data
     * warehouse to connect to. * A JSON map of configuration attributes in
     * &#x60;data_warehouse_config&#x60;. The following example shows the configuration attributes
     * for a SnowFlake connection: &#x60;&#x60;&#x60; { \&quot;configuration\&quot;:{
     * \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ ] } &#x60;&#x60;&#x60; 2. Set &#x60;validate&#x60; to
     * &#x60;false&#x60;. #### Create a connection with tables To create a connection with tables:
     * 1. Pass these parameters in your API request. * Name of the connection. * Type of the data
     * warehouse to connect to. * A JSON map of configuration attributes, database details, and
     * table properties in &#x60;data_warehouse_config&#x60; as shown in the following example:
     * &#x60;&#x60;&#x60; { \&quot;configuration\&quot;:{
     * \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ { \&quot;name\&quot;:\&quot;AllDatatypes\&quot;,
     * \&quot;isAutoCreated\&quot;:false, \&quot;schemas\&quot;:[ {
     * \&quot;name\&quot;:\&quot;alldatatypes\&quot;, \&quot;tables\&quot;:[ {
     * \&quot;name\&quot;:\&quot;allDatatypes\&quot;, \&quot;type\&quot;:\&quot;TABLE\&quot;,
     * \&quot;description\&quot;:\&quot;\&quot;, \&quot;selected\&quot;:true,
     * \&quot;linked\&quot;:true, \&quot;columns\&quot;:[ {
     * \&quot;name\&quot;:\&quot;CNUMBER\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; }, {
     * \&quot;name\&quot;:\&quot;CDECIMAL\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; } ] } ] } ] } ] } &#x60;&#x60;&#x60; 2. Set
     * &#x60;validate&#x60; to &#x60;true&#x60;.
     *
     * @param createConnectionRequest (required)
     * @return CreateConnectionResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Connection to the datasource successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public CreateConnectionResponse createConnection(
            CreateConnectionRequest createConnectionRequest) throws ApiException {
        ApiResponse<CreateConnectionResponse> localVarResp =
                createConnectionWithHttpInfo(createConnectionRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Creates a connection to a data warehouse for live query services.
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60;
     * (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required. #### Create a connection without tables To create a connection without tables: 1.
     * Pass these parameters in your API request. * Name of the connection. * Type of the data
     * warehouse to connect to. * A JSON map of configuration attributes in
     * &#x60;data_warehouse_config&#x60;. The following example shows the configuration attributes
     * for a SnowFlake connection: &#x60;&#x60;&#x60; { \&quot;configuration\&quot;:{
     * \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ ] } &#x60;&#x60;&#x60; 2. Set &#x60;validate&#x60; to
     * &#x60;false&#x60;. #### Create a connection with tables To create a connection with tables:
     * 1. Pass these parameters in your API request. * Name of the connection. * Type of the data
     * warehouse to connect to. * A JSON map of configuration attributes, database details, and
     * table properties in &#x60;data_warehouse_config&#x60; as shown in the following example:
     * &#x60;&#x60;&#x60; { \&quot;configuration\&quot;:{
     * \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ { \&quot;name\&quot;:\&quot;AllDatatypes\&quot;,
     * \&quot;isAutoCreated\&quot;:false, \&quot;schemas\&quot;:[ {
     * \&quot;name\&quot;:\&quot;alldatatypes\&quot;, \&quot;tables\&quot;:[ {
     * \&quot;name\&quot;:\&quot;allDatatypes\&quot;, \&quot;type\&quot;:\&quot;TABLE\&quot;,
     * \&quot;description\&quot;:\&quot;\&quot;, \&quot;selected\&quot;:true,
     * \&quot;linked\&quot;:true, \&quot;columns\&quot;:[ {
     * \&quot;name\&quot;:\&quot;CNUMBER\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; }, {
     * \&quot;name\&quot;:\&quot;CDECIMAL\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; } ] } ] } ] } ] } &#x60;&#x60;&#x60; 2. Set
     * &#x60;validate&#x60; to &#x60;true&#x60;.
     *
     * @param createConnectionRequest (required)
     * @return ApiResponse&lt;CreateConnectionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Connection to the datasource successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CreateConnectionResponse> createConnectionWithHttpInfo(
            CreateConnectionRequest createConnectionRequest) throws ApiException {
        okhttp3.Call localVarCall =
                createConnectionValidateBeforeCall(createConnectionRequest, null);
        Type localVarReturnType = new TypeToken<CreateConnectionResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Creates a connection to a data warehouse for live
     * query services. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required. #### Create a connection without tables To create a connection without tables: 1.
     * Pass these parameters in your API request. * Name of the connection. * Type of the data
     * warehouse to connect to. * A JSON map of configuration attributes in
     * &#x60;data_warehouse_config&#x60;. The following example shows the configuration attributes
     * for a SnowFlake connection: &#x60;&#x60;&#x60; { \&quot;configuration\&quot;:{
     * \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ ] } &#x60;&#x60;&#x60; 2. Set &#x60;validate&#x60; to
     * &#x60;false&#x60;. #### Create a connection with tables To create a connection with tables:
     * 1. Pass these parameters in your API request. * Name of the connection. * Type of the data
     * warehouse to connect to. * A JSON map of configuration attributes, database details, and
     * table properties in &#x60;data_warehouse_config&#x60; as shown in the following example:
     * &#x60;&#x60;&#x60; { \&quot;configuration\&quot;:{
     * \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ { \&quot;name\&quot;:\&quot;AllDatatypes\&quot;,
     * \&quot;isAutoCreated\&quot;:false, \&quot;schemas\&quot;:[ {
     * \&quot;name\&quot;:\&quot;alldatatypes\&quot;, \&quot;tables\&quot;:[ {
     * \&quot;name\&quot;:\&quot;allDatatypes\&quot;, \&quot;type\&quot;:\&quot;TABLE\&quot;,
     * \&quot;description\&quot;:\&quot;\&quot;, \&quot;selected\&quot;:true,
     * \&quot;linked\&quot;:true, \&quot;columns\&quot;:[ {
     * \&quot;name\&quot;:\&quot;CNUMBER\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; }, {
     * \&quot;name\&quot;:\&quot;CDECIMAL\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; } ] } ] } ] } ] } &#x60;&#x60;&#x60; 2. Set
     * &#x60;validate&#x60; to &#x60;true&#x60;.
     *
     * @param createConnectionRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Connection to the datasource successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createConnectionAsync(
            CreateConnectionRequest createConnectionRequest,
            final ApiCallback<CreateConnectionResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createConnectionValidateBeforeCall(createConnectionRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateConnectionResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createConnectionConfiguration
     *
     * @param createConnectionConfigurationRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Connection configuration successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createConnectionConfigurationCall(
            CreateConnectionConfigurationRequest createConnectionConfigurationRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createConnectionConfigurationRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/connection-configurations/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createConnectionConfigurationValidateBeforeCall(
            CreateConnectionConfigurationRequest createConnectionConfigurationRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createConnectionConfigurationRequest' is set
        if (createConnectionConfigurationRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createConnectionConfigurationRequest' when"
                            + " calling createConnectionConfiguration(Async)");
        }

        return createConnectionConfigurationCall(createConnectionConfigurationRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Creates an additional configuration to an existing connection to
     * a data warehouse. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required. #### Usage guidelines * A JSON map of configuration attributes in
     * &#x60;configuration&#x60;. The following example shows the configuration attributes:
     * &#x60;&#x60;&#x60; { \&quot;user\&quot;:\&quot;DEV_USER\&quot;,
     * \&quot;password\&quot;:\&quot;TestConn123\&quot;, \&quot;role\&quot;:\&quot;DEV\&quot;,
     * \&quot;warehouse\&quot;:\&quot;DEV_WH\&quot; } &#x60;&#x60;&#x60; * If the
     * &#x60;policy_type&#x60; is &#x60;PRINCIPALS&#x60;, then &#x60;policy_principals&#x60; is a
     * required field. * If the &#x60;policy_type&#x60; is &#x60;PROCESSES&#x60;, then
     * &#x60;policy_processes&#x60; is a required field. * If the &#x60;policy_type&#x60; is
     * &#x60;NO_POLICY&#x60;, then &#x60;policy_principals&#x60; and &#x60;policy_processes&#x60;
     * are not required fields.
     *
     * @param createConnectionConfigurationRequest (required)
     * @return ConnectionConfigurationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Connection configuration successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ConnectionConfigurationResponse createConnectionConfiguration(
            CreateConnectionConfigurationRequest createConnectionConfigurationRequest)
            throws ApiException {
        ApiResponse<ConnectionConfigurationResponse> localVarResp =
                createConnectionConfigurationWithHttpInfo(createConnectionConfigurationRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.12.0.cl or later Creates an additional configuration to an existing connection to
     * a data warehouse. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required. #### Usage guidelines * A JSON map of configuration attributes in
     * &#x60;configuration&#x60;. The following example shows the configuration attributes:
     * &#x60;&#x60;&#x60; { \&quot;user\&quot;:\&quot;DEV_USER\&quot;,
     * \&quot;password\&quot;:\&quot;TestConn123\&quot;, \&quot;role\&quot;:\&quot;DEV\&quot;,
     * \&quot;warehouse\&quot;:\&quot;DEV_WH\&quot; } &#x60;&#x60;&#x60; * If the
     * &#x60;policy_type&#x60; is &#x60;PRINCIPALS&#x60;, then &#x60;policy_principals&#x60; is a
     * required field. * If the &#x60;policy_type&#x60; is &#x60;PROCESSES&#x60;, then
     * &#x60;policy_processes&#x60; is a required field. * If the &#x60;policy_type&#x60; is
     * &#x60;NO_POLICY&#x60;, then &#x60;policy_principals&#x60; and &#x60;policy_processes&#x60;
     * are not required fields.
     *
     * @param createConnectionConfigurationRequest (required)
     * @return ApiResponse&lt;ConnectionConfigurationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Connection configuration successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ConnectionConfigurationResponse> createConnectionConfigurationWithHttpInfo(
            CreateConnectionConfigurationRequest createConnectionConfigurationRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                createConnectionConfigurationValidateBeforeCall(
                        createConnectionConfigurationRequest, null);
        Type localVarReturnType = new TypeToken<ConnectionConfigurationResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Creates an additional configuration to an
     * existing connection to a data warehouse. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage
     * data**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. #### Usage guidelines * A JSON map of configuration
     * attributes in &#x60;configuration&#x60;. The following example shows the configuration
     * attributes: &#x60;&#x60;&#x60; { \&quot;user\&quot;:\&quot;DEV_USER\&quot;,
     * \&quot;password\&quot;:\&quot;TestConn123\&quot;, \&quot;role\&quot;:\&quot;DEV\&quot;,
     * \&quot;warehouse\&quot;:\&quot;DEV_WH\&quot; } &#x60;&#x60;&#x60; * If the
     * &#x60;policy_type&#x60; is &#x60;PRINCIPALS&#x60;, then &#x60;policy_principals&#x60; is a
     * required field. * If the &#x60;policy_type&#x60; is &#x60;PROCESSES&#x60;, then
     * &#x60;policy_processes&#x60; is a required field. * If the &#x60;policy_type&#x60; is
     * &#x60;NO_POLICY&#x60;, then &#x60;policy_principals&#x60; and &#x60;policy_processes&#x60;
     * are not required fields.
     *
     * @param createConnectionConfigurationRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Connection configuration successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createConnectionConfigurationAsync(
            CreateConnectionConfigurationRequest createConnectionConfigurationRequest,
            final ApiCallback<ConnectionConfigurationResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createConnectionConfigurationValidateBeforeCall(
                        createConnectionConfigurationRequest, _callback);
        Type localVarReturnType = new TypeToken<ConnectionConfigurationResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createConversation
     *
     * @param createConversationRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createConversationCall(
            CreateConversationRequest createConversationRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createConversationRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/ai/conversation/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createConversationValidateBeforeCall(
            CreateConversationRequest createConversationRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createConversationRequest' is set
        if (createConversationRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createConversationRequest' when calling"
                            + " createConversation(Async)");
        }

        return createConversationCall(createConversationRequest, _callback);
    }

    /**
     * Version: 10.4.0.cl or later Creates a Conversation object to start an AI-driven conversation
     * based on a specific data model. Requires at least view access to the metadata object
     * specified in the request. #### Usage guidelines This API requires the
     * &#x60;metadata_identifier&#x60; parameter to define the context for the conversation. You can
     * also specify the tokens to initiate the conversation as shown in this example:
     * &#x60;\&quot;tokens\&quot;: \&quot;[tea],[sales],[type]\&quot;&#x60; If the API request is
     * successful, ThoughtSpot returns the ID of the conversation. &gt; ###### Note: &gt; * This
     * endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made
     * Generally Available. &gt; * This endpoint requires Spotter - please contact ThoughtSpot
     * support to enable Spotter on your cluster.
     *
     * @param createConversationRequest (required)
     * @return Conversation
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public Conversation createConversation(CreateConversationRequest createConversationRequest)
            throws ApiException {
        ApiResponse<Conversation> localVarResp =
                createConversationWithHttpInfo(createConversationRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.4.0.cl or later Creates a Conversation object to start an AI-driven conversation
     * based on a specific data model. Requires at least view access to the metadata object
     * specified in the request. #### Usage guidelines This API requires the
     * &#x60;metadata_identifier&#x60; parameter to define the context for the conversation. You can
     * also specify the tokens to initiate the conversation as shown in this example:
     * &#x60;\&quot;tokens\&quot;: \&quot;[tea],[sales],[type]\&quot;&#x60; If the API request is
     * successful, ThoughtSpot returns the ID of the conversation. &gt; ###### Note: &gt; * This
     * endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made
     * Generally Available. &gt; * This endpoint requires Spotter - please contact ThoughtSpot
     * support to enable Spotter on your cluster.
     *
     * @param createConversationRequest (required)
     * @return ApiResponse&lt;Conversation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Conversation> createConversationWithHttpInfo(
            CreateConversationRequest createConversationRequest) throws ApiException {
        okhttp3.Call localVarCall =
                createConversationValidateBeforeCall(createConversationRequest, null);
        Type localVarReturnType = new TypeToken<Conversation>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.4.0.cl or later Creates a Conversation object to start an
     * AI-driven conversation based on a specific data model. Requires at least view access to the
     * metadata object specified in the request. #### Usage guidelines This API requires the
     * &#x60;metadata_identifier&#x60; parameter to define the context for the conversation. You can
     * also specify the tokens to initiate the conversation as shown in this example:
     * &#x60;\&quot;tokens\&quot;: \&quot;[tea],[sales],[type]\&quot;&#x60; If the API request is
     * successful, ThoughtSpot returns the ID of the conversation. &gt; ###### Note: &gt; * This
     * endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made
     * Generally Available. &gt; * This endpoint requires Spotter - please contact ThoughtSpot
     * support to enable Spotter on your cluster.
     *
     * @param createConversationRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createConversationAsync(
            CreateConversationRequest createConversationRequest,
            final ApiCallback<Conversation> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createConversationValidateBeforeCall(createConversationRequest, _callback);
        Type localVarReturnType = new TypeToken<Conversation>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createCustomAction
     *
     * @param createCustomActionRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom action created successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createCustomActionCall(
            CreateCustomActionRequest createCustomActionRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createCustomActionRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/customization/custom-actions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createCustomActionValidateBeforeCall(
            CreateCustomActionRequest createCustomActionRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createCustomActionRequest' is set
        if (createCustomActionRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createCustomActionRequest' when calling"
                            + " createCustomAction(Async)");
        }

        return createCustomActionCall(createCustomActionRequest, _callback);
    }

    /**
     * Version: 9.6.0.cl or later Creates a custom action that appears as a menu action on a saved
     * Answer or Liveboard visualization. Requires &#x60;DEVELOPER&#x60; (**Has Developer
     * privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is
     * required. #### Usage Guidelines The API lets you create the following types of custom
     * actions: * URL-based action Allows pushing data to an external URL. * Callback action
     * Triggers a callback to the host application and initiates a response payload on an embedded
     * ThoughtSpot instance. By default, custom actions are visible to only administrator or
     * developer users. To make a custom action available to other users, and specify the groups in
     * &#x60;group_identifiers&#x60;. By default, the custom action is set as a _global_ action on
     * all visualizations and saved Answers. To assign a custom action to specific Liveboard
     * visualization, saved Answer, or Worksheet, set &#x60;visibility&#x60; to &#x60;false&#x60; in
     * &#x60;default_action_config&#x60; property and specify the GUID or name of the object in
     * &#x60;associate_metadata&#x60;. For more information, see [Custom
     * actions](https://developers.thoughtspot.com/docs/custom-action-intro).
     *
     * @param createCustomActionRequest (required)
     * @return ResponseCustomAction
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom action created successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ResponseCustomAction createCustomAction(
            CreateCustomActionRequest createCustomActionRequest) throws ApiException {
        ApiResponse<ResponseCustomAction> localVarResp =
                createCustomActionWithHttpInfo(createCustomActionRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.6.0.cl or later Creates a custom action that appears as a menu action on a saved
     * Answer or Liveboard visualization. Requires &#x60;DEVELOPER&#x60; (**Has Developer
     * privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is
     * required. #### Usage Guidelines The API lets you create the following types of custom
     * actions: * URL-based action Allows pushing data to an external URL. * Callback action
     * Triggers a callback to the host application and initiates a response payload on an embedded
     * ThoughtSpot instance. By default, custom actions are visible to only administrator or
     * developer users. To make a custom action available to other users, and specify the groups in
     * &#x60;group_identifiers&#x60;. By default, the custom action is set as a _global_ action on
     * all visualizations and saved Answers. To assign a custom action to specific Liveboard
     * visualization, saved Answer, or Worksheet, set &#x60;visibility&#x60; to &#x60;false&#x60; in
     * &#x60;default_action_config&#x60; property and specify the GUID or name of the object in
     * &#x60;associate_metadata&#x60;. For more information, see [Custom
     * actions](https://developers.thoughtspot.com/docs/custom-action-intro).
     *
     * @param createCustomActionRequest (required)
     * @return ApiResponse&lt;ResponseCustomAction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom action created successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ResponseCustomAction> createCustomActionWithHttpInfo(
            CreateCustomActionRequest createCustomActionRequest) throws ApiException {
        okhttp3.Call localVarCall =
                createCustomActionValidateBeforeCall(createCustomActionRequest, null);
        Type localVarReturnType = new TypeToken<ResponseCustomAction>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.6.0.cl or later Creates a custom action that appears as a menu
     * action on a saved Answer or Liveboard visualization. Requires &#x60;DEVELOPER&#x60; (**Has
     * Developer privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. #### Usage
     * Guidelines The API lets you create the following types of custom actions: * URL-based action
     * Allows pushing data to an external URL. * Callback action Triggers a callback to the host
     * application and initiates a response payload on an embedded ThoughtSpot instance. By default,
     * custom actions are visible to only administrator or developer users. To make a custom action
     * available to other users, and specify the groups in &#x60;group_identifiers&#x60;. By
     * default, the custom action is set as a _global_ action on all visualizations and saved
     * Answers. To assign a custom action to specific Liveboard visualization, saved Answer, or
     * Worksheet, set &#x60;visibility&#x60; to &#x60;false&#x60; in
     * &#x60;default_action_config&#x60; property and specify the GUID or name of the object in
     * &#x60;associate_metadata&#x60;. For more information, see [Custom
     * actions](https://developers.thoughtspot.com/docs/custom-action-intro).
     *
     * @param createCustomActionRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom action created successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createCustomActionAsync(
            CreateCustomActionRequest createCustomActionRequest,
            final ApiCallback<ResponseCustomAction> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createCustomActionValidateBeforeCall(createCustomActionRequest, _callback);
        Type localVarReturnType = new TypeToken<ResponseCustomAction>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createEmailCustomization
     *
     * @param createEmailCustomizationRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createEmailCustomizationCall(
            CreateEmailCustomizationRequest createEmailCustomizationRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createEmailCustomizationRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/customization/email";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createEmailCustomizationValidateBeforeCall(
            CreateEmailCustomizationRequest createEmailCustomizationRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createEmailCustomizationRequest' is set
        if (createEmailCustomizationRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createEmailCustomizationRequest' when calling"
                            + " createEmailCustomization(Async)");
        }

        return createEmailCustomizationCall(createEmailCustomizationRequest, _callback);
    }

    /**
     * Version: 10.10.0.cl or later Creates a customization configuration for the notification
     * email. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer privilege**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. **NOTE**:This
     * endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.
     * #### Usage guidelines To create a custom configuration pass these parameters in your API
     * request: - A JSON map of configuration attributes &#x60;template_properties&#x60;. The
     * following example shows a sample set of customization configuration: &#x60;&#x60;&#x60; { {
     * \&quot;ctaButtonBgColor\&quot;: \&quot;#444DEA\&quot;, \&quot;ctaTextFontColor\&quot;:
     * \&quot;#FFFFFF\&quot;, \&quot;primaryBgColor\&quot;: \&quot;#D3DEF0\&quot;,
     * \&quot;hideMobileAppNudge\&quot;: false, \&quot;fontFamily\&quot; : \&quot;\&quot;,
     * \&quot;hideProductName\&quot; : false, \&quot;hideFooterPhone\&quot; : false,
     * \&quot;hideFooterAddress\&quot; : false, \&quot;hidePrivacyPolicy\&quot; : false,
     * \&quot;hideManageNotification\&quot; : false, \&quot;hideTsVocabularyDefinitions\&quot;:
     * false, \&quot;hideNotificationStatus\&quot; : false, \&quot;hideErrorMessage\&quot;: false,
     * \&quot;hideUnsubscribeLink\&quot; : false, \&quot;hideModifyAlert\&quot;: false,
     * \&quot;textTransform\&quot;: \&quot;\&quot;, \&quot;replacementValueForLiveboard\&quot;:
     * \&quot;LB dashboard\&quot;, \&quot;replacementValueForAnswer\&quot;: \&quot;Answer
     * dashboard\&quot;, \&quot;replacementValueForSpotIQ\&quot;: \&quot;SpotIQ dashboard\&quot;,
     * \&quot;logoUrl\&quot;:\&quot;\&quot;, \&quot;productName\&quot;:\&quot;ThoughtSpot\&quot;,
     * \&quot;footerPhone\&quot;:\&quot;(800) 508-7008\&quot;,
     * \&quot;footerAddress\&quot;:\&quot;444 Castro St, Suite 1000 Mountain View, CA 94041\&quot;,
     * \&quot;companyWebsiteUrl\&quot;:\&quot;\&quot;,
     * \&quot;companyPrivacyPolicyUrl\&quot;:\&quot;\&quot; } } &#x60;&#x60;&#x60;
     *
     * @param createEmailCustomizationRequest (required)
     * @return CreateEmailCustomizationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public CreateEmailCustomizationResponse createEmailCustomization(
            CreateEmailCustomizationRequest createEmailCustomizationRequest) throws ApiException {
        ApiResponse<CreateEmailCustomizationResponse> localVarResp =
                createEmailCustomizationWithHttpInfo(createEmailCustomizationRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.10.0.cl or later Creates a customization configuration for the notification
     * email. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer privilege**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. **NOTE**:This
     * endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.
     * #### Usage guidelines To create a custom configuration pass these parameters in your API
     * request: - A JSON map of configuration attributes &#x60;template_properties&#x60;. The
     * following example shows a sample set of customization configuration: &#x60;&#x60;&#x60; { {
     * \&quot;ctaButtonBgColor\&quot;: \&quot;#444DEA\&quot;, \&quot;ctaTextFontColor\&quot;:
     * \&quot;#FFFFFF\&quot;, \&quot;primaryBgColor\&quot;: \&quot;#D3DEF0\&quot;,
     * \&quot;hideMobileAppNudge\&quot;: false, \&quot;fontFamily\&quot; : \&quot;\&quot;,
     * \&quot;hideProductName\&quot; : false, \&quot;hideFooterPhone\&quot; : false,
     * \&quot;hideFooterAddress\&quot; : false, \&quot;hidePrivacyPolicy\&quot; : false,
     * \&quot;hideManageNotification\&quot; : false, \&quot;hideTsVocabularyDefinitions\&quot;:
     * false, \&quot;hideNotificationStatus\&quot; : false, \&quot;hideErrorMessage\&quot;: false,
     * \&quot;hideUnsubscribeLink\&quot; : false, \&quot;hideModifyAlert\&quot;: false,
     * \&quot;textTransform\&quot;: \&quot;\&quot;, \&quot;replacementValueForLiveboard\&quot;:
     * \&quot;LB dashboard\&quot;, \&quot;replacementValueForAnswer\&quot;: \&quot;Answer
     * dashboard\&quot;, \&quot;replacementValueForSpotIQ\&quot;: \&quot;SpotIQ dashboard\&quot;,
     * \&quot;logoUrl\&quot;:\&quot;\&quot;, \&quot;productName\&quot;:\&quot;ThoughtSpot\&quot;,
     * \&quot;footerPhone\&quot;:\&quot;(800) 508-7008\&quot;,
     * \&quot;footerAddress\&quot;:\&quot;444 Castro St, Suite 1000 Mountain View, CA 94041\&quot;,
     * \&quot;companyWebsiteUrl\&quot;:\&quot;\&quot;,
     * \&quot;companyPrivacyPolicyUrl\&quot;:\&quot;\&quot; } } &#x60;&#x60;&#x60;
     *
     * @param createEmailCustomizationRequest (required)
     * @return ApiResponse&lt;CreateEmailCustomizationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<CreateEmailCustomizationResponse> createEmailCustomizationWithHttpInfo(
            CreateEmailCustomizationRequest createEmailCustomizationRequest) throws ApiException {
        okhttp3.Call localVarCall =
                createEmailCustomizationValidateBeforeCall(createEmailCustomizationRequest, null);
        Type localVarReturnType = new TypeToken<CreateEmailCustomizationResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.10.0.cl or later Creates a customization configuration for the
     * notification email. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer
     * privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is
     * required. **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable
     * this on your instance. #### Usage guidelines To create a custom configuration pass these
     * parameters in your API request: - A JSON map of configuration attributes
     * &#x60;template_properties&#x60;. The following example shows a sample set of customization
     * configuration: &#x60;&#x60;&#x60; { { \&quot;ctaButtonBgColor\&quot;: \&quot;#444DEA\&quot;,
     * \&quot;ctaTextFontColor\&quot;: \&quot;#FFFFFF\&quot;, \&quot;primaryBgColor\&quot;:
     * \&quot;#D3DEF0\&quot;, \&quot;hideMobileAppNudge\&quot;: false, \&quot;fontFamily\&quot; :
     * \&quot;\&quot;, \&quot;hideProductName\&quot; : false, \&quot;hideFooterPhone\&quot; : false,
     * \&quot;hideFooterAddress\&quot; : false, \&quot;hidePrivacyPolicy\&quot; : false,
     * \&quot;hideManageNotification\&quot; : false, \&quot;hideTsVocabularyDefinitions\&quot;:
     * false, \&quot;hideNotificationStatus\&quot; : false, \&quot;hideErrorMessage\&quot;: false,
     * \&quot;hideUnsubscribeLink\&quot; : false, \&quot;hideModifyAlert\&quot;: false,
     * \&quot;textTransform\&quot;: \&quot;\&quot;, \&quot;replacementValueForLiveboard\&quot;:
     * \&quot;LB dashboard\&quot;, \&quot;replacementValueForAnswer\&quot;: \&quot;Answer
     * dashboard\&quot;, \&quot;replacementValueForSpotIQ\&quot;: \&quot;SpotIQ dashboard\&quot;,
     * \&quot;logoUrl\&quot;:\&quot;\&quot;, \&quot;productName\&quot;:\&quot;ThoughtSpot\&quot;,
     * \&quot;footerPhone\&quot;:\&quot;(800) 508-7008\&quot;,
     * \&quot;footerAddress\&quot;:\&quot;444 Castro St, Suite 1000 Mountain View, CA 94041\&quot;,
     * \&quot;companyWebsiteUrl\&quot;:\&quot;\&quot;,
     * \&quot;companyPrivacyPolicyUrl\&quot;:\&quot;\&quot; } } &#x60;&#x60;&#x60;
     *
     * @param createEmailCustomizationRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createEmailCustomizationAsync(
            CreateEmailCustomizationRequest createEmailCustomizationRequest,
            final ApiCallback<CreateEmailCustomizationResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createEmailCustomizationValidateBeforeCall(
                        createEmailCustomizationRequest, _callback);
        Type localVarReturnType = new TypeToken<CreateEmailCustomizationResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createOrg
     *
     * @param createOrgRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Organization successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createOrgCall(
            CreateOrgRequest createOrgRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createOrgRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/orgs/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createOrgValidateBeforeCall(
            CreateOrgRequest createOrgRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createOrgRequest' is set
        if (createOrgRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createOrgRequest' when calling"
                            + " createOrg(Async)");
        }

        return createOrgCall(createOrgRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Creates an Org object. To use this API, the
     * [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview) feature must be enabled in
     * your cluster. Requires cluster administration (**Can administer Org**) privileges. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is
     * required.
     *
     * @param createOrgRequest (required)
     * @return OrgResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Organization successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public OrgResponse createOrg(CreateOrgRequest createOrgRequest) throws ApiException {
        ApiResponse<OrgResponse> localVarResp = createOrgWithHttpInfo(createOrgRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Creates an Org object. To use this API, the
     * [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview) feature must be enabled in
     * your cluster. Requires cluster administration (**Can administer Org**) privileges. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is
     * required.
     *
     * @param createOrgRequest (required)
     * @return ApiResponse&lt;OrgResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Organization successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<OrgResponse> createOrgWithHttpInfo(CreateOrgRequest createOrgRequest)
            throws ApiException {
        okhttp3.Call localVarCall = createOrgValidateBeforeCall(createOrgRequest, null);
        Type localVarReturnType = new TypeToken<OrgResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Creates an Org object. To use this API, the
     * [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview) feature must be enabled in
     * your cluster. Requires cluster administration (**Can administer Org**) privileges. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is
     * required.
     *
     * @param createOrgRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Organization successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createOrgAsync(
            CreateOrgRequest createOrgRequest, final ApiCallback<OrgResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = createOrgValidateBeforeCall(createOrgRequest, _callback);
        Type localVarReturnType = new TypeToken<OrgResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createRole
     *
     * @param createRoleRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Role successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid parameters. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createRoleCall(
            CreateRoleRequest createRoleRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createRoleRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/roles/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createRoleValidateBeforeCall(
            CreateRoleRequest createRoleRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createRoleRequest' is set
        if (createRoleRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createRoleRequest' when calling"
                            + " createRole(Async)");
        }

        return createRoleCall(createRoleRequest, _callback);
    }

    /**
     * Version: 9.5.0.cl or later Creates a Role object in ThoughtSpot. Available only if
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance. To create a Role, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can manage
     * roles**) privilege is required.
     *
     * @param createRoleRequest (required)
     * @return RoleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Role successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid parameters. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public RoleResponse createRole(CreateRoleRequest createRoleRequest) throws ApiException {
        ApiResponse<RoleResponse> localVarResp = createRoleWithHttpInfo(createRoleRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.5.0.cl or later Creates a Role object in ThoughtSpot. Available only if
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance. To create a Role, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can manage
     * roles**) privilege is required.
     *
     * @param createRoleRequest (required)
     * @return ApiResponse&lt;RoleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Role successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid parameters. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<RoleResponse> createRoleWithHttpInfo(CreateRoleRequest createRoleRequest)
            throws ApiException {
        okhttp3.Call localVarCall = createRoleValidateBeforeCall(createRoleRequest, null);
        Type localVarReturnType = new TypeToken<RoleResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.5.0.cl or later Creates a Role object in ThoughtSpot. Available
     * only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance. To create a Role, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can manage
     * roles**) privilege is required.
     *
     * @param createRoleRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Role successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid parameters. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createRoleAsync(
            CreateRoleRequest createRoleRequest, final ApiCallback<RoleResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = createRoleValidateBeforeCall(createRoleRequest, _callback);
        Type localVarReturnType = new TypeToken<RoleResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createSchedule
     *
     * @param createScheduleRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Schedule successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createScheduleCall(
            CreateScheduleRequest createScheduleRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createScheduleRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/schedules/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createScheduleValidateBeforeCall(
            CreateScheduleRequest createScheduleRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createScheduleRequest' is set
        if (createScheduleRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createScheduleRequest' when calling"
                            + " createSchedule(Async)");
        }

        return createScheduleCall(createScheduleRequest, _callback);
    }

    /**
     * Create schedule. Version: 9.4.0.cl or later Creates a Liveboard schedule job. Requires at
     * least edit access to Liveboards. To create a schedule on behalf of another user, you need
     * &#x60;ADMINISTRATION&#x60; (**Can administer Org**) or &#x60;JOBSCHEDULING&#x60; (**Can
     * schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege is required. #### Usage
     * guidelines * The description text is mandatory. The description text appears as
     * **Description: &lt;your content&gt;** in the Liveboard schedule email notifications. * For
     * Liveboards with both charts and tables, schedule creation is only supported in PDF and XLS
     * formats. Schedules created in CSV formats for such Liveboards will fail to run. If
     * &#x60;PDF&#x60; is set as the &#x60;file_format&#x60;, enable &#x60;pdf_options&#x60; to get
     * the correct attachment. Not doing so may cause the attachment to be rendered empty. * To
     * include only specific visualizations, specify the visualization GUIDs in the
     * &#x60;visualization_identifiers&#x60; array. * You can schedule a Liveboard job to run
     * periodically by setting frequency parameters. You can set the schedule to run daily, weekly,
     * monthly or every n minutes or hours. The scheduled job can also be configured to run at a
     * specific time of the day or on specific days of the week or month. Please ensure that when
     * setting the schedule frequency for _minute of the object_, only values that are multiples of
     * 5 are included. * If the &#x60;frequency&#x60; parameters are defined, you can set the time
     * zone to a value that matches your server&#39;s time zone. For example,
     * &#x60;US/Central&#x60;, &#x60;Etc/UTC&#x60;, &#x60;CET&#x60;. The default time zone is
     * &#x60;America/Los_Angeles&#x60;. For more information about Liveboard jobs, see [ThoughtSpot
     * Product Documentation](https://docs.thoughtspot.com/cloud/latest/liveboard-schedule).
     *
     * @param createScheduleRequest (required)
     * @return ResponseSchedule
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Schedule successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ResponseSchedule createSchedule(CreateScheduleRequest createScheduleRequest)
            throws ApiException {
        ApiResponse<ResponseSchedule> localVarResp =
                createScheduleWithHttpInfo(createScheduleRequest);
        return localVarResp.getData();
    }

    /**
     * Create schedule. Version: 9.4.0.cl or later Creates a Liveboard schedule job. Requires at
     * least edit access to Liveboards. To create a schedule on behalf of another user, you need
     * &#x60;ADMINISTRATION&#x60; (**Can administer Org**) or &#x60;JOBSCHEDULING&#x60; (**Can
     * schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege is required. #### Usage
     * guidelines * The description text is mandatory. The description text appears as
     * **Description: &lt;your content&gt;** in the Liveboard schedule email notifications. * For
     * Liveboards with both charts and tables, schedule creation is only supported in PDF and XLS
     * formats. Schedules created in CSV formats for such Liveboards will fail to run. If
     * &#x60;PDF&#x60; is set as the &#x60;file_format&#x60;, enable &#x60;pdf_options&#x60; to get
     * the correct attachment. Not doing so may cause the attachment to be rendered empty. * To
     * include only specific visualizations, specify the visualization GUIDs in the
     * &#x60;visualization_identifiers&#x60; array. * You can schedule a Liveboard job to run
     * periodically by setting frequency parameters. You can set the schedule to run daily, weekly,
     * monthly or every n minutes or hours. The scheduled job can also be configured to run at a
     * specific time of the day or on specific days of the week or month. Please ensure that when
     * setting the schedule frequency for _minute of the object_, only values that are multiples of
     * 5 are included. * If the &#x60;frequency&#x60; parameters are defined, you can set the time
     * zone to a value that matches your server&#39;s time zone. For example,
     * &#x60;US/Central&#x60;, &#x60;Etc/UTC&#x60;, &#x60;CET&#x60;. The default time zone is
     * &#x60;America/Los_Angeles&#x60;. For more information about Liveboard jobs, see [ThoughtSpot
     * Product Documentation](https://docs.thoughtspot.com/cloud/latest/liveboard-schedule).
     *
     * @param createScheduleRequest (required)
     * @return ApiResponse&lt;ResponseSchedule&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Schedule successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ResponseSchedule> createScheduleWithHttpInfo(
            CreateScheduleRequest createScheduleRequest) throws ApiException {
        okhttp3.Call localVarCall = createScheduleValidateBeforeCall(createScheduleRequest, null);
        Type localVarReturnType = new TypeToken<ResponseSchedule>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Create schedule. Version: 9.4.0.cl or later Creates a Liveboard schedule
     * job. Requires at least edit access to Liveboards. To create a schedule on behalf of another
     * user, you need &#x60;ADMINISTRATION&#x60; (**Can administer Org**) or
     * &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege and edit access to the
     * Liveboard. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege is required. #### Usage
     * guidelines * The description text is mandatory. The description text appears as
     * **Description: &lt;your content&gt;** in the Liveboard schedule email notifications. * For
     * Liveboards with both charts and tables, schedule creation is only supported in PDF and XLS
     * formats. Schedules created in CSV formats for such Liveboards will fail to run. If
     * &#x60;PDF&#x60; is set as the &#x60;file_format&#x60;, enable &#x60;pdf_options&#x60; to get
     * the correct attachment. Not doing so may cause the attachment to be rendered empty. * To
     * include only specific visualizations, specify the visualization GUIDs in the
     * &#x60;visualization_identifiers&#x60; array. * You can schedule a Liveboard job to run
     * periodically by setting frequency parameters. You can set the schedule to run daily, weekly,
     * monthly or every n minutes or hours. The scheduled job can also be configured to run at a
     * specific time of the day or on specific days of the week or month. Please ensure that when
     * setting the schedule frequency for _minute of the object_, only values that are multiples of
     * 5 are included. * If the &#x60;frequency&#x60; parameters are defined, you can set the time
     * zone to a value that matches your server&#39;s time zone. For example,
     * &#x60;US/Central&#x60;, &#x60;Etc/UTC&#x60;, &#x60;CET&#x60;. The default time zone is
     * &#x60;America/Los_Angeles&#x60;. For more information about Liveboard jobs, see [ThoughtSpot
     * Product Documentation](https://docs.thoughtspot.com/cloud/latest/liveboard-schedule).
     *
     * @param createScheduleRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Schedule successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createScheduleAsync(
            CreateScheduleRequest createScheduleRequest,
            final ApiCallback<ResponseSchedule> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createScheduleValidateBeforeCall(createScheduleRequest, _callback);
        Type localVarReturnType = new TypeToken<ResponseSchedule>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createTag
     *
     * @param createTagRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Tag successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createTagCall(
            CreateTagRequest createTagRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createTagRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/tags/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createTagValidateBeforeCall(
            CreateTagRequest createTagRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createTagRequest' is set
        if (createTagRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createTagRequest' when calling"
                            + " createTag(Async)");
        }

        return createTagCall(createTagRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Creates a tag object. Tags are labels that identify a metadata
     * object. For example, you can create a tag to designate subject areas, such as sales, HR,
     * marketing, and finance. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;TAGMANAGEMENT&#x60; (**Can manage tags**) privilege is required to create, edit, and
     * delete tags.
     *
     * @param createTagRequest (required)
     * @return Tag
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Tag successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public Tag createTag(CreateTagRequest createTagRequest) throws ApiException {
        ApiResponse<Tag> localVarResp = createTagWithHttpInfo(createTagRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Creates a tag object. Tags are labels that identify a metadata
     * object. For example, you can create a tag to designate subject areas, such as sales, HR,
     * marketing, and finance. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;TAGMANAGEMENT&#x60; (**Can manage tags**) privilege is required to create, edit, and
     * delete tags.
     *
     * @param createTagRequest (required)
     * @return ApiResponse&lt;Tag&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Tag successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Tag> createTagWithHttpInfo(CreateTagRequest createTagRequest)
            throws ApiException {
        okhttp3.Call localVarCall = createTagValidateBeforeCall(createTagRequest, null);
        Type localVarReturnType = new TypeToken<Tag>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Creates a tag object. Tags are labels that
     * identify a metadata object. For example, you can create a tag to designate subject areas,
     * such as sales, HR, marketing, and finance. Requires &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;TAGMANAGEMENT&#x60; (**Can manage tags**) privilege is required to create, edit, and
     * delete tags.
     *
     * @param createTagRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Tag successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createTagAsync(
            CreateTagRequest createTagRequest, final ApiCallback<Tag> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = createTagValidateBeforeCall(createTagRequest, _callback);
        Type localVarReturnType = new TypeToken<Tag>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createUser
     *
     * @param createUserRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createUserCall(
            CreateUserRequest createUserRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createUserRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/users/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createUserValidateBeforeCall(
            CreateUserRequest createUserRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'createUserRequest' is set
        if (createUserRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createUserRequest' when calling"
                            + " createUser(Async)");
        }

        return createUserCall(createUserRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Creates a user in ThoughtSpot. The API endpoint allows you to
     * configure several user properties such as email address, account status, share notification
     * preferences, and sharing visibility. You can provision the user to
     * [groups](https://docs.thoughtspot.com/cloud/latest/groups-privileges) and
     * [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview). You can also add Liveboard,
     * Answer, and Worksheet objects to the user’s favorites list, assign a default Liveboard for
     * the user, and set user preferences. Requires &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param createUserRequest (required)
     * @return User
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public User createUser(CreateUserRequest createUserRequest) throws ApiException {
        ApiResponse<User> localVarResp = createUserWithHttpInfo(createUserRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Creates a user in ThoughtSpot. The API endpoint allows you to
     * configure several user properties such as email address, account status, share notification
     * preferences, and sharing visibility. You can provision the user to
     * [groups](https://docs.thoughtspot.com/cloud/latest/groups-privileges) and
     * [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview). You can also add Liveboard,
     * Answer, and Worksheet objects to the user’s favorites list, assign a default Liveboard for
     * the user, and set user preferences. Requires &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param createUserRequest (required)
     * @return ApiResponse&lt;User&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<User> createUserWithHttpInfo(CreateUserRequest createUserRequest)
            throws ApiException {
        okhttp3.Call localVarCall = createUserValidateBeforeCall(createUserRequest, null);
        Type localVarReturnType = new TypeToken<User>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Creates a user in ThoughtSpot. The API endpoint
     * allows you to configure several user properties such as email address, account status, share
     * notification preferences, and sharing visibility. You can provision the user to
     * [groups](https://docs.thoughtspot.com/cloud/latest/groups-privileges) and
     * [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview). You can also add Liveboard,
     * Answer, and Worksheet objects to the user’s favorites list, assign a default Liveboard for
     * the user, and set user preferences. Requires &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param createUserRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createUserAsync(
            CreateUserRequest createUserRequest, final ApiCallback<User> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = createUserValidateBeforeCall(createUserRequest, _callback);
        Type localVarReturnType = new TypeToken<User>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createUserGroup
     *
     * @param createUserGroupRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User group successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createUserGroupCall(
            CreateUserGroupRequest createUserGroupRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createUserGroupRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/groups/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createUserGroupValidateBeforeCall(
            CreateUserGroupRequest createUserGroupRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createUserGroupRequest' is set
        if (createUserGroupRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createUserGroupRequest' when calling"
                            + " createUserGroup(Async)");
        }

        return createUserGroupCall(createUserGroupRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Creates a group object in ThoughtSpot. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is required. ####
     * About groups Groups in ThoughtSpot are used by the administrators to define privileges and
     * organize users based on their roles and access requirements. To know more about groups and
     * privileges, see [ThoughtSpot Product
     * Documentation](https://docs.thoughtspot.com/cloud/latest/groups-privileges). #### Supported
     * operations The API endpoint lets you perform the following operations: * Assign privileges *
     * Add users * Define sharing visibility * Add sub-groups * Assign a default Liveboard
     *
     * @param createUserGroupRequest (required)
     * @return UserGroupResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User group successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public UserGroupResponse createUserGroup(CreateUserGroupRequest createUserGroupRequest)
            throws ApiException {
        ApiResponse<UserGroupResponse> localVarResp =
                createUserGroupWithHttpInfo(createUserGroupRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Creates a group object in ThoughtSpot. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is required. ####
     * About groups Groups in ThoughtSpot are used by the administrators to define privileges and
     * organize users based on their roles and access requirements. To know more about groups and
     * privileges, see [ThoughtSpot Product
     * Documentation](https://docs.thoughtspot.com/cloud/latest/groups-privileges). #### Supported
     * operations The API endpoint lets you perform the following operations: * Assign privileges *
     * Add users * Define sharing visibility * Add sub-groups * Assign a default Liveboard
     *
     * @param createUserGroupRequest (required)
     * @return ApiResponse&lt;UserGroupResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User group successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<UserGroupResponse> createUserGroupWithHttpInfo(
            CreateUserGroupRequest createUserGroupRequest) throws ApiException {
        okhttp3.Call localVarCall = createUserGroupValidateBeforeCall(createUserGroupRequest, null);
        Type localVarReturnType = new TypeToken<UserGroupResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Creates a group object in ThoughtSpot. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is required. ####
     * About groups Groups in ThoughtSpot are used by the administrators to define privileges and
     * organize users based on their roles and access requirements. To know more about groups and
     * privileges, see [ThoughtSpot Product
     * Documentation](https://docs.thoughtspot.com/cloud/latest/groups-privileges). #### Supported
     * operations The API endpoint lets you perform the following operations: * Assign privileges *
     * Add users * Define sharing visibility * Add sub-groups * Assign a default Liveboard
     *
     * @param createUserGroupRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User group successfully created. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createUserGroupAsync(
            CreateUserGroupRequest createUserGroupRequest,
            final ApiCallback<UserGroupResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createUserGroupValidateBeforeCall(createUserGroupRequest, _callback);
        Type localVarReturnType = new TypeToken<UserGroupResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for createVariable
     *
     * @param createVariableRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Create variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createVariableCall(
            CreateVariableRequest createVariableRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = createVariableRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/template/variables/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call createVariableValidateBeforeCall(
            CreateVariableRequest createVariableRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'createVariableRequest' is set
        if (createVariableRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'createVariableRequest' when calling"
                            + " createVariable(Async)");
        }

        return createVariableCall(createVariableRequest, _callback);
    }

    /**
     * Create a variable which can be used for parameterizing metadata objects Version: 10.9.0.cl or
     * later Allows creating a variable which can be used for parameterizing metadata objects in
     * ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The API endpoint supports the
     * following types of variables: * CONNECTION_PROPERTY - For connection properties *
     * TABLE_MAPPING - For table mappings * CONNECTION_PROPERTY_PER_PRINCIPAL - For connection
     * properties per principal. In order to use this please contact support to enable this. When
     * creating a variable, you need to specify: * The variable type * A unique name for the
     * variable * Whether the variable contains sensitive values (defaults to false) The operation
     * will fail if: * The user lacks required permissions * The variable name already exists * The
     * variable type is invalid
     *
     * @param createVariableRequest (required)
     * @return Variable
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Create variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public Variable createVariable(CreateVariableRequest createVariableRequest)
            throws ApiException {
        ApiResponse<Variable> localVarResp = createVariableWithHttpInfo(createVariableRequest);
        return localVarResp.getData();
    }

    /**
     * Create a variable which can be used for parameterizing metadata objects Version: 10.9.0.cl or
     * later Allows creating a variable which can be used for parameterizing metadata objects in
     * ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The API endpoint supports the
     * following types of variables: * CONNECTION_PROPERTY - For connection properties *
     * TABLE_MAPPING - For table mappings * CONNECTION_PROPERTY_PER_PRINCIPAL - For connection
     * properties per principal. In order to use this please contact support to enable this. When
     * creating a variable, you need to specify: * The variable type * A unique name for the
     * variable * Whether the variable contains sensitive values (defaults to false) The operation
     * will fail if: * The user lacks required permissions * The variable name already exists * The
     * variable type is invalid
     *
     * @param createVariableRequest (required)
     * @return ApiResponse&lt;Variable&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Create variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Variable> createVariableWithHttpInfo(
            CreateVariableRequest createVariableRequest) throws ApiException {
        okhttp3.Call localVarCall = createVariableValidateBeforeCall(createVariableRequest, null);
        Type localVarReturnType = new TypeToken<Variable>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Create a variable which can be used for parameterizing metadata objects
     * Version: 10.9.0.cl or later Allows creating a variable which can be used for parameterizing
     * metadata objects in ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The API
     * endpoint supports the following types of variables: * CONNECTION_PROPERTY - For connection
     * properties * TABLE_MAPPING - For table mappings * CONNECTION_PROPERTY_PER_PRINCIPAL - For
     * connection properties per principal. In order to use this please contact support to enable
     * this. When creating a variable, you need to specify: * The variable type * A unique name for
     * the variable * Whether the variable contains sensitive values (defaults to false) The
     * operation will fail if: * The user lacks required permissions * The variable name already
     * exists * The variable type is invalid
     *
     * @param createVariableRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Create variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call createVariableAsync(
            CreateVariableRequest createVariableRequest, final ApiCallback<Variable> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                createVariableValidateBeforeCall(createVariableRequest, _callback);
        Type localVarReturnType = new TypeToken<Variable>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for dbtConnection
     *
     * @param connectionName Name of the connection. (required)
     * @param databaseName Name of the Database. (required)
     * @param importType Mention type of Import (optional, default to DBT_CLOUD)
     * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param dbtEnvId DBT Environment ID\\\&quot; (optional)
     * @param projectName Name of the project (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is Mandatory when Import Type is &#39;ZIP_FILE&#39; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Succesfully created DBT Connection. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call dbtConnectionCall(
            String connectionName,
            String databaseName,
            String importType,
            String accessToken,
            String dbtUrl,
            String accountId,
            String projectId,
            String dbtEnvId,
            String projectName,
            File fileContent,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/dbt/dbt-connection";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (connectionName != null) {
            localVarFormParams.put("connection_name", connectionName);
        }

        if (databaseName != null) {
            localVarFormParams.put("database_name", databaseName);
        }

        if (importType != null) {
            localVarFormParams.put("import_type", importType);
        }

        if (accessToken != null) {
            localVarFormParams.put("access_token", accessToken);
        }

        if (dbtUrl != null) {
            localVarFormParams.put("dbt_url", dbtUrl);
        }

        if (accountId != null) {
            localVarFormParams.put("account_id", accountId);
        }

        if (projectId != null) {
            localVarFormParams.put("project_id", projectId);
        }

        if (dbtEnvId != null) {
            localVarFormParams.put("dbt_env_id", dbtEnvId);
        }

        if (projectName != null) {
            localVarFormParams.put("project_name", projectName);
        }

        if (fileContent != null) {
            localVarFormParams.put("file_content", fileContent);
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"multipart/form-data"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call dbtConnectionValidateBeforeCall(
            String connectionName,
            String databaseName,
            String importType,
            String accessToken,
            String dbtUrl,
            String accountId,
            String projectId,
            String dbtEnvId,
            String projectName,
            File fileContent,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'connectionName' is set
        if (connectionName == null) {
            throw new ApiException(
                    "Missing the required parameter 'connectionName' when calling"
                            + " dbtConnection(Async)");
        }

        // verify the required parameter 'databaseName' is set
        if (databaseName == null) {
            throw new ApiException(
                    "Missing the required parameter 'databaseName' when calling"
                            + " dbtConnection(Async)");
        }

        return dbtConnectionCall(
                connectionName,
                databaseName,
                importType,
                accessToken,
                dbtUrl,
                accountId,
                projectId,
                dbtEnvId,
                projectName,
                fileContent,
                _callback);
    }

    /**
     * Version: 9.9.0.cl or later Creates a DBT connection object in ThoughtSpot. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About create
     * DBT connection DBT connection in ThoughtSpot is used by the user to define DBT credentials
     * for cloud . The API needs embrace connection, embrace database name, DBT url, import type,
     * DBT account identifier, DBT project identifier, DBT access token and environment details (or)
     * embrace connection, embrace database name, import type, file_content to create a connection
     * object. To know more about DBT, see ThoughtSpot Product Documentation.
     *
     * @param connectionName Name of the connection. (required)
     * @param databaseName Name of the Database. (required)
     * @param importType Mention type of Import (optional, default to DBT_CLOUD)
     * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param dbtEnvId DBT Environment ID\\\&quot; (optional)
     * @param projectName Name of the project (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is Mandatory when Import Type is &#39;ZIP_FILE&#39; (optional)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Succesfully created DBT Connection. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public Object dbtConnection(
            String connectionName,
            String databaseName,
            String importType,
            String accessToken,
            String dbtUrl,
            String accountId,
            String projectId,
            String dbtEnvId,
            String projectName,
            File fileContent)
            throws ApiException {
        ApiResponse<Object> localVarResp =
                dbtConnectionWithHttpInfo(
                        connectionName,
                        databaseName,
                        importType,
                        accessToken,
                        dbtUrl,
                        accountId,
                        projectId,
                        dbtEnvId,
                        projectName,
                        fileContent);
        return localVarResp.getData();
    }

    /**
     * Version: 9.9.0.cl or later Creates a DBT connection object in ThoughtSpot. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About create
     * DBT connection DBT connection in ThoughtSpot is used by the user to define DBT credentials
     * for cloud . The API needs embrace connection, embrace database name, DBT url, import type,
     * DBT account identifier, DBT project identifier, DBT access token and environment details (or)
     * embrace connection, embrace database name, import type, file_content to create a connection
     * object. To know more about DBT, see ThoughtSpot Product Documentation.
     *
     * @param connectionName Name of the connection. (required)
     * @param databaseName Name of the Database. (required)
     * @param importType Mention type of Import (optional, default to DBT_CLOUD)
     * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param dbtEnvId DBT Environment ID\\\&quot; (optional)
     * @param projectName Name of the project (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is Mandatory when Import Type is &#39;ZIP_FILE&#39; (optional)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Succesfully created DBT Connection. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Object> dbtConnectionWithHttpInfo(
            String connectionName,
            String databaseName,
            String importType,
            String accessToken,
            String dbtUrl,
            String accountId,
            String projectId,
            String dbtEnvId,
            String projectName,
            File fileContent)
            throws ApiException {
        okhttp3.Call localVarCall =
                dbtConnectionValidateBeforeCall(
                        connectionName,
                        databaseName,
                        importType,
                        accessToken,
                        dbtUrl,
                        accountId,
                        projectId,
                        dbtEnvId,
                        projectName,
                        fileContent,
                        null);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.9.0.cl or later Creates a DBT connection object in ThoughtSpot.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About create
     * DBT connection DBT connection in ThoughtSpot is used by the user to define DBT credentials
     * for cloud . The API needs embrace connection, embrace database name, DBT url, import type,
     * DBT account identifier, DBT project identifier, DBT access token and environment details (or)
     * embrace connection, embrace database name, import type, file_content to create a connection
     * object. To know more about DBT, see ThoughtSpot Product Documentation.
     *
     * @param connectionName Name of the connection. (required)
     * @param databaseName Name of the Database. (required)
     * @param importType Mention type of Import (optional, default to DBT_CLOUD)
     * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param dbtEnvId DBT Environment ID\\\&quot; (optional)
     * @param projectName Name of the project (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is Mandatory when Import Type is &#39;ZIP_FILE&#39; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Succesfully created DBT Connection. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call dbtConnectionAsync(
            String connectionName,
            String databaseName,
            String importType,
            String accessToken,
            String dbtUrl,
            String accountId,
            String projectId,
            String dbtEnvId,
            String projectName,
            File fileContent,
            final ApiCallback<Object> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                dbtConnectionValidateBeforeCall(
                        connectionName,
                        databaseName,
                        importType,
                        accessToken,
                        dbtUrl,
                        accountId,
                        projectId,
                        dbtEnvId,
                        projectName,
                        fileContent,
                        _callback);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for dbtGenerateSyncTml
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT connection. (required)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is mandatory if the connection was created with import_type ‘ZIP_FILE’ (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Sync Table and Worksheet TML&#39;s are successfully generated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call dbtGenerateSyncTmlCall(
            String dbtConnectionIdentifier, File fileContent, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/dbt/generate-sync-tml";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dbtConnectionIdentifier != null) {
            localVarFormParams.put("dbt_connection_identifier", dbtConnectionIdentifier);
        }

        if (fileContent != null) {
            localVarFormParams.put("file_content", fileContent);
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"multipart/form-data"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call dbtGenerateSyncTmlValidateBeforeCall(
            String dbtConnectionIdentifier, File fileContent, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'dbtConnectionIdentifier' is set
        if (dbtConnectionIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'dbtConnectionIdentifier' when calling"
                            + " dbtGenerateSyncTml(Async)");
        }

        return dbtGenerateSyncTmlCall(dbtConnectionIdentifier, fileContent, _callback);
    }

    /**
     * Version: 9.9.0.cl or later Resynchronize the existing list of models, tables, worksheet tml’s
     * and import them to Thoughtspot based on the DBT connection object. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege, along with an existing DBT
     * connection. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT connection. (required)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is mandatory if the connection was created with import_type ‘ZIP_FILE’ (optional)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Sync Table and Worksheet TML&#39;s are successfully generated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public Object dbtGenerateSyncTml(String dbtConnectionIdentifier, File fileContent)
            throws ApiException {
        ApiResponse<Object> localVarResp =
                dbtGenerateSyncTmlWithHttpInfo(dbtConnectionIdentifier, fileContent);
        return localVarResp.getData();
    }

    /**
     * Version: 9.9.0.cl or later Resynchronize the existing list of models, tables, worksheet tml’s
     * and import them to Thoughtspot based on the DBT connection object. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege, along with an existing DBT
     * connection. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT connection. (required)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is mandatory if the connection was created with import_type ‘ZIP_FILE’ (optional)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Sync Table and Worksheet TML&#39;s are successfully generated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Object> dbtGenerateSyncTmlWithHttpInfo(
            String dbtConnectionIdentifier, File fileContent) throws ApiException {
        okhttp3.Call localVarCall =
                dbtGenerateSyncTmlValidateBeforeCall(dbtConnectionIdentifier, fileContent, null);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.9.0.cl or later Resynchronize the existing list of models,
     * tables, worksheet tml’s and import them to Thoughtspot based on the DBT connection object.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege, along with an existing DBT
     * connection. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT connection. (required)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is mandatory if the connection was created with import_type ‘ZIP_FILE’ (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Sync Table and Worksheet TML&#39;s are successfully generated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call dbtGenerateSyncTmlAsync(
            String dbtConnectionIdentifier, File fileContent, final ApiCallback<Object> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                dbtGenerateSyncTmlValidateBeforeCall(
                        dbtConnectionIdentifier, fileContent, _callback);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for dbtGenerateTml
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT connection. (required)
     * @param importWorksheets Mention the worksheet tmls to import (required)
     * @param modelTables List of Models and their respective Tables (optional)
     * @param worksheets List of worksheets is mandatory when import_Worksheets is type SELECTED
     *     (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is mandatory if the connection was created with import_type ‘ZIP_FILE’ (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Required Table and Worksheet TML&#39;s are successfully generated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call dbtGenerateTmlCall(
            String dbtConnectionIdentifier,
            String importWorksheets,
            String modelTables,
            String worksheets,
            File fileContent,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/dbt/generate-tml";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dbtConnectionIdentifier != null) {
            localVarFormParams.put("dbt_connection_identifier", dbtConnectionIdentifier);
        }

        if (modelTables != null) {
            localVarFormParams.put("model_tables", modelTables);
        }

        if (importWorksheets != null) {
            localVarFormParams.put("import_worksheets", importWorksheets);
        }

        if (worksheets != null) {
            localVarFormParams.put("worksheets", worksheets);
        }

        if (fileContent != null) {
            localVarFormParams.put("file_content", fileContent);
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"multipart/form-data"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call dbtGenerateTmlValidateBeforeCall(
            String dbtConnectionIdentifier,
            String importWorksheets,
            String modelTables,
            String worksheets,
            File fileContent,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'dbtConnectionIdentifier' is set
        if (dbtConnectionIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'dbtConnectionIdentifier' when calling"
                            + " dbtGenerateTml(Async)");
        }

        // verify the required parameter 'importWorksheets' is set
        if (importWorksheets == null) {
            throw new ApiException(
                    "Missing the required parameter 'importWorksheets' when calling"
                            + " dbtGenerateTml(Async)");
        }

        return dbtGenerateTmlCall(
                dbtConnectionIdentifier,
                importWorksheets,
                modelTables,
                worksheets,
                fileContent,
                _callback);
    }

    /**
     * Version: 9.9.0.cl or later Generate required table and worksheet and import them. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege, along with an existing DBT
     * connection. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About
     * generate TML Models and Worksheets to be imported can be selected by the user as part of the
     * API.
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT connection. (required)
     * @param importWorksheets Mention the worksheet tmls to import (required)
     * @param modelTables List of Models and their respective Tables (optional)
     * @param worksheets List of worksheets is mandatory when import_Worksheets is type SELECTED
     *     (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is mandatory if the connection was created with import_type ‘ZIP_FILE’ (optional)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Required Table and Worksheet TML&#39;s are successfully generated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public Object dbtGenerateTml(
            String dbtConnectionIdentifier,
            String importWorksheets,
            String modelTables,
            String worksheets,
            File fileContent)
            throws ApiException {
        ApiResponse<Object> localVarResp =
                dbtGenerateTmlWithHttpInfo(
                        dbtConnectionIdentifier,
                        importWorksheets,
                        modelTables,
                        worksheets,
                        fileContent);
        return localVarResp.getData();
    }

    /**
     * Version: 9.9.0.cl or later Generate required table and worksheet and import them. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege, along with an existing DBT
     * connection. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About
     * generate TML Models and Worksheets to be imported can be selected by the user as part of the
     * API.
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT connection. (required)
     * @param importWorksheets Mention the worksheet tmls to import (required)
     * @param modelTables List of Models and their respective Tables (optional)
     * @param worksheets List of worksheets is mandatory when import_Worksheets is type SELECTED
     *     (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is mandatory if the connection was created with import_type ‘ZIP_FILE’ (optional)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Required Table and Worksheet TML&#39;s are successfully generated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Object> dbtGenerateTmlWithHttpInfo(
            String dbtConnectionIdentifier,
            String importWorksheets,
            String modelTables,
            String worksheets,
            File fileContent)
            throws ApiException {
        okhttp3.Call localVarCall =
                dbtGenerateTmlValidateBeforeCall(
                        dbtConnectionIdentifier,
                        importWorksheets,
                        modelTables,
                        worksheets,
                        fileContent,
                        null);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.9.0.cl or later Generate required table and worksheet and import
     * them. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege, along with an existing DBT
     * connection. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About
     * generate TML Models and Worksheets to be imported can be selected by the user as part of the
     * API.
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT connection. (required)
     * @param importWorksheets Mention the worksheet tmls to import (required)
     * @param modelTables List of Models and their respective Tables (optional)
     * @param worksheets List of worksheets is mandatory when import_Worksheets is type SELECTED
     *     (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is mandatory if the connection was created with import_type ‘ZIP_FILE’ (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Required Table and Worksheet TML&#39;s are successfully generated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call dbtGenerateTmlAsync(
            String dbtConnectionIdentifier,
            String importWorksheets,
            String modelTables,
            String worksheets,
            File fileContent,
            final ApiCallback<Object> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                dbtGenerateTmlValidateBeforeCall(
                        dbtConnectionIdentifier,
                        importWorksheets,
                        modelTables,
                        worksheets,
                        fileContent,
                        _callback);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for dbtSearch
     *
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Retrieved list of DBT connections successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call dbtSearchCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/dbt/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call dbtSearchValidateBeforeCall(final ApiCallback _callback)
            throws ApiException {
        return dbtSearchCall(_callback);
    }

    /**
     * Version: 9.9.0.cl or later Gets a list of DBT connection objects by user and organization,
     * available on the ThoughtSpot system. Requires &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege or &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About search
     * DBT connection To get details of a specific DBT connection identifier, database connection
     * identifier, database connection name, database name, project name, project identifier,
     * environment identifier , import type and author.
     *
     * @return List&lt;DbtSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Retrieved list of DBT connections successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<DbtSearchResponse> dbtSearch() throws ApiException {
        ApiResponse<List<DbtSearchResponse>> localVarResp = dbtSearchWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Version: 9.9.0.cl or later Gets a list of DBT connection objects by user and organization,
     * available on the ThoughtSpot system. Requires &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege or &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About search
     * DBT connection To get details of a specific DBT connection identifier, database connection
     * identifier, database connection name, database name, project name, project identifier,
     * environment identifier , import type and author.
     *
     * @return ApiResponse&lt;List&lt;DbtSearchResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Retrieved list of DBT connections successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<DbtSearchResponse>> dbtSearchWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = dbtSearchValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<List<DbtSearchResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.9.0.cl or later Gets a list of DBT connection objects by user and
     * organization, available on the ThoughtSpot system. Requires &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege or &#x60;DATAMANAGEMENT&#x60; (**Can manage data**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About search
     * DBT connection To get details of a specific DBT connection identifier, database connection
     * identifier, database connection name, database name, project name, project identifier,
     * environment identifier , import type and author.
     *
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Retrieved list of DBT connections successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call dbtSearchAsync(final ApiCallback<List<DbtSearchResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = dbtSearchValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<List<DbtSearchResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deactivateUser
     *
     * @param deactivateUserRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User deactivated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deactivateUserCall(
            DeactivateUserRequest deactivateUserRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deactivateUserRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/users/deactivate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deactivateUserValidateBeforeCall(
            DeactivateUserRequest deactivateUserRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'deactivateUserRequest' is set
        if (deactivateUserRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'deactivateUserRequest' when calling"
                            + " deactivateUser(Async)");
        }

        return deactivateUserCall(deactivateUserRequest, _callback);
    }

    /**
     * Version: 9.7.0.cl or later Deactivates a user account. Requires &#x60;ADMINISTRATION&#x60;
     * (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required. To deactivate a
     * user account, the API request body must include the following information: - Username or the
     * GUID of the user account - Base URL of the ThoughtSpot instance If the API request is
     * successful, ThoughtSpot returns the activation URL in the response. The activation URL is
     * valid for 14 days and can be used to re-activate the account and reset the password of the
     * deactivated account.
     *
     * @param deactivateUserRequest (required)
     * @return ResponseActivationURL
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User deactivated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ResponseActivationURL deactivateUser(DeactivateUserRequest deactivateUserRequest)
            throws ApiException {
        ApiResponse<ResponseActivationURL> localVarResp =
                deactivateUserWithHttpInfo(deactivateUserRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.7.0.cl or later Deactivates a user account. Requires &#x60;ADMINISTRATION&#x60;
     * (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required. To deactivate a
     * user account, the API request body must include the following information: - Username or the
     * GUID of the user account - Base URL of the ThoughtSpot instance If the API request is
     * successful, ThoughtSpot returns the activation URL in the response. The activation URL is
     * valid for 14 days and can be used to re-activate the account and reset the password of the
     * deactivated account.
     *
     * @param deactivateUserRequest (required)
     * @return ApiResponse&lt;ResponseActivationURL&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User deactivated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ResponseActivationURL> deactivateUserWithHttpInfo(
            DeactivateUserRequest deactivateUserRequest) throws ApiException {
        okhttp3.Call localVarCall = deactivateUserValidateBeforeCall(deactivateUserRequest, null);
        Type localVarReturnType = new TypeToken<ResponseActivationURL>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.7.0.cl or later Deactivates a user account. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer Thoughtspot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required. To
     * deactivate a user account, the API request body must include the following information: -
     * Username or the GUID of the user account - Base URL of the ThoughtSpot instance If the API
     * request is successful, ThoughtSpot returns the activation URL in the response. The activation
     * URL is valid for 14 days and can be used to re-activate the account and reset the password of
     * the deactivated account.
     *
     * @param deactivateUserRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User deactivated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deactivateUserAsync(
            DeactivateUserRequest deactivateUserRequest,
            final ApiCallback<ResponseActivationURL> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                deactivateUserValidateBeforeCall(deactivateUserRequest, _callback);
        Type localVarReturnType = new TypeToken<ResponseActivationURL>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteCalendar
     *
     * @param calendarIdentifier Unique ID or name of the Calendar. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom calendar successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteCalendarCall(String calendarIdentifier, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/calendars/{calendar_identifier}/delete"
                        .replace(
                                "{" + "calendar_identifier" + "}",
                                localVarApiClient.escapeString(calendarIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteCalendarValidateBeforeCall(
            String calendarIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'calendarIdentifier' is set
        if (calendarIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'calendarIdentifier' when calling"
                            + " deleteCalendar(Async)");
        }

        return deleteCalendarCall(calendarIdentifier, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Deletes a [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines To delete a custom calendar, specify the
     * calendar ID as a path parameter in the request URL.
     *
     * @param calendarIdentifier Unique ID or name of the Calendar. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom calendar successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteCalendar(String calendarIdentifier) throws ApiException {
        deleteCalendarWithHttpInfo(calendarIdentifier);
    }

    /**
     * Version: 10.12.0.cl or later Deletes a [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines To delete a custom calendar, specify the
     * calendar ID as a path parameter in the request URL.
     *
     * @param calendarIdentifier Unique ID or name of the Calendar. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom calendar successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteCalendarWithHttpInfo(String calendarIdentifier)
            throws ApiException {
        okhttp3.Call localVarCall = deleteCalendarValidateBeforeCall(calendarIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Deletes a [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines To delete a custom calendar, specify the
     * calendar ID as a path parameter in the request URL.
     *
     * @param calendarIdentifier Unique ID or name of the Calendar. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom calendar successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteCalendarAsync(
            String calendarIdentifier, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteCalendarValidateBeforeCall(calendarIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteConfig
     *
     * @param deleteConfigRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfully deleted local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteConfigCall(
            DeleteConfigRequest deleteConfigRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteConfigRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/vcs/git/config/delete";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteConfigValidateBeforeCall(
            DeleteConfigRequest deleteConfigRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'deleteConfigRequest' is set
        if (deleteConfigRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'deleteConfigRequest' when calling"
                            + " deleteConfig(Async)");
        }

        return deleteConfigCall(deleteConfigRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Deletes Git repository configuration from your ThoughtSpot
     * instance. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance on your instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up
     * version control**) privilege.
     *
     * @param deleteConfigRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfully deleted local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteConfig(DeleteConfigRequest deleteConfigRequest) throws ApiException {
        deleteConfigWithHttpInfo(deleteConfigRequest);
    }

    /**
     * Version: 9.2.0.cl or later Deletes Git repository configuration from your ThoughtSpot
     * instance. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance on your instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up
     * version control**) privilege.
     *
     * @param deleteConfigRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfully deleted local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteConfigWithHttpInfo(DeleteConfigRequest deleteConfigRequest)
            throws ApiException {
        okhttp3.Call localVarCall = deleteConfigValidateBeforeCall(deleteConfigRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Deletes Git repository configuration from your
     * ThoughtSpot instance. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your
     * instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up version control**)
     * privilege.
     *
     * @param deleteConfigRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfully deleted local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteConfigAsync(
            DeleteConfigRequest deleteConfigRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = deleteConfigValidateBeforeCall(deleteConfigRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteConnection
     *
     * @param deleteConnectionRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public okhttp3.Call deleteConnectionCall(
            DeleteConnectionRequest deleteConnectionRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteConnectionRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/connection/delete";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteConnectionValidateBeforeCall(
            DeleteConnectionRequest deleteConnectionRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'deleteConnectionRequest' is set
        if (deleteConnectionRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'deleteConnectionRequest' when calling"
                            + " deleteConnection(Async)");
        }

        return deleteConnectionCall(deleteConnectionRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later **Important**: This endpoint is deprecated and will be removed
     * from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Delete
     * Connection V2](#/http/api-endpoints/connections/delete-connection-v2) endpoint to delete your
     * connection objects. #### Usage guidelines Deletes a connection object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. **Note**: If a connection has dependent objects, make
     * sure you remove its associations before the delete operation.
     *
     * @param deleteConnectionRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public void deleteConnection(DeleteConnectionRequest deleteConnectionRequest)
            throws ApiException {
        deleteConnectionWithHttpInfo(deleteConnectionRequest);
    }

    /**
     * Version: 9.2.0.cl or later **Important**: This endpoint is deprecated and will be removed
     * from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Delete
     * Connection V2](#/http/api-endpoints/connections/delete-connection-v2) endpoint to delete your
     * connection objects. #### Usage guidelines Deletes a connection object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. **Note**: If a connection has dependent objects, make
     * sure you remove its associations before the delete operation.
     *
     * @param deleteConnectionRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public ApiResponse<Void> deleteConnectionWithHttpInfo(
            DeleteConnectionRequest deleteConnectionRequest) throws ApiException {
        okhttp3.Call localVarCall =
                deleteConnectionValidateBeforeCall(deleteConnectionRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later **Important**: This endpoint is deprecated and
     * will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the
     * [Delete Connection V2](#/http/api-endpoints/connections/delete-connection-v2) endpoint to
     * delete your connection objects. #### Usage guidelines Deletes a connection object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. **Note**: If a connection has dependent objects, make
     * sure you remove its associations before the delete operation.
     *
     * @param deleteConnectionRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public okhttp3.Call deleteConnectionAsync(
            DeleteConnectionRequest deleteConnectionRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                deleteConnectionValidateBeforeCall(deleteConnectionRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteConnectionConfiguration
     *
     * @param deleteConnectionConfigurationRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection Configurations successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteConnectionConfigurationCall(
            DeleteConnectionConfigurationRequest deleteConnectionConfigurationRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteConnectionConfigurationRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/connection-configurations/delete";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteConnectionConfigurationValidateBeforeCall(
            DeleteConnectionConfigurationRequest deleteConnectionConfigurationRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'deleteConnectionConfigurationRequest' is set
        if (deleteConnectionConfigurationRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'deleteConnectionConfigurationRequest' when"
                            + " calling deleteConnectionConfiguration(Async)");
        }

        return deleteConnectionConfigurationCall(deleteConnectionConfigurationRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Deletes connection configuration objects. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required.
     *
     * @param deleteConnectionConfigurationRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection Configurations successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteConnectionConfiguration(
            DeleteConnectionConfigurationRequest deleteConnectionConfigurationRequest)
            throws ApiException {
        deleteConnectionConfigurationWithHttpInfo(deleteConnectionConfigurationRequest);
    }

    /**
     * Version: 10.12.0.cl or later Deletes connection configuration objects. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required.
     *
     * @param deleteConnectionConfigurationRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection Configurations successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteConnectionConfigurationWithHttpInfo(
            DeleteConnectionConfigurationRequest deleteConnectionConfigurationRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                deleteConnectionConfigurationValidateBeforeCall(
                        deleteConnectionConfigurationRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Deletes connection configuration objects.
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the
     * connection object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege.
     * If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required.
     *
     * @param deleteConnectionConfigurationRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection Configurations successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteConnectionConfigurationAsync(
            DeleteConnectionConfigurationRequest deleteConnectionConfigurationRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                deleteConnectionConfigurationValidateBeforeCall(
                        deleteConnectionConfigurationRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteConnectionV2
     *
     * @param connectionIdentifier Unique ID or name of the connection. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteConnectionV2Call(
            String connectionIdentifier, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/connections/{connection_identifier}/delete"
                        .replace(
                                "{" + "connection_identifier" + "}",
                                localVarApiClient.escapeString(connectionIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteConnectionV2ValidateBeforeCall(
            String connectionIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'connectionIdentifier' is set
        if (connectionIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'connectionIdentifier' when calling"
                            + " deleteConnectionV2(Async)");
        }

        return deleteConnectionV2Call(connectionIdentifier, _callback);
    }

    /**
     * Version: 10.4.0.cl or later Deletes a connection object. **Note**: If a connection has
     * dependent objects, make sure you remove its associations before the delete operation.
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the
     * connection object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege.
     * If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required.
     *
     * @param connectionIdentifier Unique ID or name of the connection. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteConnectionV2(String connectionIdentifier) throws ApiException {
        deleteConnectionV2WithHttpInfo(connectionIdentifier);
    }

    /**
     * Version: 10.4.0.cl or later Deletes a connection object. **Note**: If a connection has
     * dependent objects, make sure you remove its associations before the delete operation.
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the
     * connection object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege.
     * If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required.
     *
     * @param connectionIdentifier Unique ID or name of the connection. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteConnectionV2WithHttpInfo(String connectionIdentifier)
            throws ApiException {
        okhttp3.Call localVarCall =
                deleteConnectionV2ValidateBeforeCall(connectionIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.4.0.cl or later Deletes a connection object. **Note**: If a
     * connection has dependent objects, make sure you remove its associations before the delete
     * operation. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to
     * the connection object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required.
     *
     * @param connectionIdentifier Unique ID or name of the connection. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteConnectionV2Async(
            String connectionIdentifier, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall =
                deleteConnectionV2ValidateBeforeCall(connectionIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteCustomAction
     *
     * @param customActionIdentifier Unique ID or name of the custom action. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom action is successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteCustomActionCall(
            String customActionIdentifier, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/customization/custom-actions/{custom_action_identifier}/delete"
                        .replace(
                                "{" + "custom_action_identifier" + "}",
                                localVarApiClient.escapeString(customActionIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteCustomActionValidateBeforeCall(
            String customActionIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'customActionIdentifier' is set
        if (customActionIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'customActionIdentifier' when calling"
                            + " deleteCustomAction(Async)");
        }

        return deleteCustomActionCall(customActionIdentifier, _callback);
    }

    /**
     * Version: 9.6.0.cl or later Removes the custom action specified in the API request. Requires
     * &#x60;DEVELOPER&#x60; (**Has Developer privilege**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required.
     *
     * @param customActionIdentifier Unique ID or name of the custom action. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom action is successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteCustomAction(String customActionIdentifier) throws ApiException {
        deleteCustomActionWithHttpInfo(customActionIdentifier);
    }

    /**
     * Version: 9.6.0.cl or later Removes the custom action specified in the API request. Requires
     * &#x60;DEVELOPER&#x60; (**Has Developer privilege**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required.
     *
     * @param customActionIdentifier Unique ID or name of the custom action. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom action is successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteCustomActionWithHttpInfo(String customActionIdentifier)
            throws ApiException {
        okhttp3.Call localVarCall =
                deleteCustomActionValidateBeforeCall(customActionIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.6.0.cl or later Removes the custom action specified in the API
     * request. Requires &#x60;DEVELOPER&#x60; (**Has Developer privilege**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required.
     *
     * @param customActionIdentifier Unique ID or name of the custom action. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom action is successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteCustomActionAsync(
            String customActionIdentifier, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall =
                deleteCustomActionValidateBeforeCall(customActionIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteDbtConnection
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT Connection. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> DBT Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteDbtConnectionCall(
            String dbtConnectionIdentifier, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/dbt/{dbt_connection_identifier}/delete"
                        .replace(
                                "{" + "dbt_connection_identifier" + "}",
                                localVarApiClient.escapeString(dbtConnectionIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteDbtConnectionValidateBeforeCall(
            String dbtConnectionIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'dbtConnectionIdentifier' is set
        if (dbtConnectionIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'dbtConnectionIdentifier' when calling"
                            + " deleteDbtConnection(Async)");
        }

        return deleteDbtConnectionCall(dbtConnectionIdentifier, _callback);
    }

    /**
     * Version: 9.9.0.cl or later Removes the specified DBT connection object from the ThoughtSpot
     * system. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT Connection. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> DBT Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteDbtConnection(String dbtConnectionIdentifier) throws ApiException {
        deleteDbtConnectionWithHttpInfo(dbtConnectionIdentifier);
    }

    /**
     * Version: 9.9.0.cl or later Removes the specified DBT connection object from the ThoughtSpot
     * system. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT Connection. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> DBT Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteDbtConnectionWithHttpInfo(String dbtConnectionIdentifier)
            throws ApiException {
        okhttp3.Call localVarCall =
                deleteDbtConnectionValidateBeforeCall(dbtConnectionIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.9.0.cl or later Removes the specified DBT connection object from
     * the ThoughtSpot system. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * or &#x60;DATAMANAGEMENT&#x60; (**Can manage data ThoughtSpot**) privilege. If [Role-Based
     * Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your
     * instance, the following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT Connection. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> DBT Connection successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteDbtConnectionAsync(
            String dbtConnectionIdentifier, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall =
                deleteDbtConnectionValidateBeforeCall(dbtConnectionIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteEmailCustomization
     *
     * @param templateIdentifier Unique ID or name of the email customization. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public okhttp3.Call deleteEmailCustomizationCall(
            String templateIdentifier, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/customization/email/{template_identifier}/delete"
                        .replace(
                                "{" + "template_identifier" + "}",
                                localVarApiClient.escapeString(templateIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteEmailCustomizationValidateBeforeCall(
            String templateIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'templateIdentifier' is set
        if (templateIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'templateIdentifier' when calling"
                            + " deleteEmailCustomization(Async)");
        }

        return deleteEmailCustomizationCall(templateIdentifier, _callback);
    }

    /**
     * Version: 10.10.0.cl or later Deletes the configuration for the email customization. ####
     * Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer privilege**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. **NOTE**:This
     * endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.
     * #### Usage guidelines - Call the search API endpoint to get the
     * &#x60;template_identifier&#x60; from the response. - Use that &#x60;template_identifier&#x60;
     * as a parameter in this API request.
     *
     * @param templateIdentifier Unique ID or name of the email customization. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public void deleteEmailCustomization(String templateIdentifier) throws ApiException {
        deleteEmailCustomizationWithHttpInfo(templateIdentifier);
    }

    /**
     * Version: 10.10.0.cl or later Deletes the configuration for the email customization. ####
     * Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer privilege**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. **NOTE**:This
     * endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.
     * #### Usage guidelines - Call the search API endpoint to get the
     * &#x60;template_identifier&#x60; from the response. - Use that &#x60;template_identifier&#x60;
     * as a parameter in this API request.
     *
     * @param templateIdentifier Unique ID or name of the email customization. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public ApiResponse<Void> deleteEmailCustomizationWithHttpInfo(String templateIdentifier)
            throws ApiException {
        okhttp3.Call localVarCall =
                deleteEmailCustomizationValidateBeforeCall(templateIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.10.0.cl or later Deletes the configuration for the email
     * customization. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer
     * privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is
     * required. **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable
     * this on your instance. #### Usage guidelines - Call the search API endpoint to get the
     * &#x60;template_identifier&#x60; from the response. - Use that &#x60;template_identifier&#x60;
     * as a parameter in this API request.
     *
     * @param templateIdentifier Unique ID or name of the email customization. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public okhttp3.Call deleteEmailCustomizationAsync(
            String templateIdentifier, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall =
                deleteEmailCustomizationValidateBeforeCall(templateIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteMetadata
     *
     * @param deleteMetadataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Metadata objects successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteMetadataCall(
            DeleteMetadataRequest deleteMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteMetadataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/delete";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteMetadataValidateBeforeCall(
            DeleteMetadataRequest deleteMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'deleteMetadataRequest' is set
        if (deleteMetadataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'deleteMetadataRequest' when calling"
                            + " deleteMetadata(Async)");
        }

        return deleteMetadataCall(deleteMetadataRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Removes the specified metadata object from the ThoughtSpot system.
     * Requires edit access to the metadata object.
     *
     * @param deleteMetadataRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Metadata objects successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteMetadata(DeleteMetadataRequest deleteMetadataRequest) throws ApiException {
        deleteMetadataWithHttpInfo(deleteMetadataRequest);
    }

    /**
     * Version: 9.0.0.cl or later Removes the specified metadata object from the ThoughtSpot system.
     * Requires edit access to the metadata object.
     *
     * @param deleteMetadataRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Metadata objects successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteMetadataWithHttpInfo(DeleteMetadataRequest deleteMetadataRequest)
            throws ApiException {
        okhttp3.Call localVarCall = deleteMetadataValidateBeforeCall(deleteMetadataRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Removes the specified metadata object from the
     * ThoughtSpot system. Requires edit access to the metadata object.
     *
     * @param deleteMetadataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Metadata objects successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteMetadataAsync(
            DeleteMetadataRequest deleteMetadataRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                deleteMetadataValidateBeforeCall(deleteMetadataRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteOrg
     *
     * @param orgIdentifier ID or name of the Org (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Organization successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteOrgCall(String orgIdentifier, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/orgs/{org_identifier}/delete"
                        .replace(
                                "{" + "org_identifier" + "}",
                                localVarApiClient.escapeString(orgIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteOrgValidateBeforeCall(
            String orgIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'orgIdentifier' is set
        if (orgIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'orgIdentifier' when calling deleteOrg(Async)");
        }

        return deleteOrgCall(orgIdentifier, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Deletes an Org object from the ThoughtSpot system. Requires
     * cluster administration (**Can administer Org**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is required. When you delete
     * an Org, all its users and objects created in that Org context are removed. However, if the
     * users in the deleted Org also exists in other Orgs, they are removed only from the deleted
     * Org.
     *
     * @param orgIdentifier ID or name of the Org (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Organization successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteOrg(String orgIdentifier) throws ApiException {
        deleteOrgWithHttpInfo(orgIdentifier);
    }

    /**
     * Version: 9.0.0.cl or later Deletes an Org object from the ThoughtSpot system. Requires
     * cluster administration (**Can administer Org**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is required. When you delete
     * an Org, all its users and objects created in that Org context are removed. However, if the
     * users in the deleted Org also exists in other Orgs, they are removed only from the deleted
     * Org.
     *
     * @param orgIdentifier ID or name of the Org (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Organization successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteOrgWithHttpInfo(String orgIdentifier) throws ApiException {
        okhttp3.Call localVarCall = deleteOrgValidateBeforeCall(orgIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Deletes an Org object from the ThoughtSpot
     * system. Requires cluster administration (**Can administer Org**) privilege. If [Role-Based
     * Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your
     * instance, the &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is required.
     * When you delete an Org, all its users and objects created in that Org context are removed.
     * However, if the users in the deleted Org also exists in other Orgs, they are removed only
     * from the deleted Org.
     *
     * @param orgIdentifier ID or name of the Org (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Organization successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteOrgAsync(String orgIdentifier, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = deleteOrgValidateBeforeCall(orgIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteOrgEmailCustomization
     *
     * @param deleteOrgEmailCustomizationRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteOrgEmailCustomizationCall(
            DeleteOrgEmailCustomizationRequest deleteOrgEmailCustomizationRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deleteOrgEmailCustomizationRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/customization/email/delete";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteOrgEmailCustomizationValidateBeforeCall(
            DeleteOrgEmailCustomizationRequest deleteOrgEmailCustomizationRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'deleteOrgEmailCustomizationRequest' is set
        if (deleteOrgEmailCustomizationRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'deleteOrgEmailCustomizationRequest' when"
                            + " calling deleteOrgEmailCustomization(Async)");
        }

        return deleteOrgEmailCustomizationCall(deleteOrgEmailCustomizationRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Deletes the configuration for the email customization. ####
     * Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer privilege**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. **NOTE**:This
     * endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.
     * #### Usage guidelines - Call the search API endpoint to get the &#x60;org_identifier&#x60;
     * from the response. - Use that &#x60;org_identifier&#x60; as a parameter in this API request.
     *
     * @param deleteOrgEmailCustomizationRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteOrgEmailCustomization(
            DeleteOrgEmailCustomizationRequest deleteOrgEmailCustomizationRequest)
            throws ApiException {
        deleteOrgEmailCustomizationWithHttpInfo(deleteOrgEmailCustomizationRequest);
    }

    /**
     * Version: 10.12.0.cl or later Deletes the configuration for the email customization. ####
     * Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer privilege**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. **NOTE**:This
     * endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.
     * #### Usage guidelines - Call the search API endpoint to get the &#x60;org_identifier&#x60;
     * from the response. - Use that &#x60;org_identifier&#x60; as a parameter in this API request.
     *
     * @param deleteOrgEmailCustomizationRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteOrgEmailCustomizationWithHttpInfo(
            DeleteOrgEmailCustomizationRequest deleteOrgEmailCustomizationRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                deleteOrgEmailCustomizationValidateBeforeCall(
                        deleteOrgEmailCustomizationRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Deletes the configuration for the email
     * customization. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer
     * privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is
     * required. **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable
     * this on your instance. #### Usage guidelines - Call the search API endpoint to get the
     * &#x60;org_identifier&#x60; from the response. - Use that &#x60;org_identifier&#x60; as a
     * parameter in this API request.
     *
     * @param deleteOrgEmailCustomizationRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteOrgEmailCustomizationAsync(
            DeleteOrgEmailCustomizationRequest deleteOrgEmailCustomizationRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                deleteOrgEmailCustomizationValidateBeforeCall(
                        deleteOrgEmailCustomizationRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteRole
     *
     * @param roleIdentifier Unique ID or name of the Role. ReadOnly roles cannot be deleted.
     *     (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Role successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteRoleCall(String roleIdentifier, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/roles/{role_identifier}/delete"
                        .replace(
                                "{" + "role_identifier" + "}",
                                localVarApiClient.escapeString(roleIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteRoleValidateBeforeCall(
            String roleIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'roleIdentifier' is set
        if (roleIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'roleIdentifier' when calling"
                            + " deleteRole(Async)");
        }

        return deleteRoleCall(roleIdentifier, _callback);
    }

    /**
     * Version: 9.5.0.cl or later Deletes a Role object from the ThoughtSpot system. Available only
     * if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance. To delete a Role, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can manage
     * roles**) privilege is required.
     *
     * @param roleIdentifier Unique ID or name of the Role. ReadOnly roles cannot be deleted.
     *     (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Role successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteRole(String roleIdentifier) throws ApiException {
        deleteRoleWithHttpInfo(roleIdentifier);
    }

    /**
     * Version: 9.5.0.cl or later Deletes a Role object from the ThoughtSpot system. Available only
     * if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance. To delete a Role, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can manage
     * roles**) privilege is required.
     *
     * @param roleIdentifier Unique ID or name of the Role. ReadOnly roles cannot be deleted.
     *     (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Role successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteRoleWithHttpInfo(String roleIdentifier) throws ApiException {
        okhttp3.Call localVarCall = deleteRoleValidateBeforeCall(roleIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.5.0.cl or later Deletes a Role object from the ThoughtSpot
     * system. Available only if [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To delete
     * a Role, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can manage roles**) privilege is required.
     *
     * @param roleIdentifier Unique ID or name of the Role. ReadOnly roles cannot be deleted.
     *     (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Role successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteRoleAsync(String roleIdentifier, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = deleteRoleValidateBeforeCall(roleIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteSchedule
     *
     * @param scheduleIdentifier Unique ID or name of the scheduled job. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Schedule successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteScheduleCall(String scheduleIdentifier, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/schedules/{schedule_identifier}/delete"
                        .replace(
                                "{" + "schedule_identifier" + "}",
                                localVarApiClient.escapeString(scheduleIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteScheduleValidateBeforeCall(
            String scheduleIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'scheduleIdentifier' is set
        if (scheduleIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'scheduleIdentifier' when calling"
                            + " deleteSchedule(Async)");
        }

        return deleteScheduleCall(scheduleIdentifier, _callback);
    }

    /**
     * Deletes a scheduled job. Version: 9.4.0.cl or later Deletes a scheduled Liveboard job.
     * Requires at least edit access to Liveboard or &#x60;ADMINISTRATION&#x60; (**Can administer
     * Org**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege is required.
     *
     * @param scheduleIdentifier Unique ID or name of the scheduled job. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Schedule successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteSchedule(String scheduleIdentifier) throws ApiException {
        deleteScheduleWithHttpInfo(scheduleIdentifier);
    }

    /**
     * Deletes a scheduled job. Version: 9.4.0.cl or later Deletes a scheduled Liveboard job.
     * Requires at least edit access to Liveboard or &#x60;ADMINISTRATION&#x60; (**Can administer
     * Org**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege is required.
     *
     * @param scheduleIdentifier Unique ID or name of the scheduled job. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Schedule successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteScheduleWithHttpInfo(String scheduleIdentifier)
            throws ApiException {
        okhttp3.Call localVarCall = deleteScheduleValidateBeforeCall(scheduleIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Deletes a scheduled job. Version: 9.4.0.cl or later Deletes a scheduled
     * Liveboard job. Requires at least edit access to Liveboard or &#x60;ADMINISTRATION&#x60;
     * (**Can administer Org**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege is required.
     *
     * @param scheduleIdentifier Unique ID or name of the scheduled job. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Schedule successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteScheduleAsync(
            String scheduleIdentifier, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteScheduleValidateBeforeCall(scheduleIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteTag
     *
     * @param tagIdentifier Tag identifier Tag name or Tag id. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tag successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteTagCall(String tagIdentifier, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/tags/{tag_identifier}/delete"
                        .replace(
                                "{" + "tag_identifier" + "}",
                                localVarApiClient.escapeString(tagIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteTagValidateBeforeCall(
            String tagIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'tagIdentifier' is set
        if (tagIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'tagIdentifier' when calling deleteTag(Async)");
        }

        return deleteTagCall(tagIdentifier, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Deletes a tag object from the ThoughtSpot system Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;TAGMANAGEMENT&#x60; (**Can manage tags**) privilege is required to create, edit,
     * and delete tags.
     *
     * @param tagIdentifier Tag identifier Tag name or Tag id. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tag successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteTag(String tagIdentifier) throws ApiException {
        deleteTagWithHttpInfo(tagIdentifier);
    }

    /**
     * Version: 9.0.0.cl or later Deletes a tag object from the ThoughtSpot system Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;TAGMANAGEMENT&#x60; (**Can manage tags**) privilege is required to create, edit,
     * and delete tags.
     *
     * @param tagIdentifier Tag identifier Tag name or Tag id. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tag successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteTagWithHttpInfo(String tagIdentifier) throws ApiException {
        okhttp3.Call localVarCall = deleteTagValidateBeforeCall(tagIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Deletes a tag object from the ThoughtSpot system
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;TAGMANAGEMENT&#x60; (**Can manage tags**) privilege is required
     * to create, edit, and delete tags.
     *
     * @param tagIdentifier Tag identifier Tag name or Tag id. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tag successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteTagAsync(String tagIdentifier, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = deleteTagValidateBeforeCall(tagIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteUser
     *
     * @param userIdentifier GUID / name of the user (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteUserCall(String userIdentifier, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/users/{user_identifier}/delete"
                        .replace(
                                "{" + "user_identifier" + "}",
                                localVarApiClient.escapeString(userIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteUserValidateBeforeCall(
            String userIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'userIdentifier' is set
        if (userIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'userIdentifier' when calling"
                            + " deleteUser(Async)");
        }

        return deleteUserCall(userIdentifier, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Deletes a user from the ThoughtSpot system. If you want to remove
     * a user from a specific Org but not from ThoughtSpot, update the group and Org mapping
     * properties of the user object via a POST API call to the
     * [/api/rest/2.0/users/{user_identifier}/update](#/http/api-endpoints/users/update-user)
     * endpoint. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is
     * required.
     *
     * @param userIdentifier GUID / name of the user (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteUser(String userIdentifier) throws ApiException {
        deleteUserWithHttpInfo(userIdentifier);
    }

    /**
     * Version: 9.0.0.cl or later Deletes a user from the ThoughtSpot system. If you want to remove
     * a user from a specific Org but not from ThoughtSpot, update the group and Org mapping
     * properties of the user object via a POST API call to the
     * [/api/rest/2.0/users/{user_identifier}/update](#/http/api-endpoints/users/update-user)
     * endpoint. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is
     * required.
     *
     * @param userIdentifier GUID / name of the user (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteUserWithHttpInfo(String userIdentifier) throws ApiException {
        okhttp3.Call localVarCall = deleteUserValidateBeforeCall(userIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Deletes a user from the ThoughtSpot system. If
     * you want to remove a user from a specific Org but not from ThoughtSpot, update the group and
     * Org mapping properties of the user object via a POST API call to the
     * [/api/rest/2.0/users/{user_identifier}/update](#/http/api-endpoints/users/update-user)
     * endpoint. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is
     * required.
     *
     * @param userIdentifier GUID / name of the user (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteUserAsync(String userIdentifier, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = deleteUserValidateBeforeCall(userIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteUserGroup
     *
     * @param groupIdentifier GUID or name of the group. (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User group successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteUserGroupCall(String groupIdentifier, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/groups/{group_identifier}/delete"
                        .replace(
                                "{" + "group_identifier" + "}",
                                localVarApiClient.escapeString(groupIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteUserGroupValidateBeforeCall(
            String groupIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'groupIdentifier' is set
        if (groupIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'groupIdentifier' when calling"
                            + " deleteUserGroup(Async)");
        }

        return deleteUserGroupCall(groupIdentifier, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Removes the specified group object from the ThoughtSpot system.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is
     * required.
     *
     * @param groupIdentifier GUID or name of the group. (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User group successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteUserGroup(String groupIdentifier) throws ApiException {
        deleteUserGroupWithHttpInfo(groupIdentifier);
    }

    /**
     * Version: 9.0.0.cl or later Removes the specified group object from the ThoughtSpot system.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is
     * required.
     *
     * @param groupIdentifier GUID or name of the group. (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User group successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteUserGroupWithHttpInfo(String groupIdentifier)
            throws ApiException {
        okhttp3.Call localVarCall = deleteUserGroupValidateBeforeCall(groupIdentifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Removes the specified group object from the
     * ThoughtSpot system. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is required.
     *
     * @param groupIdentifier GUID or name of the group. (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User group successfully deleted. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteUserGroupAsync(
            String groupIdentifier, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = deleteUserGroupValidateBeforeCall(groupIdentifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deleteVariable
     *
     * @param identifier Unique id or name of the variable (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Deleting the variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteVariableCall(String identifier, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/template/variables/{identifier}/delete"
                        .replace(
                                "{" + "identifier" + "}",
                                localVarApiClient.escapeString(identifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deleteVariableValidateBeforeCall(
            String identifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'identifier' is set
        if (identifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'identifier' when calling"
                            + " deleteVariable(Async)");
        }

        return deleteVariableCall(identifier, _callback);
    }

    /**
     * Delete a variable Version: 10.9.0.cl or later Allows deleting a variable from ThoughtSpot.
     * Requires ADMINISTRATION role and TENANT scope. The API endpoint requires: * The variable
     * identifier (ID or name) The operation will fail if: * The user lacks required permissions *
     * The variable doesn&#39;t exist * The variable is being used by other objects
     *
     * @param identifier Unique id or name of the variable (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Deleting the variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void deleteVariable(String identifier) throws ApiException {
        deleteVariableWithHttpInfo(identifier);
    }

    /**
     * Delete a variable Version: 10.9.0.cl or later Allows deleting a variable from ThoughtSpot.
     * Requires ADMINISTRATION role and TENANT scope. The API endpoint requires: * The variable
     * identifier (ID or name) The operation will fail if: * The user lacks required permissions *
     * The variable doesn&#39;t exist * The variable is being used by other objects
     *
     * @param identifier Unique id or name of the variable (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Deleting the variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> deleteVariableWithHttpInfo(String identifier) throws ApiException {
        okhttp3.Call localVarCall = deleteVariableValidateBeforeCall(identifier, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Delete a variable Version: 10.9.0.cl or later Allows deleting a variable
     * from ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The API endpoint requires: *
     * The variable identifier (ID or name) The operation will fail if: * The user lacks required
     * permissions * The variable doesn&#39;t exist * The variable is being used by other objects
     *
     * @param identifier Unique id or name of the variable (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Deleting the variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deleteVariableAsync(String identifier, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = deleteVariableValidateBeforeCall(identifier, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for deployCommit
     *
     * @param deployCommitRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully deployed the changes </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deployCommitCall(
            DeployCommitRequest deployCommitRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = deployCommitRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/vcs/git/commits/deploy";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call deployCommitValidateBeforeCall(
            DeployCommitRequest deployCommitRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'deployCommitRequest' is set
        if (deployCommitRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'deployCommitRequest' when calling"
                            + " deployCommit(Async)");
        }

        return deployCommitCall(deployCommitRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Allows you to deploy a commit and publish TML content to your
     * ThoughtSpot instance. Requires at least edit access to the objects used in the deploy
     * operation. The API deploys the head of the branch unless a &#x60;commit_id&#x60; is specified
     * in the API request. If the branch name is not defined in the request, the default branch is
     * considered for deploying commits. For more information, see [Git integration
     * documentation](https://developers.thoughtspot.com/docs/git-integration).
     *
     * @param deployCommitRequest (required)
     * @return List&lt;DeployResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully deployed the changes </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<DeployResponse> deployCommit(DeployCommitRequest deployCommitRequest)
            throws ApiException {
        ApiResponse<List<DeployResponse>> localVarResp =
                deployCommitWithHttpInfo(deployCommitRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Allows you to deploy a commit and publish TML content to your
     * ThoughtSpot instance. Requires at least edit access to the objects used in the deploy
     * operation. The API deploys the head of the branch unless a &#x60;commit_id&#x60; is specified
     * in the API request. If the branch name is not defined in the request, the default branch is
     * considered for deploying commits. For more information, see [Git integration
     * documentation](https://developers.thoughtspot.com/docs/git-integration).
     *
     * @param deployCommitRequest (required)
     * @return ApiResponse&lt;List&lt;DeployResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully deployed the changes </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<DeployResponse>> deployCommitWithHttpInfo(
            DeployCommitRequest deployCommitRequest) throws ApiException {
        okhttp3.Call localVarCall = deployCommitValidateBeforeCall(deployCommitRequest, null);
        Type localVarReturnType = new TypeToken<List<DeployResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Allows you to deploy a commit and publish TML
     * content to your ThoughtSpot instance. Requires at least edit access to the objects used in
     * the deploy operation. The API deploys the head of the branch unless a &#x60;commit_id&#x60;
     * is specified in the API request. If the branch name is not defined in the request, the
     * default branch is considered for deploying commits. For more information, see [Git
     * integration documentation](https://developers.thoughtspot.com/docs/git-integration).
     *
     * @param deployCommitRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully deployed the changes </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call deployCommitAsync(
            DeployCommitRequest deployCommitRequest,
            final ApiCallback<List<DeployResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = deployCommitValidateBeforeCall(deployCommitRequest, _callback);
        Type localVarReturnType = new TypeToken<List<DeployResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for downloadConnectionMetadataChanges
     *
     * @param connectionIdentifier GUID of the connection (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export metadata changes. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call downloadConnectionMetadataChangesCall(
            String connectionIdentifier, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/connections/download-connection-metadata-changes/{connection_identifier}"
                        .replace(
                                "{" + "connection_identifier" + "}",
                                localVarApiClient.escapeString(connectionIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/octet-stream", "application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call downloadConnectionMetadataChangesValidateBeforeCall(
            String connectionIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'connectionIdentifier' is set
        if (connectionIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'connectionIdentifier' when calling"
                            + " downloadConnectionMetadataChanges(Async)");
        }

        return downloadConnectionMetadataChangesCall(connectionIdentifier, _callback);
    }

    /**
     * Version: 9.9.0.cl or later Exports the difference in connection metadata between CDW and
     * ThoughtSpot Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) To download the
     * connection metadata difference between ThoughtSpot and CDW, pass the connection GUID as
     * &#x60;connection_identifier&#x60; in the API request.
     *
     * @param connectionIdentifier GUID of the connection (required)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export metadata changes. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public File downloadConnectionMetadataChanges(String connectionIdentifier) throws ApiException {
        ApiResponse<File> localVarResp =
                downloadConnectionMetadataChangesWithHttpInfo(connectionIdentifier);
        return localVarResp.getData();
    }

    /**
     * Version: 9.9.0.cl or later Exports the difference in connection metadata between CDW and
     * ThoughtSpot Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) To download the
     * connection metadata difference between ThoughtSpot and CDW, pass the connection GUID as
     * &#x60;connection_identifier&#x60; in the API request.
     *
     * @param connectionIdentifier GUID of the connection (required)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export metadata changes. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<File> downloadConnectionMetadataChangesWithHttpInfo(
            String connectionIdentifier) throws ApiException {
        okhttp3.Call localVarCall =
                downloadConnectionMetadataChangesValidateBeforeCall(connectionIdentifier, null);
        Type localVarReturnType = new TypeToken<File>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.9.0.cl or later Exports the difference in connection metadata
     * between CDW and ThoughtSpot Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) To download the
     * connection metadata difference between ThoughtSpot and CDW, pass the connection GUID as
     * &#x60;connection_identifier&#x60; in the API request.
     *
     * @param connectionIdentifier GUID of the connection (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export metadata changes. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call downloadConnectionMetadataChangesAsync(
            String connectionIdentifier, final ApiCallback<File> _callback) throws ApiException {

        okhttp3.Call localVarCall =
                downloadConnectionMetadataChangesValidateBeforeCall(
                        connectionIdentifier, _callback);
        Type localVarReturnType = new TypeToken<File>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for exportAnswerReport
     *
     * @param exportAnswerReportRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export report file of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call exportAnswerReportCall(
            ExportAnswerReportRequest exportAnswerReportRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = exportAnswerReportRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/report/answer";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/octet-stream", "application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call exportAnswerReportValidateBeforeCall(
            ExportAnswerReportRequest exportAnswerReportRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'exportAnswerReportRequest' is set
        if (exportAnswerReportRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'exportAnswerReportRequest' when calling"
                            + " exportAnswerReport(Async)");
        }

        return exportAnswerReportCall(exportAnswerReportRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Exports an Answer in the given file format. You can download the
     * Answer data as a PDF, PNG, CSV, or XLSX file. Requires at least view access to the Answer.
     * #### Usage guidelines In the request body, the GUID or name of the Answer and set
     * &#x60;file_format&#x60;. The default file format is CSV. **NOTE**: * The downloadable file
     * returned in API response file is extensionless. Please rename the downloaded file by typing
     * in the relevant extension. * HTML rendering is not supported for PDF exports of Answers with
     * tables. Optionally, you can define [runtime
     * overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides)
     * to apply to the Answer data.
     *
     * @param exportAnswerReportRequest (required)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export report file of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public File exportAnswerReport(ExportAnswerReportRequest exportAnswerReportRequest)
            throws ApiException {
        ApiResponse<File> localVarResp = exportAnswerReportWithHttpInfo(exportAnswerReportRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Exports an Answer in the given file format. You can download the
     * Answer data as a PDF, PNG, CSV, or XLSX file. Requires at least view access to the Answer.
     * #### Usage guidelines In the request body, the GUID or name of the Answer and set
     * &#x60;file_format&#x60;. The default file format is CSV. **NOTE**: * The downloadable file
     * returned in API response file is extensionless. Please rename the downloaded file by typing
     * in the relevant extension. * HTML rendering is not supported for PDF exports of Answers with
     * tables. Optionally, you can define [runtime
     * overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides)
     * to apply to the Answer data.
     *
     * @param exportAnswerReportRequest (required)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export report file of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<File> exportAnswerReportWithHttpInfo(
            ExportAnswerReportRequest exportAnswerReportRequest) throws ApiException {
        okhttp3.Call localVarCall =
                exportAnswerReportValidateBeforeCall(exportAnswerReportRequest, null);
        Type localVarReturnType = new TypeToken<File>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Exports an Answer in the given file format. You
     * can download the Answer data as a PDF, PNG, CSV, or XLSX file. Requires at least view access
     * to the Answer. #### Usage guidelines In the request body, the GUID or name of the Answer and
     * set &#x60;file_format&#x60;. The default file format is CSV. **NOTE**: * The downloadable
     * file returned in API response file is extensionless. Please rename the downloaded file by
     * typing in the relevant extension. * HTML rendering is not supported for PDF exports of
     * Answers with tables. Optionally, you can define [runtime
     * overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides)
     * to apply to the Answer data.
     *
     * @param exportAnswerReportRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export report file of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call exportAnswerReportAsync(
            ExportAnswerReportRequest exportAnswerReportRequest, final ApiCallback<File> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                exportAnswerReportValidateBeforeCall(exportAnswerReportRequest, _callback);
        Type localVarReturnType = new TypeToken<File>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for exportLiveboardReport
     *
     * @param exportLiveboardReportRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export report file of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call exportLiveboardReportCall(
            ExportLiveboardReportRequest exportLiveboardReportRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = exportLiveboardReportRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/report/liveboard";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/octet-stream", "application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call exportLiveboardReportValidateBeforeCall(
            ExportLiveboardReportRequest exportLiveboardReportRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'exportLiveboardReportRequest' is set
        if (exportLiveboardReportRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'exportLiveboardReportRequest' when calling"
                            + " exportLiveboardReport(Async)");
        }

        return exportLiveboardReportCall(exportLiveboardReportRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Exports a Liveboard and its visualizations in PDF or PNG file
     * format. Requires at least view access to the Liveboard. #### Usage guidelines In the request
     * body, specify the GUID or name of the Liveboard. To generate a Liveboard report with specific
     * visualizations, add GUIDs or names of the visualizations. The default &#x60;file_format&#x60;
     * is PDF. For PDF downloads, you can specify additional parameters to customize the page
     * orientation and include or exclude the cover page, logo, footer text, and page numbers.
     * Similar customization options are also available for PNG output. **NOTE**: The downloadable
     * file returned in API response file is extensionless. Please rename the downloaded file by
     * typing in the relevant extension. Optionally, you can define [runtime
     * overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides)
     * to apply to the Answer data. To include unsaved changes in the report, pass the
     * &#x60;transient_pinboard_content&#x60; script generated from the
     * &#x60;getExportRequestForCurrentPinboard&#x60; method in the Visual Embed SDK. Upon
     * successful execution, the API returns the report with unsaved changes, including ad hoc
     * changes to visualizations. For more information, see [Liveboard Report
     * API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_liveboard_report_api).
     * **NOTE**: Starting with ThoughtSpot Cloud 10.9.0.cl release, the Liveboard can be exported in
     * the PNG format in the resolution of your choice. To enable this on your instance, contact
     * ThoughtSpot support. When this feature is enabled, the options
     * &#x60;include_cover_page&#x60;,&#x60;include_filter_page&#x60; within the
     * &#x60;png_options&#x60; will not be available for PNG exports.
     *
     * @param exportLiveboardReportRequest (required)
     * @return File
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export report file of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public File exportLiveboardReport(ExportLiveboardReportRequest exportLiveboardReportRequest)
            throws ApiException {
        ApiResponse<File> localVarResp =
                exportLiveboardReportWithHttpInfo(exportLiveboardReportRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Exports a Liveboard and its visualizations in PDF or PNG file
     * format. Requires at least view access to the Liveboard. #### Usage guidelines In the request
     * body, specify the GUID or name of the Liveboard. To generate a Liveboard report with specific
     * visualizations, add GUIDs or names of the visualizations. The default &#x60;file_format&#x60;
     * is PDF. For PDF downloads, you can specify additional parameters to customize the page
     * orientation and include or exclude the cover page, logo, footer text, and page numbers.
     * Similar customization options are also available for PNG output. **NOTE**: The downloadable
     * file returned in API response file is extensionless. Please rename the downloaded file by
     * typing in the relevant extension. Optionally, you can define [runtime
     * overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides)
     * to apply to the Answer data. To include unsaved changes in the report, pass the
     * &#x60;transient_pinboard_content&#x60; script generated from the
     * &#x60;getExportRequestForCurrentPinboard&#x60; method in the Visual Embed SDK. Upon
     * successful execution, the API returns the report with unsaved changes, including ad hoc
     * changes to visualizations. For more information, see [Liveboard Report
     * API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_liveboard_report_api).
     * **NOTE**: Starting with ThoughtSpot Cloud 10.9.0.cl release, the Liveboard can be exported in
     * the PNG format in the resolution of your choice. To enable this on your instance, contact
     * ThoughtSpot support. When this feature is enabled, the options
     * &#x60;include_cover_page&#x60;,&#x60;include_filter_page&#x60; within the
     * &#x60;png_options&#x60; will not be available for PNG exports.
     *
     * @param exportLiveboardReportRequest (required)
     * @return ApiResponse&lt;File&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export report file of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<File> exportLiveboardReportWithHttpInfo(
            ExportLiveboardReportRequest exportLiveboardReportRequest) throws ApiException {
        okhttp3.Call localVarCall =
                exportLiveboardReportValidateBeforeCall(exportLiveboardReportRequest, null);
        Type localVarReturnType = new TypeToken<File>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Exports a Liveboard and its visualizations in PDF
     * or PNG file format. Requires at least view access to the Liveboard. #### Usage guidelines In
     * the request body, specify the GUID or name of the Liveboard. To generate a Liveboard report
     * with specific visualizations, add GUIDs or names of the visualizations. The default
     * &#x60;file_format&#x60; is PDF. For PDF downloads, you can specify additional parameters to
     * customize the page orientation and include or exclude the cover page, logo, footer text, and
     * page numbers. Similar customization options are also available for PNG output. **NOTE**: The
     * downloadable file returned in API response file is extensionless. Please rename the
     * downloaded file by typing in the relevant extension. Optionally, you can define [runtime
     * overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides)
     * to apply to the Answer data. To include unsaved changes in the report, pass the
     * &#x60;transient_pinboard_content&#x60; script generated from the
     * &#x60;getExportRequestForCurrentPinboard&#x60; method in the Visual Embed SDK. Upon
     * successful execution, the API returns the report with unsaved changes, including ad hoc
     * changes to visualizations. For more information, see [Liveboard Report
     * API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_liveboard_report_api).
     * **NOTE**: Starting with ThoughtSpot Cloud 10.9.0.cl release, the Liveboard can be exported in
     * the PNG format in the resolution of your choice. To enable this on your instance, contact
     * ThoughtSpot support. When this feature is enabled, the options
     * &#x60;include_cover_page&#x60;,&#x60;include_filter_page&#x60; within the
     * &#x60;png_options&#x60; will not be available for PNG exports.
     *
     * @param exportLiveboardReportRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export report file of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call exportLiveboardReportAsync(
            ExportLiveboardReportRequest exportLiveboardReportRequest,
            final ApiCallback<File> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                exportLiveboardReportValidateBeforeCall(exportLiveboardReportRequest, _callback);
        Type localVarReturnType = new TypeToken<File>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for exportMetadataTML
     *
     * @param exportMetadataTMLRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export TMLs of specified metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call exportMetadataTMLCall(
            ExportMetadataTMLRequest exportMetadataTMLRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = exportMetadataTMLRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/tml/export";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call exportMetadataTMLValidateBeforeCall(
            ExportMetadataTMLRequest exportMetadataTMLRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'exportMetadataTMLRequest' is set
        if (exportMetadataTMLRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'exportMetadataTMLRequest' when calling"
                            + " exportMetadataTML(Async)");
        }

        return exportMetadataTMLCall(exportMetadataTMLRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml)
     * representation of metadata objects in JSON or YAML format. Requires
     * &#x60;DATADOWNLOADING&#x60; (**Can download Data**) and at least view access to the metadata
     * object. #### Usage guidelines * You can export one or several objects by passing metadata
     * object GUIDs in the &#x60;metadata&#x60; array. * When exporting TML content for a Liveboard
     * or Answer object, you can set &#x60;export_associated&#x60; to &#x60;true&#x60; to retrieve
     * TML content for underlying Worksheets, Tables, or Views, including the GUID of each object
     * within the headers. When &#x60;export_associated&#x60; is set to &#x60;true&#x60;, consider
     * retrieving one metadata object at a time. * Set &#x60;export_fqns&#x60; to &#x60;true&#x60;
     * to add FQNs of the referenced objects in the TML content. For example, if you send an API
     * request to retrieve TML for a Liveboard and its associated objects, the API returns the TML
     * content with FQNs of the referenced Worksheet. Exporting TML with FQNs is useful if
     * ThoughtSpot has multiple objects with the same name and you want to eliminate ambiguity when
     * importing TML files into ThoughtSpot. It eliminates the need for adding FQNs of the
     * referenced objects manually during the import operation. * To export only the TML of
     * feedbacks associated with an object, set the GUID of the object as &#x60;identifier&#x60;,
     * and set the &#x60;type&#x60; as &#x60;FEEDBACK&#x60; in the &#x60;metadata&#x60; array. * To
     * export the TML of an object along with the feedbacks associated with it, set the GUID of the
     * object as &#x60;identifier&#x60;, set the &#x60;type&#x60; as &#x60;LOGIAL_TABLE&#x60; in the
     * &#x60;metadata&#x60; array, and set &#x60;export_with_associated_feedbacks&#x60; in
     * &#x60;export_options&#x60; to true. For more information, see [TML
     * Documentation](https://developers.thoughtspot.com/docs/tml#_export_a_tml). For more
     * information on feedbacks, see [Feedback
     * Documentation](https://docs.thoughtspot.com/cloud/latest/sage-feedback).
     *
     * @param exportMetadataTMLRequest (required)
     * @return List&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export TMLs of specified metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<Object> exportMetadataTML(ExportMetadataTMLRequest exportMetadataTMLRequest)
            throws ApiException {
        ApiResponse<List<Object>> localVarResp =
                exportMetadataTMLWithHttpInfo(exportMetadataTMLRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml)
     * representation of metadata objects in JSON or YAML format. Requires
     * &#x60;DATADOWNLOADING&#x60; (**Can download Data**) and at least view access to the metadata
     * object. #### Usage guidelines * You can export one or several objects by passing metadata
     * object GUIDs in the &#x60;metadata&#x60; array. * When exporting TML content for a Liveboard
     * or Answer object, you can set &#x60;export_associated&#x60; to &#x60;true&#x60; to retrieve
     * TML content for underlying Worksheets, Tables, or Views, including the GUID of each object
     * within the headers. When &#x60;export_associated&#x60; is set to &#x60;true&#x60;, consider
     * retrieving one metadata object at a time. * Set &#x60;export_fqns&#x60; to &#x60;true&#x60;
     * to add FQNs of the referenced objects in the TML content. For example, if you send an API
     * request to retrieve TML for a Liveboard and its associated objects, the API returns the TML
     * content with FQNs of the referenced Worksheet. Exporting TML with FQNs is useful if
     * ThoughtSpot has multiple objects with the same name and you want to eliminate ambiguity when
     * importing TML files into ThoughtSpot. It eliminates the need for adding FQNs of the
     * referenced objects manually during the import operation. * To export only the TML of
     * feedbacks associated with an object, set the GUID of the object as &#x60;identifier&#x60;,
     * and set the &#x60;type&#x60; as &#x60;FEEDBACK&#x60; in the &#x60;metadata&#x60; array. * To
     * export the TML of an object along with the feedbacks associated with it, set the GUID of the
     * object as &#x60;identifier&#x60;, set the &#x60;type&#x60; as &#x60;LOGIAL_TABLE&#x60; in the
     * &#x60;metadata&#x60; array, and set &#x60;export_with_associated_feedbacks&#x60; in
     * &#x60;export_options&#x60; to true. For more information, see [TML
     * Documentation](https://developers.thoughtspot.com/docs/tml#_export_a_tml). For more
     * information on feedbacks, see [Feedback
     * Documentation](https://docs.thoughtspot.com/cloud/latest/sage-feedback).
     *
     * @param exportMetadataTMLRequest (required)
     * @return ApiResponse&lt;List&lt;Object&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export TMLs of specified metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<Object>> exportMetadataTMLWithHttpInfo(
            ExportMetadataTMLRequest exportMetadataTMLRequest) throws ApiException {
        okhttp3.Call localVarCall =
                exportMetadataTMLValidateBeforeCall(exportMetadataTMLRequest, null);
        Type localVarReturnType = new TypeToken<List<Object>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Exports the
     * [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in
     * JSON or YAML format. Requires &#x60;DATADOWNLOADING&#x60; (**Can download Data**) and at
     * least view access to the metadata object. #### Usage guidelines * You can export one or
     * several objects by passing metadata object GUIDs in the &#x60;metadata&#x60; array. * When
     * exporting TML content for a Liveboard or Answer object, you can set
     * &#x60;export_associated&#x60; to &#x60;true&#x60; to retrieve TML content for underlying
     * Worksheets, Tables, or Views, including the GUID of each object within the headers. When
     * &#x60;export_associated&#x60; is set to &#x60;true&#x60;, consider retrieving one metadata
     * object at a time. * Set &#x60;export_fqns&#x60; to &#x60;true&#x60; to add FQNs of the
     * referenced objects in the TML content. For example, if you send an API request to retrieve
     * TML for a Liveboard and its associated objects, the API returns the TML content with FQNs of
     * the referenced Worksheet. Exporting TML with FQNs is useful if ThoughtSpot has multiple
     * objects with the same name and you want to eliminate ambiguity when importing TML files into
     * ThoughtSpot. It eliminates the need for adding FQNs of the referenced objects manually during
     * the import operation. * To export only the TML of feedbacks associated with an object, set
     * the GUID of the object as &#x60;identifier&#x60;, and set the &#x60;type&#x60; as
     * &#x60;FEEDBACK&#x60; in the &#x60;metadata&#x60; array. * To export the TML of an object
     * along with the feedbacks associated with it, set the GUID of the object as
     * &#x60;identifier&#x60;, set the &#x60;type&#x60; as &#x60;LOGIAL_TABLE&#x60; in the
     * &#x60;metadata&#x60; array, and set &#x60;export_with_associated_feedbacks&#x60; in
     * &#x60;export_options&#x60; to true. For more information, see [TML
     * Documentation](https://developers.thoughtspot.com/docs/tml#_export_a_tml). For more
     * information on feedbacks, see [Feedback
     * Documentation](https://docs.thoughtspot.com/cloud/latest/sage-feedback).
     *
     * @param exportMetadataTMLRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export TMLs of specified metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call exportMetadataTMLAsync(
            ExportMetadataTMLRequest exportMetadataTMLRequest,
            final ApiCallback<List<Object>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                exportMetadataTMLValidateBeforeCall(exportMetadataTMLRequest, _callback);
        Type localVarReturnType = new TypeToken<List<Object>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for exportMetadataTMLBatched
     *
     * @param exportMetadataTMLBatchedRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export TMLs of specified metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call exportMetadataTMLBatchedCall(
            ExportMetadataTMLBatchedRequest exportMetadataTMLBatchedRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = exportMetadataTMLBatchedRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/tml/export/batch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call exportMetadataTMLBatchedValidateBeforeCall(
            ExportMetadataTMLBatchedRequest exportMetadataTMLBatchedRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'exportMetadataTMLBatchedRequest' is set
        if (exportMetadataTMLBatchedRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'exportMetadataTMLBatchedRequest' when calling"
                            + " exportMetadataTMLBatched(Async)");
        }

        return exportMetadataTMLBatchedCall(exportMetadataTMLBatchedRequest, _callback);
    }

    /**
     * Version: 10.1.0.cl or later Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml)
     * representation of metadata objects in JSON or YAML format. ### **Permissions Required**
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and &#x60;USERMANAGEMENT&#x60;
     * (**Can manage users**) privileges. #### **Usage Guidelines** This API is only applicable for
     * &#x60;USER&#x60;, &#x60;GROUP&#x60;, and &#x60;ROLES&#x60; metadata types. -
     * &#x60;batch_offset&#x60; Indicates the starting position within the complete dataset from
     * which the API should begin returning objects. Useful for paginating results efficiently. -
     * &#x60;batch_size&#x60; Specifies the number of objects or items to retrieve in a single
     * request. Helps control response size for better performance. - &#x60;edoc_format&#x60;
     * Defines the format of the TML content. The exported metadata can be in JSON or YAML format. -
     * &#x60;export_dependent&#x60; Specifies whether to include dependent metadata objects in the
     * export. Ensures related objects are also retrieved if needed. - &#x60;all_orgs_override&#x60;
     * Indicates whether the export operation applies across all organizations. Useful for
     * multi-tenant environments where cross-org exports are required.
     *
     * @param exportMetadataTMLBatchedRequest (required)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export TMLs of specified metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public Object exportMetadataTMLBatched(
            ExportMetadataTMLBatchedRequest exportMetadataTMLBatchedRequest) throws ApiException {
        ApiResponse<Object> localVarResp =
                exportMetadataTMLBatchedWithHttpInfo(exportMetadataTMLBatchedRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.1.0.cl or later Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml)
     * representation of metadata objects in JSON or YAML format. ### **Permissions Required**
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and &#x60;USERMANAGEMENT&#x60;
     * (**Can manage users**) privileges. #### **Usage Guidelines** This API is only applicable for
     * &#x60;USER&#x60;, &#x60;GROUP&#x60;, and &#x60;ROLES&#x60; metadata types. -
     * &#x60;batch_offset&#x60; Indicates the starting position within the complete dataset from
     * which the API should begin returning objects. Useful for paginating results efficiently. -
     * &#x60;batch_size&#x60; Specifies the number of objects or items to retrieve in a single
     * request. Helps control response size for better performance. - &#x60;edoc_format&#x60;
     * Defines the format of the TML content. The exported metadata can be in JSON or YAML format. -
     * &#x60;export_dependent&#x60; Specifies whether to include dependent metadata objects in the
     * export. Ensures related objects are also retrieved if needed. - &#x60;all_orgs_override&#x60;
     * Indicates whether the export operation applies across all organizations. Useful for
     * multi-tenant environments where cross-org exports are required.
     *
     * @param exportMetadataTMLBatchedRequest (required)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export TMLs of specified metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Object> exportMetadataTMLBatchedWithHttpInfo(
            ExportMetadataTMLBatchedRequest exportMetadataTMLBatchedRequest) throws ApiException {
        okhttp3.Call localVarCall =
                exportMetadataTMLBatchedValidateBeforeCall(exportMetadataTMLBatchedRequest, null);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.1.0.cl or later Exports the
     * [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in
     * JSON or YAML format. ### **Permissions Required** Requires &#x60;DATAMANAGEMENT&#x60; (**Can
     * manage data**) and &#x60;USERMANAGEMENT&#x60; (**Can manage users**) privileges. #### **Usage
     * Guidelines** This API is only applicable for &#x60;USER&#x60;, &#x60;GROUP&#x60;, and
     * &#x60;ROLES&#x60; metadata types. - &#x60;batch_offset&#x60; Indicates the starting position
     * within the complete dataset from which the API should begin returning objects. Useful for
     * paginating results efficiently. - &#x60;batch_size&#x60; Specifies the number of objects or
     * items to retrieve in a single request. Helps control response size for better performance. -
     * &#x60;edoc_format&#x60; Defines the format of the TML content. The exported metadata can be
     * in JSON or YAML format. - &#x60;export_dependent&#x60; Specifies whether to include dependent
     * metadata objects in the export. Ensures related objects are also retrieved if needed. -
     * &#x60;all_orgs_override&#x60; Indicates whether the export operation applies across all
     * organizations. Useful for multi-tenant environments where cross-org exports are required.
     *
     * @param exportMetadataTMLBatchedRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Export TMLs of specified metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call exportMetadataTMLBatchedAsync(
            ExportMetadataTMLBatchedRequest exportMetadataTMLBatchedRequest,
            final ApiCallback<Object> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                exportMetadataTMLBatchedValidateBeforeCall(
                        exportMetadataTMLBatchedRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchAnswerData
     *
     * @param fetchAnswerDataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchAnswerDataCall(
            FetchAnswerDataRequest fetchAnswerDataRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fetchAnswerDataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/answer/data";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchAnswerDataValidateBeforeCall(
            FetchAnswerDataRequest fetchAnswerDataRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'fetchAnswerDataRequest' is set
        if (fetchAnswerDataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'fetchAnswerDataRequest' when calling"
                            + " fetchAnswerData(Async)");
        }

        return fetchAnswerDataCall(fetchAnswerDataRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Fetches data from a saved Answer. Requires at least view access to
     * the saved Answer. The &#x60;record_size&#x60; attribute determines the number of records to
     * retrieve in an API call. For more information about pagination, record size, and maximum row
     * limit, see [Pagination and record size
     * settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_apis).
     *
     * @param fetchAnswerDataRequest (required)
     * @return AnswerDataResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public AnswerDataResponse fetchAnswerData(FetchAnswerDataRequest fetchAnswerDataRequest)
            throws ApiException {
        ApiResponse<AnswerDataResponse> localVarResp =
                fetchAnswerDataWithHttpInfo(fetchAnswerDataRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Fetches data from a saved Answer. Requires at least view access to
     * the saved Answer. The &#x60;record_size&#x60; attribute determines the number of records to
     * retrieve in an API call. For more information about pagination, record size, and maximum row
     * limit, see [Pagination and record size
     * settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_apis).
     *
     * @param fetchAnswerDataRequest (required)
     * @return ApiResponse&lt;AnswerDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<AnswerDataResponse> fetchAnswerDataWithHttpInfo(
            FetchAnswerDataRequest fetchAnswerDataRequest) throws ApiException {
        okhttp3.Call localVarCall = fetchAnswerDataValidateBeforeCall(fetchAnswerDataRequest, null);
        Type localVarReturnType = new TypeToken<AnswerDataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Fetches data from a saved Answer. Requires at
     * least view access to the saved Answer. The &#x60;record_size&#x60; attribute determines the
     * number of records to retrieve in an API call. For more information about pagination, record
     * size, and maximum row limit, see [Pagination and record size
     * settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_apis).
     *
     * @param fetchAnswerDataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchAnswerDataAsync(
            FetchAnswerDataRequest fetchAnswerDataRequest,
            final ApiCallback<AnswerDataResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                fetchAnswerDataValidateBeforeCall(fetchAnswerDataRequest, _callback);
        Type localVarReturnType = new TypeToken<AnswerDataResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchAnswerSqlQuery
     *
     * @param fetchAnswerSqlQueryRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching SQL query of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchAnswerSqlQueryCall(
            FetchAnswerSqlQueryRequest fetchAnswerSqlQueryRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fetchAnswerSqlQueryRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/answer/sql";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchAnswerSqlQueryValidateBeforeCall(
            FetchAnswerSqlQueryRequest fetchAnswerSqlQueryRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'fetchAnswerSqlQueryRequest' is set
        if (fetchAnswerSqlQueryRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'fetchAnswerSqlQueryRequest' when calling"
                            + " fetchAnswerSqlQuery(Async)");
        }

        return fetchAnswerSqlQueryCall(fetchAnswerSqlQueryRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Fetches the underlying SQL query data for an Answer object.
     * Requires at least view access to the Answer object. Upon successful execution, the API
     * returns the SQL queries for the specified object as shown in this example: &#x60;&#x60;&#x60;
     * { \&quot;metadata_id\&quot;:\&quot;8fbe44a8-46ad-4b16-8d39-184b2fada490\&quot;,
     * \&quot;metadata_name\&quot;:\&quot;Total sales\&quot;,
     * \&quot;metadata_type\&quot;:\&quot;ANSWER\&quot;, \&quot;sql_queries\&quot;:[ {
     * \&quot;metadata_id\&quot;:\&quot;8fbe44a8-46ad-4b16-8d39-184b2fada490\&quot;,
     * \&quot;metadata_name\&quot;:\&quot;Total sales -test\&quot;,
     * \&quot;sql_query\&quot;:\&quot;SELECT \\n \\\&quot;ta_1\\\&quot;.\\\&quot;REGION\\\&quot;
     * \\\&quot;ca_1\\\&quot;, \\n \\\&quot;ta_2\\\&quot;.\\\&quot;PRODUCTNAME\\\&quot;
     * \\\&quot;ca_2\\\&quot;, \\n \\\&quot;ta_1\\\&quot;.\\\&quot;STORENAME\\\&quot;
     * \\\&quot;ca_3\\\&quot;, \\n CASE\\n WHEN sum(\\\&quot;ta_3\\\&quot;.\\\&quot;SALES\\\&quot;)
     * IS NOT NULL THEN sum(\\\&quot;ta_3\\\&quot;.\\\&quot;SALES\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_4\\\&quot;, \\n CASE\\n WHEN
     * sum(\\\&quot;ta_3\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;) IS NOT NULL THEN
     * sum(\\\&quot;ta_3\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_5\\\&quot;\\nFROM
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;FACT_RETAPP_SALES\\\&quot;
     * \\\&quot;ta_3\\\&quot;\\n JOIN
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;DIM_RETAPP_STORES\\\&quot;
     * \\\&quot;ta_1\\\&quot;\\n ON \\\&quot;ta_3\\\&quot;.\\\&quot;STOREID\\\&quot; &#x3D;
     * \\\&quot;ta_1\\\&quot;.\\\&quot;STOREID\\\&quot;\\n JOIN
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;DIM_RETAPP_PRODUCTS\\\&quot;
     * \\\&quot;ta_2\\\&quot;\\n ON \\\&quot;ta_3\\\&quot;.\\\&quot;PRODUCTID\\\&quot; &#x3D;
     * \\\&quot;ta_2\\\&quot;.\\\&quot;PRODUCTID\\\&quot;\\nGROUP BY \\n \\\&quot;ca_1\\\&quot;, \\n
     * \\\&quot;ca_2\\\&quot;, \\n \\\&quot;ca_3\\\&quot;\\n\&quot; } ] } &#x60;&#x60;&#x60;
     *
     * @param fetchAnswerSqlQueryRequest (required)
     * @return SqlQueryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching SQL query of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public SqlQueryResponse fetchAnswerSqlQuery(
            FetchAnswerSqlQueryRequest fetchAnswerSqlQueryRequest) throws ApiException {
        ApiResponse<SqlQueryResponse> localVarResp =
                fetchAnswerSqlQueryWithHttpInfo(fetchAnswerSqlQueryRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Fetches the underlying SQL query data for an Answer object.
     * Requires at least view access to the Answer object. Upon successful execution, the API
     * returns the SQL queries for the specified object as shown in this example: &#x60;&#x60;&#x60;
     * { \&quot;metadata_id\&quot;:\&quot;8fbe44a8-46ad-4b16-8d39-184b2fada490\&quot;,
     * \&quot;metadata_name\&quot;:\&quot;Total sales\&quot;,
     * \&quot;metadata_type\&quot;:\&quot;ANSWER\&quot;, \&quot;sql_queries\&quot;:[ {
     * \&quot;metadata_id\&quot;:\&quot;8fbe44a8-46ad-4b16-8d39-184b2fada490\&quot;,
     * \&quot;metadata_name\&quot;:\&quot;Total sales -test\&quot;,
     * \&quot;sql_query\&quot;:\&quot;SELECT \\n \\\&quot;ta_1\\\&quot;.\\\&quot;REGION\\\&quot;
     * \\\&quot;ca_1\\\&quot;, \\n \\\&quot;ta_2\\\&quot;.\\\&quot;PRODUCTNAME\\\&quot;
     * \\\&quot;ca_2\\\&quot;, \\n \\\&quot;ta_1\\\&quot;.\\\&quot;STORENAME\\\&quot;
     * \\\&quot;ca_3\\\&quot;, \\n CASE\\n WHEN sum(\\\&quot;ta_3\\\&quot;.\\\&quot;SALES\\\&quot;)
     * IS NOT NULL THEN sum(\\\&quot;ta_3\\\&quot;.\\\&quot;SALES\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_4\\\&quot;, \\n CASE\\n WHEN
     * sum(\\\&quot;ta_3\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;) IS NOT NULL THEN
     * sum(\\\&quot;ta_3\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_5\\\&quot;\\nFROM
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;FACT_RETAPP_SALES\\\&quot;
     * \\\&quot;ta_3\\\&quot;\\n JOIN
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;DIM_RETAPP_STORES\\\&quot;
     * \\\&quot;ta_1\\\&quot;\\n ON \\\&quot;ta_3\\\&quot;.\\\&quot;STOREID\\\&quot; &#x3D;
     * \\\&quot;ta_1\\\&quot;.\\\&quot;STOREID\\\&quot;\\n JOIN
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;DIM_RETAPP_PRODUCTS\\\&quot;
     * \\\&quot;ta_2\\\&quot;\\n ON \\\&quot;ta_3\\\&quot;.\\\&quot;PRODUCTID\\\&quot; &#x3D;
     * \\\&quot;ta_2\\\&quot;.\\\&quot;PRODUCTID\\\&quot;\\nGROUP BY \\n \\\&quot;ca_1\\\&quot;, \\n
     * \\\&quot;ca_2\\\&quot;, \\n \\\&quot;ca_3\\\&quot;\\n\&quot; } ] } &#x60;&#x60;&#x60;
     *
     * @param fetchAnswerSqlQueryRequest (required)
     * @return ApiResponse&lt;SqlQueryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching SQL query of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<SqlQueryResponse> fetchAnswerSqlQueryWithHttpInfo(
            FetchAnswerSqlQueryRequest fetchAnswerSqlQueryRequest) throws ApiException {
        okhttp3.Call localVarCall =
                fetchAnswerSqlQueryValidateBeforeCall(fetchAnswerSqlQueryRequest, null);
        Type localVarReturnType = new TypeToken<SqlQueryResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Fetches the underlying SQL query data for an
     * Answer object. Requires at least view access to the Answer object. Upon successful execution,
     * the API returns the SQL queries for the specified object as shown in this example:
     * &#x60;&#x60;&#x60; {
     * \&quot;metadata_id\&quot;:\&quot;8fbe44a8-46ad-4b16-8d39-184b2fada490\&quot;,
     * \&quot;metadata_name\&quot;:\&quot;Total sales\&quot;,
     * \&quot;metadata_type\&quot;:\&quot;ANSWER\&quot;, \&quot;sql_queries\&quot;:[ {
     * \&quot;metadata_id\&quot;:\&quot;8fbe44a8-46ad-4b16-8d39-184b2fada490\&quot;,
     * \&quot;metadata_name\&quot;:\&quot;Total sales -test\&quot;,
     * \&quot;sql_query\&quot;:\&quot;SELECT \\n \\\&quot;ta_1\\\&quot;.\\\&quot;REGION\\\&quot;
     * \\\&quot;ca_1\\\&quot;, \\n \\\&quot;ta_2\\\&quot;.\\\&quot;PRODUCTNAME\\\&quot;
     * \\\&quot;ca_2\\\&quot;, \\n \\\&quot;ta_1\\\&quot;.\\\&quot;STORENAME\\\&quot;
     * \\\&quot;ca_3\\\&quot;, \\n CASE\\n WHEN sum(\\\&quot;ta_3\\\&quot;.\\\&quot;SALES\\\&quot;)
     * IS NOT NULL THEN sum(\\\&quot;ta_3\\\&quot;.\\\&quot;SALES\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_4\\\&quot;, \\n CASE\\n WHEN
     * sum(\\\&quot;ta_3\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;) IS NOT NULL THEN
     * sum(\\\&quot;ta_3\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_5\\\&quot;\\nFROM
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;FACT_RETAPP_SALES\\\&quot;
     * \\\&quot;ta_3\\\&quot;\\n JOIN
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;DIM_RETAPP_STORES\\\&quot;
     * \\\&quot;ta_1\\\&quot;\\n ON \\\&quot;ta_3\\\&quot;.\\\&quot;STOREID\\\&quot; &#x3D;
     * \\\&quot;ta_1\\\&quot;.\\\&quot;STOREID\\\&quot;\\n JOIN
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;DIM_RETAPP_PRODUCTS\\\&quot;
     * \\\&quot;ta_2\\\&quot;\\n ON \\\&quot;ta_3\\\&quot;.\\\&quot;PRODUCTID\\\&quot; &#x3D;
     * \\\&quot;ta_2\\\&quot;.\\\&quot;PRODUCTID\\\&quot;\\nGROUP BY \\n \\\&quot;ca_1\\\&quot;, \\n
     * \\\&quot;ca_2\\\&quot;, \\n \\\&quot;ca_3\\\&quot;\\n\&quot; } ] } &#x60;&#x60;&#x60;
     *
     * @param fetchAnswerSqlQueryRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching SQL query of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchAnswerSqlQueryAsync(
            FetchAnswerSqlQueryRequest fetchAnswerSqlQueryRequest,
            final ApiCallback<SqlQueryResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                fetchAnswerSqlQueryValidateBeforeCall(fetchAnswerSqlQueryRequest, _callback);
        Type localVarReturnType = new TypeToken<SqlQueryResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchAsyncImportTaskStatus
     *
     * @param fetchAsyncImportTaskStatusRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Async TML Import Task statuses fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchAsyncImportTaskStatusCall(
            FetchAsyncImportTaskStatusRequest fetchAsyncImportTaskStatusRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fetchAsyncImportTaskStatusRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/tml/async/status";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchAsyncImportTaskStatusValidateBeforeCall(
            FetchAsyncImportTaskStatusRequest fetchAsyncImportTaskStatusRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'fetchAsyncImportTaskStatusRequest' is set
        if (fetchAsyncImportTaskStatusRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'fetchAsyncImportTaskStatusRequest' when"
                            + " calling fetchAsyncImportTaskStatus(Async)");
        }

        return fetchAsyncImportTaskStatusCall(fetchAsyncImportTaskStatusRequest, _callback);
    }

    /**
     * Version: 10.4.0.cl or later Gets information about the status of the TML async import task
     * scheduled using the &#x60;/api/rest/2.0/metadata/tml/async/import&#x60; API call. To fetch
     * the task details, specify the ID of the TML async import task. Requires access to the task
     * ID. The API allows users who initiated the asynchronous TML import via
     * &#x60;/api/rest/2.0/metadata/tml/async/import&#x60; to view the status of their tasks. Users
     * with administration privilege can view the status of all import tasks initiated by the users
     * in their Org. #### Usage guidelines See [TML API
     * Documentation](https://developers.thoughtspot.com/docs/tml#_fetch_status_of_the_tml_import_task)
     * for usage guidelines.
     *
     * @param fetchAsyncImportTaskStatusRequest (required)
     * @return GetAsyncImportStatusResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Async TML Import Task statuses fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public GetAsyncImportStatusResponse fetchAsyncImportTaskStatus(
            FetchAsyncImportTaskStatusRequest fetchAsyncImportTaskStatusRequest)
            throws ApiException {
        ApiResponse<GetAsyncImportStatusResponse> localVarResp =
                fetchAsyncImportTaskStatusWithHttpInfo(fetchAsyncImportTaskStatusRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.4.0.cl or later Gets information about the status of the TML async import task
     * scheduled using the &#x60;/api/rest/2.0/metadata/tml/async/import&#x60; API call. To fetch
     * the task details, specify the ID of the TML async import task. Requires access to the task
     * ID. The API allows users who initiated the asynchronous TML import via
     * &#x60;/api/rest/2.0/metadata/tml/async/import&#x60; to view the status of their tasks. Users
     * with administration privilege can view the status of all import tasks initiated by the users
     * in their Org. #### Usage guidelines See [TML API
     * Documentation](https://developers.thoughtspot.com/docs/tml#_fetch_status_of_the_tml_import_task)
     * for usage guidelines.
     *
     * @param fetchAsyncImportTaskStatusRequest (required)
     * @return ApiResponse&lt;GetAsyncImportStatusResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Async TML Import Task statuses fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<GetAsyncImportStatusResponse> fetchAsyncImportTaskStatusWithHttpInfo(
            FetchAsyncImportTaskStatusRequest fetchAsyncImportTaskStatusRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                fetchAsyncImportTaskStatusValidateBeforeCall(
                        fetchAsyncImportTaskStatusRequest, null);
        Type localVarReturnType = new TypeToken<GetAsyncImportStatusResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.4.0.cl or later Gets information about the status of the TML
     * async import task scheduled using the &#x60;/api/rest/2.0/metadata/tml/async/import&#x60; API
     * call. To fetch the task details, specify the ID of the TML async import task. Requires access
     * to the task ID. The API allows users who initiated the asynchronous TML import via
     * &#x60;/api/rest/2.0/metadata/tml/async/import&#x60; to view the status of their tasks. Users
     * with administration privilege can view the status of all import tasks initiated by the users
     * in their Org. #### Usage guidelines See [TML API
     * Documentation](https://developers.thoughtspot.com/docs/tml#_fetch_status_of_the_tml_import_task)
     * for usage guidelines.
     *
     * @param fetchAsyncImportTaskStatusRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Async TML Import Task statuses fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchAsyncImportTaskStatusAsync(
            FetchAsyncImportTaskStatusRequest fetchAsyncImportTaskStatusRequest,
            final ApiCallback<GetAsyncImportStatusResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                fetchAsyncImportTaskStatusValidateBeforeCall(
                        fetchAsyncImportTaskStatusRequest, _callback);
        Type localVarReturnType = new TypeToken<GetAsyncImportStatusResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchColumnSecurityRules
     *
     * @param fetchColumnSecurityRulesRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully fetched column security rules </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request - Table not found or invalid parameters </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden - User doesn&#39;t have permission to access security rules for this table </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchColumnSecurityRulesCall(
            FetchColumnSecurityRulesRequest fetchColumnSecurityRulesRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fetchColumnSecurityRulesRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/security/column/rules/fetch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchColumnSecurityRulesValidateBeforeCall(
            FetchColumnSecurityRulesRequest fetchColumnSecurityRulesRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'fetchColumnSecurityRulesRequest' is set
        if (fetchColumnSecurityRulesRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'fetchColumnSecurityRulesRequest' when calling"
                            + " fetchColumnSecurityRules(Async)");
        }

        return fetchColumnSecurityRulesCall(fetchColumnSecurityRulesRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Fetches column security rules for specified tables. This API
     * endpoint retrieves column-level security rules configured for tables. It returns information
     * about which columns are secured and which groups have access to those columns. #### Usage
     * guidelines - Provide an array of table identifiers using either &#x60;identifier&#x60; (GUID
     * or name) or &#x60;obj_identifier&#x60; (object ID) - At least one of &#x60;identifier&#x60;
     * or &#x60;obj_identifier&#x60; must be provided for each table - The API returns column
     * security rules for all specified tables - Users must have appropriate permissions to access
     * security rules for the specified tables #### Required permissions -
     * &#x60;ADMINISTRATION&#x60; - Can administer ThoughtSpot - &#x60;DATAMANAGEMENT&#x60; - Can
     * manage data - &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; - Can manage worksheet views and
     * tables #### Example request &#x60;&#x60;&#x60;json { \&quot;tables\&quot;: [ {
     * \&quot;identifier\&quot;: \&quot;table-guid\&quot;, \&quot;obj_identifier\&quot;:
     * \&quot;table-object-id\&quot; } ] } &#x60;&#x60;&#x60; #### Response format The API returns
     * an array of &#x60;ColumnSecurityRuleResponse&#x60; objects wrapped in a &#x60;data&#x60;
     * field. Each &#x60;ColumnSecurityRuleResponse&#x60; object contains: - Table information (GUID
     * and object ID) - Array of column security rules with column details, group access, and source
     * table information #### Example response &#x60;&#x60;&#x60;json { \&quot;data\&quot;: [ {
     * \&quot;guid\&quot;: \&quot;table-guid\&quot;, \&quot;objId\&quot;:
     * \&quot;table-object-id\&quot;, \&quot;columnSecurityRules\&quot;: [ { \&quot;column\&quot;: {
     * \&quot;id\&quot;: \&quot;col_123\&quot;, \&quot;name\&quot;: \&quot;Salary\&quot; },
     * \&quot;groups\&quot;: [ { \&quot;id\&quot;: \&quot;group_1\&quot;, \&quot;name\&quot;:
     * \&quot;HR Department\&quot; } ], \&quot;sourceTableDetails\&quot;: { \&quot;id\&quot;:
     * \&quot;source-table-guid\&quot;, \&quot;name\&quot;: \&quot;Employee_Data\&quot; } } ] } ] }
     * &#x60;&#x60;&#x60;
     *
     * @param fetchColumnSecurityRulesRequest (required)
     * @return List&lt;ColumnSecurityRuleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully fetched column security rules </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request - Table not found or invalid parameters </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden - User doesn&#39;t have permission to access security rules for this table </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     * </table>
     */
    public List<ColumnSecurityRuleResponse> fetchColumnSecurityRules(
            FetchColumnSecurityRulesRequest fetchColumnSecurityRulesRequest) throws ApiException {
        ApiResponse<List<ColumnSecurityRuleResponse>> localVarResp =
                fetchColumnSecurityRulesWithHttpInfo(fetchColumnSecurityRulesRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.12.0.cl or later Fetches column security rules for specified tables. This API
     * endpoint retrieves column-level security rules configured for tables. It returns information
     * about which columns are secured and which groups have access to those columns. #### Usage
     * guidelines - Provide an array of table identifiers using either &#x60;identifier&#x60; (GUID
     * or name) or &#x60;obj_identifier&#x60; (object ID) - At least one of &#x60;identifier&#x60;
     * or &#x60;obj_identifier&#x60; must be provided for each table - The API returns column
     * security rules for all specified tables - Users must have appropriate permissions to access
     * security rules for the specified tables #### Required permissions -
     * &#x60;ADMINISTRATION&#x60; - Can administer ThoughtSpot - &#x60;DATAMANAGEMENT&#x60; - Can
     * manage data - &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; - Can manage worksheet views and
     * tables #### Example request &#x60;&#x60;&#x60;json { \&quot;tables\&quot;: [ {
     * \&quot;identifier\&quot;: \&quot;table-guid\&quot;, \&quot;obj_identifier\&quot;:
     * \&quot;table-object-id\&quot; } ] } &#x60;&#x60;&#x60; #### Response format The API returns
     * an array of &#x60;ColumnSecurityRuleResponse&#x60; objects wrapped in a &#x60;data&#x60;
     * field. Each &#x60;ColumnSecurityRuleResponse&#x60; object contains: - Table information (GUID
     * and object ID) - Array of column security rules with column details, group access, and source
     * table information #### Example response &#x60;&#x60;&#x60;json { \&quot;data\&quot;: [ {
     * \&quot;guid\&quot;: \&quot;table-guid\&quot;, \&quot;objId\&quot;:
     * \&quot;table-object-id\&quot;, \&quot;columnSecurityRules\&quot;: [ { \&quot;column\&quot;: {
     * \&quot;id\&quot;: \&quot;col_123\&quot;, \&quot;name\&quot;: \&quot;Salary\&quot; },
     * \&quot;groups\&quot;: [ { \&quot;id\&quot;: \&quot;group_1\&quot;, \&quot;name\&quot;:
     * \&quot;HR Department\&quot; } ], \&quot;sourceTableDetails\&quot;: { \&quot;id\&quot;:
     * \&quot;source-table-guid\&quot;, \&quot;name\&quot;: \&quot;Employee_Data\&quot; } } ] } ] }
     * &#x60;&#x60;&#x60;
     *
     * @param fetchColumnSecurityRulesRequest (required)
     * @return ApiResponse&lt;List&lt;ColumnSecurityRuleResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully fetched column security rules </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request - Table not found or invalid parameters </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden - User doesn&#39;t have permission to access security rules for this table </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<ColumnSecurityRuleResponse>> fetchColumnSecurityRulesWithHttpInfo(
            FetchColumnSecurityRulesRequest fetchColumnSecurityRulesRequest) throws ApiException {
        okhttp3.Call localVarCall =
                fetchColumnSecurityRulesValidateBeforeCall(fetchColumnSecurityRulesRequest, null);
        Type localVarReturnType = new TypeToken<List<ColumnSecurityRuleResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Fetches column security rules for specified
     * tables. This API endpoint retrieves column-level security rules configured for tables. It
     * returns information about which columns are secured and which groups have access to those
     * columns. #### Usage guidelines - Provide an array of table identifiers using either
     * &#x60;identifier&#x60; (GUID or name) or &#x60;obj_identifier&#x60; (object ID) - At least
     * one of &#x60;identifier&#x60; or &#x60;obj_identifier&#x60; must be provided for each table -
     * The API returns column security rules for all specified tables - Users must have appropriate
     * permissions to access security rules for the specified tables #### Required permissions -
     * &#x60;ADMINISTRATION&#x60; - Can administer ThoughtSpot - &#x60;DATAMANAGEMENT&#x60; - Can
     * manage data - &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; - Can manage worksheet views and
     * tables #### Example request &#x60;&#x60;&#x60;json { \&quot;tables\&quot;: [ {
     * \&quot;identifier\&quot;: \&quot;table-guid\&quot;, \&quot;obj_identifier\&quot;:
     * \&quot;table-object-id\&quot; } ] } &#x60;&#x60;&#x60; #### Response format The API returns
     * an array of &#x60;ColumnSecurityRuleResponse&#x60; objects wrapped in a &#x60;data&#x60;
     * field. Each &#x60;ColumnSecurityRuleResponse&#x60; object contains: - Table information (GUID
     * and object ID) - Array of column security rules with column details, group access, and source
     * table information #### Example response &#x60;&#x60;&#x60;json { \&quot;data\&quot;: [ {
     * \&quot;guid\&quot;: \&quot;table-guid\&quot;, \&quot;objId\&quot;:
     * \&quot;table-object-id\&quot;, \&quot;columnSecurityRules\&quot;: [ { \&quot;column\&quot;: {
     * \&quot;id\&quot;: \&quot;col_123\&quot;, \&quot;name\&quot;: \&quot;Salary\&quot; },
     * \&quot;groups\&quot;: [ { \&quot;id\&quot;: \&quot;group_1\&quot;, \&quot;name\&quot;:
     * \&quot;HR Department\&quot; } ], \&quot;sourceTableDetails\&quot;: { \&quot;id\&quot;:
     * \&quot;source-table-guid\&quot;, \&quot;name\&quot;: \&quot;Employee_Data\&quot; } } ] } ] }
     * &#x60;&#x60;&#x60;
     *
     * @param fetchColumnSecurityRulesRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully fetched column security rules </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request - Table not found or invalid parameters </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden - User doesn&#39;t have permission to access security rules for this table </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchColumnSecurityRulesAsync(
            FetchColumnSecurityRulesRequest fetchColumnSecurityRulesRequest,
            final ApiCallback<List<ColumnSecurityRuleResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                fetchColumnSecurityRulesValidateBeforeCall(
                        fetchColumnSecurityRulesRequest, _callback);
        Type localVarReturnType = new TypeToken<List<ColumnSecurityRuleResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchConnectionDiffStatus
     *
     * @param connectionIdentifier GUID of the connection (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> true/false </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchConnectionDiffStatusCall(
            String connectionIdentifier, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/connections/fetch-connection-diff-status/{connection_identifier}"
                        .replace(
                                "{" + "connection_identifier" + "}",
                                localVarApiClient.escapeString(connectionIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchConnectionDiffStatusValidateBeforeCall(
            String connectionIdentifier, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'connectionIdentifier' is set
        if (connectionIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'connectionIdentifier' when calling"
                            + " fetchConnectionDiffStatus(Async)");
        }

        return fetchConnectionDiffStatusCall(connectionIdentifier, _callback);
    }

    /**
     * Version: 9.9.0.cl or later Validates the difference in connection metadata between CDW and
     * ThoughtSpot. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) Returns a boolean
     * indicating whether there is any difference between the connection metadata at ThoughtSpot and
     * CDW. To get the connection metadata difference status, pass the connection GUID as
     * &#x60;connection_identifier&#x60; in the API request.
     *
     * @param connectionIdentifier GUID of the connection (required)
     * @return FetchConnectionDiffStatusResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> true/false </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public FetchConnectionDiffStatusResponse fetchConnectionDiffStatus(String connectionIdentifier)
            throws ApiException {
        ApiResponse<FetchConnectionDiffStatusResponse> localVarResp =
                fetchConnectionDiffStatusWithHttpInfo(connectionIdentifier);
        return localVarResp.getData();
    }

    /**
     * Version: 9.9.0.cl or later Validates the difference in connection metadata between CDW and
     * ThoughtSpot. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) Returns a boolean
     * indicating whether there is any difference between the connection metadata at ThoughtSpot and
     * CDW. To get the connection metadata difference status, pass the connection GUID as
     * &#x60;connection_identifier&#x60; in the API request.
     *
     * @param connectionIdentifier GUID of the connection (required)
     * @return ApiResponse&lt;FetchConnectionDiffStatusResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> true/false </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<FetchConnectionDiffStatusResponse> fetchConnectionDiffStatusWithHttpInfo(
            String connectionIdentifier) throws ApiException {
        okhttp3.Call localVarCall =
                fetchConnectionDiffStatusValidateBeforeCall(connectionIdentifier, null);
        Type localVarReturnType = new TypeToken<FetchConnectionDiffStatusResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.9.0.cl or later Validates the difference in connection metadata
     * between CDW and ThoughtSpot. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following Data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) Returns a boolean
     * indicating whether there is any difference between the connection metadata at ThoughtSpot and
     * CDW. To get the connection metadata difference status, pass the connection GUID as
     * &#x60;connection_identifier&#x60; in the API request.
     *
     * @param connectionIdentifier GUID of the connection (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> true/false </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchConnectionDiffStatusAsync(
            String connectionIdentifier,
            final ApiCallback<FetchConnectionDiffStatusResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                fetchConnectionDiffStatusValidateBeforeCall(connectionIdentifier, _callback);
        Type localVarReturnType = new TypeToken<FetchConnectionDiffStatusResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchLiveboardData
     *
     * @param fetchLiveboardDataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchLiveboardDataCall(
            FetchLiveboardDataRequest fetchLiveboardDataRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fetchLiveboardDataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/liveboard/data";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchLiveboardDataValidateBeforeCall(
            FetchLiveboardDataRequest fetchLiveboardDataRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'fetchLiveboardDataRequest' is set
        if (fetchLiveboardDataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'fetchLiveboardDataRequest' when calling"
                            + " fetchLiveboardData(Async)");
        }

        return fetchLiveboardDataCall(fetchLiveboardDataRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Gets data from a Liveboard object and its visualization. Requires
     * at least view access to the Liveboard. #### Usage guidelines In the request body, specify the
     * GUID or name of the Liveboard. To get data for specific visualizations, add the GUIDs or
     * names of the visualizations in the API request. To include unsaved changes in the report,
     * pass the &#x60;transient_pinboard_content&#x60; script generated from the
     * &#x60;getExportRequestForCurrentPinboard&#x60; method in the Visual Embed SDK. Upon
     * successful execution, the API returns the report with unsaved changes. If the new Liveboard
     * experience mode, the transient content includes ad hoc changes to visualizations such as
     * sorting, toggling of legends, and data drill down. For more information, and see [Liveboard
     * data
     * API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_fetch_liveboard_data_api).
     *
     * @param fetchLiveboardDataRequest (required)
     * @return LiveboardDataResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public LiveboardDataResponse fetchLiveboardData(
            FetchLiveboardDataRequest fetchLiveboardDataRequest) throws ApiException {
        ApiResponse<LiveboardDataResponse> localVarResp =
                fetchLiveboardDataWithHttpInfo(fetchLiveboardDataRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Gets data from a Liveboard object and its visualization. Requires
     * at least view access to the Liveboard. #### Usage guidelines In the request body, specify the
     * GUID or name of the Liveboard. To get data for specific visualizations, add the GUIDs or
     * names of the visualizations in the API request. To include unsaved changes in the report,
     * pass the &#x60;transient_pinboard_content&#x60; script generated from the
     * &#x60;getExportRequestForCurrentPinboard&#x60; method in the Visual Embed SDK. Upon
     * successful execution, the API returns the report with unsaved changes. If the new Liveboard
     * experience mode, the transient content includes ad hoc changes to visualizations such as
     * sorting, toggling of legends, and data drill down. For more information, and see [Liveboard
     * data
     * API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_fetch_liveboard_data_api).
     *
     * @param fetchLiveboardDataRequest (required)
     * @return ApiResponse&lt;LiveboardDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<LiveboardDataResponse> fetchLiveboardDataWithHttpInfo(
            FetchLiveboardDataRequest fetchLiveboardDataRequest) throws ApiException {
        okhttp3.Call localVarCall =
                fetchLiveboardDataValidateBeforeCall(fetchLiveboardDataRequest, null);
        Type localVarReturnType = new TypeToken<LiveboardDataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Gets data from a Liveboard object and its
     * visualization. Requires at least view access to the Liveboard. #### Usage guidelines In the
     * request body, specify the GUID or name of the Liveboard. To get data for specific
     * visualizations, add the GUIDs or names of the visualizations in the API request. To include
     * unsaved changes in the report, pass the &#x60;transient_pinboard_content&#x60; script
     * generated from the &#x60;getExportRequestForCurrentPinboard&#x60; method in the Visual Embed
     * SDK. Upon successful execution, the API returns the report with unsaved changes. If the new
     * Liveboard experience mode, the transient content includes ad hoc changes to visualizations
     * such as sorting, toggling of legends, and data drill down. For more information, and see
     * [Liveboard data
     * API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_fetch_liveboard_data_api).
     *
     * @param fetchLiveboardDataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchLiveboardDataAsync(
            FetchLiveboardDataRequest fetchLiveboardDataRequest,
            final ApiCallback<LiveboardDataResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                fetchLiveboardDataValidateBeforeCall(fetchLiveboardDataRequest, _callback);
        Type localVarReturnType = new TypeToken<LiveboardDataResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchLiveboardSqlQuery
     *
     * @param fetchLiveboardSqlQueryRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching SQL query of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchLiveboardSqlQueryCall(
            FetchLiveboardSqlQueryRequest fetchLiveboardSqlQueryRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fetchLiveboardSqlQueryRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/liveboard/sql";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchLiveboardSqlQueryValidateBeforeCall(
            FetchLiveboardSqlQueryRequest fetchLiveboardSqlQueryRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'fetchLiveboardSqlQueryRequest' is set
        if (fetchLiveboardSqlQueryRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'fetchLiveboardSqlQueryRequest' when calling"
                            + " fetchLiveboardSqlQuery(Async)");
        }

        return fetchLiveboardSqlQueryCall(fetchLiveboardSqlQueryRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Fetches the underlying SQL query data for a Liveboard object and
     * its visualizations. Requires at least view access to the Liveboard object. To get SQL query
     * data for a Liveboard, specify the GUID of the Liveboard. Optionally, you can add an array of
     * visualization GUIDs to retrieve the SQL query data for visualizations in the Liveboard. Upon
     * successful execution, the API returns the SQL queries for the specified object as shown in
     * this example: &#x60;&#x60;&#x60; { \&quot;metadata_id\&quot;:
     * \&quot;fa68ae91-7588-4136-bacd-d71fb12dda69\&quot;, \&quot;metadata_name\&quot;: \&quot;Total
     * Sales\&quot;, \&quot;metadata_type\&quot;: \&quot;LIVEBOARD\&quot;,
     * \&quot;sql_queries\&quot;: [ { \&quot;metadata_id\&quot;:
     * \&quot;b3b6d2b9-089a-490c-8e16-b144650b7843\&quot;, \&quot;metadata_name\&quot;: \&quot;Total
     * quantity purchased, Total sales by region\&quot;, \&quot;sql_query\&quot;: \&quot;SELECT \\n
     * \\\&quot;ta_1\\\&quot;.\\\&quot;REGION\\\&quot; \\\&quot;ca_1\\\&quot;, \\n CASE\\n WHEN
     * sum(\\\&quot;ta_2\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;) IS NOT NULL THEN
     * sum(\\\&quot;ta_2\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_2\\\&quot;, \\n CASE\\n WHEN sum(\\\&quot;ta_2\\\&quot;.\\\&quot;SALES\\\&quot;)
     * IS NOT NULL THEN sum(\\\&quot;ta_2\\\&quot;.\\\&quot;SALES\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_3\\\&quot;\\nFROM
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;FACT_RETAPP_SALES\\\&quot;
     * \\\&quot;ta_2\\\&quot;\\n JOIN
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;DIM_RETAPP_STORES\\\&quot;
     * \\\&quot;ta_1\\\&quot;\\n ON \\\&quot;ta_2\\\&quot;.\\\&quot;STOREID\\\&quot; &#x3D;
     * \\\&quot;ta_1\\\&quot;.\\\&quot;STOREID\\\&quot;\\nGROUP BY \\\&quot;ca_1\\\&quot;\&quot; } ]
     * } &#x60;&#x60;&#x60;
     *
     * @param fetchLiveboardSqlQueryRequest (required)
     * @return SqlQueryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching SQL query of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public SqlQueryResponse fetchLiveboardSqlQuery(
            FetchLiveboardSqlQueryRequest fetchLiveboardSqlQueryRequest) throws ApiException {
        ApiResponse<SqlQueryResponse> localVarResp =
                fetchLiveboardSqlQueryWithHttpInfo(fetchLiveboardSqlQueryRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Fetches the underlying SQL query data for a Liveboard object and
     * its visualizations. Requires at least view access to the Liveboard object. To get SQL query
     * data for a Liveboard, specify the GUID of the Liveboard. Optionally, you can add an array of
     * visualization GUIDs to retrieve the SQL query data for visualizations in the Liveboard. Upon
     * successful execution, the API returns the SQL queries for the specified object as shown in
     * this example: &#x60;&#x60;&#x60; { \&quot;metadata_id\&quot;:
     * \&quot;fa68ae91-7588-4136-bacd-d71fb12dda69\&quot;, \&quot;metadata_name\&quot;: \&quot;Total
     * Sales\&quot;, \&quot;metadata_type\&quot;: \&quot;LIVEBOARD\&quot;,
     * \&quot;sql_queries\&quot;: [ { \&quot;metadata_id\&quot;:
     * \&quot;b3b6d2b9-089a-490c-8e16-b144650b7843\&quot;, \&quot;metadata_name\&quot;: \&quot;Total
     * quantity purchased, Total sales by region\&quot;, \&quot;sql_query\&quot;: \&quot;SELECT \\n
     * \\\&quot;ta_1\\\&quot;.\\\&quot;REGION\\\&quot; \\\&quot;ca_1\\\&quot;, \\n CASE\\n WHEN
     * sum(\\\&quot;ta_2\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;) IS NOT NULL THEN
     * sum(\\\&quot;ta_2\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_2\\\&quot;, \\n CASE\\n WHEN sum(\\\&quot;ta_2\\\&quot;.\\\&quot;SALES\\\&quot;)
     * IS NOT NULL THEN sum(\\\&quot;ta_2\\\&quot;.\\\&quot;SALES\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_3\\\&quot;\\nFROM
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;FACT_RETAPP_SALES\\\&quot;
     * \\\&quot;ta_2\\\&quot;\\n JOIN
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;DIM_RETAPP_STORES\\\&quot;
     * \\\&quot;ta_1\\\&quot;\\n ON \\\&quot;ta_2\\\&quot;.\\\&quot;STOREID\\\&quot; &#x3D;
     * \\\&quot;ta_1\\\&quot;.\\\&quot;STOREID\\\&quot;\\nGROUP BY \\\&quot;ca_1\\\&quot;\&quot; } ]
     * } &#x60;&#x60;&#x60;
     *
     * @param fetchLiveboardSqlQueryRequest (required)
     * @return ApiResponse&lt;SqlQueryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching SQL query of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<SqlQueryResponse> fetchLiveboardSqlQueryWithHttpInfo(
            FetchLiveboardSqlQueryRequest fetchLiveboardSqlQueryRequest) throws ApiException {
        okhttp3.Call localVarCall =
                fetchLiveboardSqlQueryValidateBeforeCall(fetchLiveboardSqlQueryRequest, null);
        Type localVarReturnType = new TypeToken<SqlQueryResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Fetches the underlying SQL query data for a
     * Liveboard object and its visualizations. Requires at least view access to the Liveboard
     * object. To get SQL query data for a Liveboard, specify the GUID of the Liveboard. Optionally,
     * you can add an array of visualization GUIDs to retrieve the SQL query data for visualizations
     * in the Liveboard. Upon successful execution, the API returns the SQL queries for the
     * specified object as shown in this example: &#x60;&#x60;&#x60; { \&quot;metadata_id\&quot;:
     * \&quot;fa68ae91-7588-4136-bacd-d71fb12dda69\&quot;, \&quot;metadata_name\&quot;: \&quot;Total
     * Sales\&quot;, \&quot;metadata_type\&quot;: \&quot;LIVEBOARD\&quot;,
     * \&quot;sql_queries\&quot;: [ { \&quot;metadata_id\&quot;:
     * \&quot;b3b6d2b9-089a-490c-8e16-b144650b7843\&quot;, \&quot;metadata_name\&quot;: \&quot;Total
     * quantity purchased, Total sales by region\&quot;, \&quot;sql_query\&quot;: \&quot;SELECT \\n
     * \\\&quot;ta_1\\\&quot;.\\\&quot;REGION\\\&quot; \\\&quot;ca_1\\\&quot;, \\n CASE\\n WHEN
     * sum(\\\&quot;ta_2\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;) IS NOT NULL THEN
     * sum(\\\&quot;ta_2\\\&quot;.\\\&quot;QUANTITYPURCHASED\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_2\\\&quot;, \\n CASE\\n WHEN sum(\\\&quot;ta_2\\\&quot;.\\\&quot;SALES\\\&quot;)
     * IS NOT NULL THEN sum(\\\&quot;ta_2\\\&quot;.\\\&quot;SALES\\\&quot;)\\n ELSE 0\\n END
     * \\\&quot;ca_3\\\&quot;\\nFROM
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;FACT_RETAPP_SALES\\\&quot;
     * \\\&quot;ta_2\\\&quot;\\n JOIN
     * \\\&quot;RETAILAPPAREL\\\&quot;.\\\&quot;PUBLIC\\\&quot;.\\\&quot;DIM_RETAPP_STORES\\\&quot;
     * \\\&quot;ta_1\\\&quot;\\n ON \\\&quot;ta_2\\\&quot;.\\\&quot;STOREID\\\&quot; &#x3D;
     * \\\&quot;ta_1\\\&quot;.\\\&quot;STOREID\\\&quot;\\nGROUP BY \\\&quot;ca_1\\\&quot;\&quot; } ]
     * } &#x60;&#x60;&#x60;
     *
     * @param fetchLiveboardSqlQueryRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching SQL query of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchLiveboardSqlQueryAsync(
            FetchLiveboardSqlQueryRequest fetchLiveboardSqlQueryRequest,
            final ApiCallback<SqlQueryResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                fetchLiveboardSqlQueryValidateBeforeCall(fetchLiveboardSqlQueryRequest, _callback);
        Type localVarReturnType = new TypeToken<SqlQueryResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchLogs
     *
     * @param fetchLogsRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Log fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchLogsCall(
            FetchLogsRequest fetchLogsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fetchLogsRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/logs/fetch";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchLogsValidateBeforeCall(
            FetchLogsRequest fetchLogsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'fetchLogsRequest' is set
        if (fetchLogsRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'fetchLogsRequest' when calling"
                            + " fetchLogs(Async)");
        }

        return fetchLogsCall(fetchLogsRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Fetches security audit logs. Requires &#x60;ADMINISTRATION&#x60;
     * (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the [Admin
     * Control](https://developers.thoughtspot.com/docs/rbac#_admin_control) privileges are
     * required. #### Usage guidelines By default, the API retrieves logs for the last 24 hours. You
     * can set a custom duration in EPOCH time. Make sure the log duration specified in your API
     * request doesn’t exceed 24 hours. If you must fetch logs for a longer time range, modify the
     * duration and make multiple sequential API requests. Upon successful execution, the API
     * returns logs with the following information: * timestamp of the event * event ID * event type
     * * name and GUID of the user * IP address of ThoughtSpot instance For more information see
     * [Audit logs Documentation](https://developers.thoughtspot.com/docs/audit-logs).
     *
     * @param fetchLogsRequest (required)
     * @return List&lt;LogResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Log fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<LogResponse> fetchLogs(FetchLogsRequest fetchLogsRequest) throws ApiException {
        ApiResponse<List<LogResponse>> localVarResp = fetchLogsWithHttpInfo(fetchLogsRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Fetches security audit logs. Requires &#x60;ADMINISTRATION&#x60;
     * (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the [Admin
     * Control](https://developers.thoughtspot.com/docs/rbac#_admin_control) privileges are
     * required. #### Usage guidelines By default, the API retrieves logs for the last 24 hours. You
     * can set a custom duration in EPOCH time. Make sure the log duration specified in your API
     * request doesn’t exceed 24 hours. If you must fetch logs for a longer time range, modify the
     * duration and make multiple sequential API requests. Upon successful execution, the API
     * returns logs with the following information: * timestamp of the event * event ID * event type
     * * name and GUID of the user * IP address of ThoughtSpot instance For more information see
     * [Audit logs Documentation](https://developers.thoughtspot.com/docs/audit-logs).
     *
     * @param fetchLogsRequest (required)
     * @return ApiResponse&lt;List&lt;LogResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Log fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<LogResponse>> fetchLogsWithHttpInfo(FetchLogsRequest fetchLogsRequest)
            throws ApiException {
        okhttp3.Call localVarCall = fetchLogsValidateBeforeCall(fetchLogsRequest, null);
        Type localVarReturnType = new TypeToken<List<LogResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Fetches security audit logs. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the [Admin Control](https://developers.thoughtspot.com/docs/rbac#_admin_control) privileges
     * are required. #### Usage guidelines By default, the API retrieves logs for the last 24 hours.
     * You can set a custom duration in EPOCH time. Make sure the log duration specified in your API
     * request doesn’t exceed 24 hours. If you must fetch logs for a longer time range, modify the
     * duration and make multiple sequential API requests. Upon successful execution, the API
     * returns logs with the following information: * timestamp of the event * event ID * event type
     * * name and GUID of the user * IP address of ThoughtSpot instance For more information see
     * [Audit logs Documentation](https://developers.thoughtspot.com/docs/audit-logs).
     *
     * @param fetchLogsRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Log fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchLogsAsync(
            FetchLogsRequest fetchLogsRequest, final ApiCallback<List<LogResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = fetchLogsValidateBeforeCall(fetchLogsRequest, _callback);
        Type localVarReturnType = new TypeToken<List<LogResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchPermissionsOfPrincipals
     *
     * @param fetchPermissionsOfPrincipalsRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching permissions of principals is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchPermissionsOfPrincipalsCall(
            FetchPermissionsOfPrincipalsRequest fetchPermissionsOfPrincipalsRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fetchPermissionsOfPrincipalsRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/security/principals/fetch-permissions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchPermissionsOfPrincipalsValidateBeforeCall(
            FetchPermissionsOfPrincipalsRequest fetchPermissionsOfPrincipalsRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'fetchPermissionsOfPrincipalsRequest' is set
        if (fetchPermissionsOfPrincipalsRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'fetchPermissionsOfPrincipalsRequest' when"
                            + " calling fetchPermissionsOfPrincipals(Async)");
        }

        return fetchPermissionsOfPrincipalsCall(fetchPermissionsOfPrincipalsRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Fetches object permission details for a given principal object
     * such as a user and group. Requires view access to the metadata object. #### Usage guidelines
     * * To get a list of all metadata objects that a user or group can access, specify the
     * &#x60;type&#x60; and GUID or name of the principal. * To get permission details for a
     * specific object, add the &#x60;type&#x60; and GUID or name of the metadata object to your API
     * request. Upon successful execution, the API returns a list of metadata objects and permission
     * details for each object.
     *
     * @param fetchPermissionsOfPrincipalsRequest (required)
     * @return PermissionOfPrincipalsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching permissions of principals is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public PermissionOfPrincipalsResponse fetchPermissionsOfPrincipals(
            FetchPermissionsOfPrincipalsRequest fetchPermissionsOfPrincipalsRequest)
            throws ApiException {
        ApiResponse<PermissionOfPrincipalsResponse> localVarResp =
                fetchPermissionsOfPrincipalsWithHttpInfo(fetchPermissionsOfPrincipalsRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Fetches object permission details for a given principal object
     * such as a user and group. Requires view access to the metadata object. #### Usage guidelines
     * * To get a list of all metadata objects that a user or group can access, specify the
     * &#x60;type&#x60; and GUID or name of the principal. * To get permission details for a
     * specific object, add the &#x60;type&#x60; and GUID or name of the metadata object to your API
     * request. Upon successful execution, the API returns a list of metadata objects and permission
     * details for each object.
     *
     * @param fetchPermissionsOfPrincipalsRequest (required)
     * @return ApiResponse&lt;PermissionOfPrincipalsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching permissions of principals is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<PermissionOfPrincipalsResponse> fetchPermissionsOfPrincipalsWithHttpInfo(
            FetchPermissionsOfPrincipalsRequest fetchPermissionsOfPrincipalsRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                fetchPermissionsOfPrincipalsValidateBeforeCall(
                        fetchPermissionsOfPrincipalsRequest, null);
        Type localVarReturnType = new TypeToken<PermissionOfPrincipalsResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Fetches object permission details for a given
     * principal object such as a user and group. Requires view access to the metadata object. ####
     * Usage guidelines * To get a list of all metadata objects that a user or group can access,
     * specify the &#x60;type&#x60; and GUID or name of the principal. * To get permission details
     * for a specific object, add the &#x60;type&#x60; and GUID or name of the metadata object to
     * your API request. Upon successful execution, the API returns a list of metadata objects and
     * permission details for each object.
     *
     * @param fetchPermissionsOfPrincipalsRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching permissions of principals is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchPermissionsOfPrincipalsAsync(
            FetchPermissionsOfPrincipalsRequest fetchPermissionsOfPrincipalsRequest,
            final ApiCallback<PermissionOfPrincipalsResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                fetchPermissionsOfPrincipalsValidateBeforeCall(
                        fetchPermissionsOfPrincipalsRequest, _callback);
        Type localVarReturnType = new TypeToken<PermissionOfPrincipalsResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for fetchPermissionsOnMetadata
     *
     * @param fetchPermissionsOnMetadataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching permissions of metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchPermissionsOnMetadataCall(
            FetchPermissionsOnMetadataRequest fetchPermissionsOnMetadataRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = fetchPermissionsOnMetadataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/security/metadata/fetch-permissions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call fetchPermissionsOnMetadataValidateBeforeCall(
            FetchPermissionsOnMetadataRequest fetchPermissionsOnMetadataRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'fetchPermissionsOnMetadataRequest' is set
        if (fetchPermissionsOnMetadataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'fetchPermissionsOnMetadataRequest' when"
                            + " calling fetchPermissionsOnMetadata(Async)");
        }

        return fetchPermissionsOnMetadataCall(fetchPermissionsOnMetadataRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Fetches permission details for a given metadata object. Requires
     * view access to the metadata object. #### Usage guidelines * To fetch a list of users and
     * groups for a metadata object, specify &#x60;type&#x60; and GUID or name of the metadata
     * object. * To get permission details for a specific user or group, add &#x60;type&#x60; and
     * GUID or name of the principal object to your API request. Upon successful execution, the API
     * returns permission details and principal information for the object specified in the API
     * request.
     *
     * @param fetchPermissionsOnMetadataRequest (required)
     * @return PermissionOfMetadataResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching permissions of metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public PermissionOfMetadataResponse fetchPermissionsOnMetadata(
            FetchPermissionsOnMetadataRequest fetchPermissionsOnMetadataRequest)
            throws ApiException {
        ApiResponse<PermissionOfMetadataResponse> localVarResp =
                fetchPermissionsOnMetadataWithHttpInfo(fetchPermissionsOnMetadataRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Fetches permission details for a given metadata object. Requires
     * view access to the metadata object. #### Usage guidelines * To fetch a list of users and
     * groups for a metadata object, specify &#x60;type&#x60; and GUID or name of the metadata
     * object. * To get permission details for a specific user or group, add &#x60;type&#x60; and
     * GUID or name of the principal object to your API request. Upon successful execution, the API
     * returns permission details and principal information for the object specified in the API
     * request.
     *
     * @param fetchPermissionsOnMetadataRequest (required)
     * @return ApiResponse&lt;PermissionOfMetadataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching permissions of metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<PermissionOfMetadataResponse> fetchPermissionsOnMetadataWithHttpInfo(
            FetchPermissionsOnMetadataRequest fetchPermissionsOnMetadataRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                fetchPermissionsOnMetadataValidateBeforeCall(
                        fetchPermissionsOnMetadataRequest, null);
        Type localVarReturnType = new TypeToken<PermissionOfMetadataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Fetches permission details for a given metadata
     * object. Requires view access to the metadata object. #### Usage guidelines * To fetch a list
     * of users and groups for a metadata object, specify &#x60;type&#x60; and GUID or name of the
     * metadata object. * To get permission details for a specific user or group, add
     * &#x60;type&#x60; and GUID or name of the principal object to your API request. Upon
     * successful execution, the API returns permission details and principal information for the
     * object specified in the API request.
     *
     * @param fetchPermissionsOnMetadataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching permissions of metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call fetchPermissionsOnMetadataAsync(
            FetchPermissionsOnMetadataRequest fetchPermissionsOnMetadataRequest,
            final ApiCallback<PermissionOfMetadataResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                fetchPermissionsOnMetadataValidateBeforeCall(
                        fetchPermissionsOnMetadataRequest, _callback);
        Type localVarReturnType = new TypeToken<PermissionOfMetadataResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for forceLogoutUsers
     *
     * @param forceLogoutUsersRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Force logging out of users operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call forceLogoutUsersCall(
            ForceLogoutUsersRequest forceLogoutUsersRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = forceLogoutUsersRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/users/force-logout";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call forceLogoutUsersValidateBeforeCall(
            ForceLogoutUsersRequest forceLogoutUsersRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'forceLogoutUsersRequest' is set
        if (forceLogoutUsersRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'forceLogoutUsersRequest' when calling"
                            + " forceLogoutUsers(Async)");
        }

        return forceLogoutUsersCall(forceLogoutUsersRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Enforces logout on current user sessions. Use this API with
     * caution as it may invalidate active user sessions and force users to re-login. Make sure you
     * specify the usernames or GUIDs. If you pass null values in the API call, all user sessions on
     * your cluster become invalid, and the users are forced to re-login. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param forceLogoutUsersRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Force logging out of users operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void forceLogoutUsers(ForceLogoutUsersRequest forceLogoutUsersRequest)
            throws ApiException {
        forceLogoutUsersWithHttpInfo(forceLogoutUsersRequest);
    }

    /**
     * Version: 9.0.0.cl or later Enforces logout on current user sessions. Use this API with
     * caution as it may invalidate active user sessions and force users to re-login. Make sure you
     * specify the usernames or GUIDs. If you pass null values in the API call, all user sessions on
     * your cluster become invalid, and the users are forced to re-login. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param forceLogoutUsersRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Force logging out of users operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> forceLogoutUsersWithHttpInfo(
            ForceLogoutUsersRequest forceLogoutUsersRequest) throws ApiException {
        okhttp3.Call localVarCall =
                forceLogoutUsersValidateBeforeCall(forceLogoutUsersRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Enforces logout on current user sessions. Use
     * this API with caution as it may invalidate active user sessions and force users to re-login.
     * Make sure you specify the usernames or GUIDs. If you pass null values in the API call, all
     * user sessions on your cluster become invalid, and the users are forced to re-login. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param forceLogoutUsersRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Force logging out of users operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call forceLogoutUsersAsync(
            ForceLogoutUsersRequest forceLogoutUsersRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                forceLogoutUsersValidateBeforeCall(forceLogoutUsersRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for generateCSV
     *
     * @param generateCSVRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Generate custom calendar data based on specifications, as a CSV file. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call generateCSVCall(
            GenerateCSVRequest generateCSVRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = generateCSVRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/calendars/generate-csv";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call generateCSVValidateBeforeCall(
            GenerateCSVRequest generateCSVRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'generateCSVRequest' is set
        if (generateCSVRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'generateCSVRequest' when calling"
                            + " generateCSV(Async)");
        }

        return generateCSVCall(generateCSVRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Exports a [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal) in the CSV format.
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60;
     * (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines Use this API to download a custom calendar in
     * the CSV file format. In your API request, specify the following parameters. * Start and end
     * date of the calendar. For \&quot;month offset\&quot; calendars, the start date must match the
     * month defined in the &#x60;month_offset&#x60; attribute. You can also specify optional
     * parameters such as the starting day of the week and prefixes for the quarter and year labels.
     *
     * @param generateCSVRequest (required)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Generate custom calendar data based on specifications, as a CSV file. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public Object generateCSV(GenerateCSVRequest generateCSVRequest) throws ApiException {
        ApiResponse<Object> localVarResp = generateCSVWithHttpInfo(generateCSVRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.12.0.cl or later Exports a [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal) in the CSV format.
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60;
     * (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines Use this API to download a custom calendar in
     * the CSV file format. In your API request, specify the following parameters. * Start and end
     * date of the calendar. For \&quot;month offset\&quot; calendars, the start date must match the
     * month defined in the &#x60;month_offset&#x60; attribute. You can also specify optional
     * parameters such as the starting day of the week and prefixes for the quarter and year labels.
     *
     * @param generateCSVRequest (required)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Generate custom calendar data based on specifications, as a CSV file. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Object> generateCSVWithHttpInfo(GenerateCSVRequest generateCSVRequest)
            throws ApiException {
        okhttp3.Call localVarCall = generateCSVValidateBeforeCall(generateCSVRequest, null);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Exports a [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal) in the CSV format.
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60;
     * (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines Use this API to download a custom calendar in
     * the CSV file format. In your API request, specify the following parameters. * Start and end
     * date of the calendar. For \&quot;month offset\&quot; calendars, the start date must match the
     * month defined in the &#x60;month_offset&#x60; attribute. You can also specify optional
     * parameters such as the starting day of the week and prefixes for the quarter and year labels.
     *
     * @param generateCSVRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Generate custom calendar data based on specifications, as a CSV file. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call generateCSVAsync(
            GenerateCSVRequest generateCSVRequest, final ApiCallback<Object> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = generateCSVValidateBeforeCall(generateCSVRequest, _callback);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCurrentUserInfo
     *
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetch current session user detail successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getCurrentUserInfoCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/auth/session/user";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCurrentUserInfoValidateBeforeCall(final ApiCallback _callback)
            throws ApiException {
        return getCurrentUserInfoCall(_callback);
    }

    /**
     * Version: 9.0.0.cl or later Retrieves details of the current user session for the token
     * provided in the request header. Any ThoughtSpot user can access this endpoint and send an API
     * request. The data returned in the API response varies according to user&#39;s privilege and
     * object access permissions.
     *
     * @return User
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetch current session user detail successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public User getCurrentUserInfo() throws ApiException {
        ApiResponse<User> localVarResp = getCurrentUserInfoWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Retrieves details of the current user session for the token
     * provided in the request header. Any ThoughtSpot user can access this endpoint and send an API
     * request. The data returned in the API response varies according to user&#39;s privilege and
     * object access permissions.
     *
     * @return ApiResponse&lt;User&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetch current session user detail successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<User> getCurrentUserInfoWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getCurrentUserInfoValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<User>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Retrieves details of the current user session for
     * the token provided in the request header. Any ThoughtSpot user can access this endpoint and
     * send an API request. The data returned in the API response varies according to user&#39;s
     * privilege and object access permissions.
     *
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetch current session user detail successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getCurrentUserInfoAsync(final ApiCallback<User> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = getCurrentUserInfoValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<User>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCurrentUserToken
     *
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching token for current user successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getCurrentUserTokenCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/auth/session/token";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCurrentUserTokenValidateBeforeCall(final ApiCallback _callback)
            throws ApiException {
        return getCurrentUserTokenCall(_callback);
    }

    /**
     * Version: 9.4.0.cl or later Retrieves details of the current session token for the bearer
     * token provided in the request header. This API endpoint does not create a new token. Instead,
     * it returns details about the token, including the token string, creation time, expiration
     * time, and the associated user. Use this endpoint to introspect your current session token,
     * debug authentication issues, or when a frontend application needs session token details. Any
     * ThoughtSpot user with a valid bearer token can access this endpoint and send an API request
     *
     * @return GetTokenResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching token for current user successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public GetTokenResponse getCurrentUserToken() throws ApiException {
        ApiResponse<GetTokenResponse> localVarResp = getCurrentUserTokenWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Version: 9.4.0.cl or later Retrieves details of the current session token for the bearer
     * token provided in the request header. This API endpoint does not create a new token. Instead,
     * it returns details about the token, including the token string, creation time, expiration
     * time, and the associated user. Use this endpoint to introspect your current session token,
     * debug authentication issues, or when a frontend application needs session token details. Any
     * ThoughtSpot user with a valid bearer token can access this endpoint and send an API request
     *
     * @return ApiResponse&lt;GetTokenResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching token for current user successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<GetTokenResponse> getCurrentUserTokenWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getCurrentUserTokenValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<GetTokenResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.4.0.cl or later Retrieves details of the current session token
     * for the bearer token provided in the request header. This API endpoint does not create a new
     * token. Instead, it returns details about the token, including the token string, creation
     * time, expiration time, and the associated user. Use this endpoint to introspect your current
     * session token, debug authentication issues, or when a frontend application needs session
     * token details. Any ThoughtSpot user with a valid bearer token can access this endpoint and
     * send an API request
     *
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching token for current user successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getCurrentUserTokenAsync(final ApiCallback<GetTokenResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = getCurrentUserTokenValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<GetTokenResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getCustomAccessToken
     *
     * @param getCustomAccessTokenRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> ABAC token creation was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. This could be due to missing or incorrect parameters. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. The request could not be authenticated. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. The user does not have permission to access this resource. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> An unexpected error occurred on the server. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getCustomAccessTokenCall(
            GetCustomAccessTokenRequest getCustomAccessTokenRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getCustomAccessTokenRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/auth/token/custom";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getCustomAccessTokenValidateBeforeCall(
            GetCustomAccessTokenRequest getCustomAccessTokenRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'getCustomAccessTokenRequest' is set
        if (getCustomAccessTokenRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'getCustomAccessTokenRequest' when calling"
                            + " getCustomAccessToken(Async)");
        }

        return getCustomAccessTokenCall(getCustomAccessTokenRequest, _callback);
    }

    /**
     * Version: 10.4.0.cl or later Gets an authentication token with custom rules and security
     * attributes and creates a full session in ThoughtSpot for a given user. By default, the token
     * obtained from ThoughtSpot remains valid for 5 mins. To add a new user and assign privileges
     * during auto creation, you need &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * and edit access to the data source is required. To assign security attributes with filter
     * rules and Parameters to the JWT token, you&#39;ll need administrator privileges and edit
     * access to the data source (Worksheet or Model). If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * and edit access to the data source is required. #### Usage guidelines You can generate the
     * token for a user by providing a &#x60;username&#x60; and &#x60;password&#x60;, or by using
     * the cluster’s &#x60;secret_key&#x60;. To generate a &#x60;secret_key&#x60; on your cluster,
     * the administrator must enable [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable)
     * in the **Develop** &gt; **Customizations** &gt; **Security Settings** page. **Note**: When
     * both &#x60;password&#x60; and &#x60;secret_key&#x60; are included in the API request,
     * &#x60;password&#x60; takes precedence. If Multi-Factor Authentication (MFA) is enabled on
     * your instance, the API login request with basic authentication (&#x60;username&#x60; and
     * &#x60;password&#x60; ) returns an error. You can switch to token-based authentication with
     * &#x60;secret_key&#x60; or contact ThoughtSpot Support for assistance. ##### Attribute-Based
     * Access Control (ABAC) with tokens To implement Attribute-Based Access Control (ABAC) and
     * assign security entitlements to users during session creation, you can generate a token with
     * custom filtering rules and Parameters in the &#x60;filter_rules&#x60; and
     * &#x60;parameter_values&#x60; array respectively. These attributes can be configured to
     * persist on a specific set of objects for user sessions initiated using the token. Once
     * defined, the rules are added to the user&#39;s &#x60;access_control_properties&#x60; object,
     * after which all sessions will use the persisted values. Specify the object type as
     * &#x60;LOGICAL_TABLE&#x60;. The &#x60;LIVEBOARD&#x60; and &#x60;ANSWER&#x60; object types are
     * not supported. For more information, see [ABAC via tokens
     * Documentation](https://developers.thoughtspot.com/docs/api-authv2#_get_tokens_with_custom_rules_and_filter_conditions).
     * ##### Just-in-time provisioning For just-in-time user creation and provisioning, define the
     * following attributes: * &#x60;auto_create&#x60; * &#x60;username&#x60; *
     * &#x60;display_name&#x60; * &#x60;email&#x60; * &#x60;groups&#x60; Set &#x60;auto_create&#x60;
     * to &#x60;true&#x60; if the user is not available in ThoughtSpot. If the user already exists
     * in ThoughtSpot and the &#x60;auto_create&#x60; parameter is set to &#x60;true&#x60; in the
     * API request, the user properties such as the display name, email, Org and group assignment
     * will not be updated with new values. For more information, see [Just-in-time
     * provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning). #####
     * Important point to note All options in the token creation APIs that define access to the
     * content in ThoughtSpot will do so during the token creation and not when the token is being
     * used for authentication. For example, &#x60;auto_create:true&#x60; will create the user when
     * the authentication token is created. Persist options such as &#x60;APPEND&#x60;,
     * &#x60;REPLACE&#x60;, &#x60;RESET&#x60; will persist security parameters on the user profile
     * when the token is created, while Persist option &#x60;NONE&#x60; will not persist anything
     * but will be honoured in the session.
     *
     * @param getCustomAccessTokenRequest (required)
     * @return AccessToken
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> ABAC token creation was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. This could be due to missing or incorrect parameters. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. The request could not be authenticated. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. The user does not have permission to access this resource. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> An unexpected error occurred on the server. </td><td>  -  </td></tr>
     * </table>
     */
    public AccessToken getCustomAccessToken(GetCustomAccessTokenRequest getCustomAccessTokenRequest)
            throws ApiException {
        ApiResponse<AccessToken> localVarResp =
                getCustomAccessTokenWithHttpInfo(getCustomAccessTokenRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.4.0.cl or later Gets an authentication token with custom rules and security
     * attributes and creates a full session in ThoughtSpot for a given user. By default, the token
     * obtained from ThoughtSpot remains valid for 5 mins. To add a new user and assign privileges
     * during auto creation, you need &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * and edit access to the data source is required. To assign security attributes with filter
     * rules and Parameters to the JWT token, you&#39;ll need administrator privileges and edit
     * access to the data source (Worksheet or Model). If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * and edit access to the data source is required. #### Usage guidelines You can generate the
     * token for a user by providing a &#x60;username&#x60; and &#x60;password&#x60;, or by using
     * the cluster’s &#x60;secret_key&#x60;. To generate a &#x60;secret_key&#x60; on your cluster,
     * the administrator must enable [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable)
     * in the **Develop** &gt; **Customizations** &gt; **Security Settings** page. **Note**: When
     * both &#x60;password&#x60; and &#x60;secret_key&#x60; are included in the API request,
     * &#x60;password&#x60; takes precedence. If Multi-Factor Authentication (MFA) is enabled on
     * your instance, the API login request with basic authentication (&#x60;username&#x60; and
     * &#x60;password&#x60; ) returns an error. You can switch to token-based authentication with
     * &#x60;secret_key&#x60; or contact ThoughtSpot Support for assistance. ##### Attribute-Based
     * Access Control (ABAC) with tokens To implement Attribute-Based Access Control (ABAC) and
     * assign security entitlements to users during session creation, you can generate a token with
     * custom filtering rules and Parameters in the &#x60;filter_rules&#x60; and
     * &#x60;parameter_values&#x60; array respectively. These attributes can be configured to
     * persist on a specific set of objects for user sessions initiated using the token. Once
     * defined, the rules are added to the user&#39;s &#x60;access_control_properties&#x60; object,
     * after which all sessions will use the persisted values. Specify the object type as
     * &#x60;LOGICAL_TABLE&#x60;. The &#x60;LIVEBOARD&#x60; and &#x60;ANSWER&#x60; object types are
     * not supported. For more information, see [ABAC via tokens
     * Documentation](https://developers.thoughtspot.com/docs/api-authv2#_get_tokens_with_custom_rules_and_filter_conditions).
     * ##### Just-in-time provisioning For just-in-time user creation and provisioning, define the
     * following attributes: * &#x60;auto_create&#x60; * &#x60;username&#x60; *
     * &#x60;display_name&#x60; * &#x60;email&#x60; * &#x60;groups&#x60; Set &#x60;auto_create&#x60;
     * to &#x60;true&#x60; if the user is not available in ThoughtSpot. If the user already exists
     * in ThoughtSpot and the &#x60;auto_create&#x60; parameter is set to &#x60;true&#x60; in the
     * API request, the user properties such as the display name, email, Org and group assignment
     * will not be updated with new values. For more information, see [Just-in-time
     * provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning). #####
     * Important point to note All options in the token creation APIs that define access to the
     * content in ThoughtSpot will do so during the token creation and not when the token is being
     * used for authentication. For example, &#x60;auto_create:true&#x60; will create the user when
     * the authentication token is created. Persist options such as &#x60;APPEND&#x60;,
     * &#x60;REPLACE&#x60;, &#x60;RESET&#x60; will persist security parameters on the user profile
     * when the token is created, while Persist option &#x60;NONE&#x60; will not persist anything
     * but will be honoured in the session.
     *
     * @param getCustomAccessTokenRequest (required)
     * @return ApiResponse&lt;AccessToken&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> ABAC token creation was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. This could be due to missing or incorrect parameters. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. The request could not be authenticated. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. The user does not have permission to access this resource. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> An unexpected error occurred on the server. </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<AccessToken> getCustomAccessTokenWithHttpInfo(
            GetCustomAccessTokenRequest getCustomAccessTokenRequest) throws ApiException {
        okhttp3.Call localVarCall =
                getCustomAccessTokenValidateBeforeCall(getCustomAccessTokenRequest, null);
        Type localVarReturnType = new TypeToken<AccessToken>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.4.0.cl or later Gets an authentication token with custom rules
     * and security attributes and creates a full session in ThoughtSpot for a given user. By
     * default, the token obtained from ThoughtSpot remains valid for 5 mins. To add a new user and
     * assign privileges during auto creation, you need &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * and edit access to the data source is required. To assign security attributes with filter
     * rules and Parameters to the JWT token, you&#39;ll need administrator privileges and edit
     * access to the data source (Worksheet or Model). If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * and edit access to the data source is required. #### Usage guidelines You can generate the
     * token for a user by providing a &#x60;username&#x60; and &#x60;password&#x60;, or by using
     * the cluster’s &#x60;secret_key&#x60;. To generate a &#x60;secret_key&#x60; on your cluster,
     * the administrator must enable [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable)
     * in the **Develop** &gt; **Customizations** &gt; **Security Settings** page. **Note**: When
     * both &#x60;password&#x60; and &#x60;secret_key&#x60; are included in the API request,
     * &#x60;password&#x60; takes precedence. If Multi-Factor Authentication (MFA) is enabled on
     * your instance, the API login request with basic authentication (&#x60;username&#x60; and
     * &#x60;password&#x60; ) returns an error. You can switch to token-based authentication with
     * &#x60;secret_key&#x60; or contact ThoughtSpot Support for assistance. ##### Attribute-Based
     * Access Control (ABAC) with tokens To implement Attribute-Based Access Control (ABAC) and
     * assign security entitlements to users during session creation, you can generate a token with
     * custom filtering rules and Parameters in the &#x60;filter_rules&#x60; and
     * &#x60;parameter_values&#x60; array respectively. These attributes can be configured to
     * persist on a specific set of objects for user sessions initiated using the token. Once
     * defined, the rules are added to the user&#39;s &#x60;access_control_properties&#x60; object,
     * after which all sessions will use the persisted values. Specify the object type as
     * &#x60;LOGICAL_TABLE&#x60;. The &#x60;LIVEBOARD&#x60; and &#x60;ANSWER&#x60; object types are
     * not supported. For more information, see [ABAC via tokens
     * Documentation](https://developers.thoughtspot.com/docs/api-authv2#_get_tokens_with_custom_rules_and_filter_conditions).
     * ##### Just-in-time provisioning For just-in-time user creation and provisioning, define the
     * following attributes: * &#x60;auto_create&#x60; * &#x60;username&#x60; *
     * &#x60;display_name&#x60; * &#x60;email&#x60; * &#x60;groups&#x60; Set &#x60;auto_create&#x60;
     * to &#x60;true&#x60; if the user is not available in ThoughtSpot. If the user already exists
     * in ThoughtSpot and the &#x60;auto_create&#x60; parameter is set to &#x60;true&#x60; in the
     * API request, the user properties such as the display name, email, Org and group assignment
     * will not be updated with new values. For more information, see [Just-in-time
     * provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning). #####
     * Important point to note All options in the token creation APIs that define access to the
     * content in ThoughtSpot will do so during the token creation and not when the token is being
     * used for authentication. For example, &#x60;auto_create:true&#x60; will create the user when
     * the authentication token is created. Persist options such as &#x60;APPEND&#x60;,
     * &#x60;REPLACE&#x60;, &#x60;RESET&#x60; will persist security parameters on the user profile
     * when the token is created, while Persist option &#x60;NONE&#x60; will not persist anything
     * but will be honoured in the session.
     *
     * @param getCustomAccessTokenRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> ABAC token creation was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. This could be due to missing or incorrect parameters. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. The request could not be authenticated. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. The user does not have permission to access this resource. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> An unexpected error occurred on the server. </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getCustomAccessTokenAsync(
            GetCustomAccessTokenRequest getCustomAccessTokenRequest,
            final ApiCallback<AccessToken> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                getCustomAccessTokenValidateBeforeCall(getCustomAccessTokenRequest, _callback);
        Type localVarReturnType = new TypeToken<AccessToken>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getFullAccessToken
     *
     * @param getFullAccessTokenRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Bearer auth token creation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getFullAccessTokenCall(
            GetFullAccessTokenRequest getFullAccessTokenRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getFullAccessTokenRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/auth/token/full";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getFullAccessTokenValidateBeforeCall(
            GetFullAccessTokenRequest getFullAccessTokenRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'getFullAccessTokenRequest' is set
        if (getFullAccessTokenRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'getFullAccessTokenRequest' when calling"
                            + " getFullAccessToken(Async)");
        }

        return getFullAccessTokenCall(getFullAccessTokenRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Gets an authentication token and creates a full session in
     * ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid
     * for 5 mins. You can generate the token for a user by providing a &#x60;username&#x60; and
     * &#x60;password&#x60;, or by using the cluster’s &#x60;secret_key&#x60; (for [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable)).
     * To generate a &#x60;secret_key&#x60; on your cluster, the administrator must enable **Trusted
     * authentication** in the **Develop** &gt; **Customizations** &gt; **Security Settings** page.
     * For more information, see [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable).
     * **Note**: When both &#x60;password&#x60; and &#x60;secret_key&#x60; are included in the API
     * request, &#x60;password&#x60; takes precedence. If Multi-Factor Authentication (MFA) is
     * enabled on your instance, the API login request with basic authentication
     * (&#x60;username&#x60; and &#x60;password&#x60; ) returns an error. You can switch to
     * token-based authentication with &#x60;secret_key&#x60; or contact ThoughtSpot Support for
     * assistance. #### Just-in-time provisioning For just-in-time user creation and provisioning,
     * define the following attributes: * &#x60;auto_create&#x60; * &#x60;username&#x60; *
     * &#x60;display_name&#x60; * &#x60;email&#x60; * &#x60;group_identifiers&#x60; Set
     * &#x60;auto_create&#x60; to &#x60;True&#x60; if the user is not available in ThoughtSpot. If
     * the user already exists in ThoughtSpot and the &#x60;auto_create&#x60; parameter is set to
     * &#x60;true&#x60;, the API call will update user properties like display name, email and group
     * assignment. For more information, see [Just-in-time
     * provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning). To add a
     * new user and assign privileges, you need &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * is required. #### Important point to note All options in the token creation APIs changing the
     * content in ThoughtSpot will do so during the token creation and not when the token is being
     * used for authentication. For example, &#x60;auto_create:true&#x60; will create the user when
     * the authentication token is created.
     *
     * @param getFullAccessTokenRequest (required)
     * @return Token
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Bearer auth token creation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public Token getFullAccessToken(GetFullAccessTokenRequest getFullAccessTokenRequest)
            throws ApiException {
        ApiResponse<Token> localVarResp = getFullAccessTokenWithHttpInfo(getFullAccessTokenRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Gets an authentication token and creates a full session in
     * ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid
     * for 5 mins. You can generate the token for a user by providing a &#x60;username&#x60; and
     * &#x60;password&#x60;, or by using the cluster’s &#x60;secret_key&#x60; (for [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable)).
     * To generate a &#x60;secret_key&#x60; on your cluster, the administrator must enable **Trusted
     * authentication** in the **Develop** &gt; **Customizations** &gt; **Security Settings** page.
     * For more information, see [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable).
     * **Note**: When both &#x60;password&#x60; and &#x60;secret_key&#x60; are included in the API
     * request, &#x60;password&#x60; takes precedence. If Multi-Factor Authentication (MFA) is
     * enabled on your instance, the API login request with basic authentication
     * (&#x60;username&#x60; and &#x60;password&#x60; ) returns an error. You can switch to
     * token-based authentication with &#x60;secret_key&#x60; or contact ThoughtSpot Support for
     * assistance. #### Just-in-time provisioning For just-in-time user creation and provisioning,
     * define the following attributes: * &#x60;auto_create&#x60; * &#x60;username&#x60; *
     * &#x60;display_name&#x60; * &#x60;email&#x60; * &#x60;group_identifiers&#x60; Set
     * &#x60;auto_create&#x60; to &#x60;True&#x60; if the user is not available in ThoughtSpot. If
     * the user already exists in ThoughtSpot and the &#x60;auto_create&#x60; parameter is set to
     * &#x60;true&#x60;, the API call will update user properties like display name, email and group
     * assignment. For more information, see [Just-in-time
     * provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning). To add a
     * new user and assign privileges, you need &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * is required. #### Important point to note All options in the token creation APIs changing the
     * content in ThoughtSpot will do so during the token creation and not when the token is being
     * used for authentication. For example, &#x60;auto_create:true&#x60; will create the user when
     * the authentication token is created.
     *
     * @param getFullAccessTokenRequest (required)
     * @return ApiResponse&lt;Token&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Bearer auth token creation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Token> getFullAccessTokenWithHttpInfo(
            GetFullAccessTokenRequest getFullAccessTokenRequest) throws ApiException {
        okhttp3.Call localVarCall =
                getFullAccessTokenValidateBeforeCall(getFullAccessTokenRequest, null);
        Type localVarReturnType = new TypeToken<Token>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Gets an authentication token and creates a full
     * session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot
     * remains valid for 5 mins. You can generate the token for a user by providing a
     * &#x60;username&#x60; and &#x60;password&#x60;, or by using the cluster’s
     * &#x60;secret_key&#x60; (for [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable)).
     * To generate a &#x60;secret_key&#x60; on your cluster, the administrator must enable **Trusted
     * authentication** in the **Develop** &gt; **Customizations** &gt; **Security Settings** page.
     * For more information, see [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable).
     * **Note**: When both &#x60;password&#x60; and &#x60;secret_key&#x60; are included in the API
     * request, &#x60;password&#x60; takes precedence. If Multi-Factor Authentication (MFA) is
     * enabled on your instance, the API login request with basic authentication
     * (&#x60;username&#x60; and &#x60;password&#x60; ) returns an error. You can switch to
     * token-based authentication with &#x60;secret_key&#x60; or contact ThoughtSpot Support for
     * assistance. #### Just-in-time provisioning For just-in-time user creation and provisioning,
     * define the following attributes: * &#x60;auto_create&#x60; * &#x60;username&#x60; *
     * &#x60;display_name&#x60; * &#x60;email&#x60; * &#x60;group_identifiers&#x60; Set
     * &#x60;auto_create&#x60; to &#x60;True&#x60; if the user is not available in ThoughtSpot. If
     * the user already exists in ThoughtSpot and the &#x60;auto_create&#x60; parameter is set to
     * &#x60;true&#x60;, the API call will update user properties like display name, email and group
     * assignment. For more information, see [Just-in-time
     * provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning). To add a
     * new user and assign privileges, you need &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * is required. #### Important point to note All options in the token creation APIs changing the
     * content in ThoughtSpot will do so during the token creation and not when the token is being
     * used for authentication. For example, &#x60;auto_create:true&#x60; will create the user when
     * the authentication token is created.
     *
     * @param getFullAccessTokenRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Bearer auth token creation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getFullAccessTokenAsync(
            GetFullAccessTokenRequest getFullAccessTokenRequest, final ApiCallback<Token> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                getFullAccessTokenValidateBeforeCall(getFullAccessTokenRequest, _callback);
        Type localVarReturnType = new TypeToken<Token>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getObjectAccessToken
     *
     * @param getObjectAccessTokenRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Bearer auth token creation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getObjectAccessTokenCall(
            GetObjectAccessTokenRequest getObjectAccessTokenRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = getObjectAccessTokenRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/auth/token/object";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getObjectAccessTokenValidateBeforeCall(
            GetObjectAccessTokenRequest getObjectAccessTokenRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'getObjectAccessTokenRequest' is set
        if (getObjectAccessTokenRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'getObjectAccessTokenRequest' when calling"
                            + " getObjectAccessToken(Async)");
        }

        return getObjectAccessTokenCall(getObjectAccessTokenRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Gets an authentication token that provides access to a specific
     * metadata object. By default, the token obtained from ThoughtSpot remains valid for 5 mins.
     * You can generate the token for a user by providing a &#x60;username&#x60; and
     * &#x60;password&#x60;, or by using the cluster’s &#x60;secret key&#x60; (for [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable)).
     * To generate a &#x60;secret_key&#x60; on your cluster, the administrator must enable **Trusted
     * authentication** in the **Develop** &gt; **Customizations** &gt; **Security Settings** page.
     * **Note**: When both &#x60;password&#x60; and &#x60;secret_key&#x60; are included in the API
     * request, &#x60;password&#x60; takes precedence. If Multi-Factor Authentication (MFA) is
     * enabled on your instance, the API login request with basic authentication
     * (&#x60;username&#x60; and &#x60;password&#x60; ) returns an error. You can switch to
     * token-based authentication with &#x60;secret_key&#x60; or contact ThoughtSpot Support for
     * assistance. #### Just-in-time provisioning For just-in-time user creation and provisioning,
     * define the following attributes: * &#x60;auto_create&#x60; * &#x60;username&#x60; *
     * &#x60;display_name&#x60; * &#x60;email&#x60; * &#x60;group_identifiers&#x60; Set
     * &#x60;auto_create&#x60; to &#x60;True&#x60; if the user is not available in ThoughtSpot. If
     * the user already exists in ThoughtSpot and the &#x60;auto_create&#x60; parameter is set to
     * &#x60;true&#x60;, the API call will update user properties like display name, email and group
     * assignment. For more information, see [Just-in-time
     * provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning). To add a
     * new user and assign privileges, you need &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * is required. #### Important point to note All options in the token creation APIs changing the
     * content in ThoughtSpot will do so during the token creation and not when the token is being
     * used for authentication. For example, &#x60;auto_create:true&#x60; will create the user when
     * the authentication token is created.
     *
     * @param getObjectAccessTokenRequest (required)
     * @return Token
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Bearer auth token creation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public Token getObjectAccessToken(GetObjectAccessTokenRequest getObjectAccessTokenRequest)
            throws ApiException {
        ApiResponse<Token> localVarResp =
                getObjectAccessTokenWithHttpInfo(getObjectAccessTokenRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Gets an authentication token that provides access to a specific
     * metadata object. By default, the token obtained from ThoughtSpot remains valid for 5 mins.
     * You can generate the token for a user by providing a &#x60;username&#x60; and
     * &#x60;password&#x60;, or by using the cluster’s &#x60;secret key&#x60; (for [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable)).
     * To generate a &#x60;secret_key&#x60; on your cluster, the administrator must enable **Trusted
     * authentication** in the **Develop** &gt; **Customizations** &gt; **Security Settings** page.
     * **Note**: When both &#x60;password&#x60; and &#x60;secret_key&#x60; are included in the API
     * request, &#x60;password&#x60; takes precedence. If Multi-Factor Authentication (MFA) is
     * enabled on your instance, the API login request with basic authentication
     * (&#x60;username&#x60; and &#x60;password&#x60; ) returns an error. You can switch to
     * token-based authentication with &#x60;secret_key&#x60; or contact ThoughtSpot Support for
     * assistance. #### Just-in-time provisioning For just-in-time user creation and provisioning,
     * define the following attributes: * &#x60;auto_create&#x60; * &#x60;username&#x60; *
     * &#x60;display_name&#x60; * &#x60;email&#x60; * &#x60;group_identifiers&#x60; Set
     * &#x60;auto_create&#x60; to &#x60;True&#x60; if the user is not available in ThoughtSpot. If
     * the user already exists in ThoughtSpot and the &#x60;auto_create&#x60; parameter is set to
     * &#x60;true&#x60;, the API call will update user properties like display name, email and group
     * assignment. For more information, see [Just-in-time
     * provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning). To add a
     * new user and assign privileges, you need &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * is required. #### Important point to note All options in the token creation APIs changing the
     * content in ThoughtSpot will do so during the token creation and not when the token is being
     * used for authentication. For example, &#x60;auto_create:true&#x60; will create the user when
     * the authentication token is created.
     *
     * @param getObjectAccessTokenRequest (required)
     * @return ApiResponse&lt;Token&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Bearer auth token creation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Token> getObjectAccessTokenWithHttpInfo(
            GetObjectAccessTokenRequest getObjectAccessTokenRequest) throws ApiException {
        okhttp3.Call localVarCall =
                getObjectAccessTokenValidateBeforeCall(getObjectAccessTokenRequest, null);
        Type localVarReturnType = new TypeToken<Token>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Gets an authentication token that provides access
     * to a specific metadata object. By default, the token obtained from ThoughtSpot remains valid
     * for 5 mins. You can generate the token for a user by providing a &#x60;username&#x60; and
     * &#x60;password&#x60;, or by using the cluster’s &#x60;secret key&#x60; (for [Trusted
     * authentication](https://developers.thoughtspot.com/docs/?pageid&#x3D;trusted-auth#trusted-auth-enable)).
     * To generate a &#x60;secret_key&#x60; on your cluster, the administrator must enable **Trusted
     * authentication** in the **Develop** &gt; **Customizations** &gt; **Security Settings** page.
     * **Note**: When both &#x60;password&#x60; and &#x60;secret_key&#x60; are included in the API
     * request, &#x60;password&#x60; takes precedence. If Multi-Factor Authentication (MFA) is
     * enabled on your instance, the API login request with basic authentication
     * (&#x60;username&#x60; and &#x60;password&#x60; ) returns an error. You can switch to
     * token-based authentication with &#x60;secret_key&#x60; or contact ThoughtSpot Support for
     * assistance. #### Just-in-time provisioning For just-in-time user creation and provisioning,
     * define the following attributes: * &#x60;auto_create&#x60; * &#x60;username&#x60; *
     * &#x60;display_name&#x60; * &#x60;email&#x60; * &#x60;group_identifiers&#x60; Set
     * &#x60;auto_create&#x60; to &#x60;True&#x60; if the user is not available in ThoughtSpot. If
     * the user already exists in ThoughtSpot and the &#x60;auto_create&#x60; parameter is set to
     * &#x60;true&#x60;, the API call will update user properties like display name, email and group
     * assignment. For more information, see [Just-in-time
     * provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning). To add a
     * new user and assign privileges, you need &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the
     * &#x60;CONTROL_TRUSTED_AUTH&#x60;(**Can Enable or Disable Trusted Authentication**) privilege
     * is required. #### Important point to note All options in the token creation APIs changing the
     * content in ThoughtSpot will do so during the token creation and not when the token is being
     * used for authentication. For example, &#x60;auto_create:true&#x60; will create the user when
     * the authentication token is created.
     *
     * @param getObjectAccessTokenRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Bearer auth token creation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getObjectAccessTokenAsync(
            GetObjectAccessTokenRequest getObjectAccessTokenRequest,
            final ApiCallback<Token> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                getObjectAccessTokenValidateBeforeCall(getObjectAccessTokenRequest, _callback);
        Type localVarReturnType = new TypeToken<Token>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSystemConfig
     *
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster config information. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getSystemConfigCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/system/config";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSystemConfigValidateBeforeCall(final ApiCallback _callback)
            throws ApiException {
        return getSystemConfigCall(_callback);
    }

    /**
     * Version: 9.0.0.cl or later Retrieves the current configuration details of the cluster. If the
     * request is successful, the API returns a list configuration settings applied on the cluster.
     * Requires &#x60;ADMINISTRATION&#x60;(**Can administer ThoughtSpot**) privilege to view these
     * complete configuration settings of the cluster. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;SYSTEM_INFO_ADMINISTRATION&#x60; (**Can view system activities**) privilege is
     * required. This API does not require any parameters to be passed in the request.
     *
     * @return SystemConfig
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster config information. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public SystemConfig getSystemConfig() throws ApiException {
        ApiResponse<SystemConfig> localVarResp = getSystemConfigWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Retrieves the current configuration details of the cluster. If the
     * request is successful, the API returns a list configuration settings applied on the cluster.
     * Requires &#x60;ADMINISTRATION&#x60;(**Can administer ThoughtSpot**) privilege to view these
     * complete configuration settings of the cluster. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;SYSTEM_INFO_ADMINISTRATION&#x60; (**Can view system activities**) privilege is
     * required. This API does not require any parameters to be passed in the request.
     *
     * @return ApiResponse&lt;SystemConfig&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster config information. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<SystemConfig> getSystemConfigWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getSystemConfigValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<SystemConfig>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Retrieves the current configuration details of
     * the cluster. If the request is successful, the API returns a list configuration settings
     * applied on the cluster. Requires &#x60;ADMINISTRATION&#x60;(**Can administer ThoughtSpot**)
     * privilege to view these complete configuration settings of the cluster. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;SYSTEM_INFO_ADMINISTRATION&#x60; (**Can view system activities**) privilege is
     * required. This API does not require any parameters to be passed in the request.
     *
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster config information. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getSystemConfigAsync(final ApiCallback<SystemConfig> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = getSystemConfigValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<SystemConfig>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSystemInformation
     *
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster information. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getSystemInformationCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/system";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSystemInformationValidateBeforeCall(final ApiCallback _callback)
            throws ApiException {
        return getSystemInformationCall(_callback);
    }

    /**
     * Version: 9.0.0.cl or later Gets system information such as the release version, locale, time
     * zone, deployment environment, date format, and date time format of the cluster. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privileges. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;SYSTEM_INFO_ADMINISTRATION&#x60; (**Can view system activities**) privilege is
     * required. This API does not require any parameters to be passed in the request.
     *
     * @return SystemInfo
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster information. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public SystemInfo getSystemInformation() throws ApiException {
        ApiResponse<SystemInfo> localVarResp = getSystemInformationWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Gets system information such as the release version, locale, time
     * zone, deployment environment, date format, and date time format of the cluster. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privileges. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;SYSTEM_INFO_ADMINISTRATION&#x60; (**Can view system activities**) privilege is
     * required. This API does not require any parameters to be passed in the request.
     *
     * @return ApiResponse&lt;SystemInfo&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster information. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<SystemInfo> getSystemInformationWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getSystemInformationValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<SystemInfo>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Gets system information such as the release
     * version, locale, time zone, deployment environment, date format, and date time format of the
     * cluster. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privileges. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;SYSTEM_INFO_ADMINISTRATION&#x60; (**Can view system activities**)
     * privilege is required. This API does not require any parameters to be passed in the request.
     *
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster information. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getSystemInformationAsync(final ApiCallback<SystemInfo> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = getSystemInformationValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<SystemInfo>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for getSystemOverrideInfo
     *
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster configuration which can be overridden. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getSystemOverrideInfoCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/system/config-overrides";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "GET",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call getSystemOverrideInfoValidateBeforeCall(final ApiCallback _callback)
            throws ApiException {
        return getSystemOverrideInfoCall(_callback);
    }

    /**
     * Version: 9.2.0.cl or later Gets a list of configuration overrides applied on the cluster.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;APPLICATION_ADMINISTRATION&#x60; (**Can manage application
     * settings**) privilege is required. This API does not require any parameters to be passed in
     * the request.
     *
     * @return SystemOverrideInfo
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster configuration which can be overridden. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public SystemOverrideInfo getSystemOverrideInfo() throws ApiException {
        ApiResponse<SystemOverrideInfo> localVarResp = getSystemOverrideInfoWithHttpInfo();
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Gets a list of configuration overrides applied on the cluster.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;APPLICATION_ADMINISTRATION&#x60; (**Can manage application
     * settings**) privilege is required. This API does not require any parameters to be passed in
     * the request.
     *
     * @return ApiResponse&lt;SystemOverrideInfo&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster configuration which can be overridden. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<SystemOverrideInfo> getSystemOverrideInfoWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = getSystemOverrideInfoValidateBeforeCall(null);
        Type localVarReturnType = new TypeToken<SystemOverrideInfo>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Gets a list of configuration overrides applied on
     * the cluster. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege.
     * If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance, the &#x60;APPLICATION_ADMINISTRATION&#x60; (**Can manage
     * application settings**) privilege is required. This API does not require any parameters to be
     * passed in the request.
     *
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Cluster configuration which can be overridden. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call getSystemOverrideInfoAsync(final ApiCallback<SystemOverrideInfo> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = getSystemOverrideInfoValidateBeforeCall(_callback);
        Type localVarReturnType = new TypeToken<SystemOverrideInfo>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for importMetadataTML
     *
     * @param importMetadataTMLRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import metadata objects using specified TMLs is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call importMetadataTMLCall(
            ImportMetadataTMLRequest importMetadataTMLRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importMetadataTMLRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/tml/import";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call importMetadataTMLValidateBeforeCall(
            ImportMetadataTMLRequest importMetadataTMLRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'importMetadataTMLRequest' is set
        if (importMetadataTMLRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'importMetadataTMLRequest' when calling"
                            + " importMetadataTML(Async)");
        }

        return importMetadataTMLCall(importMetadataTMLRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Imports [TML](https://docs.thoughtspot.com/cloud/latest/tml) files
     * into ThoughtSpot. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtsSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the following Data control privileges may be required: -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### Usage
     * guidelines * Import all related objects in a single TML Import API call. For example, Tables
     * that use the same Connection object and Worksheets connected to these Tables. * Include the
     * &#x60;fqn&#x60; property to distinguish objects that have the same name. For example, if you
     * have multiple Connections or Worksheets with the same name on ThoughtSpot and the Connection
     * or Worksheet referenced in your TML file does not have a unique name to distinguish, it may
     * result in invalid object references. Adding &#x60;fqn&#x60; helps ThoughtSpot differentiate a
     * Table from another with the same name. We recommend [exporting TML with
     * FQNs](#/http/api-endpoints/metadata/export-metadata-tml) and using these during the import
     * operation. * You can upload multiple TML files at a time. If you import a Worksheet along
     * with Liveboards, Answers, and other dependent objects in a single API call, the imported
     * objects will be immediately available for use. When you import only a Worksheet object, it
     * may take some time for the Worksheet to become available in the ThoughtSpot system. Please
     * wait for a few minutes, and then proceed to create an Answer and Liveboard from the newly
     * imported Worksheet. For more information, see [TML
     * Documentation](https://developers.thoughtspot.com/docs/tml#_import_a_tml).
     *
     * @param importMetadataTMLRequest (required)
     * @return List&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import metadata objects using specified TMLs is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<Object> importMetadataTML(ImportMetadataTMLRequest importMetadataTMLRequest)
            throws ApiException {
        ApiResponse<List<Object>> localVarResp =
                importMetadataTMLWithHttpInfo(importMetadataTMLRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Imports [TML](https://docs.thoughtspot.com/cloud/latest/tml) files
     * into ThoughtSpot. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtsSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the following Data control privileges may be required: -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### Usage
     * guidelines * Import all related objects in a single TML Import API call. For example, Tables
     * that use the same Connection object and Worksheets connected to these Tables. * Include the
     * &#x60;fqn&#x60; property to distinguish objects that have the same name. For example, if you
     * have multiple Connections or Worksheets with the same name on ThoughtSpot and the Connection
     * or Worksheet referenced in your TML file does not have a unique name to distinguish, it may
     * result in invalid object references. Adding &#x60;fqn&#x60; helps ThoughtSpot differentiate a
     * Table from another with the same name. We recommend [exporting TML with
     * FQNs](#/http/api-endpoints/metadata/export-metadata-tml) and using these during the import
     * operation. * You can upload multiple TML files at a time. If you import a Worksheet along
     * with Liveboards, Answers, and other dependent objects in a single API call, the imported
     * objects will be immediately available for use. When you import only a Worksheet object, it
     * may take some time for the Worksheet to become available in the ThoughtSpot system. Please
     * wait for a few minutes, and then proceed to create an Answer and Liveboard from the newly
     * imported Worksheet. For more information, see [TML
     * Documentation](https://developers.thoughtspot.com/docs/tml#_import_a_tml).
     *
     * @param importMetadataTMLRequest (required)
     * @return ApiResponse&lt;List&lt;Object&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import metadata objects using specified TMLs is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<Object>> importMetadataTMLWithHttpInfo(
            ImportMetadataTMLRequest importMetadataTMLRequest) throws ApiException {
        okhttp3.Call localVarCall =
                importMetadataTMLValidateBeforeCall(importMetadataTMLRequest, null);
        Type localVarReturnType = new TypeToken<List<Object>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Imports
     * [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtsSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following Data control privileges may be required: -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### Usage
     * guidelines * Import all related objects in a single TML Import API call. For example, Tables
     * that use the same Connection object and Worksheets connected to these Tables. * Include the
     * &#x60;fqn&#x60; property to distinguish objects that have the same name. For example, if you
     * have multiple Connections or Worksheets with the same name on ThoughtSpot and the Connection
     * or Worksheet referenced in your TML file does not have a unique name to distinguish, it may
     * result in invalid object references. Adding &#x60;fqn&#x60; helps ThoughtSpot differentiate a
     * Table from another with the same name. We recommend [exporting TML with
     * FQNs](#/http/api-endpoints/metadata/export-metadata-tml) and using these during the import
     * operation. * You can upload multiple TML files at a time. If you import a Worksheet along
     * with Liveboards, Answers, and other dependent objects in a single API call, the imported
     * objects will be immediately available for use. When you import only a Worksheet object, it
     * may take some time for the Worksheet to become available in the ThoughtSpot system. Please
     * wait for a few minutes, and then proceed to create an Answer and Liveboard from the newly
     * imported Worksheet. For more information, see [TML
     * Documentation](https://developers.thoughtspot.com/docs/tml#_import_a_tml).
     *
     * @param importMetadataTMLRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import metadata objects using specified TMLs is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call importMetadataTMLAsync(
            ImportMetadataTMLRequest importMetadataTMLRequest,
            final ApiCallback<List<Object>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                importMetadataTMLValidateBeforeCall(importMetadataTMLRequest, _callback);
        Type localVarReturnType = new TypeToken<List<Object>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for importMetadataTMLAsync
     *
     * @param importMetadataTMLAsyncRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Async TML Import Task submitted successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call importMetadataTMLAsyncCall(
            ImportMetadataTMLAsyncRequest importMetadataTMLAsyncRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importMetadataTMLAsyncRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/tml/async/import";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call importMetadataTMLAsyncValidateBeforeCall(
            ImportMetadataTMLAsyncRequest importMetadataTMLAsyncRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'importMetadataTMLAsyncRequest' is set
        if (importMetadataTMLAsyncRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'importMetadataTMLAsyncRequest' when calling"
                            + " importMetadataTMLAsync(Async)");
        }

        return importMetadataTMLAsyncCall(importMetadataTMLAsyncRequest, _callback);
    }

    /**
     * Version: 10.4.0.cl or later Schedules a task to import
     * [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot. You can use this
     * API endpoint to process TML objects asynchronously when importing TMLs of large and complex
     * metadata objects into ThoughtSpot. Unlike the synchronous import TML operation, the API
     * processes TML data in the background and returns a task ID, which can be used to check the
     * status of the import task via &#x60;/api/rest/2.0/metadata/tml/async/status&#x60; API
     * endpoint. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtsSpot**) privilege, and edit access to
     * the TML objects. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following Data control privileges may be required: -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### Usage
     * guidelines See [Async TML API
     * Documentation](https://developers.thoughtspot.com/docs/tml#_import_tml_objects_asynchronously)
     * for usage guidelines.
     *
     * @param importMetadataTMLAsyncRequest (required)
     * @return ImportEPackAsyncTaskStatus
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Async TML Import Task submitted successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ImportEPackAsyncTaskStatus importMetadataTMLAsync(
            ImportMetadataTMLAsyncRequest importMetadataTMLAsyncRequest) throws ApiException {
        ApiResponse<ImportEPackAsyncTaskStatus> localVarResp =
                importMetadataTMLAsyncWithHttpInfo(importMetadataTMLAsyncRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.4.0.cl or later Schedules a task to import
     * [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot. You can use this
     * API endpoint to process TML objects asynchronously when importing TMLs of large and complex
     * metadata objects into ThoughtSpot. Unlike the synchronous import TML operation, the API
     * processes TML data in the background and returns a task ID, which can be used to check the
     * status of the import task via &#x60;/api/rest/2.0/metadata/tml/async/status&#x60; API
     * endpoint. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtsSpot**) privilege, and edit access to
     * the TML objects. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following Data control privileges may be required: -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### Usage
     * guidelines See [Async TML API
     * Documentation](https://developers.thoughtspot.com/docs/tml#_import_tml_objects_asynchronously)
     * for usage guidelines.
     *
     * @param importMetadataTMLAsyncRequest (required)
     * @return ApiResponse&lt;ImportEPackAsyncTaskStatus&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Async TML Import Task submitted successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ImportEPackAsyncTaskStatus> importMetadataTMLAsyncWithHttpInfo(
            ImportMetadataTMLAsyncRequest importMetadataTMLAsyncRequest) throws ApiException {
        okhttp3.Call localVarCall =
                importMetadataTMLAsyncValidateBeforeCall(importMetadataTMLAsyncRequest, null);
        Type localVarReturnType = new TypeToken<ImportEPackAsyncTaskStatus>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.4.0.cl or later Schedules a task to import
     * [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot. You can use this
     * API endpoint to process TML objects asynchronously when importing TMLs of large and complex
     * metadata objects into ThoughtSpot. Unlike the synchronous import TML operation, the API
     * processes TML data in the background and returns a task ID, which can be used to check the
     * status of the import task via &#x60;/api/rest/2.0/metadata/tml/async/status&#x60; API
     * endpoint. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtsSpot**) privilege, and edit access to
     * the TML objects. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following Data control privileges may be required: -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### Usage
     * guidelines See [Async TML API
     * Documentation](https://developers.thoughtspot.com/docs/tml#_import_tml_objects_asynchronously)
     * for usage guidelines.
     *
     * @param importMetadataTMLAsyncRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Async TML Import Task submitted successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call importMetadataTMLAsyncAsync(
            ImportMetadataTMLAsyncRequest importMetadataTMLAsyncRequest,
            final ApiCallback<ImportEPackAsyncTaskStatus> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                importMetadataTMLAsyncValidateBeforeCall(importMetadataTMLAsyncRequest, _callback);
        Type localVarReturnType = new TypeToken<ImportEPackAsyncTaskStatus>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for importUserGroups
     *
     * @param importUserGroupsRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import user groups operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call importUserGroupsCall(
            ImportUserGroupsRequest importUserGroupsRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importUserGroupsRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/groups/import";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call importUserGroupsValidateBeforeCall(
            ImportUserGroupsRequest importUserGroupsRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'importUserGroupsRequest' is set
        if (importUserGroupsRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'importUserGroupsRequest' when calling"
                            + " importUserGroups(Async)");
        }

        return importUserGroupsCall(importUserGroupsRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Imports group objects from external databases into ThoughtSpot.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is
     * required. During the import operation: * If the specified group is not available in
     * ThoughtSpot, it will be added to ThoughtSpot. * If &#x60;delete_unspecified_groups&#x60; is
     * set to &#x60;true&#x60;, the groups not specified in the API request, excluding administrator
     * and system user groups, are deleted. * If the specified groups are already available in
     * ThoughtSpot, the object properties of these groups are modified and synchronized as per the
     * input data in the API request. A successful API call returns the object that represents the
     * changes made in the ThoughtSpot system.
     *
     * @param importUserGroupsRequest (required)
     * @return ImportUserGroupsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import user groups operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ImportUserGroupsResponse importUserGroups(
            ImportUserGroupsRequest importUserGroupsRequest) throws ApiException {
        ApiResponse<ImportUserGroupsResponse> localVarResp =
                importUserGroupsWithHttpInfo(importUserGroupsRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Imports group objects from external databases into ThoughtSpot.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is
     * required. During the import operation: * If the specified group is not available in
     * ThoughtSpot, it will be added to ThoughtSpot. * If &#x60;delete_unspecified_groups&#x60; is
     * set to &#x60;true&#x60;, the groups not specified in the API request, excluding administrator
     * and system user groups, are deleted. * If the specified groups are already available in
     * ThoughtSpot, the object properties of these groups are modified and synchronized as per the
     * input data in the API request. A successful API call returns the object that represents the
     * changes made in the ThoughtSpot system.
     *
     * @param importUserGroupsRequest (required)
     * @return ApiResponse&lt;ImportUserGroupsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import user groups operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ImportUserGroupsResponse> importUserGroupsWithHttpInfo(
            ImportUserGroupsRequest importUserGroupsRequest) throws ApiException {
        okhttp3.Call localVarCall =
                importUserGroupsValidateBeforeCall(importUserGroupsRequest, null);
        Type localVarReturnType = new TypeToken<ImportUserGroupsResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Imports group objects from external databases
     * into ThoughtSpot. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is required. During the
     * import operation: * If the specified group is not available in ThoughtSpot, it will be added
     * to ThoughtSpot. * If &#x60;delete_unspecified_groups&#x60; is set to &#x60;true&#x60;, the
     * groups not specified in the API request, excluding administrator and system user groups, are
     * deleted. * If the specified groups are already available in ThoughtSpot, the object
     * properties of these groups are modified and synchronized as per the input data in the API
     * request. A successful API call returns the object that represents the changes made in the
     * ThoughtSpot system.
     *
     * @param importUserGroupsRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import user groups operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call importUserGroupsAsync(
            ImportUserGroupsRequest importUserGroupsRequest,
            final ApiCallback<ImportUserGroupsResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                importUserGroupsValidateBeforeCall(importUserGroupsRequest, _callback);
        Type localVarReturnType = new TypeToken<ImportUserGroupsResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for importUsers
     *
     * @param importUsersRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import users operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call importUsersCall(
            ImportUsersRequest importUsersRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = importUsersRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/users/import";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call importUsersValidateBeforeCall(
            ImportUsersRequest importUsersRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'importUsersRequest' is set
        if (importUsersRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'importUsersRequest' when calling"
                            + " importUsers(Async)");
        }

        return importUsersCall(importUsersRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Imports user data from external databases into ThoughtSpot. During
     * the user import operation: * If the specified users are not available in ThoughtSpot, the
     * users are created and assigned a default password. Defining a &#x60;default_password&#x60; in
     * the API request is optional. * If &#x60;delete_unspecified_users&#x60; is set to
     * &#x60;true&#x60;, the users not specified in the API request, excluding the
     * &#x60;tsadmin&#x60;, &#x60;guest&#x60;, &#x60;system&#x60; and &#x60;su&#x60; users, are
     * deleted. * If the specified user objects are already available in ThoughtSpot, the object
     * properties are updated and synchronized as per the input data in the API request. A
     * successful API call returns the object that represents the changes made in the ThoughtSpot
     * system. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is
     * required.
     *
     * @param importUsersRequest (required)
     * @return ImportUsersResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import users operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ImportUsersResponse importUsers(ImportUsersRequest importUsersRequest)
            throws ApiException {
        ApiResponse<ImportUsersResponse> localVarResp = importUsersWithHttpInfo(importUsersRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Imports user data from external databases into ThoughtSpot. During
     * the user import operation: * If the specified users are not available in ThoughtSpot, the
     * users are created and assigned a default password. Defining a &#x60;default_password&#x60; in
     * the API request is optional. * If &#x60;delete_unspecified_users&#x60; is set to
     * &#x60;true&#x60;, the users not specified in the API request, excluding the
     * &#x60;tsadmin&#x60;, &#x60;guest&#x60;, &#x60;system&#x60; and &#x60;su&#x60; users, are
     * deleted. * If the specified user objects are already available in ThoughtSpot, the object
     * properties are updated and synchronized as per the input data in the API request. A
     * successful API call returns the object that represents the changes made in the ThoughtSpot
     * system. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is
     * required.
     *
     * @param importUsersRequest (required)
     * @return ApiResponse&lt;ImportUsersResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import users operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ImportUsersResponse> importUsersWithHttpInfo(
            ImportUsersRequest importUsersRequest) throws ApiException {
        okhttp3.Call localVarCall = importUsersValidateBeforeCall(importUsersRequest, null);
        Type localVarReturnType = new TypeToken<ImportUsersResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Imports user data from external databases into
     * ThoughtSpot. During the user import operation: * If the specified users are not available in
     * ThoughtSpot, the users are created and assigned a default password. Defining a
     * &#x60;default_password&#x60; in the API request is optional. * If
     * &#x60;delete_unspecified_users&#x60; is set to &#x60;true&#x60;, the users not specified in
     * the API request, excluding the &#x60;tsadmin&#x60;, &#x60;guest&#x60;, &#x60;system&#x60; and
     * &#x60;su&#x60; users, are deleted. * If the specified user objects are already available in
     * ThoughtSpot, the object properties are updated and synchronized as per the input data in the
     * API request. A successful API call returns the object that represents the changes made in the
     * ThoughtSpot system. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param importUsersRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Import users operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call importUsersAsync(
            ImportUsersRequest importUsersRequest, final ApiCallback<ImportUsersResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = importUsersValidateBeforeCall(importUsersRequest, _callback);
        Type localVarReturnType = new TypeToken<ImportUsersResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for login
     *
     * @param loginRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User login successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call loginCall(LoginRequest loginRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = loginRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/auth/session/login";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call loginValidateBeforeCall(
            LoginRequest loginRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'loginRequest' is set
        if (loginRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'loginRequest' when calling login(Async)");
        }

        return loginCall(loginRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Creates a login session for a ThoughtSpot user with Basic
     * authentication. In Basic authentication method, REST clients log in to ThoughtSpot using
     * &#x60;username&#x60; and &#x60;password&#x60; attributes. On a multi-tenant cluster with
     * Orgs, users can pass the ID of the Org in the API request to log in to a specific Org
     * context. **Note**: If Multi-Factor Authentication (MFA) is enabled on your instance, the API
     * login request with basic authentication (&#x60;username&#x60; and &#x60;password&#x60; )
     * returns an error. Contact ThoughtSpot Support for assistance. A successful login returns a
     * session cookie that can be used in your subsequent API requests.
     *
     * @param loginRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User login successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void login(LoginRequest loginRequest) throws ApiException {
        loginWithHttpInfo(loginRequest);
    }

    /**
     * Version: 9.0.0.cl or later Creates a login session for a ThoughtSpot user with Basic
     * authentication. In Basic authentication method, REST clients log in to ThoughtSpot using
     * &#x60;username&#x60; and &#x60;password&#x60; attributes. On a multi-tenant cluster with
     * Orgs, users can pass the ID of the Org in the API request to log in to a specific Org
     * context. **Note**: If Multi-Factor Authentication (MFA) is enabled on your instance, the API
     * login request with basic authentication (&#x60;username&#x60; and &#x60;password&#x60; )
     * returns an error. Contact ThoughtSpot Support for assistance. A successful login returns a
     * session cookie that can be used in your subsequent API requests.
     *
     * @param loginRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User login successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> loginWithHttpInfo(LoginRequest loginRequest) throws ApiException {
        okhttp3.Call localVarCall = loginValidateBeforeCall(loginRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Creates a login session for a ThoughtSpot user
     * with Basic authentication. In Basic authentication method, REST clients log in to ThoughtSpot
     * using &#x60;username&#x60; and &#x60;password&#x60; attributes. On a multi-tenant cluster
     * with Orgs, users can pass the ID of the Org in the API request to log in to a specific Org
     * context. **Note**: If Multi-Factor Authentication (MFA) is enabled on your instance, the API
     * login request with basic authentication (&#x60;username&#x60; and &#x60;password&#x60; )
     * returns an error. Contact ThoughtSpot Support for assistance. A successful login returns a
     * session cookie that can be used in your subsequent API requests.
     *
     * @param loginRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User login successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call loginAsync(LoginRequest loginRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = loginValidateBeforeCall(loginRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for logout
     *
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User logout successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call logoutCall(final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/auth/session/logout";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call logoutValidateBeforeCall(final ApiCallback _callback) throws ApiException {
        return logoutCall(_callback);
    }

    /**
     * Version: 9.0.0.cl or later Logs out a user from their current session.
     *
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User logout successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void logout() throws ApiException {
        logoutWithHttpInfo();
    }

    /**
     * Version: 9.0.0.cl or later Logs out a user from their current session.
     *
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User logout successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> logoutWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = logoutValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Logs out a user from their current session.
     *
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User logout successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call logoutAsync(final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = logoutValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for parameterizeMetadata
     *
     * @param parameterizeMetadataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Parameterize successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call parameterizeMetadataCall(
            ParameterizeMetadataRequest parameterizeMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = parameterizeMetadataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/parameterize";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call parameterizeMetadataValidateBeforeCall(
            ParameterizeMetadataRequest parameterizeMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'parameterizeMetadataRequest' is set
        if (parameterizeMetadataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'parameterizeMetadataRequest' when calling"
                            + " parameterizeMetadata(Async)");
        }

        return parameterizeMetadataCall(parameterizeMetadataRequest, _callback);
    }

    /**
     * Parameterize fields in metadata objects. Version: 10.9.0.cl or later Allows parameterizing
     * fields in metadata objects in ThoughtSpot. Requires appropriate permissions to modify the
     * metadata object. The API endpoint allows parameterizing the following types of metadata
     * objects: * Logical Tables * Connections For a Logical Table the field type must be
     * &#x60;ATTRIBUTE&#x60; and field name can be one of: * databaseName * schemaName * tableName
     * For a Connection the field type is always &#x60;CONNECTION_PROPERTY&#x60;. We use the
     * field_name in this case to specify the exact property of a connection which needs to be
     * parameterized.
     *
     * @param parameterizeMetadataRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Parameterize successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void parameterizeMetadata(ParameterizeMetadataRequest parameterizeMetadataRequest)
            throws ApiException {
        parameterizeMetadataWithHttpInfo(parameterizeMetadataRequest);
    }

    /**
     * Parameterize fields in metadata objects. Version: 10.9.0.cl or later Allows parameterizing
     * fields in metadata objects in ThoughtSpot. Requires appropriate permissions to modify the
     * metadata object. The API endpoint allows parameterizing the following types of metadata
     * objects: * Logical Tables * Connections For a Logical Table the field type must be
     * &#x60;ATTRIBUTE&#x60; and field name can be one of: * databaseName * schemaName * tableName
     * For a Connection the field type is always &#x60;CONNECTION_PROPERTY&#x60;. We use the
     * field_name in this case to specify the exact property of a connection which needs to be
     * parameterized.
     *
     * @param parameterizeMetadataRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Parameterize successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> parameterizeMetadataWithHttpInfo(
            ParameterizeMetadataRequest parameterizeMetadataRequest) throws ApiException {
        okhttp3.Call localVarCall =
                parameterizeMetadataValidateBeforeCall(parameterizeMetadataRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Parameterize fields in metadata objects. Version: 10.9.0.cl or later Allows
     * parameterizing fields in metadata objects in ThoughtSpot. Requires appropriate permissions to
     * modify the metadata object. The API endpoint allows parameterizing the following types of
     * metadata objects: * Logical Tables * Connections For a Logical Table the field type must be
     * &#x60;ATTRIBUTE&#x60; and field name can be one of: * databaseName * schemaName * tableName
     * For a Connection the field type is always &#x60;CONNECTION_PROPERTY&#x60;. We use the
     * field_name in this case to specify the exact property of a connection which needs to be
     * parameterized.
     *
     * @param parameterizeMetadataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Parameterize successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call parameterizeMetadataAsync(
            ParameterizeMetadataRequest parameterizeMetadataRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                parameterizeMetadataValidateBeforeCall(parameterizeMetadataRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for publishMetadata
     *
     * @param publishMetadataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Publishing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call publishMetadataCall(
            PublishMetadataRequest publishMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = publishMetadataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/security/metadata/publish";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call publishMetadataValidateBeforeCall(
            PublishMetadataRequest publishMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'publishMetadataRequest' is set
        if (publishMetadataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'publishMetadataRequest' when calling"
                            + " publishMetadata(Async)");
        }

        return publishMetadataCall(publishMetadataRequest, _callback);
    }

    /**
     * Version: 10.9.0.cl or later Allows publishing metadata objects across organizations in
     * ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The API endpoint allows
     * publishing the following types of metadata objects: * Liveboards * Answers * Logical Tables
     * This API will essentially share the objects along with it&#39;s dependencies to the org
     * admins of the orgs to which it is being published.
     *
     * @param publishMetadataRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Publishing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void publishMetadata(PublishMetadataRequest publishMetadataRequest) throws ApiException {
        publishMetadataWithHttpInfo(publishMetadataRequest);
    }

    /**
     * Version: 10.9.0.cl or later Allows publishing metadata objects across organizations in
     * ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The API endpoint allows
     * publishing the following types of metadata objects: * Liveboards * Answers * Logical Tables
     * This API will essentially share the objects along with it&#39;s dependencies to the org
     * admins of the orgs to which it is being published.
     *
     * @param publishMetadataRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Publishing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> publishMetadataWithHttpInfo(
            PublishMetadataRequest publishMetadataRequest) throws ApiException {
        okhttp3.Call localVarCall = publishMetadataValidateBeforeCall(publishMetadataRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.9.0.cl or later Allows publishing metadata objects across
     * organizations in ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The API endpoint
     * allows publishing the following types of metadata objects: * Liveboards * Answers * Logical
     * Tables This API will essentially share the objects along with it&#39;s dependencies to the
     * org admins of the orgs to which it is being published.
     *
     * @param publishMetadataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Publishing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call publishMetadataAsync(
            PublishMetadataRequest publishMetadataRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                publishMetadataValidateBeforeCall(publishMetadataRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for queryGetDecomposedQuery
     *
     * @param queryGetDecomposedQueryRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call queryGetDecomposedQueryCall(
            QueryGetDecomposedQueryRequest queryGetDecomposedQueryRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = queryGetDecomposedQueryRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/ai/analytical-questions";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call queryGetDecomposedQueryValidateBeforeCall(
            QueryGetDecomposedQueryRequest queryGetDecomposedQueryRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'queryGetDecomposedQueryRequest' is set
        if (queryGetDecomposedQueryRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'queryGetDecomposedQueryRequest' when calling"
                            + " queryGetDecomposedQuery(Async)");
        }

        return queryGetDecomposedQueryCall(queryGetDecomposedQueryRequest, _callback);
    }

    /**
     * Version: 10.7.0.cl or later
     *
     * @param queryGetDecomposedQueryRequest (required)
     * @return EurekaDecomposeQueryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public EurekaDecomposeQueryResponse queryGetDecomposedQuery(
            QueryGetDecomposedQueryRequest queryGetDecomposedQueryRequest) throws ApiException {
        ApiResponse<EurekaDecomposeQueryResponse> localVarResp =
                queryGetDecomposedQueryWithHttpInfo(queryGetDecomposedQueryRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.7.0.cl or later
     *
     * @param queryGetDecomposedQueryRequest (required)
     * @return ApiResponse&lt;EurekaDecomposeQueryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<EurekaDecomposeQueryResponse> queryGetDecomposedQueryWithHttpInfo(
            QueryGetDecomposedQueryRequest queryGetDecomposedQueryRequest) throws ApiException {
        okhttp3.Call localVarCall =
                queryGetDecomposedQueryValidateBeforeCall(queryGetDecomposedQueryRequest, null);
        Type localVarReturnType = new TypeToken<EurekaDecomposeQueryResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.7.0.cl or later
     *
     * @param queryGetDecomposedQueryRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call queryGetDecomposedQueryAsync(
            QueryGetDecomposedQueryRequest queryGetDecomposedQueryRequest,
            final ApiCallback<EurekaDecomposeQueryResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                queryGetDecomposedQueryValidateBeforeCall(
                        queryGetDecomposedQueryRequest, _callback);
        Type localVarReturnType = new TypeToken<EurekaDecomposeQueryResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for resetUserPassword
     *
     * @param resetUserPasswordRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User password reset operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call resetUserPasswordCall(
            ResetUserPasswordRequest resetUserPasswordRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = resetUserPasswordRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/users/reset-password";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call resetUserPasswordValidateBeforeCall(
            ResetUserPasswordRequest resetUserPasswordRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'resetUserPasswordRequest' is set
        if (resetUserPasswordRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'resetUserPasswordRequest' when calling"
                            + " resetUserPassword(Async)");
        }

        return resetUserPasswordCall(resetUserPasswordRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Resets the password of a user account. Administrators can reset
     * password on behalf of a user. Requires &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param resetUserPasswordRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User password reset operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void resetUserPassword(ResetUserPasswordRequest resetUserPasswordRequest)
            throws ApiException {
        resetUserPasswordWithHttpInfo(resetUserPasswordRequest);
    }

    /**
     * Version: 9.0.0.cl or later Resets the password of a user account. Administrators can reset
     * password on behalf of a user. Requires &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param resetUserPasswordRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User password reset operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> resetUserPasswordWithHttpInfo(
            ResetUserPasswordRequest resetUserPasswordRequest) throws ApiException {
        okhttp3.Call localVarCall =
                resetUserPasswordValidateBeforeCall(resetUserPasswordRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Resets the password of a user account.
     * Administrators can reset password on behalf of a user. Requires &#x60;ADMINISTRATION&#x60;
     * (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param resetUserPasswordRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User password reset operation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call resetUserPasswordAsync(
            ResetUserPasswordRequest resetUserPasswordRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                resetUserPasswordValidateBeforeCall(resetUserPasswordRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for revertCommit
     *
     * @param commitId Commit id to which the object should be reverted (required)
     * @param revertCommitRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Reverted the object to the commit point specified </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call revertCommitCall(
            String commitId, RevertCommitRequest revertCommitRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = revertCommitRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/vcs/git/commits/{commit_id}/revert"
                        .replace(
                                "{" + "commit_id" + "}",
                                localVarApiClient.escapeString(commitId.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call revertCommitValidateBeforeCall(
            String commitId, RevertCommitRequest revertCommitRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'commitId' is set
        if (commitId == null) {
            throw new ApiException(
                    "Missing the required parameter 'commitId' when calling revertCommit(Async)");
        }

        // verify the required parameter 'revertCommitRequest' is set
        if (revertCommitRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'revertCommitRequest' when calling"
                            + " revertCommit(Async)");
        }

        return revertCommitCall(commitId, revertCommitRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Reverts TML objects to a previous commit specified in the API
     * request. Requires at least edit access to objects. In the API request, specify the
     * &#x60;commit_id&#x60;. If the branch name is not specified in the request, the API will
     * consider the default branch configured on your instance. By default, the API reverts all
     * objects. If the revert operation fails for one of the objects provided in the commit, the API
     * returns an error and does not revert any object. For more information, see [Git integration
     * documentation](https://developers.thoughtspot.com/docs/git-integration).
     *
     * @param commitId Commit id to which the object should be reverted (required)
     * @param revertCommitRequest (required)
     * @return RevertResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Reverted the object to the commit point specified </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public RevertResponse revertCommit(String commitId, RevertCommitRequest revertCommitRequest)
            throws ApiException {
        ApiResponse<RevertResponse> localVarResp =
                revertCommitWithHttpInfo(commitId, revertCommitRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Reverts TML objects to a previous commit specified in the API
     * request. Requires at least edit access to objects. In the API request, specify the
     * &#x60;commit_id&#x60;. If the branch name is not specified in the request, the API will
     * consider the default branch configured on your instance. By default, the API reverts all
     * objects. If the revert operation fails for one of the objects provided in the commit, the API
     * returns an error and does not revert any object. For more information, see [Git integration
     * documentation](https://developers.thoughtspot.com/docs/git-integration).
     *
     * @param commitId Commit id to which the object should be reverted (required)
     * @param revertCommitRequest (required)
     * @return ApiResponse&lt;RevertResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Reverted the object to the commit point specified </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<RevertResponse> revertCommitWithHttpInfo(
            String commitId, RevertCommitRequest revertCommitRequest) throws ApiException {
        okhttp3.Call localVarCall =
                revertCommitValidateBeforeCall(commitId, revertCommitRequest, null);
        Type localVarReturnType = new TypeToken<RevertResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Reverts TML objects to a previous commit
     * specified in the API request. Requires at least edit access to objects. In the API request,
     * specify the &#x60;commit_id&#x60;. If the branch name is not specified in the request, the
     * API will consider the default branch configured on your instance. By default, the API reverts
     * all objects. If the revert operation fails for one of the objects provided in the commit, the
     * API returns an error and does not revert any object. For more information, see [Git
     * integration documentation](https://developers.thoughtspot.com/docs/git-integration).
     *
     * @param commitId Commit id to which the object should be reverted (required)
     * @param revertCommitRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Reverted the object to the commit point specified </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call revertCommitAsync(
            String commitId,
            RevertCommitRequest revertCommitRequest,
            final ApiCallback<RevertResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                revertCommitValidateBeforeCall(commitId, revertCommitRequest, _callback);
        Type localVarReturnType = new TypeToken<RevertResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for revokeToken
     *
     * @param revokeTokenRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Token successfully revoked. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call revokeTokenCall(
            RevokeTokenRequest revokeTokenRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = revokeTokenRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/auth/token/revoke";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call revokeTokenValidateBeforeCall(
            RevokeTokenRequest revokeTokenRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'revokeTokenRequest' is set
        if (revokeTokenRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'revokeTokenRequest' when calling"
                            + " revokeToken(Async)");
        }

        return revokeTokenCall(revokeTokenRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Revokes the authentication token issued for current user session.
     * The token of your current session expires when you make a call to the
     * &#x60;/api/rest/2.0/auth/token/revoke&#x60; endpoint. the users will not be able to access
     * ThoughtSpot objects until a new token is obtained. To restart your session, request for a new
     * token from ThoughtSpot. See [Get Full Access
     * Token](#/http/api-endpoints/authentication/get-full-access-token).
     *
     * @param revokeTokenRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Token successfully revoked. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void revokeToken(RevokeTokenRequest revokeTokenRequest) throws ApiException {
        revokeTokenWithHttpInfo(revokeTokenRequest);
    }

    /**
     * Version: 9.0.0.cl or later Revokes the authentication token issued for current user session.
     * The token of your current session expires when you make a call to the
     * &#x60;/api/rest/2.0/auth/token/revoke&#x60; endpoint. the users will not be able to access
     * ThoughtSpot objects until a new token is obtained. To restart your session, request for a new
     * token from ThoughtSpot. See [Get Full Access
     * Token](#/http/api-endpoints/authentication/get-full-access-token).
     *
     * @param revokeTokenRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Token successfully revoked. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> revokeTokenWithHttpInfo(RevokeTokenRequest revokeTokenRequest)
            throws ApiException {
        okhttp3.Call localVarCall = revokeTokenValidateBeforeCall(revokeTokenRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Revokes the authentication token issued for
     * current user session. The token of your current session expires when you make a call to the
     * &#x60;/api/rest/2.0/auth/token/revoke&#x60; endpoint. the users will not be able to access
     * ThoughtSpot objects until a new token is obtained. To restart your session, request for a new
     * token from ThoughtSpot. See [Get Full Access
     * Token](#/http/api-endpoints/authentication/get-full-access-token).
     *
     * @param revokeTokenRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Token successfully revoked. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call revokeTokenAsync(
            RevokeTokenRequest revokeTokenRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = revokeTokenValidateBeforeCall(revokeTokenRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchCalendars
     *
     * @param searchCalendarsRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom calendar fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchCalendarsCall(
            SearchCalendarsRequest searchCalendarsRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchCalendarsRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/calendars/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchCalendarsValidateBeforeCall(
            SearchCalendarsRequest searchCalendarsRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchCalendarsRequest' is set
        if (searchCalendarsRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchCalendarsRequest' when calling"
                            + " searchCalendars(Async)");
        }

        return searchCalendarsCall(searchCalendarsRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Gets a list of [custom
     * calendars](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines By default, the API returns a list of custom
     * calendars for all connection objects. To retrieve custom calendar details for a particular
     * connection, specify the connection ID. You can also use other search parameters such as
     * &#x60;name_pattern&#x60; and &#x60;sort_options&#x60; as search filters. The
     * &#x60;name_pattern&#x60; parameter filters and returns only those objects that match the
     * specified pattern. Use &#x60;%&#x60; as a wildcard for pattern matching.
     *
     * @param searchCalendarsRequest (required)
     * @return List&lt;CalendarResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom calendar fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<CalendarResponse> searchCalendars(SearchCalendarsRequest searchCalendarsRequest)
            throws ApiException {
        ApiResponse<List<CalendarResponse>> localVarResp =
                searchCalendarsWithHttpInfo(searchCalendarsRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.12.0.cl or later Gets a list of [custom
     * calendars](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines By default, the API returns a list of custom
     * calendars for all connection objects. To retrieve custom calendar details for a particular
     * connection, specify the connection ID. You can also use other search parameters such as
     * &#x60;name_pattern&#x60; and &#x60;sort_options&#x60; as search filters. The
     * &#x60;name_pattern&#x60; parameter filters and returns only those objects that match the
     * specified pattern. Use &#x60;%&#x60; as a wildcard for pattern matching.
     *
     * @param searchCalendarsRequest (required)
     * @return ApiResponse&lt;List&lt;CalendarResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom calendar fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<CalendarResponse>> searchCalendarsWithHttpInfo(
            SearchCalendarsRequest searchCalendarsRequest) throws ApiException {
        okhttp3.Call localVarCall = searchCalendarsValidateBeforeCall(searchCalendarsRequest, null);
        Type localVarReturnType = new TypeToken<List<CalendarResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Gets a list of [custom
     * calendars](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines By default, the API returns a list of custom
     * calendars for all connection objects. To retrieve custom calendar details for a particular
     * connection, specify the connection ID. You can also use other search parameters such as
     * &#x60;name_pattern&#x60; and &#x60;sort_options&#x60; as search filters. The
     * &#x60;name_pattern&#x60; parameter filters and returns only those objects that match the
     * specified pattern. Use &#x60;%&#x60; as a wildcard for pattern matching.
     *
     * @param searchCalendarsRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom calendar fetched successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchCalendarsAsync(
            SearchCalendarsRequest searchCalendarsRequest,
            final ApiCallback<List<CalendarResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                searchCalendarsValidateBeforeCall(searchCalendarsRequest, _callback);
        Type localVarReturnType = new TypeToken<List<CalendarResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchCommits
     *
     * @param searchCommitsRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Commit history of the metadata object </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchCommitsCall(
            SearchCommitsRequest searchCommitsRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchCommitsRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/vcs/git/commits/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchCommitsValidateBeforeCall(
            SearchCommitsRequest searchCommitsRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchCommitsRequest' is set
        if (searchCommitsRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchCommitsRequest' when calling"
                            + " searchCommits(Async)");
        }

        return searchCommitsCall(searchCommitsRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Gets a list of commits for a given metadata object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your
     * instance, the &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     * privilege and edit access to the metadata objects.
     *
     * @param searchCommitsRequest (required)
     * @return List&lt;CommitHistoryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Commit history of the metadata object </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<CommitHistoryResponse> searchCommits(SearchCommitsRequest searchCommitsRequest)
            throws ApiException {
        ApiResponse<List<CommitHistoryResponse>> localVarResp =
                searchCommitsWithHttpInfo(searchCommitsRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Gets a list of commits for a given metadata object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your
     * instance, the &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     * privilege and edit access to the metadata objects.
     *
     * @param searchCommitsRequest (required)
     * @return ApiResponse&lt;List&lt;CommitHistoryResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Commit history of the metadata object </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<CommitHistoryResponse>> searchCommitsWithHttpInfo(
            SearchCommitsRequest searchCommitsRequest) throws ApiException {
        okhttp3.Call localVarCall = searchCommitsValidateBeforeCall(searchCommitsRequest, null);
        Type localVarReturnType = new TypeToken<List<CommitHistoryResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Gets a list of commits for a given metadata
     * object. Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If [Role-Based
     * Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your
     * instance on your instance, the &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage
     * data models**) privilege and edit access to the metadata objects.
     *
     * @param searchCommitsRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Commit history of the metadata object </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchCommitsAsync(
            SearchCommitsRequest searchCommitsRequest,
            final ApiCallback<List<CommitHistoryResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                searchCommitsValidateBeforeCall(searchCommitsRequest, _callback);
        Type localVarReturnType = new TypeToken<List<CommitHistoryResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchConfig
     *
     * @param searchConfigRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Details of local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchConfigCall(
            SearchConfigRequest searchConfigRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchConfigRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/vcs/git/config/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchConfigValidateBeforeCall(
            SearchConfigRequest searchConfigRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchConfigRequest' is set
        if (searchConfigRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchConfigRequest' when calling"
                            + " searchConfig(Async)");
        }

        return searchConfigCall(searchConfigRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Gets Git repository connections configured on the ThoughtSpot
     * instance. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance on your instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up
     * version control**) privilege.
     *
     * @param searchConfigRequest (required)
     * @return List&lt;RepoConfigObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Details of local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<RepoConfigObject> searchConfig(SearchConfigRequest searchConfigRequest)
            throws ApiException {
        ApiResponse<List<RepoConfigObject>> localVarResp =
                searchConfigWithHttpInfo(searchConfigRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Gets Git repository connections configured on the ThoughtSpot
     * instance. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance on your instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up
     * version control**) privilege.
     *
     * @param searchConfigRequest (required)
     * @return ApiResponse&lt;List&lt;RepoConfigObject&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Details of local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<RepoConfigObject>> searchConfigWithHttpInfo(
            SearchConfigRequest searchConfigRequest) throws ApiException {
        okhttp3.Call localVarCall = searchConfigValidateBeforeCall(searchConfigRequest, null);
        Type localVarReturnType = new TypeToken<List<RepoConfigObject>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Gets Git repository connections configured on the
     * ThoughtSpot instance. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your
     * instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up version control**)
     * privilege.
     *
     * @param searchConfigRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Details of local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchConfigAsync(
            SearchConfigRequest searchConfigRequest,
            final ApiCallback<List<RepoConfigObject>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = searchConfigValidateBeforeCall(searchConfigRequest, _callback);
        Type localVarReturnType = new TypeToken<List<RepoConfigObject>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchConnection
     *
     * @param searchConnectionRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> List of connections to the datasource. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchConnectionCall(
            SearchConnectionRequest searchConnectionRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchConnectionRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/connection/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchConnectionValidateBeforeCall(
            SearchConnectionRequest searchConnectionRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchConnectionRequest' is set
        if (searchConnectionRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchConnectionRequest' when calling"
                            + " searchConnection(Async)");
        }

        return searchConnectionCall(searchConnectionRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Gets connection objects. Requires &#x60;DATAMANAGEMENT&#x60;
     * (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required. - To get a list of all connections available in the ThoughtSpot system, send the
     * API request without any attributes in the request body. - To get the connection objects for a
     * specific type of data warehouse, specify the type in &#x60;data_warehouse_types&#x60;. - To
     * fetch details of a connection object, specify the connection object GUID or name. The
     * &#x60;name_pattern&#x60; attribute allows passing partial text with &#x60;%&#x60; for a
     * wildcard match. - To get details of the database, schemas, tables, or columns from a data
     * connection object, specify &#x60;data_warehouse_object_type&#x60;. - To get a specific
     * database, schema, table, or column from a connection object, define the object type in
     * &#x60;data_warehouse_object_type&#x60; and object properties in the
     * &#x60;data_warehouse_objects&#x60; array. For example, to search for a column, you must pass
     * the database, schema, and table names in the API request. Note that in the following example,
     * object properties are set in a hierarchical order (&#x60;database&#x60; &gt;
     * &#x60;schema&#x60; &gt; &#x60;table&#x60; &gt; &#x60;column&#x60;). &#x60;&#x60;&#x60; {
     * \&quot;connections\&quot;: [ { \&quot;identifier\&quot;:
     * \&quot;b9d1f2ef-fa65-4a4b-994e-30fa2d57b0c2\&quot;, \&quot;data_warehouse_objects\&quot;: [ {
     * \&quot;database\&quot;: \&quot;NEBULADEV\&quot;, \&quot;schema\&quot;:
     * \&quot;INFORMATION_SCHEMA\&quot;, \&quot;table\&quot;: \&quot;APPLICABLE_ROLES\&quot;,
     * \&quot;column\&quot;: \&quot;ROLE_NAME\&quot; } ] } ],
     * \&quot;data_warehouse_object_type\&quot;: \&quot;COLUMN\&quot; } &#x60;&#x60;&#x60; - To
     * fetch data by &#x60;configuration&#x60;, specify &#x60;data_warehouse_object_type&#x60;. For
     * example, to fetch columns from the &#x60;DEVELOPMENT&#x60; database, specify the
     * &#x60;data_warehouse_object_type&#x60; as &#x60;DATABASE&#x60; and define the
     * &#x60;configuration&#x60; string as
     * &#x60;{\&quot;database\&quot;:\&quot;DEVELOPMENT\&quot;}&#x60;. To get column data for a
     * specific table, specify the table, for
     * example,&#x60;{\&quot;database\&quot;:\&quot;RETAILAPPAREL\&quot;,\&quot;table\&quot;:\&quot;PIPES\&quot;}&#x60;.
     * - To query connections by &#x60;authentication_type&#x60;, specify
     * &#x60;data_warehouse_object_type&#x60;. Supported values for &#x60;authentication_type&#x60;
     * are: - &#x60;SERVICE_ACCOUNT&#x60;: For connections that require service account credentials
     * to authenticate to the Cloud Data Warehouse and fetch data. - &#x60;OAUTH&#x60;: For
     * connections that require OAuth credentials to authenticate to the Cloud Data Warehouse and
     * fetch data. Teradata, Oracle, and Presto Cloud Data Warehouses do not support the OAuth
     * authentication type. - &#x60;IAM&#x60;: For connections that have the IAM OAuth set up. This
     * authentication type is supported on Amazon Redshift connections only. - &#x60;EXTOAUTH&#x60;:
     * For connections that have External OAuth set up. ThoughtSpot supports external [OAuth with
     * Microsoft Azure Active Directory (AD)](https://docs.thoughtspot.com/cloud/latest/
     * connections-snowflake-azure-ad-oauth) and [Okta for Snowflake data
     * connections](https://docs.thoughtspot.com/cloud/latest/connections-snowflake-okta-oauth). -
     * &#x60;KEY_PAIR&#x60;: For connections that require Key Pair account credentials to
     * authenticate to the Cloud Data Warehouse and fetch data. This authentication type is
     * supported on Snowflake connections only. - &#x60;OAUTH_WITH_PKCE&#x60;: For connections that
     * require OAuth with PKCE account credentials to authenticate to the Cloud Data Warehouse and
     * fetch data. This authentication type is supported on Snowflake, Starburst, Databricks, Denodo
     * connections only. - &#x60;EXTOAUTH_WITH_PKCE&#x60;: For connections that require External
     * OAuth With PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch
     * data. This authentication type is supported on Snowflake connections only. -
     * &#x60;OAUTH_WITH_PEZ&#x60;: For connections that require OAuth With PEZ account credentials
     * to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is
     * supported on Amazon Redshift connections only. - &#x60;OAUTH_WITH_SERVICE_PRINCIPAL&#x60;:
     * For connections that require OAuth With Service Principal account credentials to authenticate
     * to the Cloud Data Warehouse and fetch data. This authentication type is supported on
     * Databricks connections only. - &#x60;PERSONAL_ACCESS_TOKEN&#x60;: For connections that
     * require Personal Access Token account credentials to authenticate to the Cloud Data Warehouse
     * and fetch data. This authentication type is supported on Databricks connections only. -
     * &#x60;OAUTH_CLIENT_CREDENTIALS&#x60;: For connections that require OAuth Client Credentials
     * to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is
     * supported on Snowflake connections only. - To include more details about connection objects
     * in the API response, set &#x60;include_details&#x60; to &#x60;true&#x60;. - You can also sort
     * the output by field names and filter connections by tags. **NOTE**: When filtering connection
     * records by parameters other than &#x60;data_warehouse_types&#x60; or
     * &#x60;tag_identifiers&#x60;, ensure that you set &#x60;record_size&#x60; to &#x60;-1&#x60;
     * and &#x60;record_offset&#x60; to &#x60;0&#x60; for precise results.
     *
     * @param searchConnectionRequest (required)
     * @return List&lt;SearchConnectionResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> List of connections to the datasource. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<SearchConnectionResponse> searchConnection(
            SearchConnectionRequest searchConnectionRequest) throws ApiException {
        ApiResponse<List<SearchConnectionResponse>> localVarResp =
                searchConnectionWithHttpInfo(searchConnectionRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Gets connection objects. Requires &#x60;DATAMANAGEMENT&#x60;
     * (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required. - To get a list of all connections available in the ThoughtSpot system, send the
     * API request without any attributes in the request body. - To get the connection objects for a
     * specific type of data warehouse, specify the type in &#x60;data_warehouse_types&#x60;. - To
     * fetch details of a connection object, specify the connection object GUID or name. The
     * &#x60;name_pattern&#x60; attribute allows passing partial text with &#x60;%&#x60; for a
     * wildcard match. - To get details of the database, schemas, tables, or columns from a data
     * connection object, specify &#x60;data_warehouse_object_type&#x60;. - To get a specific
     * database, schema, table, or column from a connection object, define the object type in
     * &#x60;data_warehouse_object_type&#x60; and object properties in the
     * &#x60;data_warehouse_objects&#x60; array. For example, to search for a column, you must pass
     * the database, schema, and table names in the API request. Note that in the following example,
     * object properties are set in a hierarchical order (&#x60;database&#x60; &gt;
     * &#x60;schema&#x60; &gt; &#x60;table&#x60; &gt; &#x60;column&#x60;). &#x60;&#x60;&#x60; {
     * \&quot;connections\&quot;: [ { \&quot;identifier\&quot;:
     * \&quot;b9d1f2ef-fa65-4a4b-994e-30fa2d57b0c2\&quot;, \&quot;data_warehouse_objects\&quot;: [ {
     * \&quot;database\&quot;: \&quot;NEBULADEV\&quot;, \&quot;schema\&quot;:
     * \&quot;INFORMATION_SCHEMA\&quot;, \&quot;table\&quot;: \&quot;APPLICABLE_ROLES\&quot;,
     * \&quot;column\&quot;: \&quot;ROLE_NAME\&quot; } ] } ],
     * \&quot;data_warehouse_object_type\&quot;: \&quot;COLUMN\&quot; } &#x60;&#x60;&#x60; - To
     * fetch data by &#x60;configuration&#x60;, specify &#x60;data_warehouse_object_type&#x60;. For
     * example, to fetch columns from the &#x60;DEVELOPMENT&#x60; database, specify the
     * &#x60;data_warehouse_object_type&#x60; as &#x60;DATABASE&#x60; and define the
     * &#x60;configuration&#x60; string as
     * &#x60;{\&quot;database\&quot;:\&quot;DEVELOPMENT\&quot;}&#x60;. To get column data for a
     * specific table, specify the table, for
     * example,&#x60;{\&quot;database\&quot;:\&quot;RETAILAPPAREL\&quot;,\&quot;table\&quot;:\&quot;PIPES\&quot;}&#x60;.
     * - To query connections by &#x60;authentication_type&#x60;, specify
     * &#x60;data_warehouse_object_type&#x60;. Supported values for &#x60;authentication_type&#x60;
     * are: - &#x60;SERVICE_ACCOUNT&#x60;: For connections that require service account credentials
     * to authenticate to the Cloud Data Warehouse and fetch data. - &#x60;OAUTH&#x60;: For
     * connections that require OAuth credentials to authenticate to the Cloud Data Warehouse and
     * fetch data. Teradata, Oracle, and Presto Cloud Data Warehouses do not support the OAuth
     * authentication type. - &#x60;IAM&#x60;: For connections that have the IAM OAuth set up. This
     * authentication type is supported on Amazon Redshift connections only. - &#x60;EXTOAUTH&#x60;:
     * For connections that have External OAuth set up. ThoughtSpot supports external [OAuth with
     * Microsoft Azure Active Directory (AD)](https://docs.thoughtspot.com/cloud/latest/
     * connections-snowflake-azure-ad-oauth) and [Okta for Snowflake data
     * connections](https://docs.thoughtspot.com/cloud/latest/connections-snowflake-okta-oauth). -
     * &#x60;KEY_PAIR&#x60;: For connections that require Key Pair account credentials to
     * authenticate to the Cloud Data Warehouse and fetch data. This authentication type is
     * supported on Snowflake connections only. - &#x60;OAUTH_WITH_PKCE&#x60;: For connections that
     * require OAuth with PKCE account credentials to authenticate to the Cloud Data Warehouse and
     * fetch data. This authentication type is supported on Snowflake, Starburst, Databricks, Denodo
     * connections only. - &#x60;EXTOAUTH_WITH_PKCE&#x60;: For connections that require External
     * OAuth With PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch
     * data. This authentication type is supported on Snowflake connections only. -
     * &#x60;OAUTH_WITH_PEZ&#x60;: For connections that require OAuth With PEZ account credentials
     * to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is
     * supported on Amazon Redshift connections only. - &#x60;OAUTH_WITH_SERVICE_PRINCIPAL&#x60;:
     * For connections that require OAuth With Service Principal account credentials to authenticate
     * to the Cloud Data Warehouse and fetch data. This authentication type is supported on
     * Databricks connections only. - &#x60;PERSONAL_ACCESS_TOKEN&#x60;: For connections that
     * require Personal Access Token account credentials to authenticate to the Cloud Data Warehouse
     * and fetch data. This authentication type is supported on Databricks connections only. -
     * &#x60;OAUTH_CLIENT_CREDENTIALS&#x60;: For connections that require OAuth Client Credentials
     * to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is
     * supported on Snowflake connections only. - To include more details about connection objects
     * in the API response, set &#x60;include_details&#x60; to &#x60;true&#x60;. - You can also sort
     * the output by field names and filter connections by tags. **NOTE**: When filtering connection
     * records by parameters other than &#x60;data_warehouse_types&#x60; or
     * &#x60;tag_identifiers&#x60;, ensure that you set &#x60;record_size&#x60; to &#x60;-1&#x60;
     * and &#x60;record_offset&#x60; to &#x60;0&#x60; for precise results.
     *
     * @param searchConnectionRequest (required)
     * @return ApiResponse&lt;List&lt;SearchConnectionResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> List of connections to the datasource. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<SearchConnectionResponse>> searchConnectionWithHttpInfo(
            SearchConnectionRequest searchConnectionRequest) throws ApiException {
        okhttp3.Call localVarCall =
                searchConnectionValidateBeforeCall(searchConnectionRequest, null);
        Type localVarReturnType = new TypeToken<List<SearchConnectionResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Gets connection objects. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required. - To get a list of all connections available in the ThoughtSpot system, send the
     * API request without any attributes in the request body. - To get the connection objects for a
     * specific type of data warehouse, specify the type in &#x60;data_warehouse_types&#x60;. - To
     * fetch details of a connection object, specify the connection object GUID or name. The
     * &#x60;name_pattern&#x60; attribute allows passing partial text with &#x60;%&#x60; for a
     * wildcard match. - To get details of the database, schemas, tables, or columns from a data
     * connection object, specify &#x60;data_warehouse_object_type&#x60;. - To get a specific
     * database, schema, table, or column from a connection object, define the object type in
     * &#x60;data_warehouse_object_type&#x60; and object properties in the
     * &#x60;data_warehouse_objects&#x60; array. For example, to search for a column, you must pass
     * the database, schema, and table names in the API request. Note that in the following example,
     * object properties are set in a hierarchical order (&#x60;database&#x60; &gt;
     * &#x60;schema&#x60; &gt; &#x60;table&#x60; &gt; &#x60;column&#x60;). &#x60;&#x60;&#x60; {
     * \&quot;connections\&quot;: [ { \&quot;identifier\&quot;:
     * \&quot;b9d1f2ef-fa65-4a4b-994e-30fa2d57b0c2\&quot;, \&quot;data_warehouse_objects\&quot;: [ {
     * \&quot;database\&quot;: \&quot;NEBULADEV\&quot;, \&quot;schema\&quot;:
     * \&quot;INFORMATION_SCHEMA\&quot;, \&quot;table\&quot;: \&quot;APPLICABLE_ROLES\&quot;,
     * \&quot;column\&quot;: \&quot;ROLE_NAME\&quot; } ] } ],
     * \&quot;data_warehouse_object_type\&quot;: \&quot;COLUMN\&quot; } &#x60;&#x60;&#x60; - To
     * fetch data by &#x60;configuration&#x60;, specify &#x60;data_warehouse_object_type&#x60;. For
     * example, to fetch columns from the &#x60;DEVELOPMENT&#x60; database, specify the
     * &#x60;data_warehouse_object_type&#x60; as &#x60;DATABASE&#x60; and define the
     * &#x60;configuration&#x60; string as
     * &#x60;{\&quot;database\&quot;:\&quot;DEVELOPMENT\&quot;}&#x60;. To get column data for a
     * specific table, specify the table, for
     * example,&#x60;{\&quot;database\&quot;:\&quot;RETAILAPPAREL\&quot;,\&quot;table\&quot;:\&quot;PIPES\&quot;}&#x60;.
     * - To query connections by &#x60;authentication_type&#x60;, specify
     * &#x60;data_warehouse_object_type&#x60;. Supported values for &#x60;authentication_type&#x60;
     * are: - &#x60;SERVICE_ACCOUNT&#x60;: For connections that require service account credentials
     * to authenticate to the Cloud Data Warehouse and fetch data. - &#x60;OAUTH&#x60;: For
     * connections that require OAuth credentials to authenticate to the Cloud Data Warehouse and
     * fetch data. Teradata, Oracle, and Presto Cloud Data Warehouses do not support the OAuth
     * authentication type. - &#x60;IAM&#x60;: For connections that have the IAM OAuth set up. This
     * authentication type is supported on Amazon Redshift connections only. - &#x60;EXTOAUTH&#x60;:
     * For connections that have External OAuth set up. ThoughtSpot supports external [OAuth with
     * Microsoft Azure Active Directory (AD)](https://docs.thoughtspot.com/cloud/latest/
     * connections-snowflake-azure-ad-oauth) and [Okta for Snowflake data
     * connections](https://docs.thoughtspot.com/cloud/latest/connections-snowflake-okta-oauth). -
     * &#x60;KEY_PAIR&#x60;: For connections that require Key Pair account credentials to
     * authenticate to the Cloud Data Warehouse and fetch data. This authentication type is
     * supported on Snowflake connections only. - &#x60;OAUTH_WITH_PKCE&#x60;: For connections that
     * require OAuth with PKCE account credentials to authenticate to the Cloud Data Warehouse and
     * fetch data. This authentication type is supported on Snowflake, Starburst, Databricks, Denodo
     * connections only. - &#x60;EXTOAUTH_WITH_PKCE&#x60;: For connections that require External
     * OAuth With PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch
     * data. This authentication type is supported on Snowflake connections only. -
     * &#x60;OAUTH_WITH_PEZ&#x60;: For connections that require OAuth With PEZ account credentials
     * to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is
     * supported on Amazon Redshift connections only. - &#x60;OAUTH_WITH_SERVICE_PRINCIPAL&#x60;:
     * For connections that require OAuth With Service Principal account credentials to authenticate
     * to the Cloud Data Warehouse and fetch data. This authentication type is supported on
     * Databricks connections only. - &#x60;PERSONAL_ACCESS_TOKEN&#x60;: For connections that
     * require Personal Access Token account credentials to authenticate to the Cloud Data Warehouse
     * and fetch data. This authentication type is supported on Databricks connections only. -
     * &#x60;OAUTH_CLIENT_CREDENTIALS&#x60;: For connections that require OAuth Client Credentials
     * to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is
     * supported on Snowflake connections only. - To include more details about connection objects
     * in the API response, set &#x60;include_details&#x60; to &#x60;true&#x60;. - You can also sort
     * the output by field names and filter connections by tags. **NOTE**: When filtering connection
     * records by parameters other than &#x60;data_warehouse_types&#x60; or
     * &#x60;tag_identifiers&#x60;, ensure that you set &#x60;record_size&#x60; to &#x60;-1&#x60;
     * and &#x60;record_offset&#x60; to &#x60;0&#x60; for precise results.
     *
     * @param searchConnectionRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> List of connections to the datasource. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchConnectionAsync(
            SearchConnectionRequest searchConnectionRequest,
            final ApiCallback<List<SearchConnectionResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                searchConnectionValidateBeforeCall(searchConnectionRequest, _callback);
        Type localVarReturnType = new TypeToken<List<SearchConnectionResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchCustomActions
     *
     * @param searchCustomActionsRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom action search is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchCustomActionsCall(
            SearchCustomActionsRequest searchCustomActionsRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchCustomActionsRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/customization/custom-actions/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchCustomActionsValidateBeforeCall(
            SearchCustomActionsRequest searchCustomActionsRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchCustomActionsRequest' is set
        if (searchCustomActionsRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchCustomActionsRequest' when calling"
                            + " searchCustomActions(Async)");
        }

        return searchCustomActionsCall(searchCustomActionsRequest, _callback);
    }

    /**
     * Version: 9.6.0.cl or later Gets custom actions configured on the cluster. Requires
     * &#x60;DEVELOPER&#x60; (**Has Developer privilege**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required.
     *
     * @param searchCustomActionsRequest (required)
     * @return List&lt;ResponseCustomAction&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom action search is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<ResponseCustomAction> searchCustomActions(
            SearchCustomActionsRequest searchCustomActionsRequest) throws ApiException {
        ApiResponse<List<ResponseCustomAction>> localVarResp =
                searchCustomActionsWithHttpInfo(searchCustomActionsRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.6.0.cl or later Gets custom actions configured on the cluster. Requires
     * &#x60;DEVELOPER&#x60; (**Has Developer privilege**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required.
     *
     * @param searchCustomActionsRequest (required)
     * @return ApiResponse&lt;List&lt;ResponseCustomAction&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom action search is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<ResponseCustomAction>> searchCustomActionsWithHttpInfo(
            SearchCustomActionsRequest searchCustomActionsRequest) throws ApiException {
        okhttp3.Call localVarCall =
                searchCustomActionsValidateBeforeCall(searchCustomActionsRequest, null);
        Type localVarReturnType = new TypeToken<List<ResponseCustomAction>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.6.0.cl or later Gets custom actions configured on the cluster.
     * Requires &#x60;DEVELOPER&#x60; (**Has Developer privilege**) or &#x60;ADMINISTRATION&#x60;
     * (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required.
     *
     * @param searchCustomActionsRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Custom action search is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchCustomActionsAsync(
            SearchCustomActionsRequest searchCustomActionsRequest,
            final ApiCallback<List<ResponseCustomAction>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                searchCustomActionsValidateBeforeCall(searchCustomActionsRequest, _callback);
        Type localVarReturnType = new TypeToken<List<ResponseCustomAction>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchData
     *
     * @param searchDataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchDataCall(
            SearchDataRequest searchDataRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchDataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/searchdata";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchDataValidateBeforeCall(
            SearchDataRequest searchDataRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'searchDataRequest' is set
        if (searchDataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchDataRequest' when calling"
                            + " searchData(Async)");
        }

        return searchDataCall(searchDataRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Generates an Answer from a given data source. Requires at least
     * view access to the data source object (Worksheet or View). #### Usage guidelines To search
     * data, specify the data source GUID in &#x60;logical_table_identifier&#x60;. The data source
     * can be a Worksheet, View, Table, or SQL view. Pass search tokens in the
     * &#x60;query_string&#x60; attribute in the API request as shown in the following example:
     * &#x60;&#x60;&#x60; { \&quot;query_string\&quot;: \&quot;[sales] by [store]\&quot;,
     * \&quot;logical_table_identifier\&quot;: \&quot;cd252e5c-b552-49a8-821d-3eadaa049cca\&quot;, }
     * &#x60;&#x60;&#x60; For more information about the &#x60;query_string&#x60; format and data
     * source attribute, see [Search data
     * API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_search_data_api).
     * The &#x60;record_size&#x60; attribute determines the number of records to retrieve in an API
     * call. For more information about pagination, record size, and maximum row limit, see
     * [Pagination and record size
     * settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_api).
     *
     * @param searchDataRequest (required)
     * @return SearchDataResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public SearchDataResponse searchData(SearchDataRequest searchDataRequest) throws ApiException {
        ApiResponse<SearchDataResponse> localVarResp = searchDataWithHttpInfo(searchDataRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Generates an Answer from a given data source. Requires at least
     * view access to the data source object (Worksheet or View). #### Usage guidelines To search
     * data, specify the data source GUID in &#x60;logical_table_identifier&#x60;. The data source
     * can be a Worksheet, View, Table, or SQL view. Pass search tokens in the
     * &#x60;query_string&#x60; attribute in the API request as shown in the following example:
     * &#x60;&#x60;&#x60; { \&quot;query_string\&quot;: \&quot;[sales] by [store]\&quot;,
     * \&quot;logical_table_identifier\&quot;: \&quot;cd252e5c-b552-49a8-821d-3eadaa049cca\&quot;, }
     * &#x60;&#x60;&#x60; For more information about the &#x60;query_string&#x60; format and data
     * source attribute, see [Search data
     * API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_search_data_api).
     * The &#x60;record_size&#x60; attribute determines the number of records to retrieve in an API
     * call. For more information about pagination, record size, and maximum row limit, see
     * [Pagination and record size
     * settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_api).
     *
     * @param searchDataRequest (required)
     * @return ApiResponse&lt;SearchDataResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<SearchDataResponse> searchDataWithHttpInfo(
            SearchDataRequest searchDataRequest) throws ApiException {
        okhttp3.Call localVarCall = searchDataValidateBeforeCall(searchDataRequest, null);
        Type localVarReturnType = new TypeToken<SearchDataResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Generates an Answer from a given data source.
     * Requires at least view access to the data source object (Worksheet or View). #### Usage
     * guidelines To search data, specify the data source GUID in
     * &#x60;logical_table_identifier&#x60;. The data source can be a Worksheet, View, Table, or SQL
     * view. Pass search tokens in the &#x60;query_string&#x60; attribute in the API request as
     * shown in the following example: &#x60;&#x60;&#x60; { \&quot;query_string\&quot;:
     * \&quot;[sales] by [store]\&quot;, \&quot;logical_table_identifier\&quot;:
     * \&quot;cd252e5c-b552-49a8-821d-3eadaa049cca\&quot;, } &#x60;&#x60;&#x60; For more information
     * about the &#x60;query_string&#x60; format and data source attribute, see [Search data
     * API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_search_data_api).
     * The &#x60;record_size&#x60; attribute determines the number of records to retrieve in an API
     * call. For more information about pagination, record size, and maximum row limit, see
     * [Pagination and record size
     * settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_api).
     *
     * @param searchDataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Fetching data of specified metadata object is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchDataAsync(
            SearchDataRequest searchDataRequest, final ApiCallback<SearchDataResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = searchDataValidateBeforeCall(searchDataRequest, _callback);
        Type localVarReturnType = new TypeToken<SearchDataResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchEmailCustomization
     *
     * @param searchEmailCustomizationRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchEmailCustomizationCall(
            SearchEmailCustomizationRequest searchEmailCustomizationRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchEmailCustomizationRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/customization/email/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchEmailCustomizationValidateBeforeCall(
            SearchEmailCustomizationRequest searchEmailCustomizationRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchEmailCustomizationRequest' is set
        if (searchEmailCustomizationRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchEmailCustomizationRequest' when calling"
                            + " searchEmailCustomization(Async)");
        }

        return searchEmailCustomizationCall(searchEmailCustomizationRequest, _callback);
    }

    /**
     * Version: 10.10.0.cl or later Search the email customization configuration if any set for the
     * ThoughtSpot system. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer
     * privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is
     * required. **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable
     * this on your instance.
     *
     * @param searchEmailCustomizationRequest (required)
     * @return List&lt;CreateEmailCustomizationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<CreateEmailCustomizationResponse> searchEmailCustomization(
            SearchEmailCustomizationRequest searchEmailCustomizationRequest) throws ApiException {
        ApiResponse<List<CreateEmailCustomizationResponse>> localVarResp =
                searchEmailCustomizationWithHttpInfo(searchEmailCustomizationRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.10.0.cl or later Search the email customization configuration if any set for the
     * ThoughtSpot system. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer
     * privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is
     * required. **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable
     * this on your instance.
     *
     * @param searchEmailCustomizationRequest (required)
     * @return ApiResponse&lt;List&lt;CreateEmailCustomizationResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<CreateEmailCustomizationResponse>> searchEmailCustomizationWithHttpInfo(
            SearchEmailCustomizationRequest searchEmailCustomizationRequest) throws ApiException {
        okhttp3.Call localVarCall =
                searchEmailCustomizationValidateBeforeCall(searchEmailCustomizationRequest, null);
        Type localVarReturnType =
                new TypeToken<List<CreateEmailCustomizationResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.10.0.cl or later Search the email customization configuration if
     * any set for the ThoughtSpot system. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has
     * developer privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. **NOTE**:This
     * endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.
     *
     * @param searchEmailCustomizationRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchEmailCustomizationAsync(
            SearchEmailCustomizationRequest searchEmailCustomizationRequest,
            final ApiCallback<List<CreateEmailCustomizationResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                searchEmailCustomizationValidateBeforeCall(
                        searchEmailCustomizationRequest, _callback);
        Type localVarReturnType =
                new TypeToken<List<CreateEmailCustomizationResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchMetadata
     *
     * @param searchMetadataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Metadata objects search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchMetadataCall(
            SearchMetadataRequest searchMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchMetadataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchMetadataValidateBeforeCall(
            SearchMetadataRequest searchMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchMetadataRequest' is set
        if (searchMetadataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchMetadataRequest' when calling"
                            + " searchMetadata(Async)");
        }

        return searchMetadataCall(searchMetadataRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Gets a list of metadata objects available on the ThoughtSpot
     * system. This API endpoint is available to all users who have view access to the object. Users
     * with &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privileges can view data for
     * all metadata objects, including users and groups. #### Usage guidelines - To get all metadata
     * objects, send the API request without any attributes. - To get metadata objects of a specific
     * type, set the &#x60;type&#x60; attribute. For example, to fetch a Worksheet, set the type as
     * &#x60;LOGICAL_TABLE&#x60;. - To filter metadata objects within type
     * &#x60;LOGICAL_TABLE&#x60;, set the &#x60;subtypes&#x60; attribute. For example, to fetch a
     * Worksheet, set the type as &#x60;LOGICAL_TABLE&#x60; &amp; subtypes as
     * &#x60;[WORKSHEET]&#x60;. - To get a specific metadata object, specify the GUID. - To
     * customize your search and filter the API response, you can use several parameters. You can
     * search for objects created or modified by specific users, by tags applied to the objects, or
     * by using the include parameters like &#x60;include_auto_created_objects&#x60;,
     * &#x60;include_dependent_objects&#x60;, &#x60;include_headers&#x60;,
     * &#x60;include_incomplete_objects&#x60;, and so on. You can also define sorting options to
     * sort the data retrieved in the API response. - To get discoverable objects when linientmodel
     * is enabled you can use &#x60;include_discoverable_objects&#x60; as true else false. Default
     * value is true. - For liveboard metadata type, to get the newer format, set the
     * &#x60;liveboard_response_format&#x60; as V2. Default value is V1. - To retrieve only objects
     * that are published, set the &#x60;include_only_published_objects&#x60; as true. Default value
     * is false. **NOTE**: The following parameters support pagination of metadata records: -
     * &#x60;tag_identifiers&#x60; - &#x60;type&#x60; - &#x60;subtypes&#x60; -
     * &#x60;created_by_user_identifiers&#x60; - &#x60;modified_by_user_identifiers&#x60; -
     * &#x60;owned_by_user_identifiers&#x60; - &#x60;exclude_objects&#x60; -
     * &#x60;include_auto_created_objects&#x60; - &#x60;favorite_object_options&#x60; -
     * &#x60;include_only_published_objects&#x60; If you are using other parameters to search
     * metadata, set &#x60;record_size&#x60; to &#x60;-1&#x60; and &#x60;record_offset&#x60; to
     * &#x60;0&#x60;.
     *
     * @param searchMetadataRequest (required)
     * @return List&lt;MetadataSearchResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Metadata objects search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<MetadataSearchResponse> searchMetadata(SearchMetadataRequest searchMetadataRequest)
            throws ApiException {
        ApiResponse<List<MetadataSearchResponse>> localVarResp =
                searchMetadataWithHttpInfo(searchMetadataRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Gets a list of metadata objects available on the ThoughtSpot
     * system. This API endpoint is available to all users who have view access to the object. Users
     * with &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privileges can view data for
     * all metadata objects, including users and groups. #### Usage guidelines - To get all metadata
     * objects, send the API request without any attributes. - To get metadata objects of a specific
     * type, set the &#x60;type&#x60; attribute. For example, to fetch a Worksheet, set the type as
     * &#x60;LOGICAL_TABLE&#x60;. - To filter metadata objects within type
     * &#x60;LOGICAL_TABLE&#x60;, set the &#x60;subtypes&#x60; attribute. For example, to fetch a
     * Worksheet, set the type as &#x60;LOGICAL_TABLE&#x60; &amp; subtypes as
     * &#x60;[WORKSHEET]&#x60;. - To get a specific metadata object, specify the GUID. - To
     * customize your search and filter the API response, you can use several parameters. You can
     * search for objects created or modified by specific users, by tags applied to the objects, or
     * by using the include parameters like &#x60;include_auto_created_objects&#x60;,
     * &#x60;include_dependent_objects&#x60;, &#x60;include_headers&#x60;,
     * &#x60;include_incomplete_objects&#x60;, and so on. You can also define sorting options to
     * sort the data retrieved in the API response. - To get discoverable objects when linientmodel
     * is enabled you can use &#x60;include_discoverable_objects&#x60; as true else false. Default
     * value is true. - For liveboard metadata type, to get the newer format, set the
     * &#x60;liveboard_response_format&#x60; as V2. Default value is V1. - To retrieve only objects
     * that are published, set the &#x60;include_only_published_objects&#x60; as true. Default value
     * is false. **NOTE**: The following parameters support pagination of metadata records: -
     * &#x60;tag_identifiers&#x60; - &#x60;type&#x60; - &#x60;subtypes&#x60; -
     * &#x60;created_by_user_identifiers&#x60; - &#x60;modified_by_user_identifiers&#x60; -
     * &#x60;owned_by_user_identifiers&#x60; - &#x60;exclude_objects&#x60; -
     * &#x60;include_auto_created_objects&#x60; - &#x60;favorite_object_options&#x60; -
     * &#x60;include_only_published_objects&#x60; If you are using other parameters to search
     * metadata, set &#x60;record_size&#x60; to &#x60;-1&#x60; and &#x60;record_offset&#x60; to
     * &#x60;0&#x60;.
     *
     * @param searchMetadataRequest (required)
     * @return ApiResponse&lt;List&lt;MetadataSearchResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Metadata objects search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<MetadataSearchResponse>> searchMetadataWithHttpInfo(
            SearchMetadataRequest searchMetadataRequest) throws ApiException {
        okhttp3.Call localVarCall = searchMetadataValidateBeforeCall(searchMetadataRequest, null);
        Type localVarReturnType = new TypeToken<List<MetadataSearchResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Gets a list of metadata objects available on the
     * ThoughtSpot system. This API endpoint is available to all users who have view access to the
     * object. Users with &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privileges can
     * view data for all metadata objects, including users and groups. #### Usage guidelines - To
     * get all metadata objects, send the API request without any attributes. - To get metadata
     * objects of a specific type, set the &#x60;type&#x60; attribute. For example, to fetch a
     * Worksheet, set the type as &#x60;LOGICAL_TABLE&#x60;. - To filter metadata objects within
     * type &#x60;LOGICAL_TABLE&#x60;, set the &#x60;subtypes&#x60; attribute. For example, to fetch
     * a Worksheet, set the type as &#x60;LOGICAL_TABLE&#x60; &amp; subtypes as
     * &#x60;[WORKSHEET]&#x60;. - To get a specific metadata object, specify the GUID. - To
     * customize your search and filter the API response, you can use several parameters. You can
     * search for objects created or modified by specific users, by tags applied to the objects, or
     * by using the include parameters like &#x60;include_auto_created_objects&#x60;,
     * &#x60;include_dependent_objects&#x60;, &#x60;include_headers&#x60;,
     * &#x60;include_incomplete_objects&#x60;, and so on. You can also define sorting options to
     * sort the data retrieved in the API response. - To get discoverable objects when linientmodel
     * is enabled you can use &#x60;include_discoverable_objects&#x60; as true else false. Default
     * value is true. - For liveboard metadata type, to get the newer format, set the
     * &#x60;liveboard_response_format&#x60; as V2. Default value is V1. - To retrieve only objects
     * that are published, set the &#x60;include_only_published_objects&#x60; as true. Default value
     * is false. **NOTE**: The following parameters support pagination of metadata records: -
     * &#x60;tag_identifiers&#x60; - &#x60;type&#x60; - &#x60;subtypes&#x60; -
     * &#x60;created_by_user_identifiers&#x60; - &#x60;modified_by_user_identifiers&#x60; -
     * &#x60;owned_by_user_identifiers&#x60; - &#x60;exclude_objects&#x60; -
     * &#x60;include_auto_created_objects&#x60; - &#x60;favorite_object_options&#x60; -
     * &#x60;include_only_published_objects&#x60; If you are using other parameters to search
     * metadata, set &#x60;record_size&#x60; to &#x60;-1&#x60; and &#x60;record_offset&#x60; to
     * &#x60;0&#x60;.
     *
     * @param searchMetadataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Metadata objects search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchMetadataAsync(
            SearchMetadataRequest searchMetadataRequest,
            final ApiCallback<List<MetadataSearchResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                searchMetadataValidateBeforeCall(searchMetadataRequest, _callback);
        Type localVarReturnType = new TypeToken<List<MetadataSearchResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchOrgs
     *
     * @param searchOrgsRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Organization search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchOrgsCall(
            SearchOrgsRequest searchOrgsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchOrgsRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/orgs/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchOrgsValidateBeforeCall(
            SearchOrgsRequest searchOrgsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'searchOrgsRequest' is set
        if (searchOrgsRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchOrgsRequest' when calling"
                            + " searchOrgs(Async)");
        }

        return searchOrgsCall(searchOrgsRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Gets a list of Orgs configured on the ThoughtSpot system. To get
     * details of a specific Org, specify the Org ID or name. You can also pass parameters such as
     * status, visibility, and user identifiers to get a specific list of Orgs. Requires cluster
     * administration (**Can administer Org**) privileges. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is required.
     *
     * @param searchOrgsRequest (required)
     * @return List&lt;OrgResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Organization search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<OrgResponse> searchOrgs(SearchOrgsRequest searchOrgsRequest) throws ApiException {
        ApiResponse<List<OrgResponse>> localVarResp = searchOrgsWithHttpInfo(searchOrgsRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Gets a list of Orgs configured on the ThoughtSpot system. To get
     * details of a specific Org, specify the Org ID or name. You can also pass parameters such as
     * status, visibility, and user identifiers to get a specific list of Orgs. Requires cluster
     * administration (**Can administer Org**) privileges. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is required.
     *
     * @param searchOrgsRequest (required)
     * @return ApiResponse&lt;List&lt;OrgResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Organization search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<OrgResponse>> searchOrgsWithHttpInfo(
            SearchOrgsRequest searchOrgsRequest) throws ApiException {
        okhttp3.Call localVarCall = searchOrgsValidateBeforeCall(searchOrgsRequest, null);
        Type localVarReturnType = new TypeToken<List<OrgResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Gets a list of Orgs configured on the ThoughtSpot
     * system. To get details of a specific Org, specify the Org ID or name. You can also pass
     * parameters such as status, visibility, and user identifiers to get a specific list of Orgs.
     * Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is required.
     *
     * @param searchOrgsRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Organization search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchOrgsAsync(
            SearchOrgsRequest searchOrgsRequest, final ApiCallback<List<OrgResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = searchOrgsValidateBeforeCall(searchOrgsRequest, _callback);
        Type localVarReturnType = new TypeToken<List<OrgResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchRoles
     *
     * @param searchRolesRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Roles search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchRolesCall(
            SearchRolesRequest searchRolesRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchRolesRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/roles/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchRolesValidateBeforeCall(
            SearchRolesRequest searchRolesRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchRolesRequest' is set
        if (searchRolesRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchRolesRequest' when calling"
                            + " searchRoles(Async)");
        }

        return searchRolesCall(searchRolesRequest, _callback);
    }

    /**
     * Version: 9.5.0.cl or later Gets a list of Role objects from the ThoughtSpot system. Available
     * if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance. To search for Roles, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can
     * manage roles**) privilege is required. To get details of a specific Role object, specify the
     * GUID or name. You can also filter the API response based on user group and Org identifiers,
     * privileges assigned to the Role, and deprecation status.
     *
     * @param searchRolesRequest (required)
     * @return List&lt;SearchRoleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Roles search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public List<SearchRoleResponse> searchRoles(SearchRolesRequest searchRolesRequest)
            throws ApiException {
        ApiResponse<List<SearchRoleResponse>> localVarResp =
                searchRolesWithHttpInfo(searchRolesRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.5.0.cl or later Gets a list of Role objects from the ThoughtSpot system. Available
     * if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance. To search for Roles, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can
     * manage roles**) privilege is required. To get details of a specific Role object, specify the
     * GUID or name. You can also filter the API response based on user group and Org identifiers,
     * privileges assigned to the Role, and deprecation status.
     *
     * @param searchRolesRequest (required)
     * @return ApiResponse&lt;List&lt;SearchRoleResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Roles search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<SearchRoleResponse>> searchRolesWithHttpInfo(
            SearchRolesRequest searchRolesRequest) throws ApiException {
        okhttp3.Call localVarCall = searchRolesValidateBeforeCall(searchRolesRequest, null);
        Type localVarReturnType = new TypeToken<List<SearchRoleResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.5.0.cl or later Gets a list of Role objects from the ThoughtSpot
     * system. Available if [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To search
     * for Roles, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can manage roles**) privilege is required.
     * To get details of a specific Role object, specify the GUID or name. You can also filter the
     * API response based on user group and Org identifiers, privileges assigned to the Role, and
     * deprecation status.
     *
     * @param searchRolesRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Roles search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchRolesAsync(
            SearchRolesRequest searchRolesRequest,
            final ApiCallback<List<SearchRoleResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = searchRolesValidateBeforeCall(searchRolesRequest, _callback);
        Type localVarReturnType = new TypeToken<List<SearchRoleResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchSchedules
     *
     * @param searchSchedulesRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Schedule search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchSchedulesCall(
            SearchSchedulesRequest searchSchedulesRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchSchedulesRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/schedules/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchSchedulesValidateBeforeCall(
            SearchSchedulesRequest searchSchedulesRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchSchedulesRequest' is set
        if (searchSchedulesRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchSchedulesRequest' when calling"
                            + " searchSchedules(Async)");
        }

        return searchSchedulesCall(searchSchedulesRequest, _callback);
    }

    /**
     * Search Schedules Version: 9.4.0.cl or later Gets a list of scheduled jobs configured for a
     * Liveboard. To get details of a specific scheduled job, specify the name or GUID of the
     * scheduled job. Requires at least view access to Liveboards. **NOTE**: When filtering
     * schedules by parameters other than &#x60;metadata&#x60;, set &#x60;record_size&#x60; to
     * &#x60;-1&#x60; and &#x60;record_offset&#x60; to &#x60;0&#x60; for accurate results.
     *
     * @param searchSchedulesRequest (required)
     * @return List&lt;ResponseSchedule&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Schedule search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<ResponseSchedule> searchSchedules(SearchSchedulesRequest searchSchedulesRequest)
            throws ApiException {
        ApiResponse<List<ResponseSchedule>> localVarResp =
                searchSchedulesWithHttpInfo(searchSchedulesRequest);
        return localVarResp.getData();
    }

    /**
     * Search Schedules Version: 9.4.0.cl or later Gets a list of scheduled jobs configured for a
     * Liveboard. To get details of a specific scheduled job, specify the name or GUID of the
     * scheduled job. Requires at least view access to Liveboards. **NOTE**: When filtering
     * schedules by parameters other than &#x60;metadata&#x60;, set &#x60;record_size&#x60; to
     * &#x60;-1&#x60; and &#x60;record_offset&#x60; to &#x60;0&#x60; for accurate results.
     *
     * @param searchSchedulesRequest (required)
     * @return ApiResponse&lt;List&lt;ResponseSchedule&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Schedule search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<ResponseSchedule>> searchSchedulesWithHttpInfo(
            SearchSchedulesRequest searchSchedulesRequest) throws ApiException {
        okhttp3.Call localVarCall = searchSchedulesValidateBeforeCall(searchSchedulesRequest, null);
        Type localVarReturnType = new TypeToken<List<ResponseSchedule>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Search Schedules Version: 9.4.0.cl or later Gets a list of scheduled jobs
     * configured for a Liveboard. To get details of a specific scheduled job, specify the name or
     * GUID of the scheduled job. Requires at least view access to Liveboards. **NOTE**: When
     * filtering schedules by parameters other than &#x60;metadata&#x60;, set
     * &#x60;record_size&#x60; to &#x60;-1&#x60; and &#x60;record_offset&#x60; to &#x60;0&#x60; for
     * accurate results.
     *
     * @param searchSchedulesRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Schedule search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchSchedulesAsync(
            SearchSchedulesRequest searchSchedulesRequest,
            final ApiCallback<List<ResponseSchedule>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                searchSchedulesValidateBeforeCall(searchSchedulesRequest, _callback);
        Type localVarReturnType = new TypeToken<List<ResponseSchedule>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchTags
     *
     * @param searchTagsRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Tags search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchTagsCall(
            SearchTagsRequest searchTagsRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchTagsRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/tags/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchTagsValidateBeforeCall(
            SearchTagsRequest searchTagsRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'searchTagsRequest' is set
        if (searchTagsRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchTagsRequest' when calling"
                            + " searchTags(Async)");
        }

        return searchTagsCall(searchTagsRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Gets a list of tag objects available on the ThoughtSpot system. To
     * get details of a specific tag object, specify the GUID or name. Any authenticated user can
     * search for tag objects.
     *
     * @param searchTagsRequest (required)
     * @return List&lt;Tag&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Tags search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<Tag> searchTags(SearchTagsRequest searchTagsRequest) throws ApiException {
        ApiResponse<List<Tag>> localVarResp = searchTagsWithHttpInfo(searchTagsRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Gets a list of tag objects available on the ThoughtSpot system. To
     * get details of a specific tag object, specify the GUID or name. Any authenticated user can
     * search for tag objects.
     *
     * @param searchTagsRequest (required)
     * @return ApiResponse&lt;List&lt;Tag&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Tags search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<Tag>> searchTagsWithHttpInfo(SearchTagsRequest searchTagsRequest)
            throws ApiException {
        okhttp3.Call localVarCall = searchTagsValidateBeforeCall(searchTagsRequest, null);
        Type localVarReturnType = new TypeToken<List<Tag>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Gets a list of tag objects available on the
     * ThoughtSpot system. To get details of a specific tag object, specify the GUID or name. Any
     * authenticated user can search for tag objects.
     *
     * @param searchTagsRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Tags search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchTagsAsync(
            SearchTagsRequest searchTagsRequest, final ApiCallback<List<Tag>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = searchTagsValidateBeforeCall(searchTagsRequest, _callback);
        Type localVarReturnType = new TypeToken<List<Tag>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchUserGroups
     *
     * @param searchUserGroupsRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User group search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchUserGroupsCall(
            SearchUserGroupsRequest searchUserGroupsRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchUserGroupsRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/groups/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchUserGroupsValidateBeforeCall(
            SearchUserGroupsRequest searchUserGroupsRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchUserGroupsRequest' is set
        if (searchUserGroupsRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchUserGroupsRequest' when calling"
                            + " searchUserGroups(Async)");
        }

        return searchUserGroupsCall(searchUserGroupsRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Gets a list of user group objects from the ThoughtSpot system. To
     * get details of a specific user group, specify the user group GUID or name. You can also
     * filter the API response based on User ID, Org ID, Role ID, type of group, sharing visibility,
     * privileges assigned to the group, and the Liveboard IDs assigned to the users in the group.
     * Available to all users. Users with &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privileges can view all users properties. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is required. **NOTE**: If
     * you do not get precise results, try setting &#x60;record_size&#x60; to &#x60;-1&#x60; and
     * &#x60;record_offset&#x60; to &#x60;0&#x60;.
     *
     * @param searchUserGroupsRequest (required)
     * @return List&lt;UserGroupResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User group search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<UserGroupResponse> searchUserGroups(SearchUserGroupsRequest searchUserGroupsRequest)
            throws ApiException {
        ApiResponse<List<UserGroupResponse>> localVarResp =
                searchUserGroupsWithHttpInfo(searchUserGroupsRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Gets a list of user group objects from the ThoughtSpot system. To
     * get details of a specific user group, specify the user group GUID or name. You can also
     * filter the API response based on User ID, Org ID, Role ID, type of group, sharing visibility,
     * privileges assigned to the group, and the Liveboard IDs assigned to the users in the group.
     * Available to all users. Users with &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privileges can view all users properties. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is required. **NOTE**: If
     * you do not get precise results, try setting &#x60;record_size&#x60; to &#x60;-1&#x60; and
     * &#x60;record_offset&#x60; to &#x60;0&#x60;.
     *
     * @param searchUserGroupsRequest (required)
     * @return ApiResponse&lt;List&lt;UserGroupResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User group search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<UserGroupResponse>> searchUserGroupsWithHttpInfo(
            SearchUserGroupsRequest searchUserGroupsRequest) throws ApiException {
        okhttp3.Call localVarCall =
                searchUserGroupsValidateBeforeCall(searchUserGroupsRequest, null);
        Type localVarReturnType = new TypeToken<List<UserGroupResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Gets a list of user group objects from the
     * ThoughtSpot system. To get details of a specific user group, specify the user group GUID or
     * name. You can also filter the API response based on User ID, Org ID, Role ID, type of group,
     * sharing visibility, privileges assigned to the group, and the Liveboard IDs assigned to the
     * users in the group. Available to all users. Users with &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privileges can view all users properties. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is required. **NOTE**:
     * If you do not get precise results, try setting &#x60;record_size&#x60; to &#x60;-1&#x60; and
     * &#x60;record_offset&#x60; to &#x60;0&#x60;.
     *
     * @param searchUserGroupsRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User group search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchUserGroupsAsync(
            SearchUserGroupsRequest searchUserGroupsRequest,
            final ApiCallback<List<UserGroupResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                searchUserGroupsValidateBeforeCall(searchUserGroupsRequest, _callback);
        Type localVarReturnType = new TypeToken<List<UserGroupResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchUsers
     *
     * @param searchUsersRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchUsersCall(
            SearchUsersRequest searchUsersRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchUsersRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/users/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchUsersValidateBeforeCall(
            SearchUsersRequest searchUsersRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchUsersRequest' is set
        if (searchUsersRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchUsersRequest' when calling"
                            + " searchUsers(Async)");
        }

        return searchUsersCall(searchUsersRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Gets a list of users available on the ThoughtSpot system. To get
     * details of a specific user, specify the user GUID or name. You can also filter the API
     * response based on groups, Org ID, user visibility, account status, user type, and user
     * preference settings and favorites. Available to all users. Users with
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privileges can view all users
     * properties. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required. **NOTE**: If
     * the API returns an empty list, consider increasing the value of the &#x60;record_size&#x60;
     * parameter. To search across all available users, set &#x60;record_size&#x60; to
     * &#x60;-1&#x60;.
     *
     * @param searchUsersRequest (required)
     * @return List&lt;User&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<User> searchUsers(SearchUsersRequest searchUsersRequest) throws ApiException {
        ApiResponse<List<User>> localVarResp = searchUsersWithHttpInfo(searchUsersRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.0.0.cl or later Gets a list of users available on the ThoughtSpot system. To get
     * details of a specific user, specify the user GUID or name. You can also filter the API
     * response based on groups, Org ID, user visibility, account status, user type, and user
     * preference settings and favorites. Available to all users. Users with
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privileges can view all users
     * properties. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required. **NOTE**: If
     * the API returns an empty list, consider increasing the value of the &#x60;record_size&#x60;
     * parameter. To search across all available users, set &#x60;record_size&#x60; to
     * &#x60;-1&#x60;.
     *
     * @param searchUsersRequest (required)
     * @return ApiResponse&lt;List&lt;User&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<User>> searchUsersWithHttpInfo(SearchUsersRequest searchUsersRequest)
            throws ApiException {
        okhttp3.Call localVarCall = searchUsersValidateBeforeCall(searchUsersRequest, null);
        Type localVarReturnType = new TypeToken<List<User>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Gets a list of users available on the ThoughtSpot
     * system. To get details of a specific user, specify the user GUID or name. You can also filter
     * the API response based on groups, Org ID, user visibility, account status, user type, and
     * user preference settings and favorites. Available to all users. Users with
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privileges can view all users
     * properties. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required. **NOTE**: If
     * the API returns an empty list, consider increasing the value of the &#x60;record_size&#x60;
     * parameter. To search across all available users, set &#x60;record_size&#x60; to
     * &#x60;-1&#x60;.
     *
     * @param searchUsersRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> User search result. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchUsersAsync(
            SearchUsersRequest searchUsersRequest, final ApiCallback<List<User>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = searchUsersValidateBeforeCall(searchUsersRequest, _callback);
        Type localVarReturnType = new TypeToken<List<User>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for searchVariables
     *
     * @param searchVariablesRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> List of variables is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchVariablesCall(
            SearchVariablesRequest searchVariablesRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = searchVariablesRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/template/variables/search";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call searchVariablesValidateBeforeCall(
            SearchVariablesRequest searchVariablesRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'searchVariablesRequest' is set
        if (searchVariablesRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'searchVariablesRequest' when calling"
                            + " searchVariables(Async)");
        }

        return searchVariablesCall(searchVariablesRequest, _callback);
    }

    /**
     * Search variables Version: 10.9.0.cl or later Allows searching for variables in ThoughtSpot.
     * Requires ADMINISTRATION role. The API endpoint supports searching variables by: * Variable
     * identifier (ID or name) * Variable type * Name pattern (case-insensitive, supports % for
     * wildcard) The search results can be formatted in three ways: * METADATA_ONLY - Returns only
     * variable metadata (default) * METADATA_AND_VALUES - Returns variable metadata and values *
     * EDITABLE_METADATA_AND_VALUES - Returns only editable variable metadata and values The values
     * can be filtered by scope: * org_identifier * principal_identifier * model_identifier
     *
     * @param searchVariablesRequest (required)
     * @return List&lt;Variable&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> List of variables is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<Variable> searchVariables(SearchVariablesRequest searchVariablesRequest)
            throws ApiException {
        ApiResponse<List<Variable>> localVarResp =
                searchVariablesWithHttpInfo(searchVariablesRequest);
        return localVarResp.getData();
    }

    /**
     * Search variables Version: 10.9.0.cl or later Allows searching for variables in ThoughtSpot.
     * Requires ADMINISTRATION role. The API endpoint supports searching variables by: * Variable
     * identifier (ID or name) * Variable type * Name pattern (case-insensitive, supports % for
     * wildcard) The search results can be formatted in three ways: * METADATA_ONLY - Returns only
     * variable metadata (default) * METADATA_AND_VALUES - Returns variable metadata and values *
     * EDITABLE_METADATA_AND_VALUES - Returns only editable variable metadata and values The values
     * can be filtered by scope: * org_identifier * principal_identifier * model_identifier
     *
     * @param searchVariablesRequest (required)
     * @return ApiResponse&lt;List&lt;Variable&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> List of variables is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<Variable>> searchVariablesWithHttpInfo(
            SearchVariablesRequest searchVariablesRequest) throws ApiException {
        okhttp3.Call localVarCall = searchVariablesValidateBeforeCall(searchVariablesRequest, null);
        Type localVarReturnType = new TypeToken<List<Variable>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Search variables Version: 10.9.0.cl or later Allows searching for variables
     * in ThoughtSpot. Requires ADMINISTRATION role. The API endpoint supports searching variables
     * by: * Variable identifier (ID or name) * Variable type * Name pattern (case-insensitive,
     * supports % for wildcard) The search results can be formatted in three ways: * METADATA_ONLY -
     * Returns only variable metadata (default) * METADATA_AND_VALUES - Returns variable metadata
     * and values * EDITABLE_METADATA_AND_VALUES - Returns only editable variable metadata and
     * values The values can be filtered by scope: * org_identifier * principal_identifier *
     * model_identifier
     *
     * @param searchVariablesRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> List of variables is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call searchVariablesAsync(
            SearchVariablesRequest searchVariablesRequest,
            final ApiCallback<List<Variable>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                searchVariablesValidateBeforeCall(searchVariablesRequest, _callback);
        Type localVarReturnType = new TypeToken<List<Variable>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for sendMessage
     *
     * @param conversationIdentifier Unique identifier of the conversation. (required)
     * @param sendMessageRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call sendMessageCall(
            String conversationIdentifier,
            SendMessageRequest sendMessageRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = sendMessageRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/ai/conversation/{conversation_identifier}/converse"
                        .replace(
                                "{" + "conversation_identifier" + "}",
                                localVarApiClient.escapeString(conversationIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call sendMessageValidateBeforeCall(
            String conversationIdentifier,
            SendMessageRequest sendMessageRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'conversationIdentifier' is set
        if (conversationIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'conversationIdentifier' when calling"
                            + " sendMessage(Async)");
        }

        // verify the required parameter 'sendMessageRequest' is set
        if (sendMessageRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'sendMessageRequest' when calling"
                            + " sendMessage(Async)");
        }

        return sendMessageCall(conversationIdentifier, sendMessageRequest, _callback);
    }

    /**
     * Version: 10.4.0.cl or later Allows sending a follow-up message to an ongoing conversation
     * within the context of the metadata model. Requires at least view access to the metadata
     * object specified in the request. #### Usage guidelines The API requires you to specify the
     * &#x60;conversation_identifier&#x60; in the request path, and a
     * &#x60;metadata_identifier&#x60; and &#x60;message&#x60; string in the request body. If the
     * API request is successful, ThoughtSpot returns the session ID, tokens used in the
     * conversation, and visualization type. &gt; ###### Note: &gt; * This endpoint is currently in
     * Beta. Breaking changes may be introduced before the endpoint is made Generally Available.
     * &gt; * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter
     * on your cluster.
     *
     * @param conversationIdentifier Unique identifier of the conversation. (required)
     * @param sendMessageRequest (required)
     * @return List&lt;ResponseMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public List<ResponseMessage> sendMessage(
            String conversationIdentifier, SendMessageRequest sendMessageRequest)
            throws ApiException {
        ApiResponse<List<ResponseMessage>> localVarResp =
                sendMessageWithHttpInfo(conversationIdentifier, sendMessageRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.4.0.cl or later Allows sending a follow-up message to an ongoing conversation
     * within the context of the metadata model. Requires at least view access to the metadata
     * object specified in the request. #### Usage guidelines The API requires you to specify the
     * &#x60;conversation_identifier&#x60; in the request path, and a
     * &#x60;metadata_identifier&#x60; and &#x60;message&#x60; string in the request body. If the
     * API request is successful, ThoughtSpot returns the session ID, tokens used in the
     * conversation, and visualization type. &gt; ###### Note: &gt; * This endpoint is currently in
     * Beta. Breaking changes may be introduced before the endpoint is made Generally Available.
     * &gt; * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter
     * on your cluster.
     *
     * @param conversationIdentifier Unique identifier of the conversation. (required)
     * @param sendMessageRequest (required)
     * @return ApiResponse&lt;List&lt;ResponseMessage&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<ResponseMessage>> sendMessageWithHttpInfo(
            String conversationIdentifier, SendMessageRequest sendMessageRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                sendMessageValidateBeforeCall(conversationIdentifier, sendMessageRequest, null);
        Type localVarReturnType = new TypeToken<List<ResponseMessage>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.4.0.cl or later Allows sending a follow-up message to an ongoing
     * conversation within the context of the metadata model. Requires at least view access to the
     * metadata object specified in the request. #### Usage guidelines The API requires you to
     * specify the &#x60;conversation_identifier&#x60; in the request path, and a
     * &#x60;metadata_identifier&#x60; and &#x60;message&#x60; string in the request body. If the
     * API request is successful, ThoughtSpot returns the session ID, tokens used in the
     * conversation, and visualization type. &gt; ###### Note: &gt; * This endpoint is currently in
     * Beta. Breaking changes may be introduced before the endpoint is made Generally Available.
     * &gt; * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter
     * on your cluster.
     *
     * @param conversationIdentifier Unique identifier of the conversation. (required)
     * @param sendMessageRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call sendMessageAsync(
            String conversationIdentifier,
            SendMessageRequest sendMessageRequest,
            final ApiCallback<List<ResponseMessage>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                sendMessageValidateBeforeCall(
                        conversationIdentifier, sendMessageRequest, _callback);
        Type localVarReturnType = new TypeToken<List<ResponseMessage>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for shareMetadata
     *
     * @param shareMetadataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Sharing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call shareMetadataCall(
            ShareMetadataRequest shareMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = shareMetadataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/security/metadata/share";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call shareMetadataValidateBeforeCall(
            ShareMetadataRequest shareMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'shareMetadataRequest' is set
        if (shareMetadataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'shareMetadataRequest' when calling"
                            + " shareMetadata(Async)");
        }

        return shareMetadataCall(shareMetadataRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Allows sharing one or several metadata objects with users and
     * groups in ThoughtSpot. Requires edit access to the metadata object. The API endpoint allows
     * sharing only the following types of metadata objects: * Liveboards * Visualizations * Answers
     * * Worksheets * Views * Connections You can provide &#x60;READ_ONLY&#x60; or
     * &#x60;MODIFY&#x60; access when sharing an object with another user or group. With
     * &#x60;READ_ONLY&#x60; access grants view access to the shared object, whereas
     * &#x60;MODIFY&#x60; provides edit access. To prevent a user or group from accessing the shared
     * object, specify the GUID or name of the principal and set &#x60;shareMode&#x60; to
     * &#x60;NO_ACCESS&#x60;.
     *
     * @param shareMetadataRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Sharing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void shareMetadata(ShareMetadataRequest shareMetadataRequest) throws ApiException {
        shareMetadataWithHttpInfo(shareMetadataRequest);
    }

    /**
     * Version: 9.0.0.cl or later Allows sharing one or several metadata objects with users and
     * groups in ThoughtSpot. Requires edit access to the metadata object. The API endpoint allows
     * sharing only the following types of metadata objects: * Liveboards * Visualizations * Answers
     * * Worksheets * Views * Connections You can provide &#x60;READ_ONLY&#x60; or
     * &#x60;MODIFY&#x60; access when sharing an object with another user or group. With
     * &#x60;READ_ONLY&#x60; access grants view access to the shared object, whereas
     * &#x60;MODIFY&#x60; provides edit access. To prevent a user or group from accessing the shared
     * object, specify the GUID or name of the principal and set &#x60;shareMode&#x60; to
     * &#x60;NO_ACCESS&#x60;.
     *
     * @param shareMetadataRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Sharing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> shareMetadataWithHttpInfo(ShareMetadataRequest shareMetadataRequest)
            throws ApiException {
        okhttp3.Call localVarCall = shareMetadataValidateBeforeCall(shareMetadataRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Allows sharing one or several metadata objects
     * with users and groups in ThoughtSpot. Requires edit access to the metadata object. The API
     * endpoint allows sharing only the following types of metadata objects: * Liveboards *
     * Visualizations * Answers * Worksheets * Views * Connections You can provide
     * &#x60;READ_ONLY&#x60; or &#x60;MODIFY&#x60; access when sharing an object with another user
     * or group. With &#x60;READ_ONLY&#x60; access grants view access to the shared object, whereas
     * &#x60;MODIFY&#x60; provides edit access. To prevent a user or group from accessing the shared
     * object, specify the GUID or name of the principal and set &#x60;shareMode&#x60; to
     * &#x60;NO_ACCESS&#x60;.
     *
     * @param shareMetadataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Sharing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call shareMetadataAsync(
            ShareMetadataRequest shareMetadataRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                shareMetadataValidateBeforeCall(shareMetadataRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for singleAnswer
     *
     * @param singleAnswerRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call singleAnswerCall(
            SingleAnswerRequest singleAnswerRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = singleAnswerRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/ai/answer/create";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call singleAnswerValidateBeforeCall(
            SingleAnswerRequest singleAnswerRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'singleAnswerRequest' is set
        if (singleAnswerRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'singleAnswerRequest' when calling"
                            + " singleAnswer(Async)");
        }

        return singleAnswerCall(singleAnswerRequest, _callback);
    }

    /**
     * Version: 10.4.0.cl or later Processes a natural language query and returns an AI-generated
     * response based on a specified data model. Requires at least view access to the metadata
     * object specified in the request. &gt; ###### Note: &gt; * This endpoint is currently in Beta.
     * Breaking changes may be introduced before the endpoint is made Generally Available. &gt; *
     * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your
     * cluster.
     *
     * @param singleAnswerRequest (required)
     * @return ResponseMessage
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public ResponseMessage singleAnswer(SingleAnswerRequest singleAnswerRequest)
            throws ApiException {
        ApiResponse<ResponseMessage> localVarResp = singleAnswerWithHttpInfo(singleAnswerRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 10.4.0.cl or later Processes a natural language query and returns an AI-generated
     * response based on a specified data model. Requires at least view access to the metadata
     * object specified in the request. &gt; ###### Note: &gt; * This endpoint is currently in Beta.
     * Breaking changes may be introduced before the endpoint is made Generally Available. &gt; *
     * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your
     * cluster.
     *
     * @param singleAnswerRequest (required)
     * @return ApiResponse&lt;ResponseMessage&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<ResponseMessage> singleAnswerWithHttpInfo(
            SingleAnswerRequest singleAnswerRequest) throws ApiException {
        okhttp3.Call localVarCall = singleAnswerValidateBeforeCall(singleAnswerRequest, null);
        Type localVarReturnType = new TypeToken<ResponseMessage>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 10.4.0.cl or later Processes a natural language query and returns
     * an AI-generated response based on a specified data model. Requires at least view access to
     * the metadata object specified in the request. &gt; ###### Note: &gt; * This endpoint is
     * currently in Beta. Breaking changes may be introduced before the endpoint is made Generally
     * Available. &gt; * This endpoint requires Spotter - please contact ThoughtSpot support to
     * enable Spotter on your cluster.
     *
     * @param singleAnswerRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Common successful response </td><td>  -  </td></tr>
     * <tr><td> 201 </td><td> Common error response </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Operation failed </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Operation failed </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call singleAnswerAsync(
            SingleAnswerRequest singleAnswerRequest, final ApiCallback<ResponseMessage> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = singleAnswerValidateBeforeCall(singleAnswerRequest, _callback);
        Type localVarReturnType = new TypeToken<ResponseMessage>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for unassignTag
     *
     * @param assignTagRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tags successfully unassigned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call unassignTagCall(
            AssignTagRequest assignTagRequest, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = assignTagRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/tags/unassign";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call unassignTagValidateBeforeCall(
            AssignTagRequest assignTagRequest, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'assignTagRequest' is set
        if (assignTagRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'assignTagRequest' when calling"
                            + " unassignTag(Async)");
        }

        return unassignTagCall(assignTagRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Removes the tags applied to a Liveboard, Answer, Table, or
     * Worksheet. Requires edit access to the metadata object.
     *
     * @param assignTagRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tags successfully unassigned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void unassignTag(AssignTagRequest assignTagRequest) throws ApiException {
        unassignTagWithHttpInfo(assignTagRequest);
    }

    /**
     * Version: 9.0.0.cl or later Removes the tags applied to a Liveboard, Answer, Table, or
     * Worksheet. Requires edit access to the metadata object.
     *
     * @param assignTagRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tags successfully unassigned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> unassignTagWithHttpInfo(AssignTagRequest assignTagRequest)
            throws ApiException {
        okhttp3.Call localVarCall = unassignTagValidateBeforeCall(assignTagRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Removes the tags applied to a Liveboard, Answer,
     * Table, or Worksheet. Requires edit access to the metadata object.
     *
     * @param assignTagRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tags successfully unassigned. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call unassignTagAsync(
            AssignTagRequest assignTagRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = unassignTagValidateBeforeCall(assignTagRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for unparameterizeMetadata
     *
     * @param unparameterizeMetadataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfuly removed parameters. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call unparameterizeMetadataCall(
            UnparameterizeMetadataRequest unparameterizeMetadataRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = unparameterizeMetadataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/unparameterize";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call unparameterizeMetadataValidateBeforeCall(
            UnparameterizeMetadataRequest unparameterizeMetadataRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'unparameterizeMetadataRequest' is set
        if (unparameterizeMetadataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'unparameterizeMetadataRequest' when calling"
                            + " unparameterizeMetadata(Async)");
        }

        return unparameterizeMetadataCall(unparameterizeMetadataRequest, _callback);
    }

    /**
     * Remove parameterization from fields in metadata objects. Version: 10.9.0.cl or later Allows
     * removing parameterization from fields in metadata objects in ThoughtSpot. Requires
     * appropriate permissions to modify the metadata object. The API endpoint allows
     * unparameterizing the following types of metadata objects: * Logical Tables * Connections For
     * a Logical Table the field type must be &#x60;ATTRIBUTE&#x60; and field name can be one of: *
     * databaseName * schemaName * tableName For a Connection the field type is always
     * &#x60;CONNECTION_PROPERTY&#x60;. We use the field_name in this case to specify the exact
     * property of a connection which needs to be unparameterized.
     *
     * @param unparameterizeMetadataRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfuly removed parameters. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void unparameterizeMetadata(UnparameterizeMetadataRequest unparameterizeMetadataRequest)
            throws ApiException {
        unparameterizeMetadataWithHttpInfo(unparameterizeMetadataRequest);
    }

    /**
     * Remove parameterization from fields in metadata objects. Version: 10.9.0.cl or later Allows
     * removing parameterization from fields in metadata objects in ThoughtSpot. Requires
     * appropriate permissions to modify the metadata object. The API endpoint allows
     * unparameterizing the following types of metadata objects: * Logical Tables * Connections For
     * a Logical Table the field type must be &#x60;ATTRIBUTE&#x60; and field name can be one of: *
     * databaseName * schemaName * tableName For a Connection the field type is always
     * &#x60;CONNECTION_PROPERTY&#x60;. We use the field_name in this case to specify the exact
     * property of a connection which needs to be unparameterized.
     *
     * @param unparameterizeMetadataRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfuly removed parameters. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> unparameterizeMetadataWithHttpInfo(
            UnparameterizeMetadataRequest unparameterizeMetadataRequest) throws ApiException {
        okhttp3.Call localVarCall =
                unparameterizeMetadataValidateBeforeCall(unparameterizeMetadataRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Remove parameterization from fields in metadata objects. Version: 10.9.0.cl
     * or later Allows removing parameterization from fields in metadata objects in ThoughtSpot.
     * Requires appropriate permissions to modify the metadata object. The API endpoint allows
     * unparameterizing the following types of metadata objects: * Logical Tables * Connections For
     * a Logical Table the field type must be &#x60;ATTRIBUTE&#x60; and field name can be one of: *
     * databaseName * schemaName * tableName For a Connection the field type is always
     * &#x60;CONNECTION_PROPERTY&#x60;. We use the field_name in this case to specify the exact
     * property of a connection which needs to be unparameterized.
     *
     * @param unparameterizeMetadataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfuly removed parameters. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call unparameterizeMetadataAsync(
            UnparameterizeMetadataRequest unparameterizeMetadataRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                unparameterizeMetadataValidateBeforeCall(unparameterizeMetadataRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for unpublishMetadata
     *
     * @param unpublishMetadataRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Unpublishing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call unpublishMetadataCall(
            UnpublishMetadataRequest unpublishMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = unpublishMetadataRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/security/metadata/unpublish";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call unpublishMetadataValidateBeforeCall(
            UnpublishMetadataRequest unpublishMetadataRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'unpublishMetadataRequest' is set
        if (unpublishMetadataRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'unpublishMetadataRequest' when calling"
                            + " unpublishMetadata(Async)");
        }

        return unpublishMetadataCall(unpublishMetadataRequest, _callback);
    }

    /**
     * Version: 10.9.0.cl or later Allows unpublishing metadata objects from organizations in
     * ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The API endpoint allows
     * unpublishing the following types of metadata objects: * Liveboards * Answers * Logical Tables
     * When unpublishing objects, you can: * Include dependencies by setting
     * &#x60;include_dependencies&#x60; to true - this will unpublish all dependent objects if no
     * other published object is using them * Force unpublish by setting &#x60;force&#x60; to true -
     * this will break all dependent objects in the unpublished organizations
     *
     * @param unpublishMetadataRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Unpublishing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void unpublishMetadata(UnpublishMetadataRequest unpublishMetadataRequest)
            throws ApiException {
        unpublishMetadataWithHttpInfo(unpublishMetadataRequest);
    }

    /**
     * Version: 10.9.0.cl or later Allows unpublishing metadata objects from organizations in
     * ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The API endpoint allows
     * unpublishing the following types of metadata objects: * Liveboards * Answers * Logical Tables
     * When unpublishing objects, you can: * Include dependencies by setting
     * &#x60;include_dependencies&#x60; to true - this will unpublish all dependent objects if no
     * other published object is using them * Force unpublish by setting &#x60;force&#x60; to true -
     * this will break all dependent objects in the unpublished organizations
     *
     * @param unpublishMetadataRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Unpublishing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> unpublishMetadataWithHttpInfo(
            UnpublishMetadataRequest unpublishMetadataRequest) throws ApiException {
        okhttp3.Call localVarCall =
                unpublishMetadataValidateBeforeCall(unpublishMetadataRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.9.0.cl or later Allows unpublishing metadata objects from
     * organizations in ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The API endpoint
     * allows unpublishing the following types of metadata objects: * Liveboards * Answers * Logical
     * Tables When unpublishing objects, you can: * Include dependencies by setting
     * &#x60;include_dependencies&#x60; to true - this will unpublish all dependent objects if no
     * other published object is using them * Force unpublish by setting &#x60;force&#x60; to true -
     * this will break all dependent objects in the unpublished organizations
     *
     * @param unpublishMetadataRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Unpublishing metadata objects is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call unpublishMetadataAsync(
            UnpublishMetadataRequest unpublishMetadataRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                unpublishMetadataValidateBeforeCall(unpublishMetadataRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCalendar
     *
     * @param calendarIdentifier Unique Id or name of the calendar. (required)
     * @param updateCalendarRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom calendar updated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateCalendarCall(
            String calendarIdentifier,
            UpdateCalendarRequest updateCalendarRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateCalendarRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/calendars/{calendar_identifier}/update"
                        .replace(
                                "{" + "calendar_identifier" + "}",
                                localVarApiClient.escapeString(calendarIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCalendarValidateBeforeCall(
            String calendarIdentifier,
            UpdateCalendarRequest updateCalendarRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'calendarIdentifier' is set
        if (calendarIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'calendarIdentifier' when calling"
                            + " updateCalendar(Async)");
        }

        // verify the required parameter 'updateCalendarRequest' is set
        if (updateCalendarRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateCalendarRequest' when calling"
                            + " updateCalendar(Async)");
        }

        return updateCalendarCall(calendarIdentifier, updateCalendarRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Updates the properties of a [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines You can update the properties of a calendar
     * using one of the following methods: * &#x60;FROM_INPUT_PARAMS&#x60; to update the calendar
     * properties with the values defined in the API request. * &#x60;FROM_EXISTING_TABLE&#x60;
     * Creates a calendar from the parameters defined in the API request. To update a custom
     * calendar, specify the calendar ID as a path parameter in the request URL and the following
     * parameters in the request body: * Connection ID and Table name * Database and schema name
     * attributes: For most Cloud Data Warehouse (CDW) connectors, both &#x60;database_name&#x60;
     * and &#x60;schema_name&#x60; attributes are required. However, the attribute requirements are
     * conditional and vary based on the connector type and its metadata structure. For example, for
     * connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL,
     * Oracle, and GCP_MYSQL, the &#x60;schema_name&#x60; is required, whereas the
     * &#x60;database_name&#x60; attribute is not. Similarly, connectors such as ClickHouse require
     * you to specify the &#x60;database_name&#x60; and the schema specification in such cases is
     * optional. The API allows you to modify the calendar type, month offset value, start and end
     * date, starting day of the week, and prefixes assigned to the year and quarter labels. ####
     * Examples Update a custom calendar using an existing Table in ThoughtSpot: &#x60;&#x60;&#x60;
     * { \&quot;update_method\&quot;: \&quot;FROM_EXISTING_TABLE\&quot;,
     * \&quot;table_reference\&quot;: { \&quot;connection_identifier\&quot;:
     * \&quot;Connection1\&quot;, \&quot;database_name\&quot;: \&quot;db1\&quot;,
     * \&quot;table_name\&quot;: \&quot;custom_calendar_2025\&quot;, \&quot;schame_name\&quot;:
     * \&quot;schemaVar\&quot; } } &#x60;&#x60;&#x60; Update a custom calendar with the attributes
     * defined in the API request: &#x60;&#x60;&#x60; { \&quot;update_method\&quot;:
     * \&quot;FROM_INPUT_PARAMS\&quot;, \&quot;table_reference\&quot;: {
     * \&quot;connection_identifier\&quot;: \&quot;Connection1\&quot;, \&quot;database_name\&quot;:
     * \&quot;db1\&quot;, \&quot;table_name\&quot;: \&quot;custom_calendar_2025\&quot;,
     * \&quot;schame_name\&quot;: \&quot;schemaVar\&quot; }, \&quot;month_offset\&quot;:
     * \&quot;August\&quot;, \&quot;start_day_of_week\&quot;: \&quot;Monday\&quot;,
     * \&quot;start_date\&quot;: \&quot;08/01/2025\&quot;, \&quot;end_date\&quot;:
     * \&quot;07/31/2026\&quot; } &#x60;&#x60;&#x60;
     *
     * @param calendarIdentifier Unique Id or name of the calendar. (required)
     * @param updateCalendarRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom calendar updated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateCalendar(
            String calendarIdentifier, UpdateCalendarRequest updateCalendarRequest)
            throws ApiException {
        updateCalendarWithHttpInfo(calendarIdentifier, updateCalendarRequest);
    }

    /**
     * Version: 10.12.0.cl or later Updates the properties of a [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines You can update the properties of a calendar
     * using one of the following methods: * &#x60;FROM_INPUT_PARAMS&#x60; to update the calendar
     * properties with the values defined in the API request. * &#x60;FROM_EXISTING_TABLE&#x60;
     * Creates a calendar from the parameters defined in the API request. To update a custom
     * calendar, specify the calendar ID as a path parameter in the request URL and the following
     * parameters in the request body: * Connection ID and Table name * Database and schema name
     * attributes: For most Cloud Data Warehouse (CDW) connectors, both &#x60;database_name&#x60;
     * and &#x60;schema_name&#x60; attributes are required. However, the attribute requirements are
     * conditional and vary based on the connector type and its metadata structure. For example, for
     * connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL,
     * Oracle, and GCP_MYSQL, the &#x60;schema_name&#x60; is required, whereas the
     * &#x60;database_name&#x60; attribute is not. Similarly, connectors such as ClickHouse require
     * you to specify the &#x60;database_name&#x60; and the schema specification in such cases is
     * optional. The API allows you to modify the calendar type, month offset value, start and end
     * date, starting day of the week, and prefixes assigned to the year and quarter labels. ####
     * Examples Update a custom calendar using an existing Table in ThoughtSpot: &#x60;&#x60;&#x60;
     * { \&quot;update_method\&quot;: \&quot;FROM_EXISTING_TABLE\&quot;,
     * \&quot;table_reference\&quot;: { \&quot;connection_identifier\&quot;:
     * \&quot;Connection1\&quot;, \&quot;database_name\&quot;: \&quot;db1\&quot;,
     * \&quot;table_name\&quot;: \&quot;custom_calendar_2025\&quot;, \&quot;schame_name\&quot;:
     * \&quot;schemaVar\&quot; } } &#x60;&#x60;&#x60; Update a custom calendar with the attributes
     * defined in the API request: &#x60;&#x60;&#x60; { \&quot;update_method\&quot;:
     * \&quot;FROM_INPUT_PARAMS\&quot;, \&quot;table_reference\&quot;: {
     * \&quot;connection_identifier\&quot;: \&quot;Connection1\&quot;, \&quot;database_name\&quot;:
     * \&quot;db1\&quot;, \&quot;table_name\&quot;: \&quot;custom_calendar_2025\&quot;,
     * \&quot;schame_name\&quot;: \&quot;schemaVar\&quot; }, \&quot;month_offset\&quot;:
     * \&quot;August\&quot;, \&quot;start_day_of_week\&quot;: \&quot;Monday\&quot;,
     * \&quot;start_date\&quot;: \&quot;08/01/2025\&quot;, \&quot;end_date\&quot;:
     * \&quot;07/31/2026\&quot; } &#x60;&#x60;&#x60;
     *
     * @param calendarIdentifier Unique Id or name of the calendar. (required)
     * @param updateCalendarRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom calendar updated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateCalendarWithHttpInfo(
            String calendarIdentifier, UpdateCalendarRequest updateCalendarRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                updateCalendarValidateBeforeCall(calendarIdentifier, updateCalendarRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Updates the properties of a [custom
     * calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal). Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot
     * instance, the &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60; (**Can manage custom calendars**)
     * privilege is required. #### Usage guidelines You can update the properties of a calendar
     * using one of the following methods: * &#x60;FROM_INPUT_PARAMS&#x60; to update the calendar
     * properties with the values defined in the API request. * &#x60;FROM_EXISTING_TABLE&#x60;
     * Creates a calendar from the parameters defined in the API request. To update a custom
     * calendar, specify the calendar ID as a path parameter in the request URL and the following
     * parameters in the request body: * Connection ID and Table name * Database and schema name
     * attributes: For most Cloud Data Warehouse (CDW) connectors, both &#x60;database_name&#x60;
     * and &#x60;schema_name&#x60; attributes are required. However, the attribute requirements are
     * conditional and vary based on the connector type and its metadata structure. For example, for
     * connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL,
     * Oracle, and GCP_MYSQL, the &#x60;schema_name&#x60; is required, whereas the
     * &#x60;database_name&#x60; attribute is not. Similarly, connectors such as ClickHouse require
     * you to specify the &#x60;database_name&#x60; and the schema specification in such cases is
     * optional. The API allows you to modify the calendar type, month offset value, start and end
     * date, starting day of the week, and prefixes assigned to the year and quarter labels. ####
     * Examples Update a custom calendar using an existing Table in ThoughtSpot: &#x60;&#x60;&#x60;
     * { \&quot;update_method\&quot;: \&quot;FROM_EXISTING_TABLE\&quot;,
     * \&quot;table_reference\&quot;: { \&quot;connection_identifier\&quot;:
     * \&quot;Connection1\&quot;, \&quot;database_name\&quot;: \&quot;db1\&quot;,
     * \&quot;table_name\&quot;: \&quot;custom_calendar_2025\&quot;, \&quot;schame_name\&quot;:
     * \&quot;schemaVar\&quot; } } &#x60;&#x60;&#x60; Update a custom calendar with the attributes
     * defined in the API request: &#x60;&#x60;&#x60; { \&quot;update_method\&quot;:
     * \&quot;FROM_INPUT_PARAMS\&quot;, \&quot;table_reference\&quot;: {
     * \&quot;connection_identifier\&quot;: \&quot;Connection1\&quot;, \&quot;database_name\&quot;:
     * \&quot;db1\&quot;, \&quot;table_name\&quot;: \&quot;custom_calendar_2025\&quot;,
     * \&quot;schame_name\&quot;: \&quot;schemaVar\&quot; }, \&quot;month_offset\&quot;:
     * \&quot;August\&quot;, \&quot;start_day_of_week\&quot;: \&quot;Monday\&quot;,
     * \&quot;start_date\&quot;: \&quot;08/01/2025\&quot;, \&quot;end_date\&quot;:
     * \&quot;07/31/2026\&quot; } &#x60;&#x60;&#x60;
     *
     * @param calendarIdentifier Unique Id or name of the calendar. (required)
     * @param updateCalendarRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom calendar updated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateCalendarAsync(
            String calendarIdentifier,
            UpdateCalendarRequest updateCalendarRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateCalendarValidateBeforeCall(
                        calendarIdentifier, updateCalendarRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateColumnSecurityRules
     *
     * @param updateColumnSecurityRulesRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfully updated column security rules </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request - Invalid parameters or table not found </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden - User doesn&#39;t have permission to modify security rules for this table </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateColumnSecurityRulesCall(
            UpdateColumnSecurityRulesRequest updateColumnSecurityRulesRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateColumnSecurityRulesRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/security/column/rules/update";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateColumnSecurityRulesValidateBeforeCall(
            UpdateColumnSecurityRulesRequest updateColumnSecurityRulesRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'updateColumnSecurityRulesRequest' is set
        if (updateColumnSecurityRulesRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateColumnSecurityRulesRequest' when"
                            + " calling updateColumnSecurityRules(Async)");
        }

        return updateColumnSecurityRulesCall(updateColumnSecurityRulesRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Creates, updates, or deletes column security rules for specified
     * tables. This API endpoint allows you to create, update, or delete column-level security rules
     * on columns of a table. The operation follows an \&quot;all or none\&quot; policy: if defining
     * security rules for any of the provided columns fails, the entire operation will be rolled
     * back, and no rules will be created. #### Usage guidelines - Provide table identifier using
     * either &#x60;identifier&#x60; (GUID or name) or &#x60;obj_identifier&#x60; (object ID) - Use
     * &#x60;clear_csr: true&#x60; to remove all column security rules from the table - For each
     * column, specify the security rule using &#x60;column_security_rules&#x60; array - Use
     * &#x60;is_unsecured: true&#x60; to mark a specific column as unprotected - Use
     * &#x60;group_access&#x60; operations to manage group associations: - &#x60;ADD&#x60;: Add
     * groups to the column&#39;s access list - &#x60;REMOVE&#x60;: Remove groups from the
     * column&#39;s access list - &#x60;REPLACE&#x60;: Replace all existing groups with the
     * specified groups #### Required permissions - &#x60;ADMINISTRATION&#x60; - Can administer
     * ThoughtSpot - &#x60;DATAMANAGEMENT&#x60; - Can manage data (if RBAC is disabled) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; - Can manage worksheet views and tables (if
     * RBAC is enabled) #### Example request &#x60;&#x60;&#x60;json { \&quot;identifier\&quot;:
     * \&quot;table-guid\&quot;, \&quot;obj_identifier\&quot;: \&quot;table-object-id\&quot;,
     * \&quot;clear_csr\&quot;: false, \&quot;column_security_rules\&quot;: [ {
     * \&quot;column_identifier\&quot;: \&quot;col id or col name\&quot;,
     * \&quot;is_unsecured\&quot;: false, \&quot;group_access\&quot;: [ { \&quot;operation\&quot;:
     * \&quot;ADD\&quot;, \&quot;group_identifiers\&quot;: [\&quot;hr_group_id\&quot;,
     * \&quot;hr_group_name\&quot;, \&quot;finance_group_id\&quot;] } ] }, {
     * \&quot;column_identifier\&quot;: \&quot;col id or col name\&quot;,
     * \&quot;is_unsecured\&quot;: true }, { \&quot;column_identifier\&quot;: \&quot;col id or col
     * name\&quot;, \&quot;is_unsecured\&quot;: false, \&quot;group_access\&quot;: [ {
     * \&quot;operation\&quot;: \&quot;REPLACE\&quot;, \&quot;group_identifiers\&quot;:
     * [\&quot;management_group_id\&quot;, \&quot;management_group_name\&quot;] } ] } ] }
     * &#x60;&#x60;&#x60; #### Request Body Schema - &#x60;identifier&#x60; (string, optional): GUID
     * or name of the table for which we want to create column security rules -
     * &#x60;obj_identifier&#x60; (string, optional): The object ID of the table -
     * &#x60;clear_csr&#x60; (boolean, optional): If true, then all the secured columns will be
     * marked as unprotected, and all the group associations will be removed -
     * &#x60;column_security_rules&#x60; (array of objects, required): An array where each object
     * defines the security rule for a specific column Each column security rule object contains: -
     * &#x60;column_identifier&#x60; (string, required): Column identifier (col_id or name) -
     * &#x60;is_unsecured&#x60; (boolean, optional): If true, the column will be marked as
     * unprotected and all groups associated with it will be removed - &#x60;group_access&#x60;
     * (array of objects, optional): Array of group operation objects Each group operation object
     * contains: - &#x60;operation&#x60; (string, required): Operation type - ADD, REMOVE, or
     * REPLACE - &#x60;group_identifiers&#x60; (array of strings, required): Array of group
     * identifiers (name or GUID) on which the operation will be performed #### Response This API
     * does not return any response body. A successful operation returns HTTP 200 status code. ####
     * Operation Types - **ADD**: Adds the specified groups to the column&#39;s access list -
     * **REMOVE**: Removes the specified groups from the column&#39;s access list - **REPLACE**:
     * Replaces all existing groups with the specified groups
     *
     * @param updateColumnSecurityRulesRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfully updated column security rules </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request - Invalid parameters or table not found </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden - User doesn&#39;t have permission to modify security rules for this table </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateColumnSecurityRules(
            UpdateColumnSecurityRulesRequest updateColumnSecurityRulesRequest) throws ApiException {
        updateColumnSecurityRulesWithHttpInfo(updateColumnSecurityRulesRequest);
    }

    /**
     * Version: 10.12.0.cl or later Creates, updates, or deletes column security rules for specified
     * tables. This API endpoint allows you to create, update, or delete column-level security rules
     * on columns of a table. The operation follows an \&quot;all or none\&quot; policy: if defining
     * security rules for any of the provided columns fails, the entire operation will be rolled
     * back, and no rules will be created. #### Usage guidelines - Provide table identifier using
     * either &#x60;identifier&#x60; (GUID or name) or &#x60;obj_identifier&#x60; (object ID) - Use
     * &#x60;clear_csr: true&#x60; to remove all column security rules from the table - For each
     * column, specify the security rule using &#x60;column_security_rules&#x60; array - Use
     * &#x60;is_unsecured: true&#x60; to mark a specific column as unprotected - Use
     * &#x60;group_access&#x60; operations to manage group associations: - &#x60;ADD&#x60;: Add
     * groups to the column&#39;s access list - &#x60;REMOVE&#x60;: Remove groups from the
     * column&#39;s access list - &#x60;REPLACE&#x60;: Replace all existing groups with the
     * specified groups #### Required permissions - &#x60;ADMINISTRATION&#x60; - Can administer
     * ThoughtSpot - &#x60;DATAMANAGEMENT&#x60; - Can manage data (if RBAC is disabled) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; - Can manage worksheet views and tables (if
     * RBAC is enabled) #### Example request &#x60;&#x60;&#x60;json { \&quot;identifier\&quot;:
     * \&quot;table-guid\&quot;, \&quot;obj_identifier\&quot;: \&quot;table-object-id\&quot;,
     * \&quot;clear_csr\&quot;: false, \&quot;column_security_rules\&quot;: [ {
     * \&quot;column_identifier\&quot;: \&quot;col id or col name\&quot;,
     * \&quot;is_unsecured\&quot;: false, \&quot;group_access\&quot;: [ { \&quot;operation\&quot;:
     * \&quot;ADD\&quot;, \&quot;group_identifiers\&quot;: [\&quot;hr_group_id\&quot;,
     * \&quot;hr_group_name\&quot;, \&quot;finance_group_id\&quot;] } ] }, {
     * \&quot;column_identifier\&quot;: \&quot;col id or col name\&quot;,
     * \&quot;is_unsecured\&quot;: true }, { \&quot;column_identifier\&quot;: \&quot;col id or col
     * name\&quot;, \&quot;is_unsecured\&quot;: false, \&quot;group_access\&quot;: [ {
     * \&quot;operation\&quot;: \&quot;REPLACE\&quot;, \&quot;group_identifiers\&quot;:
     * [\&quot;management_group_id\&quot;, \&quot;management_group_name\&quot;] } ] } ] }
     * &#x60;&#x60;&#x60; #### Request Body Schema - &#x60;identifier&#x60; (string, optional): GUID
     * or name of the table for which we want to create column security rules -
     * &#x60;obj_identifier&#x60; (string, optional): The object ID of the table -
     * &#x60;clear_csr&#x60; (boolean, optional): If true, then all the secured columns will be
     * marked as unprotected, and all the group associations will be removed -
     * &#x60;column_security_rules&#x60; (array of objects, required): An array where each object
     * defines the security rule for a specific column Each column security rule object contains: -
     * &#x60;column_identifier&#x60; (string, required): Column identifier (col_id or name) -
     * &#x60;is_unsecured&#x60; (boolean, optional): If true, the column will be marked as
     * unprotected and all groups associated with it will be removed - &#x60;group_access&#x60;
     * (array of objects, optional): Array of group operation objects Each group operation object
     * contains: - &#x60;operation&#x60; (string, required): Operation type - ADD, REMOVE, or
     * REPLACE - &#x60;group_identifiers&#x60; (array of strings, required): Array of group
     * identifiers (name or GUID) on which the operation will be performed #### Response This API
     * does not return any response body. A successful operation returns HTTP 200 status code. ####
     * Operation Types - **ADD**: Adds the specified groups to the column&#39;s access list -
     * **REMOVE**: Removes the specified groups from the column&#39;s access list - **REPLACE**:
     * Replaces all existing groups with the specified groups
     *
     * @param updateColumnSecurityRulesRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfully updated column security rules </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request - Invalid parameters or table not found </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden - User doesn&#39;t have permission to modify security rules for this table </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateColumnSecurityRulesWithHttpInfo(
            UpdateColumnSecurityRulesRequest updateColumnSecurityRulesRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateColumnSecurityRulesValidateBeforeCall(updateColumnSecurityRulesRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Creates, updates, or deletes column security
     * rules for specified tables. This API endpoint allows you to create, update, or delete
     * column-level security rules on columns of a table. The operation follows an \&quot;all or
     * none\&quot; policy: if defining security rules for any of the provided columns fails, the
     * entire operation will be rolled back, and no rules will be created. #### Usage guidelines -
     * Provide table identifier using either &#x60;identifier&#x60; (GUID or name) or
     * &#x60;obj_identifier&#x60; (object ID) - Use &#x60;clear_csr: true&#x60; to remove all column
     * security rules from the table - For each column, specify the security rule using
     * &#x60;column_security_rules&#x60; array - Use &#x60;is_unsecured: true&#x60; to mark a
     * specific column as unprotected - Use &#x60;group_access&#x60; operations to manage group
     * associations: - &#x60;ADD&#x60;: Add groups to the column&#39;s access list -
     * &#x60;REMOVE&#x60;: Remove groups from the column&#39;s access list - &#x60;REPLACE&#x60;:
     * Replace all existing groups with the specified groups #### Required permissions -
     * &#x60;ADMINISTRATION&#x60; - Can administer ThoughtSpot - &#x60;DATAMANAGEMENT&#x60; - Can
     * manage data (if RBAC is disabled) - &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; - Can
     * manage worksheet views and tables (if RBAC is enabled) #### Example request
     * &#x60;&#x60;&#x60;json { \&quot;identifier\&quot;: \&quot;table-guid\&quot;,
     * \&quot;obj_identifier\&quot;: \&quot;table-object-id\&quot;, \&quot;clear_csr\&quot;: false,
     * \&quot;column_security_rules\&quot;: [ { \&quot;column_identifier\&quot;: \&quot;col id or
     * col name\&quot;, \&quot;is_unsecured\&quot;: false, \&quot;group_access\&quot;: [ {
     * \&quot;operation\&quot;: \&quot;ADD\&quot;, \&quot;group_identifiers\&quot;:
     * [\&quot;hr_group_id\&quot;, \&quot;hr_group_name\&quot;, \&quot;finance_group_id\&quot;] } ]
     * }, { \&quot;column_identifier\&quot;: \&quot;col id or col name\&quot;,
     * \&quot;is_unsecured\&quot;: true }, { \&quot;column_identifier\&quot;: \&quot;col id or col
     * name\&quot;, \&quot;is_unsecured\&quot;: false, \&quot;group_access\&quot;: [ {
     * \&quot;operation\&quot;: \&quot;REPLACE\&quot;, \&quot;group_identifiers\&quot;:
     * [\&quot;management_group_id\&quot;, \&quot;management_group_name\&quot;] } ] } ] }
     * &#x60;&#x60;&#x60; #### Request Body Schema - &#x60;identifier&#x60; (string, optional): GUID
     * or name of the table for which we want to create column security rules -
     * &#x60;obj_identifier&#x60; (string, optional): The object ID of the table -
     * &#x60;clear_csr&#x60; (boolean, optional): If true, then all the secured columns will be
     * marked as unprotected, and all the group associations will be removed -
     * &#x60;column_security_rules&#x60; (array of objects, required): An array where each object
     * defines the security rule for a specific column Each column security rule object contains: -
     * &#x60;column_identifier&#x60; (string, required): Column identifier (col_id or name) -
     * &#x60;is_unsecured&#x60; (boolean, optional): If true, the column will be marked as
     * unprotected and all groups associated with it will be removed - &#x60;group_access&#x60;
     * (array of objects, optional): Array of group operation objects Each group operation object
     * contains: - &#x60;operation&#x60; (string, required): Operation type - ADD, REMOVE, or
     * REPLACE - &#x60;group_identifiers&#x60; (array of strings, required): Array of group
     * identifiers (name or GUID) on which the operation will be performed #### Response This API
     * does not return any response body. A successful operation returns HTTP 200 status code. ####
     * Operation Types - **ADD**: Adds the specified groups to the column&#39;s access list -
     * **REMOVE**: Removes the specified groups from the column&#39;s access list - **REPLACE**:
     * Replaces all existing groups with the specified groups
     *
     * @param updateColumnSecurityRulesRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Successfully updated column security rules </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Bad request - Invalid parameters or table not found </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden - User doesn&#39;t have permission to modify security rules for this table </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Internal server error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateColumnSecurityRulesAsync(
            UpdateColumnSecurityRulesRequest updateColumnSecurityRulesRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateColumnSecurityRulesValidateBeforeCall(
                        updateColumnSecurityRulesRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateConfig
     *
     * @param updateConfigRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully updated local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateConfigCall(
            UpdateConfigRequest updateConfigRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateConfigRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/vcs/git/config/update";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateConfigValidateBeforeCall(
            UpdateConfigRequest updateConfigRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'updateConfigRequest' is set
        if (updateConfigRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateConfigRequest' when calling"
                            + " updateConfig(Async)");
        }

        return updateConfigCall(updateConfigRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Updates Git repository configuration settings. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on
     * your instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up version control**)
     * privilege.
     *
     * @param updateConfigRequest (required)
     * @return RepoConfigObject
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully updated local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public RepoConfigObject updateConfig(UpdateConfigRequest updateConfigRequest)
            throws ApiException {
        ApiResponse<RepoConfigObject> localVarResp = updateConfigWithHttpInfo(updateConfigRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Updates Git repository configuration settings. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on
     * your instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up version control**)
     * privilege.
     *
     * @param updateConfigRequest (required)
     * @return ApiResponse&lt;RepoConfigObject&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully updated local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<RepoConfigObject> updateConfigWithHttpInfo(
            UpdateConfigRequest updateConfigRequest) throws ApiException {
        okhttp3.Call localVarCall = updateConfigValidateBeforeCall(updateConfigRequest, null);
        Type localVarReturnType = new TypeToken<RepoConfigObject>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Updates Git repository configuration settings.
     * Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance on your instance, the &#x60;CAN_SETUP_VERSION_CONTROL&#x60; (**Can set up
     * version control**) privilege.
     *
     * @param updateConfigRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Successfully updated local repository configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateConfigAsync(
            UpdateConfigRequest updateConfigRequest, final ApiCallback<RepoConfigObject> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = updateConfigValidateBeforeCall(updateConfigRequest, _callback);
        Type localVarReturnType = new TypeToken<RepoConfigObject>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateConnection
     *
     * @param updateConnectionRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public okhttp3.Call updateConnectionCall(
            UpdateConnectionRequest updateConnectionRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateConnectionRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/connection/update";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @Deprecated
    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateConnectionValidateBeforeCall(
            UpdateConnectionRequest updateConnectionRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'updateConnectionRequest' is set
        if (updateConnectionRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateConnectionRequest' when calling"
                            + " updateConnection(Async)");
        }

        return updateConnectionCall(updateConnectionRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later **Important**: This endpoint is deprecated and will be removed
     * from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Update
     * connection V2](#/http/api-endpoints/connections/update-connection-v2) endpoint to update your
     * connection objects. #### Usage guidelines Updates a connection object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. To update a connection object, pass these parameters in
     * your API request: 1. GUID of the connection object. 2. If you are updating tables or database
     * schema of a connection object: a. Add the updated JSON map of metadata with database, schema,
     * and tables in &#x60;data_warehouse_config&#x60;. b. Set &#x60;validate&#x60; to
     * &#x60;true&#x60;. 3. If you are updating a configuration attribute, connection name, or
     * description, you can set &#x60;validate&#x60; to &#x60;false&#x60;.
     *
     * @param updateConnectionRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public void updateConnection(UpdateConnectionRequest updateConnectionRequest)
            throws ApiException {
        updateConnectionWithHttpInfo(updateConnectionRequest);
    }

    /**
     * Version: 9.2.0.cl or later **Important**: This endpoint is deprecated and will be removed
     * from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Update
     * connection V2](#/http/api-endpoints/connections/update-connection-v2) endpoint to update your
     * connection objects. #### Usage guidelines Updates a connection object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. To update a connection object, pass these parameters in
     * your API request: 1. GUID of the connection object. 2. If you are updating tables or database
     * schema of a connection object: a. Add the updated JSON map of metadata with database, schema,
     * and tables in &#x60;data_warehouse_config&#x60;. b. Set &#x60;validate&#x60; to
     * &#x60;true&#x60;. 3. If you are updating a configuration attribute, connection name, or
     * description, you can set &#x60;validate&#x60; to &#x60;false&#x60;.
     *
     * @param updateConnectionRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public ApiResponse<Void> updateConnectionWithHttpInfo(
            UpdateConnectionRequest updateConnectionRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateConnectionValidateBeforeCall(updateConnectionRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later **Important**: This endpoint is deprecated and
     * will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the
     * [Update connection V2](#/http/api-endpoints/connections/update-connection-v2) endpoint to
     * update your connection objects. #### Usage guidelines Updates a connection object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. To update a connection object, pass these parameters in
     * your API request: 1. GUID of the connection object. 2. If you are updating tables or database
     * schema of a connection object: a. Add the updated JSON map of metadata with database, schema,
     * and tables in &#x60;data_warehouse_config&#x60;. b. Set &#x60;validate&#x60; to
     * &#x60;true&#x60;. 3. If you are updating a configuration attribute, connection name, or
     * description, you can set &#x60;validate&#x60; to &#x60;false&#x60;.
     *
     * @param updateConnectionRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     *
     * @deprecated
     */
    @Deprecated
    public okhttp3.Call updateConnectionAsync(
            UpdateConnectionRequest updateConnectionRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateConnectionValidateBeforeCall(updateConnectionRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateConnectionConfiguration
     *
     * @param configurationIdentifier Unique ID or name of the configuration. (required)
     * @param updateConnectionConfigurationRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateConnectionConfigurationCall(
            String configurationIdentifier,
            UpdateConnectionConfigurationRequest updateConnectionConfigurationRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateConnectionConfigurationRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/connection-configurations/{configuration_identifier}/update"
                        .replace(
                                "{" + "configuration_identifier" + "}",
                                localVarApiClient.escapeString(configurationIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateConnectionConfigurationValidateBeforeCall(
            String configurationIdentifier,
            UpdateConnectionConfigurationRequest updateConnectionConfigurationRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'configurationIdentifier' is set
        if (configurationIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'configurationIdentifier' when calling"
                            + " updateConnectionConfiguration(Async)");
        }

        // verify the required parameter 'updateConnectionConfigurationRequest' is set
        if (updateConnectionConfigurationRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateConnectionConfigurationRequest' when"
                            + " calling updateConnectionConfiguration(Async)");
        }

        return updateConnectionConfigurationCall(
                configurationIdentifier, updateConnectionConfigurationRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Updates a connection configuration object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. #### Supported operations This API endpoint lets you
     * perform the following operations in a single API request: * Edit the name or description of
     * the configuration * Edit the configuration properties * Edit the &#x60;policy_type&#x60; *
     * Edit the type of authentication * Enable or disable a configuration **NOTE**: When updating a
     * configuration where &#x60;disabled&#x60; is &#x60;true&#x60;, you must reset
     * &#x60;disabled&#x60; to &#x60;true&#x60; in your update request payload. If not explicitly
     * set again, the API will default &#x60;disabled&#x60; to &#x60;false&#x60;.
     *
     * @param configurationIdentifier Unique ID or name of the configuration. (required)
     * @param updateConnectionConfigurationRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateConnectionConfiguration(
            String configurationIdentifier,
            UpdateConnectionConfigurationRequest updateConnectionConfigurationRequest)
            throws ApiException {
        updateConnectionConfigurationWithHttpInfo(
                configurationIdentifier, updateConnectionConfigurationRequest);
    }

    /**
     * Version: 10.12.0.cl or later Updates a connection configuration object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. #### Supported operations This API endpoint lets you
     * perform the following operations in a single API request: * Edit the name or description of
     * the configuration * Edit the configuration properties * Edit the &#x60;policy_type&#x60; *
     * Edit the type of authentication * Enable or disable a configuration **NOTE**: When updating a
     * configuration where &#x60;disabled&#x60; is &#x60;true&#x60;, you must reset
     * &#x60;disabled&#x60; to &#x60;true&#x60; in your update request payload. If not explicitly
     * set again, the API will default &#x60;disabled&#x60; to &#x60;false&#x60;.
     *
     * @param configurationIdentifier Unique ID or name of the configuration. (required)
     * @param updateConnectionConfigurationRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateConnectionConfigurationWithHttpInfo(
            String configurationIdentifier,
            UpdateConnectionConfigurationRequest updateConnectionConfigurationRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                updateConnectionConfigurationValidateBeforeCall(
                        configurationIdentifier, updateConnectionConfigurationRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Updates a connection configuration object.
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the
     * connection object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege.
     * If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. #### Supported operations This API endpoint lets you
     * perform the following operations in a single API request: * Edit the name or description of
     * the configuration * Edit the configuration properties * Edit the &#x60;policy_type&#x60; *
     * Edit the type of authentication * Enable or disable a configuration **NOTE**: When updating a
     * configuration where &#x60;disabled&#x60; is &#x60;true&#x60;, you must reset
     * &#x60;disabled&#x60; to &#x60;true&#x60; in your update request payload. If not explicitly
     * set again, the API will default &#x60;disabled&#x60; to &#x60;false&#x60;.
     *
     * @param configurationIdentifier Unique ID or name of the configuration. (required)
     * @param updateConnectionConfigurationRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateConnectionConfigurationAsync(
            String configurationIdentifier,
            UpdateConnectionConfigurationRequest updateConnectionConfigurationRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateConnectionConfigurationValidateBeforeCall(
                        configurationIdentifier, updateConnectionConfigurationRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateConnectionV2
     *
     * @param connectionIdentifier Unique ID or name of the connection. (required)
     * @param updateConnectionV2Request (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateConnectionV2Call(
            String connectionIdentifier,
            UpdateConnectionV2Request updateConnectionV2Request,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateConnectionV2Request;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/connections/{connection_identifier}/update"
                        .replace(
                                "{" + "connection_identifier" + "}",
                                localVarApiClient.escapeString(connectionIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateConnectionV2ValidateBeforeCall(
            String connectionIdentifier,
            UpdateConnectionV2Request updateConnectionV2Request,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'connectionIdentifier' is set
        if (connectionIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'connectionIdentifier' when calling"
                            + " updateConnectionV2(Async)");
        }

        // verify the required parameter 'updateConnectionV2Request' is set
        if (updateConnectionV2Request == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateConnectionV2Request' when calling"
                            + " updateConnectionV2(Async)");
        }

        return updateConnectionV2Call(connectionIdentifier, updateConnectionV2Request, _callback);
    }

    /**
     * Version: 10.4.0.cl or later Updates a connection object. Requires &#x60;DATAMANAGEMENT&#x60;
     * (**Can manage data**) and edit permissions to the connection object, or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required. To update a connection object, pass these parameters in your API request: 1. GUID
     * of the connection object. 2. If you are updating tables or database schema of a connection
     * object: a. Add the updated JSON map of metadata with database, schema, and tables in
     * &#x60;data_warehouse_config&#x60;. b. Set &#x60;validate&#x60; to &#x60;true&#x60;. **NOTE:**
     * If the &#x60;authentication_type&#x60; is anything other than SERVICE_ACCOUNT, you must
     * explicitly provide the authenticationType property in the payload. If you do not specify
     * authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type. * A
     * JSON map of configuration attributes, database details, and table properties in
     * &#x60;data_warehouse_config&#x60; as shown in the following example: &#x60;&#x60;&#x60; {
     * \&quot;configuration\&quot;:{ \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ { \&quot;name\&quot;:\&quot;AllDatatypes\&quot;,
     * \&quot;isAutoCreated\&quot;:false, \&quot;schemas\&quot;:[ {
     * \&quot;name\&quot;:\&quot;alldatatypes\&quot;, \&quot;tables\&quot;:[ {
     * \&quot;name\&quot;:\&quot;allDatatypes\&quot;, \&quot;type\&quot;:\&quot;TABLE\&quot;,
     * \&quot;description\&quot;:\&quot;\&quot;, \&quot;selected\&quot;:true,
     * \&quot;linked\&quot;:true, \&quot;columns\&quot;:[ {
     * \&quot;name\&quot;:\&quot;CNUMBER\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; }, {
     * \&quot;name\&quot;:\&quot;CDECIMAL\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; } ] } ] } ] } ] } &#x60;&#x60;&#x60; 3. If
     * you are updating a configuration attribute, connection name, or description, you can set
     * &#x60;validate&#x60; to &#x60;false&#x60;. **NOTE:** If the &#x60;authentication_type&#x60;
     * is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType
     * property in the payload. If you do not specify authenticationType, the API will default to
     * SERVICE_ACCOUNT as the authentication type. * A JSON map of configuration attributes in
     * &#x60;data_warehouse_config&#x60;. The following example shows the configuration attributes
     * for a Snowflake connection: &#x60;&#x60;&#x60; { \&quot;configuration\&quot;:{
     * \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ ] } &#x60;&#x60;&#x60;
     *
     * @param connectionIdentifier Unique ID or name of the connection. (required)
     * @param updateConnectionV2Request (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateConnectionV2(
            String connectionIdentifier, UpdateConnectionV2Request updateConnectionV2Request)
            throws ApiException {
        updateConnectionV2WithHttpInfo(connectionIdentifier, updateConnectionV2Request);
    }

    /**
     * Version: 10.4.0.cl or later Updates a connection object. Requires &#x60;DATAMANAGEMENT&#x60;
     * (**Can manage data**) and edit permissions to the connection object, or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) privilege is
     * required. To update a connection object, pass these parameters in your API request: 1. GUID
     * of the connection object. 2. If you are updating tables or database schema of a connection
     * object: a. Add the updated JSON map of metadata with database, schema, and tables in
     * &#x60;data_warehouse_config&#x60;. b. Set &#x60;validate&#x60; to &#x60;true&#x60;. **NOTE:**
     * If the &#x60;authentication_type&#x60; is anything other than SERVICE_ACCOUNT, you must
     * explicitly provide the authenticationType property in the payload. If you do not specify
     * authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type. * A
     * JSON map of configuration attributes, database details, and table properties in
     * &#x60;data_warehouse_config&#x60; as shown in the following example: &#x60;&#x60;&#x60; {
     * \&quot;configuration\&quot;:{ \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ { \&quot;name\&quot;:\&quot;AllDatatypes\&quot;,
     * \&quot;isAutoCreated\&quot;:false, \&quot;schemas\&quot;:[ {
     * \&quot;name\&quot;:\&quot;alldatatypes\&quot;, \&quot;tables\&quot;:[ {
     * \&quot;name\&quot;:\&quot;allDatatypes\&quot;, \&quot;type\&quot;:\&quot;TABLE\&quot;,
     * \&quot;description\&quot;:\&quot;\&quot;, \&quot;selected\&quot;:true,
     * \&quot;linked\&quot;:true, \&quot;columns\&quot;:[ {
     * \&quot;name\&quot;:\&quot;CNUMBER\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; }, {
     * \&quot;name\&quot;:\&quot;CDECIMAL\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; } ] } ] } ] } ] } &#x60;&#x60;&#x60; 3. If
     * you are updating a configuration attribute, connection name, or description, you can set
     * &#x60;validate&#x60; to &#x60;false&#x60;. **NOTE:** If the &#x60;authentication_type&#x60;
     * is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType
     * property in the payload. If you do not specify authenticationType, the API will default to
     * SERVICE_ACCOUNT as the authentication type. * A JSON map of configuration attributes in
     * &#x60;data_warehouse_config&#x60;. The following example shows the configuration attributes
     * for a Snowflake connection: &#x60;&#x60;&#x60; { \&quot;configuration\&quot;:{
     * \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ ] } &#x60;&#x60;&#x60;
     *
     * @param connectionIdentifier Unique ID or name of the connection. (required)
     * @param updateConnectionV2Request (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateConnectionV2WithHttpInfo(
            String connectionIdentifier, UpdateConnectionV2Request updateConnectionV2Request)
            throws ApiException {
        okhttp3.Call localVarCall =
                updateConnectionV2ValidateBeforeCall(
                        connectionIdentifier, updateConnectionV2Request, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.4.0.cl or later Updates a connection object. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) and edit permissions to the connection
     * object, or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit
     * Connections**) privilege is required. To update a connection object, pass these parameters in
     * your API request: 1. GUID of the connection object. 2. If you are updating tables or database
     * schema of a connection object: a. Add the updated JSON map of metadata with database, schema,
     * and tables in &#x60;data_warehouse_config&#x60;. b. Set &#x60;validate&#x60; to
     * &#x60;true&#x60;. **NOTE:** If the &#x60;authentication_type&#x60; is anything other than
     * SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload.
     * If you do not specify authenticationType, the API will default to SERVICE_ACCOUNT as the
     * authentication type. * A JSON map of configuration attributes, database details, and table
     * properties in &#x60;data_warehouse_config&#x60; as shown in the following example:
     * &#x60;&#x60;&#x60; { \&quot;configuration\&quot;:{
     * \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ { \&quot;name\&quot;:\&quot;AllDatatypes\&quot;,
     * \&quot;isAutoCreated\&quot;:false, \&quot;schemas\&quot;:[ {
     * \&quot;name\&quot;:\&quot;alldatatypes\&quot;, \&quot;tables\&quot;:[ {
     * \&quot;name\&quot;:\&quot;allDatatypes\&quot;, \&quot;type\&quot;:\&quot;TABLE\&quot;,
     * \&quot;description\&quot;:\&quot;\&quot;, \&quot;selected\&quot;:true,
     * \&quot;linked\&quot;:true, \&quot;columns\&quot;:[ {
     * \&quot;name\&quot;:\&quot;CNUMBER\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; }, {
     * \&quot;name\&quot;:\&quot;CDECIMAL\&quot;, \&quot;type\&quot;:\&quot;INT64\&quot;,
     * \&quot;canImport\&quot;:true, \&quot;selected\&quot;:true, \&quot;isLinkedActive\&quot;:true,
     * \&quot;isImported\&quot;:false, \&quot;tableName\&quot;:\&quot;allDatatypes\&quot;,
     * \&quot;schemaName\&quot;:\&quot;alldatatypes\&quot;,
     * \&quot;dbName\&quot;:\&quot;AllDatatypes\&quot; } ] } ] } ] } ] } &#x60;&#x60;&#x60; 3. If
     * you are updating a configuration attribute, connection name, or description, you can set
     * &#x60;validate&#x60; to &#x60;false&#x60;. **NOTE:** If the &#x60;authentication_type&#x60;
     * is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType
     * property in the payload. If you do not specify authenticationType, the API will default to
     * SERVICE_ACCOUNT as the authentication type. * A JSON map of configuration attributes in
     * &#x60;data_warehouse_config&#x60;. The following example shows the configuration attributes
     * for a Snowflake connection: &#x60;&#x60;&#x60; { \&quot;configuration\&quot;:{
     * \&quot;accountName\&quot;:\&quot;thoughtspot_partner\&quot;,
     * \&quot;user\&quot;:\&quot;tsadmin\&quot;, \&quot;password\&quot;:\&quot;TestConn123\&quot;,
     * \&quot;role\&quot;:\&quot;sysadmin\&quot;, \&quot;warehouse\&quot;:\&quot;MEDIUM_WH\&quot; },
     * \&quot;externalDatabases\&quot;:[ ] } &#x60;&#x60;&#x60;
     *
     * @param connectionIdentifier Unique ID or name of the connection. (required)
     * @param updateConnectionV2Request (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateConnectionV2Async(
            String connectionIdentifier,
            UpdateConnectionV2Request updateConnectionV2Request,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateConnectionV2ValidateBeforeCall(
                        connectionIdentifier, updateConnectionV2Request, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateCustomAction
     *
     * @param customActionIdentifier Unique ID or name of the custom action. (required)
     * @param updateCustomActionRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom action updated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateCustomActionCall(
            String customActionIdentifier,
            UpdateCustomActionRequest updateCustomActionRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateCustomActionRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/customization/custom-actions/{custom_action_identifier}/update"
                        .replace(
                                "{" + "custom_action_identifier" + "}",
                                localVarApiClient.escapeString(customActionIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateCustomActionValidateBeforeCall(
            String customActionIdentifier,
            UpdateCustomActionRequest updateCustomActionRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'customActionIdentifier' is set
        if (customActionIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'customActionIdentifier' when calling"
                            + " updateCustomAction(Async)");
        }

        // verify the required parameter 'updateCustomActionRequest' is set
        if (updateCustomActionRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateCustomActionRequest' when calling"
                            + " updateCustomAction(Async)");
        }

        return updateCustomActionCall(customActionIdentifier, updateCustomActionRequest, _callback);
    }

    /**
     * Version: 9.6.0.cl or later Updates a custom action. Requires &#x60;DEVELOPER&#x60; (**Has
     * Developer privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. #### Usage
     * Guidelines The API allows you to modify the following properties: * Name of the custom action
     * * Action availability to groups * Association to metadata objects * Authentication settings
     * for a URL-based action For more information, see [Custom
     * actions](https://developers.thoughtspot.com/docs/custom-action-intro).
     *
     * @param customActionIdentifier Unique ID or name of the custom action. (required)
     * @param updateCustomActionRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom action updated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateCustomAction(
            String customActionIdentifier, UpdateCustomActionRequest updateCustomActionRequest)
            throws ApiException {
        updateCustomActionWithHttpInfo(customActionIdentifier, updateCustomActionRequest);
    }

    /**
     * Version: 9.6.0.cl or later Updates a custom action. Requires &#x60;DEVELOPER&#x60; (**Has
     * Developer privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. #### Usage
     * Guidelines The API allows you to modify the following properties: * Name of the custom action
     * * Action availability to groups * Association to metadata objects * Authentication settings
     * for a URL-based action For more information, see [Custom
     * actions](https://developers.thoughtspot.com/docs/custom-action-intro).
     *
     * @param customActionIdentifier Unique ID or name of the custom action. (required)
     * @param updateCustomActionRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom action updated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateCustomActionWithHttpInfo(
            String customActionIdentifier, UpdateCustomActionRequest updateCustomActionRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                updateCustomActionValidateBeforeCall(
                        customActionIdentifier, updateCustomActionRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.6.0.cl or later Updates a custom action. Requires
     * &#x60;DEVELOPER&#x60; (**Has Developer privilege**) or &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. #### Usage
     * Guidelines The API allows you to modify the following properties: * Name of the custom action
     * * Action availability to groups * Association to metadata objects * Authentication settings
     * for a URL-based action For more information, see [Custom
     * actions](https://developers.thoughtspot.com/docs/custom-action-intro).
     *
     * @param customActionIdentifier Unique ID or name of the custom action. (required)
     * @param updateCustomActionRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Custom action updated successfully. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateCustomActionAsync(
            String customActionIdentifier,
            UpdateCustomActionRequest updateCustomActionRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateCustomActionValidateBeforeCall(
                        customActionIdentifier, updateCustomActionRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateDbtConnection
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT Connection. (required)
     * @param connectionName Name of the connection. (optional)
     * @param databaseName Name of the Database. (optional)
     * @param importType Mention type of Import (optional, default to DBT_CLOUD)
     * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param dbtEnvId DBT Environment ID\\\&quot; (optional)
     * @param projectName Name of the project (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is Mandatory when Import Type is &#39;ZIP_FILE&#39; (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> DBT Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateDbtConnectionCall(
            String dbtConnectionIdentifier,
            String connectionName,
            String databaseName,
            String importType,
            String accessToken,
            String dbtUrl,
            String accountId,
            String projectId,
            String dbtEnvId,
            String projectName,
            File fileContent,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/dbt/update-dbt-connection";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (dbtConnectionIdentifier != null) {
            localVarFormParams.put("dbt_connection_identifier", dbtConnectionIdentifier);
        }

        if (connectionName != null) {
            localVarFormParams.put("connection_name", connectionName);
        }

        if (databaseName != null) {
            localVarFormParams.put("database_name", databaseName);
        }

        if (importType != null) {
            localVarFormParams.put("import_type", importType);
        }

        if (accessToken != null) {
            localVarFormParams.put("access_token", accessToken);
        }

        if (dbtUrl != null) {
            localVarFormParams.put("dbt_url", dbtUrl);
        }

        if (accountId != null) {
            localVarFormParams.put("account_id", accountId);
        }

        if (projectId != null) {
            localVarFormParams.put("project_id", projectId);
        }

        if (dbtEnvId != null) {
            localVarFormParams.put("dbt_env_id", dbtEnvId);
        }

        if (projectName != null) {
            localVarFormParams.put("project_name", projectName);
        }

        if (fileContent != null) {
            localVarFormParams.put("file_content", fileContent);
        }

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"multipart/form-data"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateDbtConnectionValidateBeforeCall(
            String dbtConnectionIdentifier,
            String connectionName,
            String databaseName,
            String importType,
            String accessToken,
            String dbtUrl,
            String accountId,
            String projectId,
            String dbtEnvId,
            String projectName,
            File fileContent,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'dbtConnectionIdentifier' is set
        if (dbtConnectionIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'dbtConnectionIdentifier' when calling"
                            + " updateDbtConnection(Async)");
        }

        return updateDbtConnectionCall(
                dbtConnectionIdentifier,
                connectionName,
                databaseName,
                importType,
                accessToken,
                dbtUrl,
                accountId,
                projectId,
                dbtEnvId,
                projectName,
                fileContent,
                _callback);
    }

    /**
     * Version: 9.9.0.cl or later Updates a DBT connection object. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data ThoughtSpot**) privilege, along with an
     * existing DBT connection. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About update
     * DBT connection You can modify DBT connection object properties such as embrace connection
     * name, embrace database name, import type, account identifier, access token, project
     * identifier and environment (or) embrace connection, embrace database name, import type,
     * file_content settings.
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT Connection. (required)
     * @param connectionName Name of the connection. (optional)
     * @param databaseName Name of the Database. (optional)
     * @param importType Mention type of Import (optional, default to DBT_CLOUD)
     * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param dbtEnvId DBT Environment ID\\\&quot; (optional)
     * @param projectName Name of the project (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is Mandatory when Import Type is &#39;ZIP_FILE&#39; (optional)
     * @return Object
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> DBT Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public Object updateDbtConnection(
            String dbtConnectionIdentifier,
            String connectionName,
            String databaseName,
            String importType,
            String accessToken,
            String dbtUrl,
            String accountId,
            String projectId,
            String dbtEnvId,
            String projectName,
            File fileContent)
            throws ApiException {
        ApiResponse<Object> localVarResp =
                updateDbtConnectionWithHttpInfo(
                        dbtConnectionIdentifier,
                        connectionName,
                        databaseName,
                        importType,
                        accessToken,
                        dbtUrl,
                        accountId,
                        projectId,
                        dbtEnvId,
                        projectName,
                        fileContent);
        return localVarResp.getData();
    }

    /**
     * Version: 9.9.0.cl or later Updates a DBT connection object. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data ThoughtSpot**) privilege, along with an
     * existing DBT connection. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About update
     * DBT connection You can modify DBT connection object properties such as embrace connection
     * name, embrace database name, import type, account identifier, access token, project
     * identifier and environment (or) embrace connection, embrace database name, import type,
     * file_content settings.
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT Connection. (required)
     * @param connectionName Name of the connection. (optional)
     * @param databaseName Name of the Database. (optional)
     * @param importType Mention type of Import (optional, default to DBT_CLOUD)
     * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param dbtEnvId DBT Environment ID\\\&quot; (optional)
     * @param projectName Name of the project (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is Mandatory when Import Type is &#39;ZIP_FILE&#39; (optional)
     * @return ApiResponse&lt;Object&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> DBT Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Object> updateDbtConnectionWithHttpInfo(
            String dbtConnectionIdentifier,
            String connectionName,
            String databaseName,
            String importType,
            String accessToken,
            String dbtUrl,
            String accountId,
            String projectId,
            String dbtEnvId,
            String projectName,
            File fileContent)
            throws ApiException {
        okhttp3.Call localVarCall =
                updateDbtConnectionValidateBeforeCall(
                        dbtConnectionIdentifier,
                        connectionName,
                        databaseName,
                        importType,
                        accessToken,
                        dbtUrl,
                        accountId,
                        projectId,
                        dbtEnvId,
                        projectName,
                        fileContent,
                        null);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.9.0.cl or later Updates a DBT connection object. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege or
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data ThoughtSpot**) privilege, along with an
     * existing DBT connection. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * following data control privileges may be required: -
     * &#x60;CAN_MANAGE_CUSTOM_CALENDAR&#x60;(**Can manage custom calendars**) -
     * &#x60;CAN_CREATE_OR_EDIT_CONNECTIONS&#x60; (**Can create/edit Connections**) -
     * &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**) #### About update
     * DBT connection You can modify DBT connection object properties such as embrace connection
     * name, embrace database name, import type, account identifier, access token, project
     * identifier and environment (or) embrace connection, embrace database name, import type,
     * file_content settings.
     *
     * @param dbtConnectionIdentifier Unique ID of the DBT Connection. (required)
     * @param connectionName Name of the connection. (optional)
     * @param databaseName Name of the Database. (optional)
     * @param importType Mention type of Import (optional, default to DBT_CLOUD)
     * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD. (optional)
     * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD (optional)
     * @param dbtEnvId DBT Environment ID\\\&quot; (optional)
     * @param projectName Name of the project (optional)
     * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field
     *     is Mandatory when Import Type is &#39;ZIP_FILE&#39; (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> DBT Connection successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateDbtConnectionAsync(
            String dbtConnectionIdentifier,
            String connectionName,
            String databaseName,
            String importType,
            String accessToken,
            String dbtUrl,
            String accountId,
            String projectId,
            String dbtEnvId,
            String projectName,
            File fileContent,
            final ApiCallback<Object> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateDbtConnectionValidateBeforeCall(
                        dbtConnectionIdentifier,
                        connectionName,
                        databaseName,
                        importType,
                        accessToken,
                        dbtUrl,
                        accountId,
                        projectId,
                        dbtEnvId,
                        projectName,
                        fileContent,
                        _callback);
        Type localVarReturnType = new TypeToken<Object>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateEmailCustomization
     *
     * @param updateEmailCustomizationRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateEmailCustomizationCall(
            UpdateEmailCustomizationRequest updateEmailCustomizationRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateEmailCustomizationRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/customization/email/update";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateEmailCustomizationValidateBeforeCall(
            UpdateEmailCustomizationRequest updateEmailCustomizationRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'updateEmailCustomizationRequest' is set
        if (updateEmailCustomizationRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateEmailCustomizationRequest' when calling"
                            + " updateEmailCustomization(Async)");
        }

        return updateEmailCustomizationCall(updateEmailCustomizationRequest, _callback);
    }

    /**
     * Version: 10.12.0.cl or later Updates a customization configuration for the notification
     * email. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer privilege**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. **NOTE**:This
     * endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.
     * #### Usage guidelines To update a custom configuration pass these parameters in your API
     * request: - A JSON map of configuration attributes &#x60;template_properties&#x60;. The
     * following example shows a sample set of customization configuration: &#x60;&#x60;&#x60; { {
     * \&quot;ctaButtonBgColor\&quot;: \&quot;#444DEA\&quot;, \&quot;ctaTextFontColor\&quot;:
     * \&quot;#FFFFFF\&quot;, \&quot;primaryBgColor\&quot;: \&quot;#D3DEF0\&quot;,
     * \&quot;hideMobileAppNudge\&quot;: false, \&quot;fontFamily\&quot; : \&quot;\&quot;,
     * \&quot;hideProductName\&quot; : false, \&quot;hideFooterPhone\&quot; : false,
     * \&quot;hideFooterAddress\&quot; : false, \&quot;hidePrivacyPolicy\&quot; : false,
     * \&quot;hideManageNotification\&quot; : false, \&quot;hideTsVocabularyDefinitions\&quot;:
     * false, \&quot;hideNotificationStatus\&quot; : false, \&quot;hideErrorMessage\&quot;: false,
     * \&quot;hideUnsubscribeLink\&quot; : false, \&quot;hideModifyAlert\&quot;: false,
     * \&quot;textTransform\&quot;: \&quot;\&quot;, \&quot;replacementValueForLiveboard\&quot;:
     * \&quot;LB dashboard\&quot;, \&quot;replacementValueForAnswer\&quot;: \&quot;Answer
     * dashboard\&quot;, \&quot;replacementValueForSpotIQ\&quot;: \&quot;SpotIQ dashboard\&quot;,
     * \&quot;logoUrl\&quot;:\&quot;\&quot;, \&quot;productName\&quot;:\&quot;ThoughtSpot\&quot;,
     * \&quot;footerPhone\&quot;:\&quot;(800) 508-7008\&quot;,
     * \&quot;footerAddress\&quot;:\&quot;444 Castro St, Suite 1000 Mountain View, CA 94041\&quot;,
     * \&quot;companyWebsiteUrl\&quot;:\&quot;\&quot;,
     * \&quot;companyPrivacyPolicyUrl\&quot;:\&quot;\&quot; } } &#x60;&#x60;&#x60;
     *
     * @param updateEmailCustomizationRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateEmailCustomization(
            UpdateEmailCustomizationRequest updateEmailCustomizationRequest) throws ApiException {
        updateEmailCustomizationWithHttpInfo(updateEmailCustomizationRequest);
    }

    /**
     * Version: 10.12.0.cl or later Updates a customization configuration for the notification
     * email. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer privilege**) or
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. **NOTE**:This
     * endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.
     * #### Usage guidelines To update a custom configuration pass these parameters in your API
     * request: - A JSON map of configuration attributes &#x60;template_properties&#x60;. The
     * following example shows a sample set of customization configuration: &#x60;&#x60;&#x60; { {
     * \&quot;ctaButtonBgColor\&quot;: \&quot;#444DEA\&quot;, \&quot;ctaTextFontColor\&quot;:
     * \&quot;#FFFFFF\&quot;, \&quot;primaryBgColor\&quot;: \&quot;#D3DEF0\&quot;,
     * \&quot;hideMobileAppNudge\&quot;: false, \&quot;fontFamily\&quot; : \&quot;\&quot;,
     * \&quot;hideProductName\&quot; : false, \&quot;hideFooterPhone\&quot; : false,
     * \&quot;hideFooterAddress\&quot; : false, \&quot;hidePrivacyPolicy\&quot; : false,
     * \&quot;hideManageNotification\&quot; : false, \&quot;hideTsVocabularyDefinitions\&quot;:
     * false, \&quot;hideNotificationStatus\&quot; : false, \&quot;hideErrorMessage\&quot;: false,
     * \&quot;hideUnsubscribeLink\&quot; : false, \&quot;hideModifyAlert\&quot;: false,
     * \&quot;textTransform\&quot;: \&quot;\&quot;, \&quot;replacementValueForLiveboard\&quot;:
     * \&quot;LB dashboard\&quot;, \&quot;replacementValueForAnswer\&quot;: \&quot;Answer
     * dashboard\&quot;, \&quot;replacementValueForSpotIQ\&quot;: \&quot;SpotIQ dashboard\&quot;,
     * \&quot;logoUrl\&quot;:\&quot;\&quot;, \&quot;productName\&quot;:\&quot;ThoughtSpot\&quot;,
     * \&quot;footerPhone\&quot;:\&quot;(800) 508-7008\&quot;,
     * \&quot;footerAddress\&quot;:\&quot;444 Castro St, Suite 1000 Mountain View, CA 94041\&quot;,
     * \&quot;companyWebsiteUrl\&quot;:\&quot;\&quot;,
     * \&quot;companyPrivacyPolicyUrl\&quot;:\&quot;\&quot; } } &#x60;&#x60;&#x60;
     *
     * @param updateEmailCustomizationRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateEmailCustomizationWithHttpInfo(
            UpdateEmailCustomizationRequest updateEmailCustomizationRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateEmailCustomizationValidateBeforeCall(updateEmailCustomizationRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.12.0.cl or later Updates a customization configuration for the
     * notification email. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer
     * privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is
     * required. **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable
     * this on your instance. #### Usage guidelines To update a custom configuration pass these
     * parameters in your API request: - A JSON map of configuration attributes
     * &#x60;template_properties&#x60;. The following example shows a sample set of customization
     * configuration: &#x60;&#x60;&#x60; { { \&quot;ctaButtonBgColor\&quot;: \&quot;#444DEA\&quot;,
     * \&quot;ctaTextFontColor\&quot;: \&quot;#FFFFFF\&quot;, \&quot;primaryBgColor\&quot;:
     * \&quot;#D3DEF0\&quot;, \&quot;hideMobileAppNudge\&quot;: false, \&quot;fontFamily\&quot; :
     * \&quot;\&quot;, \&quot;hideProductName\&quot; : false, \&quot;hideFooterPhone\&quot; : false,
     * \&quot;hideFooterAddress\&quot; : false, \&quot;hidePrivacyPolicy\&quot; : false,
     * \&quot;hideManageNotification\&quot; : false, \&quot;hideTsVocabularyDefinitions\&quot;:
     * false, \&quot;hideNotificationStatus\&quot; : false, \&quot;hideErrorMessage\&quot;: false,
     * \&quot;hideUnsubscribeLink\&quot; : false, \&quot;hideModifyAlert\&quot;: false,
     * \&quot;textTransform\&quot;: \&quot;\&quot;, \&quot;replacementValueForLiveboard\&quot;:
     * \&quot;LB dashboard\&quot;, \&quot;replacementValueForAnswer\&quot;: \&quot;Answer
     * dashboard\&quot;, \&quot;replacementValueForSpotIQ\&quot;: \&quot;SpotIQ dashboard\&quot;,
     * \&quot;logoUrl\&quot;:\&quot;\&quot;, \&quot;productName\&quot;:\&quot;ThoughtSpot\&quot;,
     * \&quot;footerPhone\&quot;:\&quot;(800) 508-7008\&quot;,
     * \&quot;footerAddress\&quot;:\&quot;444 Castro St, Suite 1000 Mountain View, CA 94041\&quot;,
     * \&quot;companyWebsiteUrl\&quot;:\&quot;\&quot;,
     * \&quot;companyPrivacyPolicyUrl\&quot;:\&quot;\&quot; } } &#x60;&#x60;&#x60;
     *
     * @param updateEmailCustomizationRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Email Customization configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateEmailCustomizationAsync(
            UpdateEmailCustomizationRequest updateEmailCustomizationRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateEmailCustomizationValidateBeforeCall(
                        updateEmailCustomizationRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateMetadataHeader
     *
     * @param updateMetadataHeaderRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Headers update was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateMetadataHeaderCall(
            UpdateMetadataHeaderRequest updateMetadataHeaderRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateMetadataHeaderRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/headers/update";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateMetadataHeaderValidateBeforeCall(
            UpdateMetadataHeaderRequest updateMetadataHeaderRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'updateMetadataHeaderRequest' is set
        if (updateMetadataHeaderRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateMetadataHeaderRequest' when calling"
                            + " updateMetadataHeader(Async)");
        }

        return updateMetadataHeaderCall(updateMetadataHeaderRequest, _callback);
    }

    /**
     * Update header attributes for a given list of header objects. Version: 10.6.0.cl or later ##
     * Prerequisites - **Privileges Required:** - &#x60;DATAMANAGEMENT&#x60; (Can manage data) or
     * &#x60;ADMINISTRATION&#x60; (Can administer ThoughtSpot). - **Additional Privileges (if RBAC
     * is enabled):** - &#x60;ORG_ADMINISTRATION&#x60; (Can manage orgs). --- ## Usage Guidelines
     * ### Parameters 1. **headers_update** - **Description:** List of header objects with their
     * attributes to be updated. Each object contains a list of attributes to be updated in the
     * header. - **Usage:** - You must provide either &#x60;identifier&#x60; or
     * &#x60;obj_identifier&#x60;, but not both. Both fields cannot be empty. - When
     * &#x60;org_identifier&#x60; is set to &#x60;-1&#x60;, only the &#x60;identifier&#x60; value is
     * accepted; &#x60;obj_identifier&#x60; is not allowed. 2. **org_identifier** - **Description:**
     * GUID (Globally Unique Identifier) or name of the organization. - **Usage:** - Leaving this
     * field empty assumes that the changes should be applied to the current organization - Provide
     * &#x60;org_guid&#x60; or &#x60;org_name&#x60; to uniquely identify the organization where
     * changes need to be applied. . - Provide &#x60;-1&#x60; if changes have to be applied across
     * all the org. --- ## Note Currently, this API is enabled only for updating the
     * &#x60;obj_identifier&#x60; attribute. Only &#x60;text&#x60; will be allowed in
     * attribute&#39;s value. ## Best Practices 1. **Backup Before Conversion:** Always export
     * metadata as a backup before initiating the update process --- ## Examples ### Only
     * &#x60;identifier&#x60; is given &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [ {
     * \&quot;identifier\&quot;: \&quot;guid_1\&quot;, \&quot;obj_identifier\&quot;: \&quot;\&quot;,
     * \&quot;type\&quot;: \&quot;LOGICAL_COLUMN\&quot;, \&quot;attributes\&quot;: [ {
     * \&quot;name\&quot;: \&quot;obj_id\&quot;, \&quot;value\&quot;: \&quot;custom_object_id\&quot;
     * } ] } ], \&quot;org_identifier\&quot;: \&quot;orgGuid\&quot; } &#x60;&#x60;&#x60; ### Only
     * &#x60;obj_identifier&#x60; is given &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [
     * { \&quot;obj_identifier\&quot;: \&quot;custom_object_id\&quot;, \&quot;type\&quot;:
     * \&quot;ANSWER\&quot;, \&quot;attributes\&quot;: [ { \&quot;name\&quot;: \&quot;obj_id\&quot;,
     * \&quot;value\&quot;: \&quot;custom_object_id\&quot; } ] } ], \&quot;org_identifier\&quot;:
     * \&quot;orgName\&quot; } &#x60;&#x60;&#x60; ### Executing update for all org &#x60;-1&#x60;
     * &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [ { \&quot;identifier\&quot;:
     * \&quot;guid_1\&quot;, \&quot;type\&quot;: \&quot;ANSWER\&quot;, \&quot;attributes\&quot;: [ {
     * \&quot;name\&quot;: \&quot;obj_id\&quot;, \&quot;value\&quot;: \&quot;custom_object_id\&quot;
     * } ] } ], \&quot;org_identifier\&quot;: -1 } &#x60;&#x60;&#x60; ### Optional &#x60;type&#x60;
     * is not provided &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [ {
     * \&quot;identifier\&quot;: \&quot;guid_1\&quot;, \&quot;attributes\&quot;: [ {
     * \&quot;name\&quot;: \&quot;obj_id\&quot;, \&quot;value\&quot;: \&quot;custom_object_id\&quot;
     * } ] } ], \&quot;org_identifier\&quot;: -1 } &#x60;&#x60;&#x60;
     *
     * @param updateMetadataHeaderRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Headers update was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateMetadataHeader(UpdateMetadataHeaderRequest updateMetadataHeaderRequest)
            throws ApiException {
        updateMetadataHeaderWithHttpInfo(updateMetadataHeaderRequest);
    }

    /**
     * Update header attributes for a given list of header objects. Version: 10.6.0.cl or later ##
     * Prerequisites - **Privileges Required:** - &#x60;DATAMANAGEMENT&#x60; (Can manage data) or
     * &#x60;ADMINISTRATION&#x60; (Can administer ThoughtSpot). - **Additional Privileges (if RBAC
     * is enabled):** - &#x60;ORG_ADMINISTRATION&#x60; (Can manage orgs). --- ## Usage Guidelines
     * ### Parameters 1. **headers_update** - **Description:** List of header objects with their
     * attributes to be updated. Each object contains a list of attributes to be updated in the
     * header. - **Usage:** - You must provide either &#x60;identifier&#x60; or
     * &#x60;obj_identifier&#x60;, but not both. Both fields cannot be empty. - When
     * &#x60;org_identifier&#x60; is set to &#x60;-1&#x60;, only the &#x60;identifier&#x60; value is
     * accepted; &#x60;obj_identifier&#x60; is not allowed. 2. **org_identifier** - **Description:**
     * GUID (Globally Unique Identifier) or name of the organization. - **Usage:** - Leaving this
     * field empty assumes that the changes should be applied to the current organization - Provide
     * &#x60;org_guid&#x60; or &#x60;org_name&#x60; to uniquely identify the organization where
     * changes need to be applied. . - Provide &#x60;-1&#x60; if changes have to be applied across
     * all the org. --- ## Note Currently, this API is enabled only for updating the
     * &#x60;obj_identifier&#x60; attribute. Only &#x60;text&#x60; will be allowed in
     * attribute&#39;s value. ## Best Practices 1. **Backup Before Conversion:** Always export
     * metadata as a backup before initiating the update process --- ## Examples ### Only
     * &#x60;identifier&#x60; is given &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [ {
     * \&quot;identifier\&quot;: \&quot;guid_1\&quot;, \&quot;obj_identifier\&quot;: \&quot;\&quot;,
     * \&quot;type\&quot;: \&quot;LOGICAL_COLUMN\&quot;, \&quot;attributes\&quot;: [ {
     * \&quot;name\&quot;: \&quot;obj_id\&quot;, \&quot;value\&quot;: \&quot;custom_object_id\&quot;
     * } ] } ], \&quot;org_identifier\&quot;: \&quot;orgGuid\&quot; } &#x60;&#x60;&#x60; ### Only
     * &#x60;obj_identifier&#x60; is given &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [
     * { \&quot;obj_identifier\&quot;: \&quot;custom_object_id\&quot;, \&quot;type\&quot;:
     * \&quot;ANSWER\&quot;, \&quot;attributes\&quot;: [ { \&quot;name\&quot;: \&quot;obj_id\&quot;,
     * \&quot;value\&quot;: \&quot;custom_object_id\&quot; } ] } ], \&quot;org_identifier\&quot;:
     * \&quot;orgName\&quot; } &#x60;&#x60;&#x60; ### Executing update for all org &#x60;-1&#x60;
     * &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [ { \&quot;identifier\&quot;:
     * \&quot;guid_1\&quot;, \&quot;type\&quot;: \&quot;ANSWER\&quot;, \&quot;attributes\&quot;: [ {
     * \&quot;name\&quot;: \&quot;obj_id\&quot;, \&quot;value\&quot;: \&quot;custom_object_id\&quot;
     * } ] } ], \&quot;org_identifier\&quot;: -1 } &#x60;&#x60;&#x60; ### Optional &#x60;type&#x60;
     * is not provided &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [ {
     * \&quot;identifier\&quot;: \&quot;guid_1\&quot;, \&quot;attributes\&quot;: [ {
     * \&quot;name\&quot;: \&quot;obj_id\&quot;, \&quot;value\&quot;: \&quot;custom_object_id\&quot;
     * } ] } ], \&quot;org_identifier\&quot;: -1 } &#x60;&#x60;&#x60;
     *
     * @param updateMetadataHeaderRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Headers update was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateMetadataHeaderWithHttpInfo(
            UpdateMetadataHeaderRequest updateMetadataHeaderRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateMetadataHeaderValidateBeforeCall(updateMetadataHeaderRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Update header attributes for a given list of header objects. Version:
     * 10.6.0.cl or later ## Prerequisites - **Privileges Required:** - &#x60;DATAMANAGEMENT&#x60;
     * (Can manage data) or &#x60;ADMINISTRATION&#x60; (Can administer ThoughtSpot). - **Additional
     * Privileges (if RBAC is enabled):** - &#x60;ORG_ADMINISTRATION&#x60; (Can manage orgs). --- ##
     * Usage Guidelines ### Parameters 1. **headers_update** - **Description:** List of header
     * objects with their attributes to be updated. Each object contains a list of attributes to be
     * updated in the header. - **Usage:** - You must provide either &#x60;identifier&#x60; or
     * &#x60;obj_identifier&#x60;, but not both. Both fields cannot be empty. - When
     * &#x60;org_identifier&#x60; is set to &#x60;-1&#x60;, only the &#x60;identifier&#x60; value is
     * accepted; &#x60;obj_identifier&#x60; is not allowed. 2. **org_identifier** - **Description:**
     * GUID (Globally Unique Identifier) or name of the organization. - **Usage:** - Leaving this
     * field empty assumes that the changes should be applied to the current organization - Provide
     * &#x60;org_guid&#x60; or &#x60;org_name&#x60; to uniquely identify the organization where
     * changes need to be applied. . - Provide &#x60;-1&#x60; if changes have to be applied across
     * all the org. --- ## Note Currently, this API is enabled only for updating the
     * &#x60;obj_identifier&#x60; attribute. Only &#x60;text&#x60; will be allowed in
     * attribute&#39;s value. ## Best Practices 1. **Backup Before Conversion:** Always export
     * metadata as a backup before initiating the update process --- ## Examples ### Only
     * &#x60;identifier&#x60; is given &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [ {
     * \&quot;identifier\&quot;: \&quot;guid_1\&quot;, \&quot;obj_identifier\&quot;: \&quot;\&quot;,
     * \&quot;type\&quot;: \&quot;LOGICAL_COLUMN\&quot;, \&quot;attributes\&quot;: [ {
     * \&quot;name\&quot;: \&quot;obj_id\&quot;, \&quot;value\&quot;: \&quot;custom_object_id\&quot;
     * } ] } ], \&quot;org_identifier\&quot;: \&quot;orgGuid\&quot; } &#x60;&#x60;&#x60; ### Only
     * &#x60;obj_identifier&#x60; is given &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [
     * { \&quot;obj_identifier\&quot;: \&quot;custom_object_id\&quot;, \&quot;type\&quot;:
     * \&quot;ANSWER\&quot;, \&quot;attributes\&quot;: [ { \&quot;name\&quot;: \&quot;obj_id\&quot;,
     * \&quot;value\&quot;: \&quot;custom_object_id\&quot; } ] } ], \&quot;org_identifier\&quot;:
     * \&quot;orgName\&quot; } &#x60;&#x60;&#x60; ### Executing update for all org &#x60;-1&#x60;
     * &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [ { \&quot;identifier\&quot;:
     * \&quot;guid_1\&quot;, \&quot;type\&quot;: \&quot;ANSWER\&quot;, \&quot;attributes\&quot;: [ {
     * \&quot;name\&quot;: \&quot;obj_id\&quot;, \&quot;value\&quot;: \&quot;custom_object_id\&quot;
     * } ] } ], \&quot;org_identifier\&quot;: -1 } &#x60;&#x60;&#x60; ### Optional &#x60;type&#x60;
     * is not provided &#x60;&#x60;&#x60;json { \&quot;headers_update\&quot;: [ {
     * \&quot;identifier\&quot;: \&quot;guid_1\&quot;, \&quot;attributes\&quot;: [ {
     * \&quot;name\&quot;: \&quot;obj_id\&quot;, \&quot;value\&quot;: \&quot;custom_object_id\&quot;
     * } ] } ], \&quot;org_identifier\&quot;: -1 } &#x60;&#x60;&#x60;
     *
     * @param updateMetadataHeaderRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Headers update was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateMetadataHeaderAsync(
            UpdateMetadataHeaderRequest updateMetadataHeaderRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateMetadataHeaderValidateBeforeCall(updateMetadataHeaderRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateMetadataObjId
     *
     * @param updateMetadataObjIdRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Headers update was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateMetadataObjIdCall(
            UpdateMetadataObjIdRequest updateMetadataObjIdRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateMetadataObjIdRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/metadata/update-obj-id";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateMetadataObjIdValidateBeforeCall(
            UpdateMetadataObjIdRequest updateMetadataObjIdRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'updateMetadataObjIdRequest' is set
        if (updateMetadataObjIdRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateMetadataObjIdRequest' when calling"
                            + " updateMetadataObjId(Async)");
        }

        return updateMetadataObjIdCall(updateMetadataObjIdRequest, _callback);
    }

    /**
     * Update object IDs for given metadata objects. Version: 10.8.0.cl or later ## Prerequisites -
     * **Privileges Required:** - &#x60;DATAMANAGEMENT&#x60; (Can manage data) or
     * &#x60;ADMINISTRATION&#x60; (Can administer ThoughtSpot). - **Additional Privileges (if RBAC
     * is enabled):** - &#x60;ORG_ADMINISTRATION&#x60; (Can manage orgs). --- ## Usage Guidelines
     * ### Parameters 1. **metadata** - **Description:** List of metadata objects to update their
     * object IDs. - **Usage:** - Use either &#x60;current_obj_id&#x60; alone OR use
     * &#x60;metadata_identifier&#x60; with &#x60;type&#x60; (when needed). - When using
     * &#x60;metadata_identifier&#x60;, the &#x60;type&#x60; field is required if using a name
     * instead of a GUID. - The &#x60;new_obj_id&#x60; field is always required. --- ## Note This
     * API is specifically designed for updating object IDs of metadata objects. It internally uses
     * the header update mechanism to perform the changes. ## Best Practices 1. **Backup Before
     * Update:** Always export metadata as a backup before initiating the update process. 2.
     * **Validation:** - When using &#x60;current_obj_id&#x60;, ensure it matches the existing
     * object ID exactly. - When using &#x60;metadata_identifier&#x60; with a name, ensure the
     * &#x60;type&#x60; is specified correctly. - Verify that the &#x60;new_obj_id&#x60; follows
     * your naming conventions and is unique within your system. --- ## Examples ### Using
     * current_obj_id &#x60;&#x60;&#x60;json { \&quot;metadata\&quot;: [ {
     * \&quot;current_obj_id\&quot;: \&quot;existing_object_id\&quot;, \&quot;new_obj_id\&quot;:
     * \&quot;new_object_id\&quot; } ] } &#x60;&#x60;&#x60; ### Using metadata_identifier with GUID
     * &#x60;&#x60;&#x60;json { \&quot;metadata\&quot;: [ { \&quot;metadata_identifier\&quot;:
     * \&quot;01234567-89ab-cdef-0123-456789abcdef\&quot;, \&quot;new_obj_id\&quot;:
     * \&quot;new_object_id\&quot; } ] } &#x60;&#x60;&#x60; ### Using metadata_identifier with name
     * and type &#x60;&#x60;&#x60;json { \&quot;metadata\&quot;: [ {
     * \&quot;metadata_identifier\&quot;: \&quot;My Answer\&quot;, \&quot;type\&quot;:
     * \&quot;ANSWER\&quot;, \&quot;new_obj_id\&quot;: \&quot;new_object_id\&quot; } ] }
     * &#x60;&#x60;&#x60; ### Multiple objects update &#x60;&#x60;&#x60;json {
     * \&quot;metadata\&quot;: [ { \&quot;current_obj_id\&quot;: \&quot;existing_object_id_1\&quot;,
     * \&quot;new_obj_id\&quot;: \&quot;new_object_id_1\&quot; }, {
     * \&quot;metadata_identifier\&quot;: \&quot;My Worksheet\&quot;, \&quot;type\&quot;:
     * \&quot;LOGICAL_TABLE\&quot;, \&quot;new_obj_id\&quot;: \&quot;new_object_id_2\&quot; } ] }
     * &#x60;&#x60;&#x60;
     *
     * @param updateMetadataObjIdRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Headers update was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateMetadataObjId(UpdateMetadataObjIdRequest updateMetadataObjIdRequest)
            throws ApiException {
        updateMetadataObjIdWithHttpInfo(updateMetadataObjIdRequest);
    }

    /**
     * Update object IDs for given metadata objects. Version: 10.8.0.cl or later ## Prerequisites -
     * **Privileges Required:** - &#x60;DATAMANAGEMENT&#x60; (Can manage data) or
     * &#x60;ADMINISTRATION&#x60; (Can administer ThoughtSpot). - **Additional Privileges (if RBAC
     * is enabled):** - &#x60;ORG_ADMINISTRATION&#x60; (Can manage orgs). --- ## Usage Guidelines
     * ### Parameters 1. **metadata** - **Description:** List of metadata objects to update their
     * object IDs. - **Usage:** - Use either &#x60;current_obj_id&#x60; alone OR use
     * &#x60;metadata_identifier&#x60; with &#x60;type&#x60; (when needed). - When using
     * &#x60;metadata_identifier&#x60;, the &#x60;type&#x60; field is required if using a name
     * instead of a GUID. - The &#x60;new_obj_id&#x60; field is always required. --- ## Note This
     * API is specifically designed for updating object IDs of metadata objects. It internally uses
     * the header update mechanism to perform the changes. ## Best Practices 1. **Backup Before
     * Update:** Always export metadata as a backup before initiating the update process. 2.
     * **Validation:** - When using &#x60;current_obj_id&#x60;, ensure it matches the existing
     * object ID exactly. - When using &#x60;metadata_identifier&#x60; with a name, ensure the
     * &#x60;type&#x60; is specified correctly. - Verify that the &#x60;new_obj_id&#x60; follows
     * your naming conventions and is unique within your system. --- ## Examples ### Using
     * current_obj_id &#x60;&#x60;&#x60;json { \&quot;metadata\&quot;: [ {
     * \&quot;current_obj_id\&quot;: \&quot;existing_object_id\&quot;, \&quot;new_obj_id\&quot;:
     * \&quot;new_object_id\&quot; } ] } &#x60;&#x60;&#x60; ### Using metadata_identifier with GUID
     * &#x60;&#x60;&#x60;json { \&quot;metadata\&quot;: [ { \&quot;metadata_identifier\&quot;:
     * \&quot;01234567-89ab-cdef-0123-456789abcdef\&quot;, \&quot;new_obj_id\&quot;:
     * \&quot;new_object_id\&quot; } ] } &#x60;&#x60;&#x60; ### Using metadata_identifier with name
     * and type &#x60;&#x60;&#x60;json { \&quot;metadata\&quot;: [ {
     * \&quot;metadata_identifier\&quot;: \&quot;My Answer\&quot;, \&quot;type\&quot;:
     * \&quot;ANSWER\&quot;, \&quot;new_obj_id\&quot;: \&quot;new_object_id\&quot; } ] }
     * &#x60;&#x60;&#x60; ### Multiple objects update &#x60;&#x60;&#x60;json {
     * \&quot;metadata\&quot;: [ { \&quot;current_obj_id\&quot;: \&quot;existing_object_id_1\&quot;,
     * \&quot;new_obj_id\&quot;: \&quot;new_object_id_1\&quot; }, {
     * \&quot;metadata_identifier\&quot;: \&quot;My Worksheet\&quot;, \&quot;type\&quot;:
     * \&quot;LOGICAL_TABLE\&quot;, \&quot;new_obj_id\&quot;: \&quot;new_object_id_2\&quot; } ] }
     * &#x60;&#x60;&#x60;
     *
     * @param updateMetadataObjIdRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Headers update was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateMetadataObjIdWithHttpInfo(
            UpdateMetadataObjIdRequest updateMetadataObjIdRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateMetadataObjIdValidateBeforeCall(updateMetadataObjIdRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Update object IDs for given metadata objects. Version: 10.8.0.cl or later ##
     * Prerequisites - **Privileges Required:** - &#x60;DATAMANAGEMENT&#x60; (Can manage data) or
     * &#x60;ADMINISTRATION&#x60; (Can administer ThoughtSpot). - **Additional Privileges (if RBAC
     * is enabled):** - &#x60;ORG_ADMINISTRATION&#x60; (Can manage orgs). --- ## Usage Guidelines
     * ### Parameters 1. **metadata** - **Description:** List of metadata objects to update their
     * object IDs. - **Usage:** - Use either &#x60;current_obj_id&#x60; alone OR use
     * &#x60;metadata_identifier&#x60; with &#x60;type&#x60; (when needed). - When using
     * &#x60;metadata_identifier&#x60;, the &#x60;type&#x60; field is required if using a name
     * instead of a GUID. - The &#x60;new_obj_id&#x60; field is always required. --- ## Note This
     * API is specifically designed for updating object IDs of metadata objects. It internally uses
     * the header update mechanism to perform the changes. ## Best Practices 1. **Backup Before
     * Update:** Always export metadata as a backup before initiating the update process. 2.
     * **Validation:** - When using &#x60;current_obj_id&#x60;, ensure it matches the existing
     * object ID exactly. - When using &#x60;metadata_identifier&#x60; with a name, ensure the
     * &#x60;type&#x60; is specified correctly. - Verify that the &#x60;new_obj_id&#x60; follows
     * your naming conventions and is unique within your system. --- ## Examples ### Using
     * current_obj_id &#x60;&#x60;&#x60;json { \&quot;metadata\&quot;: [ {
     * \&quot;current_obj_id\&quot;: \&quot;existing_object_id\&quot;, \&quot;new_obj_id\&quot;:
     * \&quot;new_object_id\&quot; } ] } &#x60;&#x60;&#x60; ### Using metadata_identifier with GUID
     * &#x60;&#x60;&#x60;json { \&quot;metadata\&quot;: [ { \&quot;metadata_identifier\&quot;:
     * \&quot;01234567-89ab-cdef-0123-456789abcdef\&quot;, \&quot;new_obj_id\&quot;:
     * \&quot;new_object_id\&quot; } ] } &#x60;&#x60;&#x60; ### Using metadata_identifier with name
     * and type &#x60;&#x60;&#x60;json { \&quot;metadata\&quot;: [ {
     * \&quot;metadata_identifier\&quot;: \&quot;My Answer\&quot;, \&quot;type\&quot;:
     * \&quot;ANSWER\&quot;, \&quot;new_obj_id\&quot;: \&quot;new_object_id\&quot; } ] }
     * &#x60;&#x60;&#x60; ### Multiple objects update &#x60;&#x60;&#x60;json {
     * \&quot;metadata\&quot;: [ { \&quot;current_obj_id\&quot;: \&quot;existing_object_id_1\&quot;,
     * \&quot;new_obj_id\&quot;: \&quot;new_object_id_1\&quot; }, {
     * \&quot;metadata_identifier\&quot;: \&quot;My Worksheet\&quot;, \&quot;type\&quot;:
     * \&quot;LOGICAL_TABLE\&quot;, \&quot;new_obj_id\&quot;: \&quot;new_object_id_2\&quot; } ] }
     * &#x60;&#x60;&#x60;
     *
     * @param updateMetadataObjIdRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Headers update was successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateMetadataObjIdAsync(
            UpdateMetadataObjIdRequest updateMetadataObjIdRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateMetadataObjIdValidateBeforeCall(updateMetadataObjIdRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateOrg
     *
     * @param orgIdentifier ID or name of the Org (required)
     * @param updateOrgRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Organization successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateOrgCall(
            String orgIdentifier, UpdateOrgRequest updateOrgRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateOrgRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/orgs/{org_identifier}/update"
                        .replace(
                                "{" + "org_identifier" + "}",
                                localVarApiClient.escapeString(orgIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateOrgValidateBeforeCall(
            String orgIdentifier, UpdateOrgRequest updateOrgRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'orgIdentifier' is set
        if (orgIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'orgIdentifier' when calling updateOrg(Async)");
        }

        // verify the required parameter 'updateOrgRequest' is set
        if (updateOrgRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateOrgRequest' when calling"
                            + " updateOrg(Async)");
        }

        return updateOrgCall(orgIdentifier, updateOrgRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Updates an Org object. You can modify Org properties such as name,
     * description, and user associations. Requires cluster administration (**Can administer Org**)
     * privileges. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is required.
     *
     * @param orgIdentifier ID or name of the Org (required)
     * @param updateOrgRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Organization successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateOrg(String orgIdentifier, UpdateOrgRequest updateOrgRequest)
            throws ApiException {
        updateOrgWithHttpInfo(orgIdentifier, updateOrgRequest);
    }

    /**
     * Version: 9.0.0.cl or later Updates an Org object. You can modify Org properties such as name,
     * description, and user associations. Requires cluster administration (**Can administer Org**)
     * privileges. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is required.
     *
     * @param orgIdentifier ID or name of the Org (required)
     * @param updateOrgRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Organization successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateOrgWithHttpInfo(
            String orgIdentifier, UpdateOrgRequest updateOrgRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateOrgValidateBeforeCall(orgIdentifier, updateOrgRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Updates an Org object. You can modify Org
     * properties such as name, description, and user associations. Requires cluster administration
     * (**Can administer Org**) privileges. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;ORG_ADMINISTRATION&#x60; (**Can manage Orgs**) privilege is required.
     *
     * @param orgIdentifier ID or name of the Org (required)
     * @param updateOrgRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Organization successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateOrgAsync(
            String orgIdentifier,
            UpdateOrgRequest updateOrgRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateOrgValidateBeforeCall(orgIdentifier, updateOrgRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateRole
     *
     * @param roleIdentifier Unique ID or name of the Role. (required)
     * @param updateRoleRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Role successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateRoleCall(
            String roleIdentifier, UpdateRoleRequest updateRoleRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateRoleRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/roles/{role_identifier}/update"
                        .replace(
                                "{" + "role_identifier" + "}",
                                localVarApiClient.escapeString(roleIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateRoleValidateBeforeCall(
            String roleIdentifier, UpdateRoleRequest updateRoleRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'roleIdentifier' is set
        if (roleIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'roleIdentifier' when calling"
                            + " updateRole(Async)");
        }

        // verify the required parameter 'updateRoleRequest' is set
        if (updateRoleRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateRoleRequest' when calling"
                            + " updateRole(Async)");
        }

        return updateRoleCall(roleIdentifier, updateRoleRequest, _callback);
    }

    /**
     * Version: 9.5.0.cl or later Updates the properties of a Role object. Available only if
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance. To update a Role, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can manage
     * roles**) privilege is required.
     *
     * @param roleIdentifier Unique ID or name of the Role. (required)
     * @param updateRoleRequest (required)
     * @return RoleResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Role successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public RoleResponse updateRole(String roleIdentifier, UpdateRoleRequest updateRoleRequest)
            throws ApiException {
        ApiResponse<RoleResponse> localVarResp =
                updateRoleWithHttpInfo(roleIdentifier, updateRoleRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.5.0.cl or later Updates the properties of a Role object. Available only if
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance. To update a Role, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can manage
     * roles**) privilege is required.
     *
     * @param roleIdentifier Unique ID or name of the Role. (required)
     * @param updateRoleRequest (required)
     * @return ApiResponse&lt;RoleResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Role successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<RoleResponse> updateRoleWithHttpInfo(
            String roleIdentifier, UpdateRoleRequest updateRoleRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateRoleValidateBeforeCall(roleIdentifier, updateRoleRequest, null);
        Type localVarReturnType = new TypeToken<RoleResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.5.0.cl or later Updates the properties of a Role object.
     * Available only if [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To update
     * a Role, the &#x60;ROLE_ADMINISTRATION&#x60; (**Can manage roles**) privilege is required.
     *
     * @param roleIdentifier Unique ID or name of the Role. (required)
     * @param updateRoleRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Role successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateRoleAsync(
            String roleIdentifier,
            UpdateRoleRequest updateRoleRequest,
            final ApiCallback<RoleResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateRoleValidateBeforeCall(roleIdentifier, updateRoleRequest, _callback);
        Type localVarReturnType = new TypeToken<RoleResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateSchedule
     *
     * @param scheduleIdentifier Unique ID or name of the schedule. (required)
     * @param updateScheduleRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Schedule successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateScheduleCall(
            String scheduleIdentifier,
            UpdateScheduleRequest updateScheduleRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateScheduleRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/schedules/{schedule_identifier}/update"
                        .replace(
                                "{" + "schedule_identifier" + "}",
                                localVarApiClient.escapeString(scheduleIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateScheduleValidateBeforeCall(
            String scheduleIdentifier,
            UpdateScheduleRequest updateScheduleRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'scheduleIdentifier' is set
        if (scheduleIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'scheduleIdentifier' when calling"
                            + " updateSchedule(Async)");
        }

        // verify the required parameter 'updateScheduleRequest' is set
        if (updateScheduleRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateScheduleRequest' when calling"
                            + " updateSchedule(Async)");
        }

        return updateScheduleCall(scheduleIdentifier, updateScheduleRequest, _callback);
    }

    /**
     * Update schedule. Version: 9.4.0.cl or later Updates a scheduled Liveboard job. Requires at
     * least edit access to Liveboards. To update a schedule on behalf of another user, you need
     * &#x60;ADMINISTRATION&#x60; (**Can administer Org**) or &#x60;JOBSCHEDULING&#x60; (**Can
     * schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege is required. The API
     * endpoint allows you to pause a scheduled job, change the status of a paused job. You can also
     * edit the recipients list, frequency of the job, format of the file to send to the recipients
     * in email notifications, PDF options, and time zone setting.
     *
     * @param scheduleIdentifier Unique ID or name of the schedule. (required)
     * @param updateScheduleRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Schedule successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateSchedule(
            String scheduleIdentifier, UpdateScheduleRequest updateScheduleRequest)
            throws ApiException {
        updateScheduleWithHttpInfo(scheduleIdentifier, updateScheduleRequest);
    }

    /**
     * Update schedule. Version: 9.4.0.cl or later Updates a scheduled Liveboard job. Requires at
     * least edit access to Liveboards. To update a schedule on behalf of another user, you need
     * &#x60;ADMINISTRATION&#x60; (**Can administer Org**) or &#x60;JOBSCHEDULING&#x60; (**Can
     * schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege is required. The API
     * endpoint allows you to pause a scheduled job, change the status of a paused job. You can also
     * edit the recipients list, frequency of the job, format of the file to send to the recipients
     * in email notifications, PDF options, and time zone setting.
     *
     * @param scheduleIdentifier Unique ID or name of the schedule. (required)
     * @param updateScheduleRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Schedule successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateScheduleWithHttpInfo(
            String scheduleIdentifier, UpdateScheduleRequest updateScheduleRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                updateScheduleValidateBeforeCall(scheduleIdentifier, updateScheduleRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Update schedule. Version: 9.4.0.cl or later Updates a scheduled Liveboard
     * job. Requires at least edit access to Liveboards. To update a schedule on behalf of another
     * user, you need &#x60;ADMINISTRATION&#x60; (**Can administer Org**) or
     * &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege and edit access to the
     * Liveboard. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;JOBSCHEDULING&#x60; (**Can schedule for others**) privilege is required. The API
     * endpoint allows you to pause a scheduled job, change the status of a paused job. You can also
     * edit the recipients list, frequency of the job, format of the file to send to the recipients
     * in email notifications, PDF options, and time zone setting.
     *
     * @param scheduleIdentifier Unique ID or name of the schedule. (required)
     * @param updateScheduleRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Schedule successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateScheduleAsync(
            String scheduleIdentifier,
            UpdateScheduleRequest updateScheduleRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateScheduleValidateBeforeCall(
                        scheduleIdentifier, updateScheduleRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateSystemConfig
     *
     * @param updateSystemConfigRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateSystemConfigCall(
            UpdateSystemConfigRequest updateSystemConfigRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateSystemConfigRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/system/config-update";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateSystemConfigValidateBeforeCall(
            UpdateSystemConfigRequest updateSystemConfigRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'updateSystemConfigRequest' is set
        if (updateSystemConfigRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateSystemConfigRequest' when calling"
                            + " updateSystemConfig(Async)");
        }

        return updateSystemConfigCall(updateSystemConfigRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Updates the current configuration of the cluster. You must send
     * the configuration data in JSON format. Requires &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privileges. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;APPLICATION_ADMINISTRATION&#x60; (**Can manage application settings**) privilege is
     * required.
     *
     * @param updateSystemConfigRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateSystemConfig(UpdateSystemConfigRequest updateSystemConfigRequest)
            throws ApiException {
        updateSystemConfigWithHttpInfo(updateSystemConfigRequest);
    }

    /**
     * Version: 9.2.0.cl or later Updates the current configuration of the cluster. You must send
     * the configuration data in JSON format. Requires &#x60;ADMINISTRATION&#x60; (**Can administer
     * ThoughtSpot**) privileges. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;APPLICATION_ADMINISTRATION&#x60; (**Can manage application settings**) privilege is
     * required.
     *
     * @param updateSystemConfigRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateSystemConfigWithHttpInfo(
            UpdateSystemConfigRequest updateSystemConfigRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateSystemConfigValidateBeforeCall(updateSystemConfigRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Updates the current configuration of the cluster.
     * You must send the configuration data in JSON format. Requires &#x60;ADMINISTRATION&#x60;
     * (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;APPLICATION_ADMINISTRATION&#x60; (**Can manage application settings**) privilege is
     * required.
     *
     * @param updateSystemConfigRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Configuration successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateSystemConfigAsync(
            UpdateSystemConfigRequest updateSystemConfigRequest, final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateSystemConfigValidateBeforeCall(updateSystemConfigRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateTag
     *
     * @param tagIdentifier Name or Id of the tag. (required)
     * @param updateTagRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tag successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateTagCall(
            String tagIdentifier, UpdateTagRequest updateTagRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateTagRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/tags/{tag_identifier}/update"
                        .replace(
                                "{" + "tag_identifier" + "}",
                                localVarApiClient.escapeString(tagIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateTagValidateBeforeCall(
            String tagIdentifier, UpdateTagRequest updateTagRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'tagIdentifier' is set
        if (tagIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'tagIdentifier' when calling updateTag(Async)");
        }

        // verify the required parameter 'updateTagRequest' is set
        if (updateTagRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateTagRequest' when calling"
                            + " updateTag(Async)");
        }

        return updateTagCall(tagIdentifier, updateTagRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Updates a tag object. You can modify the &#x60;name&#x60; and
     * &#x60;color&#x60; properties of a tag object. Requires &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;TAGMANAGEMENT&#x60; (**Can manage tags**) privilege is required to create, edit, and
     * delete tags.
     *
     * @param tagIdentifier Name or Id of the tag. (required)
     * @param updateTagRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tag successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateTag(String tagIdentifier, UpdateTagRequest updateTagRequest)
            throws ApiException {
        updateTagWithHttpInfo(tagIdentifier, updateTagRequest);
    }

    /**
     * Version: 9.0.0.cl or later Updates a tag object. You can modify the &#x60;name&#x60; and
     * &#x60;color&#x60; properties of a tag object. Requires &#x60;ADMINISTRATION&#x60; (**Can
     * administer ThoughtSpot**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;TAGMANAGEMENT&#x60; (**Can manage tags**) privilege is required to create, edit, and
     * delete tags.
     *
     * @param tagIdentifier Name or Id of the tag. (required)
     * @param updateTagRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tag successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateTagWithHttpInfo(
            String tagIdentifier, UpdateTagRequest updateTagRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateTagValidateBeforeCall(tagIdentifier, updateTagRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Updates a tag object. You can modify the
     * &#x60;name&#x60; and &#x60;color&#x60; properties of a tag object. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;TAGMANAGEMENT&#x60; (**Can manage tags**) privilege is required to create, edit,
     * and delete tags.
     *
     * @param tagIdentifier Name or Id of the tag. (required)
     * @param updateTagRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Tag successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateTagAsync(
            String tagIdentifier,
            UpdateTagRequest updateTagRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateTagValidateBeforeCall(tagIdentifier, updateTagRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateUser
     *
     * @param userIdentifier GUID / name of the user (required)
     * @param updateUserRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateUserCall(
            String userIdentifier, UpdateUserRequest updateUserRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateUserRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/users/{user_identifier}/update"
                        .replace(
                                "{" + "user_identifier" + "}",
                                localVarApiClient.escapeString(userIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateUserValidateBeforeCall(
            String userIdentifier, UpdateUserRequest updateUserRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'userIdentifier' is set
        if (userIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'userIdentifier' when calling"
                            + " updateUser(Async)");
        }

        // verify the required parameter 'updateUserRequest' is set
        if (updateUserRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateUserRequest' when calling"
                            + " updateUser(Async)");
        }

        return updateUserCall(userIdentifier, updateUserRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Updates the properties of a user object. You can modify user
     * properties such as username, email, and share notification settings. You can also assign new
     * groups and Orgs, remove the user from a group or Org, reset password, and modify user
     * preferences. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege.
     * If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance, the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**)
     * privilege is required.
     *
     * @param userIdentifier GUID / name of the user (required)
     * @param updateUserRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateUser(String userIdentifier, UpdateUserRequest updateUserRequest)
            throws ApiException {
        updateUserWithHttpInfo(userIdentifier, updateUserRequest);
    }

    /**
     * Version: 9.0.0.cl or later Updates the properties of a user object. You can modify user
     * properties such as username, email, and share notification settings. You can also assign new
     * groups and Orgs, remove the user from a group or Org, reset password, and modify user
     * preferences. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege.
     * If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance, the &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**)
     * privilege is required.
     *
     * @param userIdentifier GUID / name of the user (required)
     * @param updateUserRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateUserWithHttpInfo(
            String userIdentifier, UpdateUserRequest updateUserRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateUserValidateBeforeCall(userIdentifier, updateUserRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Updates the properties of a user object. You can
     * modify user properties such as username, email, and share notification settings. You can also
     * assign new groups and Orgs, remove the user from a group or Org, reset password, and modify
     * user preferences. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;USER_ADMINISTRATION&#x60; (**Can manage users**) privilege is required.
     *
     * @param userIdentifier GUID / name of the user (required)
     * @param updateUserRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateUserAsync(
            String userIdentifier,
            UpdateUserRequest updateUserRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateUserValidateBeforeCall(userIdentifier, updateUserRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateUserGroup
     *
     * @param groupIdentifier GUID or name of the group. (required)
     * @param updateUserGroupRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User group successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateUserGroupCall(
            String groupIdentifier,
            UpdateUserGroupRequest updateUserGroupRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateUserGroupRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/groups/{group_identifier}/update"
                        .replace(
                                "{" + "group_identifier" + "}",
                                localVarApiClient.escapeString(groupIdentifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateUserGroupValidateBeforeCall(
            String groupIdentifier,
            UpdateUserGroupRequest updateUserGroupRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'groupIdentifier' is set
        if (groupIdentifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'groupIdentifier' when calling"
                            + " updateUserGroup(Async)");
        }

        // verify the required parameter 'updateUserGroupRequest' is set
        if (updateUserGroupRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateUserGroupRequest' when calling"
                            + " updateUserGroup(Async)");
        }

        return updateUserGroupCall(groupIdentifier, updateUserGroupRequest, _callback);
    }

    /**
     * Version: 9.0.0.cl or later Updates the properties of a group object in ThoughtSpot. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is required. ####
     * Supported operations This API endpoint lets you perform the following operations in a single
     * API request: * Edit
     * [privileges](https://developers.thoughtspot.com/docs/?pageid&#x3D;api-user-management#group-privileges)
     * * Add or remove users * Change sharing visibility settings * Add or remove sub-groups *
     * Assign a default Liveboard or update the existing settings
     *
     * @param groupIdentifier GUID or name of the group. (required)
     * @param updateUserGroupRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User group successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateUserGroup(
            String groupIdentifier, UpdateUserGroupRequest updateUserGroupRequest)
            throws ApiException {
        updateUserGroupWithHttpInfo(groupIdentifier, updateUserGroupRequest);
    }

    /**
     * Version: 9.0.0.cl or later Updates the properties of a group object in ThoughtSpot. Requires
     * &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance,
     * the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**) privilege is required. ####
     * Supported operations This API endpoint lets you perform the following operations in a single
     * API request: * Edit
     * [privileges](https://developers.thoughtspot.com/docs/?pageid&#x3D;api-user-management#group-privileges)
     * * Add or remove users * Change sharing visibility settings * Add or remove sub-groups *
     * Assign a default Liveboard or update the existing settings
     *
     * @param groupIdentifier GUID or name of the group. (required)
     * @param updateUserGroupRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User group successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateUserGroupWithHttpInfo(
            String groupIdentifier, UpdateUserGroupRequest updateUserGroupRequest)
            throws ApiException {
        okhttp3.Call localVarCall =
                updateUserGroupValidateBeforeCall(groupIdentifier, updateUserGroupRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 9.0.0.cl or later Updates the properties of a group object in
     * ThoughtSpot. Requires &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege.
     * If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is
     * enabled on your instance, the &#x60;GROUP_ADMINISTRATION&#x60; (**Can manage groups**)
     * privilege is required. #### Supported operations This API endpoint lets you perform the
     * following operations in a single API request: * Edit
     * [privileges](https://developers.thoughtspot.com/docs/?pageid&#x3D;api-user-management#group-privileges)
     * * Add or remove users * Change sharing visibility settings * Add or remove sub-groups *
     * Assign a default Liveboard or update the existing settings
     *
     * @param groupIdentifier GUID or name of the group. (required)
     * @param updateUserGroupRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> User group successfully updated. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateUserGroupAsync(
            String groupIdentifier,
            UpdateUserGroupRequest updateUserGroupRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateUserGroupValidateBeforeCall(
                        groupIdentifier, updateUserGroupRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateVariable
     *
     * @param identifier Unique id or name of the variable to update. (required)
     * @param updateVariableRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Updating the variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateVariableCall(
            String identifier,
            UpdateVariableRequest updateVariableRequest,
            final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateVariableRequest;

        // create path and map variables
        String localVarPath =
                "/api/rest/2.0/template/variables/{identifier}/update"
                        .replace(
                                "{" + "identifier" + "}",
                                localVarApiClient.escapeString(identifier.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateVariableValidateBeforeCall(
            String identifier,
            UpdateVariableRequest updateVariableRequest,
            final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'identifier' is set
        if (identifier == null) {
            throw new ApiException(
                    "Missing the required parameter 'identifier' when calling"
                            + " updateVariable(Async)");
        }

        // verify the required parameter 'updateVariableRequest' is set
        if (updateVariableRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateVariableRequest' when calling"
                            + " updateVariable(Async)");
        }

        return updateVariableCall(identifier, updateVariableRequest, _callback);
    }

    /**
     * Update a variable&#39;s properties Version: 10.9.0.cl or later Allows updating a
     * variable&#39;s properties in ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The
     * API endpoint allows updating: * The variable name
     *
     * @param identifier Unique id or name of the variable to update. (required)
     * @param updateVariableRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Updating the variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateVariable(String identifier, UpdateVariableRequest updateVariableRequest)
            throws ApiException {
        updateVariableWithHttpInfo(identifier, updateVariableRequest);
    }

    /**
     * Update a variable&#39;s properties Version: 10.9.0.cl or later Allows updating a
     * variable&#39;s properties in ThoughtSpot. Requires ADMINISTRATION role and TENANT scope. The
     * API endpoint allows updating: * The variable name
     *
     * @param identifier Unique id or name of the variable to update. (required)
     * @param updateVariableRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Updating the variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateVariableWithHttpInfo(
            String identifier, UpdateVariableRequest updateVariableRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateVariableValidateBeforeCall(identifier, updateVariableRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Update a variable&#39;s properties Version: 10.9.0.cl or later Allows
     * updating a variable&#39;s properties in ThoughtSpot. Requires ADMINISTRATION role and TENANT
     * scope. The API endpoint allows updating: * The variable name
     *
     * @param identifier Unique id or name of the variable to update. (required)
     * @param updateVariableRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Updating the variable is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateVariableAsync(
            String identifier,
            UpdateVariableRequest updateVariableRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateVariableValidateBeforeCall(identifier, updateVariableRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for updateVariableValues
     *
     * @param updateVariableValuesRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Updating variable values is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateVariableValuesCall(
            UpdateVariableValuesRequest updateVariableValuesRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = updateVariableValuesRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/template/variables/update";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call updateVariableValuesValidateBeforeCall(
            UpdateVariableValuesRequest updateVariableValuesRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'updateVariableValuesRequest' is set
        if (updateVariableValuesRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'updateVariableValuesRequest' when calling"
                            + " updateVariableValues(Async)");
        }

        return updateVariableValuesCall(updateVariableValuesRequest, _callback);
    }

    /**
     * Update values for multiple variables Version: 10.9.0.cl or later Allows updating values for
     * multiple variables in ThoughtSpot. Requires ADMINISTRATION role. The API endpoint allows: *
     * Adding new values to variables * Replacing existing values * Deleting values from variables
     * When updating variable values, you need to specify: * The variable identifiers * The values
     * to add/replace/remove for each variable * The operation to perform (ADD, REPLACE, REMOVE,
     * CLEAR) Behaviour based on operation type: * ADD - Adds values to the variable if this is a
     * list type variable, else same as replace. * REPLACE - Replaces all values of a given set of
     * constraints with the current set of values. * REMOVE - Removes any values which match the set
     * of conditions of the variables if this is a list type variable, else clears value. * CLEAR -
     * Removes all constrains for a given variable, scope is ignored
     *
     * @param updateVariableValuesRequest (required)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Updating variable values is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void updateVariableValues(UpdateVariableValuesRequest updateVariableValuesRequest)
            throws ApiException {
        updateVariableValuesWithHttpInfo(updateVariableValuesRequest);
    }

    /**
     * Update values for multiple variables Version: 10.9.0.cl or later Allows updating values for
     * multiple variables in ThoughtSpot. Requires ADMINISTRATION role. The API endpoint allows: *
     * Adding new values to variables * Replacing existing values * Deleting values from variables
     * When updating variable values, you need to specify: * The variable identifiers * The values
     * to add/replace/remove for each variable * The operation to perform (ADD, REPLACE, REMOVE,
     * CLEAR) Behaviour based on operation type: * ADD - Adds values to the variable if this is a
     * list type variable, else same as replace. * REPLACE - Replaces all values of a given set of
     * constraints with the current set of values. * REMOVE - Removes any values which match the set
     * of conditions of the variables if this is a list type variable, else clears value. * CLEAR -
     * Removes all constrains for a given variable, scope is ignored
     *
     * @param updateVariableValuesRequest (required)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Updating variable values is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> updateVariableValuesWithHttpInfo(
            UpdateVariableValuesRequest updateVariableValuesRequest) throws ApiException {
        okhttp3.Call localVarCall =
                updateVariableValuesValidateBeforeCall(updateVariableValuesRequest, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Update values for multiple variables Version: 10.9.0.cl or later Allows
     * updating values for multiple variables in ThoughtSpot. Requires ADMINISTRATION role. The API
     * endpoint allows: * Adding new values to variables * Replacing existing values * Deleting
     * values from variables When updating variable values, you need to specify: * The variable
     * identifiers * The values to add/replace/remove for each variable * The operation to perform
     * (ADD, REPLACE, REMOVE, CLEAR) Behaviour based on operation type: * ADD - Adds values to the
     * variable if this is a list type variable, else same as replace. * REPLACE - Replaces all
     * values of a given set of constraints with the current set of values. * REMOVE - Removes any
     * values which match the set of conditions of the variables if this is a list type variable,
     * else clears value. * CLEAR - Removes all constrains for a given variable, scope is ignored
     *
     * @param updateVariableValuesRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Updating variable values is successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call updateVariableValuesAsync(
            UpdateVariableValuesRequest updateVariableValuesRequest,
            final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                updateVariableValuesValidateBeforeCall(updateVariableValuesRequest, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for validateEmailCustomization
     *
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Triggered test email for customization configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call validateEmailCustomizationCall(final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/customization/email/validate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call validateEmailCustomizationValidateBeforeCall(final ApiCallback _callback)
            throws ApiException {
        return validateEmailCustomizationCall(_callback);
    }

    /**
     * Version: 10.10.0.cl or later Validates the email customization configuration if any set for
     * the ThoughtSpot system. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer
     * privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is
     * required. **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable
     * this on your instance.
     *
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Triggered test email for customization configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public void validateEmailCustomization() throws ApiException {
        validateEmailCustomizationWithHttpInfo();
    }

    /**
     * Version: 10.10.0.cl or later Validates the email customization configuration if any set for
     * the ThoughtSpot system. #### Pre-requisites Requires &#x60;DEVELOPER&#x60; (**has developer
     * privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**) privilege. If
     * [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled
     * on your instance, the &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is
     * required. **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable
     * this on your instance.
     *
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Triggered test email for customization configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<Void> validateEmailCustomizationWithHttpInfo() throws ApiException {
        okhttp3.Call localVarCall = validateEmailCustomizationValidateBeforeCall(null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * (asynchronously) Version: 10.10.0.cl or later Validates the email customization configuration
     * if any set for the ThoughtSpot system. #### Pre-requisites Requires &#x60;DEVELOPER&#x60;
     * (**has developer privilege**) or &#x60;ADMINISTRATION&#x60; (**Can administer ThoughtSpot**)
     * privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the
     * &#x60;DEVELOPER&#x60; (**Has developer privilege**) privilege is required. **NOTE**:This
     * endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.
     *
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 204 </td><td> Triggered test email for customization configuration </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call validateEmailCustomizationAsync(final ApiCallback<Void> _callback)
            throws ApiException {

        okhttp3.Call localVarCall = validateEmailCustomizationValidateBeforeCall(_callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for validateMerge
     *
     * @param validateMergeRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> validation done successfully </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call validateMergeCall(
            ValidateMergeRequest validateMergeRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = validateMergeRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/vcs/git/branches/validate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call validateMergeValidateBeforeCall(
            ValidateMergeRequest validateMergeRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'validateMergeRequest' is set
        if (validateMergeRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'validateMergeRequest' when calling"
                            + " validateMerge(Async)");
        }

        return validateMergeCall(validateMergeRequest, _callback);
    }

    /**
     * Version: 9.2.0.cl or later Validates the content of your source branch against the objects in
     * your destination environment. Before merging content from your source branch to the
     * destination branch, run this API operation from your destination environment and ensure that
     * the changes from the source branch function in the destination environment. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your
     * instance, the &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     * privilege and edit access to the metadata objects.
     *
     * @param validateMergeRequest (required)
     * @return List&lt;DeployResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> validation done successfully </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public List<DeployResponse> validateMerge(ValidateMergeRequest validateMergeRequest)
            throws ApiException {
        ApiResponse<List<DeployResponse>> localVarResp =
                validateMergeWithHttpInfo(validateMergeRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.2.0.cl or later Validates the content of your source branch against the objects in
     * your destination environment. Before merging content from your source branch to the
     * destination branch, run this API operation from your destination environment and ensure that
     * the changes from the source branch function in the destination environment. Requires
     * &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If [Role-Based Access Control
     * (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your
     * instance, the &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     * privilege and edit access to the metadata objects.
     *
     * @param validateMergeRequest (required)
     * @return ApiResponse&lt;List&lt;DeployResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> validation done successfully </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<List<DeployResponse>> validateMergeWithHttpInfo(
            ValidateMergeRequest validateMergeRequest) throws ApiException {
        okhttp3.Call localVarCall = validateMergeValidateBeforeCall(validateMergeRequest, null);
        Type localVarReturnType = new TypeToken<List<DeployResponse>>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.2.0.cl or later Validates the content of your source branch
     * against the objects in your destination environment. Before merging content from your source
     * branch to the destination branch, run this API operation from your destination environment
     * and ensure that the changes from the source branch function in the destination environment.
     * Requires &#x60;DATAMANAGEMENT&#x60; (**Can manage data**) privilege. If [Role-Based Access
     * Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on
     * your instance, the &#x60;CAN_MANAGE_WORKSHEET_VIEWS_TABLES&#x60; (**Can manage data models**)
     * privilege and edit access to the metadata objects.
     *
     * @param validateMergeRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> validation done successfully </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call validateMergeAsync(
            ValidateMergeRequest validateMergeRequest,
            final ApiCallback<List<DeployResponse>> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                validateMergeValidateBeforeCall(validateMergeRequest, _callback);
        Type localVarReturnType = new TypeToken<List<DeployResponse>>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for validateToken
     *
     * @param validateTokenRequest (required)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Token validation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call validateTokenCall(
            ValidateTokenRequest validateTokenRequest, final ApiCallback _callback)
            throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {};

        // Determine Base Path to Use
        if (localCustomBaseUrl != null) {
            basePath = localCustomBaseUrl;
        } else if (localBasePaths.length > 0) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = validateTokenRequest;

        // create path and map variables
        String localVarPath = "/api/rest/2.0/auth/token/validate";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        final String[] localVarAccepts = {"application/json"};
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {"application/json"};
        final String localVarContentType =
                localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {"bearerAuth"};
        return localVarApiClient.buildCall(
                basePath,
                localVarPath,
                "POST",
                localVarQueryParams,
                localVarCollectionQueryParams,
                localVarPostBody,
                localVarHeaderParams,
                localVarCookieParams,
                localVarFormParams,
                localVarAuthNames,
                _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call validateTokenValidateBeforeCall(
            ValidateTokenRequest validateTokenRequest, final ApiCallback _callback)
            throws ApiException {
        // verify the required parameter 'validateTokenRequest' is set
        if (validateTokenRequest == null) {
            throw new ApiException(
                    "Missing the required parameter 'validateTokenRequest' when calling"
                            + " validateToken(Async)");
        }

        return validateTokenCall(validateTokenRequest, _callback);
    }

    /**
     * Version: 9.12.0.cl or later Validates the authentication token specified in the API request.
     * If your token is not valid, [Get a new
     * token](#/http/api-endpoints/authentication/get-full-access-token).
     *
     * @param validateTokenRequest (required)
     * @return TokenValidationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Token validation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public TokenValidationResponse validateToken(ValidateTokenRequest validateTokenRequest)
            throws ApiException {
        ApiResponse<TokenValidationResponse> localVarResp =
                validateTokenWithHttpInfo(validateTokenRequest);
        return localVarResp.getData();
    }

    /**
     * Version: 9.12.0.cl or later Validates the authentication token specified in the API request.
     * If your token is not valid, [Get a new
     * token](#/http/api-endpoints/authentication/get-full-access-token).
     *
     * @param validateTokenRequest (required)
     * @return ApiResponse&lt;TokenValidationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the
     *     response body
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Token validation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public ApiResponse<TokenValidationResponse> validateTokenWithHttpInfo(
            ValidateTokenRequest validateTokenRequest) throws ApiException {
        okhttp3.Call localVarCall = validateTokenValidateBeforeCall(validateTokenRequest, null);
        Type localVarReturnType = new TypeToken<TokenValidationResponse>() {}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * (asynchronously) Version: 9.12.0.cl or later Validates the authentication token specified in
     * the API request. If your token is not valid, [Get a new
     * token](#/http/api-endpoints/authentication/get-full-access-token).
     *
     * @param validateTokenRequest (required)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body
     *     object
     * @http.response.details
     *     <table border="1">
     * <caption>Response Details</caption>
     * <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
     * <tr><td> 200 </td><td> Token validation successful. </td><td>  -  </td></tr>
     * <tr><td> 400 </td><td> Invalid request. </td><td>  -  </td></tr>
     * <tr><td> 401 </td><td> Unauthorized access. </td><td>  -  </td></tr>
     * <tr><td> 403 </td><td> Forbidden access. </td><td>  -  </td></tr>
     * <tr><td> 500 </td><td> Unexpected error </td><td>  -  </td></tr>
     * </table>
     */
    public okhttp3.Call validateTokenAsync(
            ValidateTokenRequest validateTokenRequest,
            final ApiCallback<TokenValidationResponse> _callback)
            throws ApiException {

        okhttp3.Call localVarCall =
                validateTokenValidateBeforeCall(validateTokenRequest, _callback);
        Type localVarReturnType = new TypeToken<TokenValidationResponse>() {}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
