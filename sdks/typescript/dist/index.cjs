"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// index.ts
var typescript_exports = {};
__export(typescript_exports, {
  AIApi: () => PromiseAIApi,
  AIContext: () => AIContext,
  APIKey: () => APIKey,
  APIKeyInput: () => APIKeyInput,
  AccessToken: () => AccessToken,
  ActionConfig: () => ActionConfig,
  ActionConfigInput: () => ActionConfigInput,
  ActionConfigInputCreate: () => ActionConfigInputCreate,
  ActionDetails: () => ActionDetails,
  ActionDetailsInput: () => ActionDetailsInput,
  ActionDetailsInputCreate: () => ActionDetailsInputCreate,
  ActivateUserRequest: () => ActivateUserRequest,
  AgentConversation: () => AgentConversation,
  AnswerContent: () => AnswerContent,
  AnswerContextInput: () => AnswerContextInput,
  AnswerDataResponse: () => AnswerDataResponse,
  ApiException: () => ApiException,
  AssignChangeAuthorRequest: () => AssignChangeAuthorRequest,
  AssignTagRequest: () => AssignTagRequest,
  AssociateMetadataInput: () => AssociateMetadataInput,
  AssociateMetadataInputCreate: () => AssociateMetadataInputCreate,
  Authentication: () => Authentication,
  AuthenticationApi: () => PromiseAuthenticationApi,
  AuthenticationInput: () => AuthenticationInput,
  Author: () => Author,
  AuthorMetadataTypeInput: () => AuthorMetadataTypeInput,
  AuthorType: () => AuthorType,
  BasicAuth: () => BasicAuth,
  BasicAuthInput: () => BasicAuthInput,
  BearerAuthAuthentication: () => BearerAuthAuthentication,
  CALLBACK: () => CALLBACK,
  CALLBACKInput: () => CALLBACKInput,
  CALLBACKInputMandatory: () => CALLBACKInputMandatory,
  CalendarResponse: () => CalendarResponse,
  ChangeUserPasswordRequest: () => ChangeUserPasswordRequest,
  ClusterNonEmbedAccess: () => ClusterNonEmbedAccess,
  ClusterNonEmbedAccessInput: () => ClusterNonEmbedAccessInput,
  Column: () => Column,
  ColumnSecurityRule: () => ColumnSecurityRule,
  ColumnSecurityRuleColumn: () => ColumnSecurityRuleColumn,
  ColumnSecurityRuleGroup: () => ColumnSecurityRuleGroup,
  ColumnSecurityRuleGroupOperation: () => ColumnSecurityRuleGroupOperation,
  ColumnSecurityRuleResponse: () => ColumnSecurityRuleResponse,
  ColumnSecurityRuleSourceTable: () => ColumnSecurityRuleSourceTable,
  ColumnSecurityRuleTableInput: () => ColumnSecurityRuleTableInput,
  ColumnSecurityRuleUpdate: () => ColumnSecurityRuleUpdate,
  CommitBranchRequest: () => CommitBranchRequest,
  CommitFileType: () => CommitFileType,
  CommitHistoryResponse: () => CommitHistoryResponse,
  CommitResponse: () => CommitResponse,
  CommiterType: () => CommiterType,
  CommunicationChannelPreferencesResponse: () => CommunicationChannelPreferencesResponse,
  ConfigureCommunicationChannelPreferencesRequest: () => ConfigureCommunicationChannelPreferencesRequest,
  ConnectionConfigurationResponse: () => ConnectionConfigurationResponse,
  ConnectionConfigurationSearchRequest: () => ConnectionConfigurationSearchRequest,
  ConnectionConfigurationsApi: () => PromiseConnectionConfigurationsApi,
  ConnectionInput: () => ConnectionInput,
  ConnectionsApi: () => PromiseConnectionsApi,
  ContextPayloadV2Input: () => ContextPayloadV2Input,
  Conversation: () => Conversation,
  ConversationSettingsInput: () => ConversationSettingsInput,
  ConvertWorksheetToModelRequest: () => ConvertWorksheetToModelRequest,
  CopyObjectRequest: () => CopyObjectRequest,
  CreateAgentConversationRequest: () => CreateAgentConversationRequest,
  CreateAgentConversationRequestConversationSettings: () => CreateAgentConversationRequestConversationSettings,
  CreateAgentConversationRequestMetadataContext: () => CreateAgentConversationRequestMetadataContext,
  CreateCalendarRequest: () => CreateCalendarRequest,
  CreateCalendarRequestTableReference: () => CreateCalendarRequestTableReference,
  CreateConfigRequest: () => CreateConfigRequest,
  CreateConnectionConfigurationRequest: () => CreateConnectionConfigurationRequest,
  CreateConnectionConfigurationRequestPolicyProcessOptions: () => CreateConnectionConfigurationRequestPolicyProcessOptions,
  CreateConnectionRequest: () => CreateConnectionRequest,
  CreateConnectionResponse: () => CreateConnectionResponse,
  CreateConversationRequest: () => CreateConversationRequest,
  CreateCustomActionRequest: () => CreateCustomActionRequest,
  CreateCustomActionRequestActionDetails: () => CreateCustomActionRequestActionDetails,
  CreateCustomActionRequestDefaultActionConfig: () => CreateCustomActionRequestDefaultActionConfig,
  CreateEmailCustomizationRequest: () => CreateEmailCustomizationRequest,
  CreateEmailCustomizationRequestTemplateProperties: () => CreateEmailCustomizationRequestTemplateProperties,
  CreateEmailCustomizationResponse: () => CreateEmailCustomizationResponse,
  CreateOrgRequest: () => CreateOrgRequest,
  CreateRoleRequest: () => CreateRoleRequest,
  CreateScheduleRequest: () => CreateScheduleRequest,
  CreateScheduleRequestFrequency: () => CreateScheduleRequestFrequency,
  CreateScheduleRequestLiveboardOptions: () => CreateScheduleRequestLiveboardOptions,
  CreateScheduleRequestPdfOptions: () => CreateScheduleRequestPdfOptions,
  CreateScheduleRequestRecipientDetails: () => CreateScheduleRequestRecipientDetails,
  CreateTagRequest: () => CreateTagRequest,
  CreateUserGroupRequest: () => CreateUserGroupRequest,
  CreateUserRequest: () => CreateUserRequest,
  CreateVariableRequest: () => CreateVariableRequest,
  CreateWebhookConfigurationRequest: () => CreateWebhookConfigurationRequest,
  CreateWebhookConfigurationRequestAuthentication: () => CreateWebhookConfigurationRequestAuthentication,
  CreateWebhookConfigurationRequestSignatureVerification: () => CreateWebhookConfigurationRequestSignatureVerification,
  CronExpression: () => CronExpression,
  CronExpressionInput: () => CronExpressionInput,
  CspSettings: () => CspSettings,
  CspSettingsInput: () => CspSettingsInput,
  CustomActionApi: () => PromiseCustomActionApi,
  CustomActionMetadataTypeInput: () => CustomActionMetadataTypeInput,
  CustomCalendarsApi: () => PromiseCustomCalendarsApi,
  DBTApi: () => PromiseDBTApi,
  DataApi: () => PromiseDataApi,
  DataSource: () => DataSource,
  DataSourceContextInput: () => DataSourceContextInput,
  DataWarehouseObjectInput: () => DataWarehouseObjectInput,
  DataWarehouseObjects: () => DataWarehouseObjects,
  Database: () => Database,
  DbtSearchResponse: () => DbtSearchResponse,
  DeactivateUserRequest: () => DeactivateUserRequest,
  DefaultActionConfig: () => DefaultActionConfig,
  DefaultActionConfigInput: () => DefaultActionConfigInput,
  DefaultActionConfigInputCreate: () => DefaultActionConfigInputCreate,
  DefaultActionConfigSearchInput: () => DefaultActionConfigSearchInput,
  DeleteConfigRequest: () => DeleteConfigRequest,
  DeleteConnectionConfigurationRequest: () => DeleteConnectionConfigurationRequest,
  DeleteConnectionRequest: () => DeleteConnectionRequest,
  DeleteMetadataRequest: () => DeleteMetadataRequest,
  DeleteMetadataTypeInput: () => DeleteMetadataTypeInput,
  DeleteOrgEmailCustomizationRequest: () => DeleteOrgEmailCustomizationRequest,
  DeleteWebhookConfigurationsRequest: () => DeleteWebhookConfigurationsRequest,
  DeployCommitRequest: () => DeployCommitRequest,
  DeployResponse: () => DeployResponse,
  EmailCustomizationApi: () => PromiseEmailCustomizationApi,
  EntityHeader: () => EntityHeader,
  ErrorResponse: () => ErrorResponse,
  EurekaDataSourceSuggestionResponse: () => EurekaDataSourceSuggestionResponse,
  EurekaDecomposeQueryResponse: () => EurekaDecomposeQueryResponse,
  EurekaGetNLInstructionsResponse: () => EurekaGetNLInstructionsResponse,
  EurekaGetRelevantQuestionsResponse: () => EurekaGetRelevantQuestionsResponse,
  EurekaLLMDecomposeQueryResponse: () => EurekaLLMDecomposeQueryResponse,
  EurekaLLMSuggestedQuery: () => EurekaLLMSuggestedQuery,
  EurekaRelevantQuestion: () => EurekaRelevantQuestion,
  EurekaSetNLInstructionsResponse: () => EurekaSetNLInstructionsResponse,
  EventChannelConfig: () => EventChannelConfig,
  EventChannelConfigInput: () => EventChannelConfigInput,
  ExcludeMetadataListItemInput: () => ExcludeMetadataListItemInput,
  ExportAnswerReportRequest: () => ExportAnswerReportRequest,
  ExportAnswerReportRequestRegionalSettings: () => ExportAnswerReportRequestRegionalSettings,
  ExportLiveboardReportRequest: () => ExportLiveboardReportRequest,
  ExportLiveboardReportRequestPdfOptions: () => ExportLiveboardReportRequestPdfOptions,
  ExportLiveboardReportRequestPngOptions: () => ExportLiveboardReportRequestPngOptions,
  ExportMetadataTMLBatchedRequest: () => ExportMetadataTMLBatchedRequest,
  ExportMetadataTMLRequest: () => ExportMetadataTMLRequest,
  ExportMetadataTMLRequestExportOptions: () => ExportMetadataTMLRequestExportOptions,
  ExportMetadataTypeInput: () => ExportMetadataTypeInput,
  ExportOptions: () => ExportOptions,
  ExternalTableInput: () => ExternalTableInput,
  FavoriteMetadataInput: () => FavoriteMetadataInput,
  FavoriteMetadataItem: () => FavoriteMetadataItem,
  FavoriteObjectOptionsInput: () => FavoriteObjectOptionsInput,
  FetchAnswerDataRequest: () => FetchAnswerDataRequest,
  FetchAnswerSqlQueryRequest: () => FetchAnswerSqlQueryRequest,
  FetchAsyncImportTaskStatusRequest: () => FetchAsyncImportTaskStatusRequest,
  FetchColumnSecurityRulesRequest: () => FetchColumnSecurityRulesRequest,
  FetchConnectionDiffStatusResponse: () => FetchConnectionDiffStatusResponse,
  FetchLiveboardDataRequest: () => FetchLiveboardDataRequest,
  FetchLiveboardSqlQueryRequest: () => FetchLiveboardSqlQueryRequest,
  FetchLogsRequest: () => FetchLogsRequest,
  FetchPermissionsOfPrincipalsRequest: () => FetchPermissionsOfPrincipalsRequest,
  FetchPermissionsOnMetadataRequest: () => FetchPermissionsOnMetadataRequest,
  FilterRules: () => FilterRules,
  ForceLogoutUsersRequest: () => ForceLogoutUsersRequest,
  Frequency: () => Frequency,
  FrequencyInput: () => FrequencyInput,
  GenerateCSVRequest: () => GenerateCSVRequest,
  GenericInfo: () => GenericInfo,
  GetAsyncImportStatusResponse: () => GetAsyncImportStatusResponse,
  GetCustomAccessTokenRequest: () => GetCustomAccessTokenRequest,
  GetFullAccessTokenRequest: () => GetFullAccessTokenRequest,
  GetFullAccessTokenRequestUserParameters: () => GetFullAccessTokenRequestUserParameters,
  GetObjectAccessTokenRequest: () => GetObjectAccessTokenRequest,
  GetRelevantQuestionsRequest: () => GetRelevantQuestionsRequest,
  GetRelevantQuestionsRequestAiContext: () => GetRelevantQuestionsRequestAiContext,
  GetRelevantQuestionsRequestMetadataContext: () => GetRelevantQuestionsRequestMetadataContext,
  GetTokenResponse: () => GetTokenResponse,
  GroupInfo: () => GroupInfo,
  GroupObject: () => GroupObject,
  GroupsApi: () => PromiseGroupsApi,
  GroupsImportListInput: () => GroupsImportListInput,
  HeaderAttributeInput: () => HeaderAttributeInput,
  HeaderUpdateInput: () => HeaderUpdateInput,
  HttpException: () => HttpException,
  HttpMethod: () => HttpMethod,
  ImportEPackAsyncTaskStatus: () => ImportEPackAsyncTaskStatus,
  ImportMetadataTMLAsyncRequest: () => ImportMetadataTMLAsyncRequest,
  ImportMetadataTMLRequest: () => ImportMetadataTMLRequest,
  ImportUser: () => ImportUser,
  ImportUserGroupsRequest: () => ImportUserGroupsRequest,
  ImportUserGroupsResponse: () => ImportUserGroupsResponse,
  ImportUserType: () => ImportUserType,
  ImportUsersRequest: () => ImportUsersRequest,
  ImportUsersResponse: () => ImportUsersResponse,
  InputEurekaNLSRequest: () => InputEurekaNLSRequest,
  IsomorphicFetchHttpLibrary: () => IsomorphicFetchHttpLibrary,
  JWTMetadataObject: () => JWTMetadataObject,
  JWTParameter: () => JWTParameter,
  JWTUserOptions: () => JWTUserOptions,
  JWTUserOptionsFull: () => JWTUserOptionsFull,
  LBContextInput: () => LBContextInput,
  LiveboardContent: () => LiveboardContent,
  LiveboardDataResponse: () => LiveboardDataResponse,
  LiveboardOptions: () => LiveboardOptions,
  LiveboardOptionsInput: () => LiveboardOptionsInput,
  LogApi: () => PromiseLogApi,
  LogResponse: () => LogResponse,
  LoginRequest: () => LoginRequest,
  MetadataApi: () => PromiseMetadataApi,
  MetadataAssociationItem: () => MetadataAssociationItem,
  MetadataContext: () => MetadataContext,
  MetadataInput: () => MetadataInput,
  MetadataListItemInput: () => MetadataListItemInput,
  MetadataObject: () => MetadataObject,
  MetadataResponse: () => MetadataResponse,
  MetadataSearchResponse: () => MetadataSearchResponse,
  MetadataSearchSortOptions: () => MetadataSearchSortOptions,
  ModelTableList: () => ModelTableList,
  NLInstructionsInfo: () => NLInstructionsInfo,
  NLInstructionsInfoInput: () => NLInstructionsInfoInput,
  ObjectIDAndName: () => ObjectIDAndName,
  Org: () => Org,
  OrgChannelConfigInput: () => OrgChannelConfigInput,
  OrgChannelConfigResponse: () => OrgChannelConfigResponse,
  OrgDetails: () => OrgDetails,
  OrgInfo: () => OrgInfo,
  OrgNonEmbedAccess: () => OrgNonEmbedAccess,
  OrgNonEmbedAccessInput: () => OrgNonEmbedAccessInput,
  OrgPreferenceSearchCriteriaInput: () => OrgPreferenceSearchCriteriaInput,
  OrgResponse: () => OrgResponse,
  OrgType: () => OrgType,
  OrgsApi: () => PromiseOrgsApi,
  ParameterValues: () => ParameterValues,
  ParameterizeMetadataRequest: () => ParameterizeMetadataRequest,
  ParametersListItem: () => ParametersListItem,
  ParametersListItemInput: () => ParametersListItemInput,
  PdfOptions: () => PdfOptions,
  PdfOptionsInput: () => PdfOptionsInput,
  PermissionInput: () => PermissionInput,
  PermissionOfMetadataResponse: () => PermissionOfMetadataResponse,
  PermissionOfPrincipalsResponse: () => PermissionOfPrincipalsResponse,
  PermissionsMetadataTypeInput: () => PermissionsMetadataTypeInput,
  PngOptionsInput: () => PngOptionsInput,
  PolicyProcessOptions: () => PolicyProcessOptions,
  PolicyProcessOptionsInput: () => PolicyProcessOptionsInput,
  PrincipalsInput: () => PrincipalsInput,
  PrincipalsListItem: () => PrincipalsListItem,
  PrincipalsListItemInput: () => PrincipalsListItemInput,
  PublishMetadataListItem: () => PublishMetadataListItem,
  PublishMetadataRequest: () => PublishMetadataRequest,
  QueryGetDecomposedQueryRequest: () => QueryGetDecomposedQueryRequest,
  QueryGetDecomposedQueryRequestNlsRequest: () => QueryGetDecomposedQueryRequestNlsRequest,
  RecipientDetails: () => RecipientDetails,
  RecipientDetailsInput: () => RecipientDetailsInput,
  RegionalSettingsInput: () => RegionalSettingsInput,
  RepoConfigObject: () => RepoConfigObject,
  ReportsApi: () => PromiseReportsApi,
  RequestContext: () => RequestContext2,
  RequiredError: () => RequiredError,
  ResetUserPasswordRequest: () => ResetUserPasswordRequest,
  ResponseActivationURL: () => ResponseActivationURL,
  ResponseContext: () => ResponseContext,
  ResponseCopyObject: () => ResponseCopyObject,
  ResponseCustomAction: () => ResponseCustomAction,
  ResponseFailedEntities: () => ResponseFailedEntities,
  ResponseFailedEntity: () => ResponseFailedEntity,
  ResponseIncompleteEntities: () => ResponseIncompleteEntities,
  ResponseIncompleteEntity: () => ResponseIncompleteEntity,
  ResponseMessage: () => ResponseMessage,
  ResponsePostUpgradeFailedEntities: () => ResponsePostUpgradeFailedEntities,
  ResponsePostUpgradeFailedEntity: () => ResponsePostUpgradeFailedEntity,
  ResponseSchedule: () => ResponseSchedule,
  ResponseScheduleRun: () => ResponseScheduleRun,
  ResponseSuccessfulEntities: () => ResponseSuccessfulEntities,
  ResponseSuccessfulEntity: () => ResponseSuccessfulEntity,
  ResponseWorksheetToModelConversion: () => ResponseWorksheetToModelConversion,
  RevertCommitRequest: () => RevertCommitRequest,
  RevertResponse: () => RevertResponse,
  RevertedMetadata: () => RevertedMetadata,
  RevokeRefreshTokensResponse: () => RevokeRefreshTokensResponse,
  RevokeTokenRequest: () => RevokeTokenRequest,
  RiseGQLArgWrapper: () => RiseGQLArgWrapper,
  RiseSetter: () => RiseSetter,
  Role: () => Role,
  RoleResponse: () => RoleResponse,
  RolesApi: () => PromiseRolesApi,
  RuntimeFilter: () => RuntimeFilter,
  RuntimeFilters: () => RuntimeFilters,
  RuntimeParamOverride: () => RuntimeParamOverride,
  RuntimeParameters: () => RuntimeParameters,
  RuntimeSort: () => RuntimeSort,
  RuntimeSorts: () => RuntimeSorts,
  ScheduleHistoryRunsOptionsInput: () => ScheduleHistoryRunsOptionsInput,
  SchedulesApi: () => PromiseSchedulesApi,
  SchedulesPdfOptionsInput: () => SchedulesPdfOptionsInput,
  SchemaObject: () => SchemaObject,
  Scope: () => Scope,
  ScriptSrcUrls: () => ScriptSrcUrls,
  ScriptSrcUrlsInput: () => ScriptSrcUrlsInput,
  SearchCalendarsRequest: () => SearchCalendarsRequest,
  SearchCalendarsRequestSortOptions: () => SearchCalendarsRequestSortOptions,
  SearchCommitsRequest: () => SearchCommitsRequest,
  SearchCommunicationChannelPreferencesRequest: () => SearchCommunicationChannelPreferencesRequest,
  SearchConfigRequest: () => SearchConfigRequest,
  SearchConnectionRequest: () => SearchConnectionRequest,
  SearchConnectionRequestSortOptions: () => SearchConnectionRequestSortOptions,
  SearchConnectionResponse: () => SearchConnectionResponse,
  SearchCustomActionsRequest: () => SearchCustomActionsRequest,
  SearchCustomActionsRequestDefaultActionConfig: () => SearchCustomActionsRequestDefaultActionConfig,
  SearchDataRequest: () => SearchDataRequest,
  SearchDataResponse: () => SearchDataResponse,
  SearchEmailCustomizationRequest: () => SearchEmailCustomizationRequest,
  SearchMetadataRequest: () => SearchMetadataRequest,
  SearchMetadataRequestFavoriteObjectOptions: () => SearchMetadataRequestFavoriteObjectOptions,
  SearchMetadataRequestSortOptions: () => SearchMetadataRequestSortOptions,
  SearchOrgsRequest: () => SearchOrgsRequest,
  SearchRoleResponse: () => SearchRoleResponse,
  SearchRolesRequest: () => SearchRolesRequest,
  SearchSchedulesRequest: () => SearchSchedulesRequest,
  SearchSchedulesRequestHistoryRunsOptions: () => SearchSchedulesRequestHistoryRunsOptions,
  SearchSchedulesRequestSortOptions: () => SearchSchedulesRequestSortOptions,
  SearchTagsRequest: () => SearchTagsRequest,
  SearchUserGroupsRequest: () => SearchUserGroupsRequest,
  SearchUserGroupsRequestSortOptions: () => SearchUserGroupsRequestSortOptions,
  SearchUsersRequest: () => SearchUsersRequest,
  SearchUsersRequestSortOptions: () => SearchUsersRequestSortOptions,
  SearchVariablesRequest: () => SearchVariablesRequest,
  SearchWebhookConfigurationsRequest: () => SearchWebhookConfigurationsRequest,
  SearchWebhookConfigurationsRequestSortOptions: () => SearchWebhookConfigurationsRequestSortOptions,
  SecurityApi: () => PromiseSecurityApi,
  SecuritySettingsClusterPreferences: () => SecuritySettingsClusterPreferences,
  SecuritySettingsClusterPreferencesInput: () => SecuritySettingsClusterPreferencesInput,
  SecuritySettingsOrgDetails: () => SecuritySettingsOrgDetails,
  SecuritySettingsOrgPreferences: () => SecuritySettingsOrgPreferences,
  SecuritySettingsOrgPreferencesInput: () => SecuritySettingsOrgPreferencesInput,
  SecuritySettingsResponse: () => SecuritySettingsResponse,
  SelfDecodingBody: () => SelfDecodingBody,
  SendAgentMessageResponse: () => SendAgentMessageResponse,
  SendAgentMessageStreamingRequest: () => SendAgentMessageStreamingRequest,
  SendMessageRequest: () => SendMessageRequest,
  ServerConfiguration: () => ServerConfiguration,
  ShareMetadataRequest: () => ShareMetadataRequest,
  ShareMetadataTypeInput: () => ShareMetadataTypeInput,
  SharePermissionsInput: () => SharePermissionsInput,
  SingleAnswerRequest: () => SingleAnswerRequest,
  SortOption: () => SortOption,
  SortOptionInput: () => SortOptionInput,
  SortOptions: () => SortOptions,
  SortingOptions: () => SortingOptions,
  SqlQuery: () => SqlQuery,
  SqlQueryResponse: () => SqlQueryResponse,
  SystemApi: () => PromiseSystemApi,
  SystemConfig: () => SystemConfig,
  SystemInfo: () => SystemInfo,
  SystemOverrideInfo: () => SystemOverrideInfo,
  Table: () => Table,
  Tag: () => Tag,
  TagMetadataTypeInput: () => TagMetadataTypeInput,
  TagsApi: () => PromiseTagsApi,
  TemplatePropertiesInputCreate: () => TemplatePropertiesInputCreate,
  ThoughtSpotRestApi: () => PromiseThoughtSpotRestApi,
  Token: () => Token,
  TokenAccessScopeObject: () => TokenAccessScopeObject,
  TokenValidationResponse: () => TokenValidationResponse,
  URL: () => URL2,
  URLInput: () => URLInput,
  URLInputMandatory: () => URLInputMandatory,
  UnparameterizeMetadataRequest: () => UnparameterizeMetadataRequest,
  UnpublishMetadataRequest: () => UnpublishMetadataRequest,
  UpdateCalendarRequest: () => UpdateCalendarRequest,
  UpdateCalendarRequestTableReference: () => UpdateCalendarRequestTableReference,
  UpdateColumnSecurityRulesRequest: () => UpdateColumnSecurityRulesRequest,
  UpdateConfigRequest: () => UpdateConfigRequest,
  UpdateConnectionConfigurationRequest: () => UpdateConnectionConfigurationRequest,
  UpdateConnectionRequest: () => UpdateConnectionRequest,
  UpdateConnectionV2Request: () => UpdateConnectionV2Request,
  UpdateCustomActionRequest: () => UpdateCustomActionRequest,
  UpdateCustomActionRequestActionDetails: () => UpdateCustomActionRequestActionDetails,
  UpdateCustomActionRequestDefaultActionConfig: () => UpdateCustomActionRequestDefaultActionConfig,
  UpdateEmailCustomizationRequest: () => UpdateEmailCustomizationRequest,
  UpdateMetadataHeaderRequest: () => UpdateMetadataHeaderRequest,
  UpdateMetadataObjIdRequest: () => UpdateMetadataObjIdRequest,
  UpdateObjIdInput: () => UpdateObjIdInput,
  UpdateOrgRequest: () => UpdateOrgRequest,
  UpdateRoleRequest: () => UpdateRoleRequest,
  UpdateScheduleRequest: () => UpdateScheduleRequest,
  UpdateScheduleRequestFrequency: () => UpdateScheduleRequestFrequency,
  UpdateScheduleRequestLiveboardOptions: () => UpdateScheduleRequestLiveboardOptions,
  UpdateScheduleRequestPdfOptions: () => UpdateScheduleRequestPdfOptions,
  UpdateScheduleRequestRecipientDetails: () => UpdateScheduleRequestRecipientDetails,
  UpdateSystemConfigRequest: () => UpdateSystemConfigRequest,
  UpdateTagRequest: () => UpdateTagRequest,
  UpdateUserGroupRequest: () => UpdateUserGroupRequest,
  UpdateUserRequest: () => UpdateUserRequest,
  UpdateVariableRequest: () => UpdateVariableRequest,
  UpdateVariableValuesRequest: () => UpdateVariableValuesRequest,
  UpdateWebhookConfigurationRequest: () => UpdateWebhookConfigurationRequest,
  User: () => User,
  UserGroup: () => UserGroup,
  UserGroupResponse: () => UserGroupResponse,
  UserInfo: () => UserInfo,
  UserObject: () => UserObject,
  UserParameterOptions: () => UserParameterOptions,
  UserPrincipal: () => UserPrincipal,
  UsersApi: () => PromiseUsersApi,
  ValidateMergeRequest: () => ValidateMergeRequest,
  ValidateTokenRequest: () => ValidateTokenRequest,
  ValueScopeInput: () => ValueScopeInput,
  Variable: () => Variable,
  VariableApi: () => PromiseVariableApi,
  VariableDetailInput: () => VariableDetailInput,
  VariableUpdateAssignmentInput: () => VariableUpdateAssignmentInput,
  VariableUpdateScopeInput: () => VariableUpdateScopeInput,
  VariableValue: () => VariableValue,
  VariableValues: () => VariableValues,
  VersionControlApi: () => PromiseVersionControlApi,
  WebhookAuthApiKey: () => WebhookAuthApiKey,
  WebhookAuthApiKeyInput: () => WebhookAuthApiKeyInput,
  WebhookAuthBasicAuth: () => WebhookAuthBasicAuth,
  WebhookAuthBasicAuthInput: () => WebhookAuthBasicAuthInput,
  WebhookAuthOAuth2: () => WebhookAuthOAuth2,
  WebhookAuthOAuth2Input: () => WebhookAuthOAuth2Input,
  WebhookAuthentication: () => WebhookAuthentication,
  WebhookAuthenticationInput: () => WebhookAuthenticationInput,
  WebhookDeleteFailure: () => WebhookDeleteFailure,
  WebhookDeleteResponse: () => WebhookDeleteResponse,
  WebhookOrg: () => WebhookOrg,
  WebhookPagination: () => WebhookPagination,
  WebhookResponse: () => WebhookResponse,
  WebhookSearchResponse: () => WebhookSearchResponse,
  WebhookSignatureVerification: () => WebhookSignatureVerification,
  WebhookSignatureVerificationInput: () => WebhookSignatureVerificationInput,
  WebhookSortOptionsInput: () => WebhookSortOptionsInput,
  WebhookUser: () => WebhookUser,
  WebhooksApi: () => PromiseWebhooksApi,
  configureAuthMethods: () => configureAuthMethods,
  createBasicConfig: () => createBasicConfig,
  createBearerAuthenticationConfig: () => createBearerAuthenticationConfig,
  createConfiguration: () => createConfiguration,
  server1: () => server1,
  servers: () => servers,
  wrapHttpLibrary: () => wrapHttpLibrary
});
module.exports = __toCommonJS(typescript_exports);

// rxjsStub.ts
var Observable = class _Observable {
  constructor(promise) {
    this.promise = promise;
  }
  toPromise() {
    return this.promise;
  }
  pipe(callback) {
    return new _Observable(this.promise.then(callback));
  }
};
function from(promise) {
  return new Observable(promise);
}
function of(value) {
  return new Observable(Promise.resolve(value));
}
function mergeMap(callback) {
  return (value) => callback(value).toPromise();
}
function map(callback) {
  return callback;
}

// http/isomorphic-fetch.ts
var import_whatwg_fetch = require("whatwg-fetch");
var IsomorphicFetchHttpLibrary = class {
  send(request) {
    let method = request.getHttpMethod().toString();
    let body = request.getBody();
    const resultPromise = fetch(request.getUrl(), {
      method,
      body,
      headers: request.getHeaders(),
      credentials: "include"
    }).then((resp) => {
      const headers = {};
      resp.headers.forEach((value, name) => {
        headers[name] = value;
      });
      const body2 = {
        text: () => resp.text(),
        binary: () => resp.blob()
      };
      return new ResponseContext(resp.status, headers, body2);
    });
    return from(resultPromise);
  }
};

// http/http.ts
var HttpMethod = /* @__PURE__ */ ((HttpMethod3) => {
  HttpMethod3["GET"] = "GET";
  HttpMethod3["HEAD"] = "HEAD";
  HttpMethod3["POST"] = "POST";
  HttpMethod3["PUT"] = "PUT";
  HttpMethod3["DELETE"] = "DELETE";
  HttpMethod3["CONNECT"] = "CONNECT";
  HttpMethod3["OPTIONS"] = "OPTIONS";
  HttpMethod3["TRACE"] = "TRACE";
  HttpMethod3["PATCH"] = "PATCH";
  return HttpMethod3;
})(HttpMethod || {});
var HttpException = class extends Error {
  constructor(msg) {
    super(msg);
  }
};
var RequestContext2 = class {
  /**
   * Creates the request context using a http method and request resource url
   *
   * @param url url of the requested resource
   * @param httpMethod http method
   */
  constructor(url, httpMethod) {
    this.httpMethod = httpMethod;
    this.headers = {};
    this.body = void 0;
    this.url = new URL(url);
  }
  /*
   * Returns the url set in the constructor including the query string
   *
   */
  getUrl() {
    return this.url.toString().endsWith("/") ? this.url.toString().slice(0, -1) : this.url.toString();
  }
  /**
   * Replaces the url set in the constructor with this url.
   *
   */
  setUrl(url) {
    this.url = new URL(url);
  }
  /**
   * Sets the body of the http request either as a string or FormData
   *
   * Note that setting a body on a HTTP GET, HEAD, DELETE, CONNECT or TRACE
   * request is discouraged.
   * https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.7.3.1
   *
   * @param body the body of the request
   */
  setBody(body) {
    this.body = body;
  }
  getHttpMethod() {
    return this.httpMethod;
  }
  getHeaders() {
    return this.headers;
  }
  getBody() {
    return this.body;
  }
  setQueryParam(name, value) {
    this.url.searchParams.set(name, value);
  }
  /**
   * Sets a cookie with the name and value. NO check  for duplicate cookies is performed
   *
   */
  addCookie(name, value) {
    if (!this.headers["Cookie"]) {
      this.headers["Cookie"] = "";
    }
    this.headers["Cookie"] += name + "=" + value + "; ";
  }
  setHeaderParam(key, value) {
    this.headers[key] = value;
  }
};
var SelfDecodingBody = class {
  constructor(dataSource) {
    this.dataSource = dataSource;
  }
  binary() {
    return this.dataSource;
  }
  text() {
    return __async(this, null, function* () {
      const data = yield this.dataSource;
      if (data.text) {
        return data.text();
      }
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.addEventListener("load", () => resolve(reader.result));
        reader.addEventListener("error", () => reject(reader.error));
        reader.readAsText(data);
      });
    });
  }
};
var ResponseContext = class {
  constructor(httpStatusCode, headers, body) {
    this.httpStatusCode = httpStatusCode;
    this.headers = headers;
    this.body = body;
  }
  /**
   * Parse header value in the form `value; param1="value1"`
   *
   * E.g. for Content-Type or Content-Disposition
   * Parameter names are converted to lower case
   * The first parameter is returned with the key `""`
   */
  getParsedHeader(headerName) {
    const result = {};
    if (!this.headers[headerName]) {
      return result;
    }
    const parameters = this.headers[headerName].split(";");
    for (const parameter of parameters) {
      let [key, value] = parameter.split("=", 2);
      key = key.toLowerCase().trim();
      if (value === void 0) {
        result[""] = key;
      } else {
        value = value.trim();
        if (value.startsWith('"') && value.endsWith('"')) {
          value = value.substring(1, value.length - 1);
        }
        result[key] = value;
      }
    }
    return result;
  }
  getBodyAsFile() {
    return __async(this, null, function* () {
      const data = yield this.body.binary();
      const fileName = this.getParsedHeader("content-disposition")["filename"] || "";
      const contentType = this.headers["content-type"] || "";
      try {
        return new File([data], fileName, { type: contentType });
      } catch (error) {
        return Object.assign(data, {
          name: fileName,
          type: contentType
        });
      }
    });
  }
  /**
   * Use a heuristic to get a body of unknown data structure.
   * Return as string if possible, otherwise as binary.
   */
  getBodyAsAny() {
    try {
      return this.body.text();
    } catch (e) {
    }
    try {
      return this.body.binary();
    } catch (e) {
    }
    return Promise.resolve(void 0);
  }
};
function wrapHttpLibrary(promiseHttpLibrary) {
  return {
    send(request) {
      return from(promiseHttpLibrary.send(request));
    }
  };
}

// auth/auth.ts
var BearerAuthAuthentication = class {
  /**
   * Configures the http authentication with the required details.
   *
   * @param tokenProvider service that can provide the up-to-date token when needed
   */
  constructor(tokenProvider) {
    this.tokenProvider = tokenProvider;
  }
  getName() {
    return "bearerAuth";
  }
  applySecurityAuthentication(context) {
    return __async(this, null, function* () {
      context.setHeaderParam("Authorization", "Bearer " + (yield this.tokenProvider.getToken()));
    });
  }
};
function configureAuthMethods(config) {
  let authMethods = {};
  if (!config) {
    return authMethods;
  }
  authMethods["default"] = config["default"];
  if (config["bearerAuth"]) {
    authMethods["bearerAuth"] = new BearerAuthAuthentication(
      config["bearerAuth"]["tokenProvider"]
    );
  }
  return authMethods;
}

// models/AIContext.ts
var _AIContext = class _AIContext {
  static getAttributeTypeMap() {
    return _AIContext.attributeTypeMap;
  }
  constructor() {
  }
};
_AIContext.discriminator = void 0;
_AIContext.attributeTypeMap = [
  {
    "name": "instructions",
    "baseName": "instructions",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "content",
    "baseName": "content",
    "type": "Array<string>",
    "format": ""
  }
];
var AIContext = _AIContext;

// models/APIKey.ts
var _APIKey = class _APIKey {
  static getAttributeTypeMap() {
    return _APIKey.attributeTypeMap;
  }
  constructor() {
  }
};
_APIKey.discriminator = void 0;
_APIKey.attributeTypeMap = [
  {
    "name": "key",
    "baseName": "key",
    "type": "string",
    "format": ""
  },
  {
    "name": "value",
    "baseName": "value",
    "type": "string",
    "format": ""
  }
];
var APIKey = _APIKey;

// models/APIKeyInput.ts
var _APIKeyInput = class _APIKeyInput {
  static getAttributeTypeMap() {
    return _APIKeyInput.attributeTypeMap;
  }
  constructor() {
  }
};
_APIKeyInput.discriminator = void 0;
_APIKeyInput.attributeTypeMap = [
  {
    "name": "key",
    "baseName": "key",
    "type": "string",
    "format": ""
  },
  {
    "name": "value",
    "baseName": "value",
    "type": "string",
    "format": ""
  }
];
var APIKeyInput = _APIKeyInput;

// models/AccessToken.ts
var _AccessToken = class _AccessToken {
  static getAttributeTypeMap() {
    return _AccessToken.attributeTypeMap;
  }
  constructor() {
  }
};
_AccessToken.discriminator = void 0;
_AccessToken.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "token",
    "baseName": "token",
    "type": "string",
    "format": ""
  },
  {
    "name": "org",
    "baseName": "org",
    "type": "OrgInfo",
    "format": ""
  },
  {
    "name": "user",
    "baseName": "user",
    "type": "UserInfo",
    "format": ""
  },
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "expiration_time_in_millis",
    "baseName": "expiration_time_in_millis",
    "type": "number",
    "format": "float"
  }
];
var AccessToken = _AccessToken;

// models/ActionConfig.ts
var _ActionConfig = class _ActionConfig {
  static getAttributeTypeMap() {
    return _ActionConfig.attributeTypeMap;
  }
  constructor() {
  }
};
_ActionConfig.discriminator = void 0;
_ActionConfig.attributeTypeMap = [
  {
    "name": "position",
    "baseName": "position",
    "type": "string",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "boolean",
    "format": ""
  }
];
var ActionConfig = _ActionConfig;

// models/ActionConfigInput.ts
var _ActionConfigInput = class _ActionConfigInput {
  static getAttributeTypeMap() {
    return _ActionConfigInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ActionConfigInput.discriminator = void 0;
_ActionConfigInput.attributeTypeMap = [
  {
    "name": "position",
    "baseName": "position",
    "type": "ActionConfigInputPositionEnum",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "boolean",
    "format": ""
  }
];
var ActionConfigInput = _ActionConfigInput;

// models/ActionConfigInputCreate.ts
var _ActionConfigInputCreate = class _ActionConfigInputCreate {
  static getAttributeTypeMap() {
    return _ActionConfigInputCreate.attributeTypeMap;
  }
  constructor() {
  }
};
_ActionConfigInputCreate.discriminator = void 0;
_ActionConfigInputCreate.attributeTypeMap = [
  {
    "name": "position",
    "baseName": "position",
    "type": "ActionConfigInputCreatePositionEnum",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "boolean",
    "format": ""
  }
];
var ActionConfigInputCreate = _ActionConfigInputCreate;

// models/ActionDetails.ts
var _ActionDetails = class _ActionDetails {
  static getAttributeTypeMap() {
    return _ActionDetails.attributeTypeMap;
  }
  constructor() {
  }
};
_ActionDetails.discriminator = void 0;
_ActionDetails.attributeTypeMap = [
  {
    "name": "CALLBACK",
    "baseName": "CALLBACK",
    "type": "CALLBACK",
    "format": ""
  },
  {
    "name": "URL",
    "baseName": "URL",
    "type": "URL",
    "format": ""
  }
];
var ActionDetails = _ActionDetails;

// models/ActionDetailsInput.ts
var _ActionDetailsInput = class _ActionDetailsInput {
  static getAttributeTypeMap() {
    return _ActionDetailsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ActionDetailsInput.discriminator = void 0;
_ActionDetailsInput.attributeTypeMap = [
  {
    "name": "CALLBACK",
    "baseName": "CALLBACK",
    "type": "CALLBACKInput",
    "format": ""
  },
  {
    "name": "URL",
    "baseName": "URL",
    "type": "URLInput",
    "format": ""
  }
];
var ActionDetailsInput = _ActionDetailsInput;

// models/ActionDetailsInputCreate.ts
var _ActionDetailsInputCreate = class _ActionDetailsInputCreate {
  static getAttributeTypeMap() {
    return _ActionDetailsInputCreate.attributeTypeMap;
  }
  constructor() {
  }
};
_ActionDetailsInputCreate.discriminator = void 0;
_ActionDetailsInputCreate.attributeTypeMap = [
  {
    "name": "CALLBACK",
    "baseName": "CALLBACK",
    "type": "CALLBACKInputMandatory",
    "format": ""
  },
  {
    "name": "URL",
    "baseName": "URL",
    "type": "URLInputMandatory",
    "format": ""
  }
];
var ActionDetailsInputCreate = _ActionDetailsInputCreate;

// models/ActivateUserRequest.ts
var _ActivateUserRequest = class _ActivateUserRequest {
  static getAttributeTypeMap() {
    return _ActivateUserRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ActivateUserRequest.discriminator = void 0;
_ActivateUserRequest.attributeTypeMap = [
  {
    "name": "user_identifier",
    "baseName": "user_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "auth_token",
    "baseName": "auth_token",
    "type": "string",
    "format": ""
  },
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  },
  {
    "name": "properties",
    "baseName": "properties",
    "type": "string",
    "format": ""
  }
];
var ActivateUserRequest = _ActivateUserRequest;

// models/AgentConversation.ts
var _AgentConversation = class _AgentConversation {
  static getAttributeTypeMap() {
    return _AgentConversation.attributeTypeMap;
  }
  constructor() {
  }
};
_AgentConversation.discriminator = void 0;
_AgentConversation.attributeTypeMap = [
  {
    "name": "conversation_id",
    "baseName": "conversation_id",
    "type": "string",
    "format": ""
  }
];
var AgentConversation = _AgentConversation;

// models/AnswerContent.ts
var _AnswerContent = class _AnswerContent {
  static getAttributeTypeMap() {
    return _AnswerContent.attributeTypeMap;
  }
  constructor() {
  }
};
_AnswerContent.discriminator = void 0;
_AnswerContent.attributeTypeMap = [
  {
    "name": "available_data_row_count",
    "baseName": "available_data_row_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "column_names",
    "baseName": "column_names",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "data_rows",
    "baseName": "data_rows",
    "type": "Array<any>",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "returned_data_row_count",
    "baseName": "returned_data_row_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "sampling_ratio",
    "baseName": "sampling_ratio",
    "type": "number",
    "format": "float"
  }
];
var AnswerContent = _AnswerContent;

// models/AnswerContextInput.ts
var _AnswerContextInput = class _AnswerContextInput {
  static getAttributeTypeMap() {
    return _AnswerContextInput.attributeTypeMap;
  }
  constructor() {
  }
};
_AnswerContextInput.discriminator = void 0;
_AnswerContextInput.attributeTypeMap = [
  {
    "name": "session_identifier",
    "baseName": "session_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "generation_number",
    "baseName": "generation_number",
    "type": "number",
    "format": "int32"
  }
];
var AnswerContextInput = _AnswerContextInput;

// models/AnswerDataResponse.ts
var _AnswerDataResponse = class _AnswerDataResponse {
  static getAttributeTypeMap() {
    return _AnswerDataResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_AnswerDataResponse.discriminator = void 0;
_AnswerDataResponse.attributeTypeMap = [
  {
    "name": "metadata_id",
    "baseName": "metadata_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_name",
    "baseName": "metadata_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "contents",
    "baseName": "contents",
    "type": "Array<AnswerContent>",
    "format": ""
  }
];
var AnswerDataResponse = _AnswerDataResponse;

// models/AssignChangeAuthorRequest.ts
var _AssignChangeAuthorRequest = class _AssignChangeAuthorRequest {
  static getAttributeTypeMap() {
    return _AssignChangeAuthorRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_AssignChangeAuthorRequest.discriminator = void 0;
_AssignChangeAuthorRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<AuthorMetadataTypeInput>",
    "format": ""
  },
  {
    "name": "user_identifier",
    "baseName": "user_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "current_owner_identifier",
    "baseName": "current_owner_identifier",
    "type": "string",
    "format": ""
  }
];
var AssignChangeAuthorRequest = _AssignChangeAuthorRequest;

// models/AssignTagRequest.ts
var _AssignTagRequest = class _AssignTagRequest {
  static getAttributeTypeMap() {
    return _AssignTagRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_AssignTagRequest.discriminator = void 0;
_AssignTagRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<TagMetadataTypeInput>",
    "format": ""
  },
  {
    "name": "tag_identifiers",
    "baseName": "tag_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var AssignTagRequest = _AssignTagRequest;

// models/AssociateMetadataInput.ts
var _AssociateMetadataInput = class _AssociateMetadataInput {
  static getAttributeTypeMap() {
    return _AssociateMetadataInput.attributeTypeMap;
  }
  constructor() {
  }
};
_AssociateMetadataInput.discriminator = void 0;
_AssociateMetadataInput.attributeTypeMap = [
  {
    "name": "action_config",
    "baseName": "action_config",
    "type": "ActionConfigInput",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "AssociateMetadataInputTypeEnum",
    "format": ""
  }
];
var AssociateMetadataInput = _AssociateMetadataInput;

// models/AssociateMetadataInputCreate.ts
var _AssociateMetadataInputCreate = class _AssociateMetadataInputCreate {
  static getAttributeTypeMap() {
    return _AssociateMetadataInputCreate.attributeTypeMap;
  }
  constructor() {
  }
};
_AssociateMetadataInputCreate.discriminator = void 0;
_AssociateMetadataInputCreate.attributeTypeMap = [
  {
    "name": "action_config",
    "baseName": "action_config",
    "type": "ActionConfigInputCreate",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "AssociateMetadataInputCreateTypeEnum",
    "format": ""
  }
];
var AssociateMetadataInputCreate = _AssociateMetadataInputCreate;

// models/Authentication.ts
var _Authentication = class _Authentication {
  static getAttributeTypeMap() {
    return _Authentication.attributeTypeMap;
  }
  constructor() {
  }
};
_Authentication.discriminator = void 0;
_Authentication.attributeTypeMap = [
  {
    "name": "API_Key",
    "baseName": "API_Key",
    "type": "APIKey",
    "format": ""
  },
  {
    "name": "Basic_Auth",
    "baseName": "Basic_Auth",
    "type": "BasicAuth",
    "format": ""
  },
  {
    "name": "Bearer_Token",
    "baseName": "Bearer_Token",
    "type": "string",
    "format": ""
  },
  {
    "name": "No_Auth",
    "baseName": "No_Auth",
    "type": "string",
    "format": ""
  }
];
var Authentication = _Authentication;

// models/AuthenticationInput.ts
var _AuthenticationInput = class _AuthenticationInput {
  static getAttributeTypeMap() {
    return _AuthenticationInput.attributeTypeMap;
  }
  constructor() {
  }
};
_AuthenticationInput.discriminator = void 0;
_AuthenticationInput.attributeTypeMap = [
  {
    "name": "API_Key",
    "baseName": "API_Key",
    "type": "APIKeyInput",
    "format": ""
  },
  {
    "name": "Basic_Auth",
    "baseName": "Basic_Auth",
    "type": "BasicAuthInput",
    "format": ""
  },
  {
    "name": "Bearer_Token",
    "baseName": "Bearer_Token",
    "type": "string",
    "format": ""
  },
  {
    "name": "No_Auth",
    "baseName": "No_Auth",
    "type": "string",
    "format": ""
  }
];
var AuthenticationInput = _AuthenticationInput;

// models/Author.ts
var _Author = class _Author {
  static getAttributeTypeMap() {
    return _Author.attributeTypeMap;
  }
  constructor() {
  }
};
_Author.discriminator = void 0;
_Author.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var Author = _Author;

// models/AuthorMetadataTypeInput.ts
var _AuthorMetadataTypeInput = class _AuthorMetadataTypeInput {
  static getAttributeTypeMap() {
    return _AuthorMetadataTypeInput.attributeTypeMap;
  }
  constructor() {
  }
};
_AuthorMetadataTypeInput.discriminator = void 0;
_AuthorMetadataTypeInput.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "AuthorMetadataTypeInputTypeEnum",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  }
];
var AuthorMetadataTypeInput = _AuthorMetadataTypeInput;

// models/AuthorType.ts
var _AuthorType = class _AuthorType {
  static getAttributeTypeMap() {
    return _AuthorType.attributeTypeMap;
  }
  constructor() {
  }
};
_AuthorType.discriminator = void 0;
_AuthorType.attributeTypeMap = [
  {
    "name": "email",
    "baseName": "email",
    "type": "string",
    "format": ""
  },
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  }
];
var AuthorType = _AuthorType;

// models/BasicAuth.ts
var _BasicAuth = class _BasicAuth {
  static getAttributeTypeMap() {
    return _BasicAuth.attributeTypeMap;
  }
  constructor() {
  }
};
_BasicAuth.discriminator = void 0;
_BasicAuth.attributeTypeMap = [
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  },
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  }
];
var BasicAuth = _BasicAuth;

// models/BasicAuthInput.ts
var _BasicAuthInput = class _BasicAuthInput {
  static getAttributeTypeMap() {
    return _BasicAuthInput.attributeTypeMap;
  }
  constructor() {
  }
};
_BasicAuthInput.discriminator = void 0;
_BasicAuthInput.attributeTypeMap = [
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  },
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  }
];
var BasicAuthInput = _BasicAuthInput;

// models/CALLBACK.ts
var _CALLBACK = class _CALLBACK {
  static getAttributeTypeMap() {
    return _CALLBACK.attributeTypeMap;
  }
  constructor() {
  }
};
_CALLBACK.discriminator = void 0;
_CALLBACK.attributeTypeMap = [
  {
    "name": "reference",
    "baseName": "reference",
    "type": "string",
    "format": ""
  }
];
var CALLBACK = _CALLBACK;

// models/CALLBACKInput.ts
var _CALLBACKInput = class _CALLBACKInput {
  static getAttributeTypeMap() {
    return _CALLBACKInput.attributeTypeMap;
  }
  constructor() {
  }
};
_CALLBACKInput.discriminator = void 0;
_CALLBACKInput.attributeTypeMap = [
  {
    "name": "reference",
    "baseName": "reference",
    "type": "string",
    "format": ""
  }
];
var CALLBACKInput = _CALLBACKInput;

// models/CALLBACKInputMandatory.ts
var _CALLBACKInputMandatory = class _CALLBACKInputMandatory {
  static getAttributeTypeMap() {
    return _CALLBACKInputMandatory.attributeTypeMap;
  }
  constructor() {
  }
};
_CALLBACKInputMandatory.discriminator = void 0;
_CALLBACKInputMandatory.attributeTypeMap = [
  {
    "name": "reference",
    "baseName": "reference",
    "type": "string",
    "format": ""
  }
];
var CALLBACKInputMandatory = _CALLBACKInputMandatory;

// models/CalendarResponse.ts
var _CalendarResponse = class _CalendarResponse {
  static getAttributeTypeMap() {
    return _CalendarResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_CalendarResponse.discriminator = void 0;
_CalendarResponse.attributeTypeMap = [
  {
    "name": "calendar_name",
    "baseName": "calendar_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "connection_name",
    "baseName": "connection_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_warehouse_type",
    "baseName": "data_warehouse_type",
    "type": "string",
    "format": ""
  },
  {
    "name": "modification_time_in_millis",
    "baseName": "modification_time_in_millis",
    "type": "string",
    "format": ""
  },
  {
    "name": "author_name",
    "baseName": "author_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "connection_id",
    "baseName": "connection_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "calendar_id",
    "baseName": "calendar_id",
    "type": "string",
    "format": ""
  }
];
var CalendarResponse = _CalendarResponse;

// models/ChangeUserPasswordRequest.ts
var _ChangeUserPasswordRequest = class _ChangeUserPasswordRequest {
  static getAttributeTypeMap() {
    return _ChangeUserPasswordRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ChangeUserPasswordRequest.discriminator = void 0;
_ChangeUserPasswordRequest.attributeTypeMap = [
  {
    "name": "current_password",
    "baseName": "current_password",
    "type": "string",
    "format": ""
  },
  {
    "name": "new_password",
    "baseName": "new_password",
    "type": "string",
    "format": ""
  },
  {
    "name": "user_identifier",
    "baseName": "user_identifier",
    "type": "string",
    "format": ""
  }
];
var ChangeUserPasswordRequest = _ChangeUserPasswordRequest;

// models/ClusterNonEmbedAccess.ts
var _ClusterNonEmbedAccess = class _ClusterNonEmbedAccess {
  static getAttributeTypeMap() {
    return _ClusterNonEmbedAccess.attributeTypeMap;
  }
  constructor() {
  }
};
_ClusterNonEmbedAccess.discriminator = void 0;
_ClusterNonEmbedAccess.attributeTypeMap = [
  {
    "name": "block_full_app_access",
    "baseName": "block_full_app_access",
    "type": "boolean",
    "format": ""
  }
];
var ClusterNonEmbedAccess = _ClusterNonEmbedAccess;

// models/ClusterNonEmbedAccessInput.ts
var _ClusterNonEmbedAccessInput = class _ClusterNonEmbedAccessInput {
  static getAttributeTypeMap() {
    return _ClusterNonEmbedAccessInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ClusterNonEmbedAccessInput.discriminator = void 0;
_ClusterNonEmbedAccessInput.attributeTypeMap = [
  {
    "name": "block_full_app_access",
    "baseName": "block_full_app_access",
    "type": "boolean",
    "format": ""
  }
];
var ClusterNonEmbedAccessInput = _ClusterNonEmbedAccessInput;

// models/Column.ts
var _Column = class _Column {
  static getAttributeTypeMap() {
    return _Column.attributeTypeMap;
  }
  constructor() {
  }
};
_Column.discriminator = void 0;
_Column.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_type",
    "baseName": "data_type",
    "type": "string",
    "format": ""
  },
  {
    "name": "is_aggregate",
    "baseName": "is_aggregate",
    "type": "string",
    "format": ""
  },
  {
    "name": "can_import",
    "baseName": "can_import",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "selected",
    "baseName": "selected",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "is_linked_active",
    "baseName": "is_linked_active",
    "type": "boolean",
    "format": ""
  }
];
var Column = _Column;

// models/ColumnSecurityRule.ts
var _ColumnSecurityRule = class _ColumnSecurityRule {
  static getAttributeTypeMap() {
    return _ColumnSecurityRule.attributeTypeMap;
  }
  constructor() {
  }
};
_ColumnSecurityRule.discriminator = void 0;
_ColumnSecurityRule.attributeTypeMap = [
  {
    "name": "column",
    "baseName": "column",
    "type": "ColumnSecurityRuleColumn",
    "format": ""
  },
  {
    "name": "groups",
    "baseName": "groups",
    "type": "Array<ColumnSecurityRuleGroup>",
    "format": ""
  },
  {
    "name": "source_table_details",
    "baseName": "source_table_details",
    "type": "ColumnSecurityRuleSourceTable",
    "format": ""
  }
];
var ColumnSecurityRule = _ColumnSecurityRule;

// models/ColumnSecurityRuleColumn.ts
var _ColumnSecurityRuleColumn = class _ColumnSecurityRuleColumn {
  static getAttributeTypeMap() {
    return _ColumnSecurityRuleColumn.attributeTypeMap;
  }
  constructor() {
  }
};
_ColumnSecurityRuleColumn.discriminator = void 0;
_ColumnSecurityRuleColumn.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var ColumnSecurityRuleColumn = _ColumnSecurityRuleColumn;

// models/ColumnSecurityRuleGroup.ts
var _ColumnSecurityRuleGroup = class _ColumnSecurityRuleGroup {
  static getAttributeTypeMap() {
    return _ColumnSecurityRuleGroup.attributeTypeMap;
  }
  constructor() {
  }
};
_ColumnSecurityRuleGroup.discriminator = void 0;
_ColumnSecurityRuleGroup.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var ColumnSecurityRuleGroup = _ColumnSecurityRuleGroup;

// models/ColumnSecurityRuleGroupOperation.ts
var _ColumnSecurityRuleGroupOperation = class _ColumnSecurityRuleGroupOperation {
  static getAttributeTypeMap() {
    return _ColumnSecurityRuleGroupOperation.attributeTypeMap;
  }
  constructor() {
  }
};
_ColumnSecurityRuleGroupOperation.discriminator = void 0;
_ColumnSecurityRuleGroupOperation.attributeTypeMap = [
  {
    "name": "operation",
    "baseName": "operation",
    "type": "ColumnSecurityRuleGroupOperationOperationEnum",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var ColumnSecurityRuleGroupOperation = _ColumnSecurityRuleGroupOperation;

// models/ColumnSecurityRuleResponse.ts
var _ColumnSecurityRuleResponse = class _ColumnSecurityRuleResponse {
  static getAttributeTypeMap() {
    return _ColumnSecurityRuleResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_ColumnSecurityRuleResponse.discriminator = void 0;
_ColumnSecurityRuleResponse.attributeTypeMap = [
  {
    "name": "table_guid",
    "baseName": "table_guid",
    "type": "string",
    "format": ""
  },
  {
    "name": "obj_id",
    "baseName": "obj_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "column_security_rules",
    "baseName": "column_security_rules",
    "type": "Array<ColumnSecurityRule>",
    "format": ""
  }
];
var ColumnSecurityRuleResponse = _ColumnSecurityRuleResponse;

// models/ColumnSecurityRuleSourceTable.ts
var _ColumnSecurityRuleSourceTable = class _ColumnSecurityRuleSourceTable {
  static getAttributeTypeMap() {
    return _ColumnSecurityRuleSourceTable.attributeTypeMap;
  }
  constructor() {
  }
};
_ColumnSecurityRuleSourceTable.discriminator = void 0;
_ColumnSecurityRuleSourceTable.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var ColumnSecurityRuleSourceTable = _ColumnSecurityRuleSourceTable;

// models/ColumnSecurityRuleTableInput.ts
var _ColumnSecurityRuleTableInput = class _ColumnSecurityRuleTableInput {
  static getAttributeTypeMap() {
    return _ColumnSecurityRuleTableInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ColumnSecurityRuleTableInput.discriminator = void 0;
_ColumnSecurityRuleTableInput.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "obj_identifier",
    "baseName": "obj_identifier",
    "type": "string",
    "format": ""
  }
];
var ColumnSecurityRuleTableInput = _ColumnSecurityRuleTableInput;

// models/ColumnSecurityRuleUpdate.ts
var _ColumnSecurityRuleUpdate = class _ColumnSecurityRuleUpdate {
  static getAttributeTypeMap() {
    return _ColumnSecurityRuleUpdate.attributeTypeMap;
  }
  constructor() {
  }
};
_ColumnSecurityRuleUpdate.discriminator = void 0;
_ColumnSecurityRuleUpdate.attributeTypeMap = [
  {
    "name": "column_identifier",
    "baseName": "column_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "is_unsecured",
    "baseName": "is_unsecured",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "group_access",
    "baseName": "group_access",
    "type": "Array<ColumnSecurityRuleGroupOperation>",
    "format": ""
  }
];
var ColumnSecurityRuleUpdate = _ColumnSecurityRuleUpdate;

// models/CommitBranchRequest.ts
var _CommitBranchRequest = class _CommitBranchRequest {
  static getAttributeTypeMap() {
    return _CommitBranchRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CommitBranchRequest.discriminator = void 0;
_CommitBranchRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<MetadataObject>",
    "format": ""
  },
  {
    "name": "delete_aware",
    "baseName": "delete_aware",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "branch_name",
    "baseName": "branch_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "comment",
    "baseName": "comment",
    "type": "string",
    "format": ""
  }
];
var CommitBranchRequest = _CommitBranchRequest;

// models/CommitFileType.ts
var _CommitFileType = class _CommitFileType {
  static getAttributeTypeMap() {
    return _CommitFileType.attributeTypeMap;
  }
  constructor() {
  }
};
_CommitFileType.discriminator = void 0;
_CommitFileType.attributeTypeMap = [
  {
    "name": "file_name",
    "baseName": "file_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "status_code",
    "baseName": "status_code",
    "type": "string",
    "format": ""
  },
  {
    "name": "status_message",
    "baseName": "status_message",
    "type": "string",
    "format": ""
  }
];
var CommitFileType = _CommitFileType;

// models/CommitHistoryResponse.ts
var _CommitHistoryResponse = class _CommitHistoryResponse {
  static getAttributeTypeMap() {
    return _CommitHistoryResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_CommitHistoryResponse.discriminator = void 0;
_CommitHistoryResponse.attributeTypeMap = [
  {
    "name": "committer",
    "baseName": "committer",
    "type": "CommiterType",
    "format": ""
  },
  {
    "name": "author",
    "baseName": "author",
    "type": "AuthorType",
    "format": ""
  },
  {
    "name": "comment",
    "baseName": "comment",
    "type": "string",
    "format": ""
  },
  {
    "name": "commit_time",
    "baseName": "commit_time",
    "type": "string",
    "format": ""
  },
  {
    "name": "commit_id",
    "baseName": "commit_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "branch",
    "baseName": "branch",
    "type": "string",
    "format": ""
  }
];
var CommitHistoryResponse = _CommitHistoryResponse;

// models/CommitResponse.ts
var _CommitResponse = class _CommitResponse {
  static getAttributeTypeMap() {
    return _CommitResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_CommitResponse.discriminator = void 0;
_CommitResponse.attributeTypeMap = [
  {
    "name": "committer",
    "baseName": "committer",
    "type": "CommiterType",
    "format": ""
  },
  {
    "name": "author",
    "baseName": "author",
    "type": "AuthorType",
    "format": ""
  },
  {
    "name": "comment",
    "baseName": "comment",
    "type": "string",
    "format": ""
  },
  {
    "name": "commit_time",
    "baseName": "commit_time",
    "type": "string",
    "format": ""
  },
  {
    "name": "commit_id",
    "baseName": "commit_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "branch",
    "baseName": "branch",
    "type": "string",
    "format": ""
  },
  {
    "name": "committed_files",
    "baseName": "committed_files",
    "type": "Array<CommitFileType>",
    "format": ""
  }
];
var CommitResponse = _CommitResponse;

// models/CommiterType.ts
var _CommiterType = class _CommiterType {
  static getAttributeTypeMap() {
    return _CommiterType.attributeTypeMap;
  }
  constructor() {
  }
};
_CommiterType.discriminator = void 0;
_CommiterType.attributeTypeMap = [
  {
    "name": "email",
    "baseName": "email",
    "type": "string",
    "format": ""
  },
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  }
];
var CommiterType = _CommiterType;

// models/CommunicationChannelPreferencesResponse.ts
var _CommunicationChannelPreferencesResponse = class _CommunicationChannelPreferencesResponse {
  static getAttributeTypeMap() {
    return _CommunicationChannelPreferencesResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_CommunicationChannelPreferencesResponse.discriminator = void 0;
_CommunicationChannelPreferencesResponse.attributeTypeMap = [
  {
    "name": "cluster_preferences",
    "baseName": "cluster_preferences",
    "type": "Array<EventChannelConfig>",
    "format": ""
  },
  {
    "name": "org_preferences",
    "baseName": "org_preferences",
    "type": "Array<OrgChannelConfigResponse>",
    "format": ""
  }
];
var CommunicationChannelPreferencesResponse = _CommunicationChannelPreferencesResponse;

// models/ConfigureCommunicationChannelPreferencesRequest.ts
var _ConfigureCommunicationChannelPreferencesRequest = class _ConfigureCommunicationChannelPreferencesRequest {
  static getAttributeTypeMap() {
    return _ConfigureCommunicationChannelPreferencesRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ConfigureCommunicationChannelPreferencesRequest.discriminator = void 0;
_ConfigureCommunicationChannelPreferencesRequest.attributeTypeMap = [
  {
    "name": "cluster_preferences",
    "baseName": "cluster_preferences",
    "type": "Array<EventChannelConfigInput>",
    "format": ""
  },
  {
    "name": "org_preferences",
    "baseName": "org_preferences",
    "type": "Array<OrgChannelConfigInput>",
    "format": ""
  }
];
var ConfigureCommunicationChannelPreferencesRequest = _ConfigureCommunicationChannelPreferencesRequest;

// models/ConnectionConfigurationResponse.ts
var _ConnectionConfigurationResponse = class _ConnectionConfigurationResponse {
  static getAttributeTypeMap() {
    return _ConnectionConfigurationResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_ConnectionConfigurationResponse.discriminator = void 0;
_ConnectionConfigurationResponse.attributeTypeMap = [
  {
    "name": "configuration_identifier",
    "baseName": "configuration_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "configuration",
    "baseName": "configuration",
    "type": "any",
    "format": ""
  },
  {
    "name": "policy_principals",
    "baseName": "policy_principals",
    "type": "Array<UserPrincipal>",
    "format": ""
  },
  {
    "name": "policy_processes",
    "baseName": "policy_processes",
    "type": "Array<ConnectionConfigurationResponsePolicyProcessesEnum>",
    "format": ""
  },
  {
    "name": "disabled",
    "baseName": "disabled",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "data_warehouse_type",
    "baseName": "data_warehouse_type",
    "type": "ConnectionConfigurationResponseDataWarehouseTypeEnum",
    "format": ""
  },
  {
    "name": "policy_type",
    "baseName": "policy_type",
    "type": "ConnectionConfigurationResponsePolicyTypeEnum",
    "format": ""
  },
  {
    "name": "same_as_parent",
    "baseName": "same_as_parent",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "policy_process_options",
    "baseName": "policy_process_options",
    "type": "PolicyProcessOptions",
    "format": ""
  }
];
var ConnectionConfigurationResponse = _ConnectionConfigurationResponse;

// models/ConnectionConfigurationSearchRequest.ts
var _ConnectionConfigurationSearchRequest = class _ConnectionConfigurationSearchRequest {
  static getAttributeTypeMap() {
    return _ConnectionConfigurationSearchRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ConnectionConfigurationSearchRequest.discriminator = void 0;
_ConnectionConfigurationSearchRequest.attributeTypeMap = [
  {
    "name": "connection_identifier",
    "baseName": "connection_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "configuration_identifier",
    "baseName": "configuration_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "policy_type",
    "baseName": "policy_type",
    "type": "ConnectionConfigurationSearchRequestPolicyTypeEnum",
    "format": ""
  }
];
var ConnectionConfigurationSearchRequest = _ConnectionConfigurationSearchRequest;

// models/ConnectionInput.ts
var _ConnectionInput = class _ConnectionInput {
  static getAttributeTypeMap() {
    return _ConnectionInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ConnectionInput.discriminator = void 0;
_ConnectionInput.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "name_pattern",
    "baseName": "name_pattern",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_warehouse_objects",
    "baseName": "data_warehouse_objects",
    "type": "Array<DataWarehouseObjectInput>",
    "format": ""
  }
];
var ConnectionInput = _ConnectionInput;

// models/ContextPayloadV2Input.ts
var _ContextPayloadV2Input = class _ContextPayloadV2Input {
  static getAttributeTypeMap() {
    return _ContextPayloadV2Input.attributeTypeMap;
  }
  constructor() {
  }
};
_ContextPayloadV2Input.discriminator = void 0;
_ContextPayloadV2Input.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "ContextPayloadV2InputTypeEnum",
    "format": ""
  },
  {
    "name": "answer_context",
    "baseName": "answer_context",
    "type": "AnswerContextInput",
    "format": ""
  },
  {
    "name": "liveboard_context",
    "baseName": "liveboard_context",
    "type": "LBContextInput",
    "format": ""
  },
  {
    "name": "data_source_context",
    "baseName": "data_source_context",
    "type": "DataSourceContextInput",
    "format": ""
  }
];
var ContextPayloadV2Input = _ContextPayloadV2Input;

// models/Conversation.ts
var _Conversation = class _Conversation {
  static getAttributeTypeMap() {
    return _Conversation.attributeTypeMap;
  }
  constructor() {
  }
};
_Conversation.discriminator = void 0;
_Conversation.attributeTypeMap = [
  {
    "name": "conversation_identifier",
    "baseName": "conversation_identifier",
    "type": "string",
    "format": ""
  }
];
var Conversation = _Conversation;

// models/ConversationSettingsInput.ts
var _ConversationSettingsInput = class _ConversationSettingsInput {
  static getAttributeTypeMap() {
    return _ConversationSettingsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ConversationSettingsInput.discriminator = void 0;
_ConversationSettingsInput.attributeTypeMap = [
  {
    "name": "enable_contextual_change_analysis",
    "baseName": "enable_contextual_change_analysis",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "enable_natural_language_answer_generation",
    "baseName": "enable_natural_language_answer_generation",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "enable_reasoning",
    "baseName": "enable_reasoning",
    "type": "boolean",
    "format": ""
  }
];
var ConversationSettingsInput = _ConversationSettingsInput;

// models/ConvertWorksheetToModelRequest.ts
var _ConvertWorksheetToModelRequest = class _ConvertWorksheetToModelRequest {
  static getAttributeTypeMap() {
    return _ConvertWorksheetToModelRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ConvertWorksheetToModelRequest.discriminator = void 0;
_ConvertWorksheetToModelRequest.attributeTypeMap = [
  {
    "name": "worksheet_ids",
    "baseName": "worksheet_ids",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "exclude_worksheet_ids",
    "baseName": "exclude_worksheet_ids",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "convert_all",
    "baseName": "convert_all",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "apply_changes",
    "baseName": "apply_changes",
    "type": "boolean",
    "format": ""
  }
];
var ConvertWorksheetToModelRequest = _ConvertWorksheetToModelRequest;

// models/CopyObjectRequest.ts
var _CopyObjectRequest = class _CopyObjectRequest {
  static getAttributeTypeMap() {
    return _CopyObjectRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CopyObjectRequest.discriminator = void 0;
_CopyObjectRequest.attributeTypeMap = [
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "CopyObjectRequestTypeEnum",
    "format": ""
  },
  {
    "name": "title",
    "baseName": "title",
    "type": "string",
    "format": ""
  }
];
var CopyObjectRequest = _CopyObjectRequest;

// models/CreateAgentConversationRequest.ts
var _CreateAgentConversationRequest = class _CreateAgentConversationRequest {
  static getAttributeTypeMap() {
    return _CreateAgentConversationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateAgentConversationRequest.discriminator = void 0;
_CreateAgentConversationRequest.attributeTypeMap = [
  {
    "name": "metadata_context",
    "baseName": "metadata_context",
    "type": "CreateAgentConversationRequestMetadataContext",
    "format": ""
  },
  {
    "name": "conversation_settings",
    "baseName": "conversation_settings",
    "type": "CreateAgentConversationRequestConversationSettings",
    "format": ""
  }
];
var CreateAgentConversationRequest = _CreateAgentConversationRequest;

// models/CreateAgentConversationRequestConversationSettings.ts
var _CreateAgentConversationRequestConversationSettings = class _CreateAgentConversationRequestConversationSettings {
  static getAttributeTypeMap() {
    return _CreateAgentConversationRequestConversationSettings.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateAgentConversationRequestConversationSettings.discriminator = void 0;
_CreateAgentConversationRequestConversationSettings.attributeTypeMap = [
  {
    "name": "enable_contextual_change_analysis",
    "baseName": "enable_contextual_change_analysis",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "enable_natural_language_answer_generation",
    "baseName": "enable_natural_language_answer_generation",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "enable_reasoning",
    "baseName": "enable_reasoning",
    "type": "boolean",
    "format": ""
  }
];
var CreateAgentConversationRequestConversationSettings = _CreateAgentConversationRequestConversationSettings;

// models/CreateAgentConversationRequestMetadataContext.ts
var _CreateAgentConversationRequestMetadataContext = class _CreateAgentConversationRequestMetadataContext {
  static getAttributeTypeMap() {
    return _CreateAgentConversationRequestMetadataContext.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateAgentConversationRequestMetadataContext.discriminator = void 0;
_CreateAgentConversationRequestMetadataContext.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "CreateAgentConversationRequestMetadataContextTypeEnum",
    "format": ""
  },
  {
    "name": "answer_context",
    "baseName": "answer_context",
    "type": "AnswerContextInput",
    "format": ""
  },
  {
    "name": "liveboard_context",
    "baseName": "liveboard_context",
    "type": "LBContextInput",
    "format": ""
  },
  {
    "name": "data_source_context",
    "baseName": "data_source_context",
    "type": "DataSourceContextInput",
    "format": ""
  }
];
var CreateAgentConversationRequestMetadataContext = _CreateAgentConversationRequestMetadataContext;

// models/CreateCalendarRequest.ts
var _CreateCalendarRequest = class _CreateCalendarRequest {
  static getAttributeTypeMap() {
    return _CreateCalendarRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateCalendarRequest.discriminator = void 0;
_CreateCalendarRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "creation_method",
    "baseName": "creation_method",
    "type": "CreateCalendarRequestCreationMethodEnum",
    "format": ""
  },
  {
    "name": "table_reference",
    "baseName": "table_reference",
    "type": "CreateCalendarRequestTableReference",
    "format": ""
  },
  {
    "name": "start_date",
    "baseName": "start_date",
    "type": "string",
    "format": ""
  },
  {
    "name": "end_date",
    "baseName": "end_date",
    "type": "string",
    "format": ""
  },
  {
    "name": "calendar_type",
    "baseName": "calendar_type",
    "type": "CreateCalendarRequestCalendarTypeEnum",
    "format": ""
  },
  {
    "name": "month_offset",
    "baseName": "month_offset",
    "type": "CreateCalendarRequestMonthOffsetEnum",
    "format": ""
  },
  {
    "name": "start_day_of_week",
    "baseName": "start_day_of_week",
    "type": "CreateCalendarRequestStartDayOfWeekEnum",
    "format": ""
  },
  {
    "name": "quarter_name_prefix",
    "baseName": "quarter_name_prefix",
    "type": "string",
    "format": ""
  },
  {
    "name": "year_name_prefix",
    "baseName": "year_name_prefix",
    "type": "string",
    "format": ""
  }
];
var CreateCalendarRequest = _CreateCalendarRequest;

// models/CreateCalendarRequestTableReference.ts
var _CreateCalendarRequestTableReference = class _CreateCalendarRequestTableReference {
  static getAttributeTypeMap() {
    return _CreateCalendarRequestTableReference.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateCalendarRequestTableReference.discriminator = void 0;
_CreateCalendarRequestTableReference.attributeTypeMap = [
  {
    "name": "connection_identifier",
    "baseName": "connection_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "database_name",
    "baseName": "database_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "schema_name",
    "baseName": "schema_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "table_name",
    "baseName": "table_name",
    "type": "string",
    "format": ""
  }
];
var CreateCalendarRequestTableReference = _CreateCalendarRequestTableReference;

// models/CreateConfigRequest.ts
var _CreateConfigRequest = class _CreateConfigRequest {
  static getAttributeTypeMap() {
    return _CreateConfigRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateConfigRequest.discriminator = void 0;
_CreateConfigRequest.attributeTypeMap = [
  {
    "name": "repository_url",
    "baseName": "repository_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  },
  {
    "name": "access_token",
    "baseName": "access_token",
    "type": "string",
    "format": ""
  },
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "branch_names",
    "baseName": "branch_names",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "commit_branch_name",
    "baseName": "commit_branch_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "enable_guid_mapping",
    "baseName": "enable_guid_mapping",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "configuration_branch_name",
    "baseName": "configuration_branch_name",
    "type": "string",
    "format": ""
  }
];
var CreateConfigRequest = _CreateConfigRequest;

// models/CreateConnectionConfigurationRequest.ts
var _CreateConnectionConfigurationRequest = class _CreateConnectionConfigurationRequest {
  static getAttributeTypeMap() {
    return _CreateConnectionConfigurationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateConnectionConfigurationRequest.discriminator = void 0;
_CreateConnectionConfigurationRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "connection_identifier",
    "baseName": "connection_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "same_as_parent",
    "baseName": "same_as_parent",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "policy_process_options",
    "baseName": "policy_process_options",
    "type": "CreateConnectionConfigurationRequestPolicyProcessOptions",
    "format": ""
  },
  {
    "name": "authentication_type",
    "baseName": "authentication_type",
    "type": "CreateConnectionConfigurationRequestAuthenticationTypeEnum",
    "format": ""
  },
  {
    "name": "configuration",
    "baseName": "configuration",
    "type": "any",
    "format": ""
  },
  {
    "name": "policy_type",
    "baseName": "policy_type",
    "type": "CreateConnectionConfigurationRequestPolicyTypeEnum",
    "format": ""
  },
  {
    "name": "policy_principals",
    "baseName": "policy_principals",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "policy_processes",
    "baseName": "policy_processes",
    "type": "Array<CreateConnectionConfigurationRequestPolicyProcessesEnum>",
    "format": ""
  }
];
var CreateConnectionConfigurationRequest = _CreateConnectionConfigurationRequest;

// models/CreateConnectionConfigurationRequestPolicyProcessOptions.ts
var _CreateConnectionConfigurationRequestPolicyProcessOptions = class _CreateConnectionConfigurationRequestPolicyProcessOptions {
  static getAttributeTypeMap() {
    return _CreateConnectionConfigurationRequestPolicyProcessOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateConnectionConfigurationRequestPolicyProcessOptions.discriminator = void 0;
_CreateConnectionConfigurationRequestPolicyProcessOptions.attributeTypeMap = [
  {
    "name": "impersonate_user",
    "baseName": "impersonate_user",
    "type": "string",
    "format": ""
  }
];
var CreateConnectionConfigurationRequestPolicyProcessOptions = _CreateConnectionConfigurationRequestPolicyProcessOptions;

// models/CreateConnectionRequest.ts
var _CreateConnectionRequest = class _CreateConnectionRequest {
  static getAttributeTypeMap() {
    return _CreateConnectionRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateConnectionRequest.discriminator = void 0;
_CreateConnectionRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_warehouse_type",
    "baseName": "data_warehouse_type",
    "type": "CreateConnectionRequestDataWarehouseTypeEnum",
    "format": ""
  },
  {
    "name": "data_warehouse_config",
    "baseName": "data_warehouse_config",
    "type": "any",
    "format": ""
  },
  {
    "name": "validate",
    "baseName": "validate",
    "type": "boolean",
    "format": ""
  }
];
var CreateConnectionRequest = _CreateConnectionRequest;

// models/CreateConnectionResponse.ts
var _CreateConnectionResponse = class _CreateConnectionResponse {
  static getAttributeTypeMap() {
    return _CreateConnectionResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateConnectionResponse.discriminator = void 0;
_CreateConnectionResponse.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_warehouse_type",
    "baseName": "data_warehouse_type",
    "type": "CreateConnectionResponseDataWarehouseTypeEnum",
    "format": ""
  },
  {
    "name": "details",
    "baseName": "details",
    "type": "any",
    "format": ""
  }
];
var CreateConnectionResponse = _CreateConnectionResponse;

// models/CreateConversationRequest.ts
var _CreateConversationRequest = class _CreateConversationRequest {
  static getAttributeTypeMap() {
    return _CreateConversationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateConversationRequest.discriminator = void 0;
_CreateConversationRequest.attributeTypeMap = [
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "tokens",
    "baseName": "tokens",
    "type": "string",
    "format": ""
  }
];
var CreateConversationRequest = _CreateConversationRequest;

// models/CreateCustomActionRequest.ts
var _CreateCustomActionRequest = class _CreateCustomActionRequest {
  static getAttributeTypeMap() {
    return _CreateCustomActionRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateCustomActionRequest.discriminator = void 0;
_CreateCustomActionRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "action_details",
    "baseName": "action_details",
    "type": "CreateCustomActionRequestActionDetails",
    "format": ""
  },
  {
    "name": "associate_metadata",
    "baseName": "associate_metadata",
    "type": "Array<AssociateMetadataInputCreate>",
    "format": ""
  },
  {
    "name": "default_action_config",
    "baseName": "default_action_config",
    "type": "CreateCustomActionRequestDefaultActionConfig",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var CreateCustomActionRequest = _CreateCustomActionRequest;

// models/CreateCustomActionRequestActionDetails.ts
var _CreateCustomActionRequestActionDetails = class _CreateCustomActionRequestActionDetails {
  static getAttributeTypeMap() {
    return _CreateCustomActionRequestActionDetails.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateCustomActionRequestActionDetails.discriminator = void 0;
_CreateCustomActionRequestActionDetails.attributeTypeMap = [
  {
    "name": "CALLBACK",
    "baseName": "CALLBACK",
    "type": "CALLBACKInputMandatory",
    "format": ""
  },
  {
    "name": "URL",
    "baseName": "URL",
    "type": "URLInputMandatory",
    "format": ""
  }
];
var CreateCustomActionRequestActionDetails = _CreateCustomActionRequestActionDetails;

// models/CreateCustomActionRequestDefaultActionConfig.ts
var _CreateCustomActionRequestDefaultActionConfig = class _CreateCustomActionRequestDefaultActionConfig {
  static getAttributeTypeMap() {
    return _CreateCustomActionRequestDefaultActionConfig.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateCustomActionRequestDefaultActionConfig.discriminator = void 0;
_CreateCustomActionRequestDefaultActionConfig.attributeTypeMap = [
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "boolean",
    "format": ""
  }
];
var CreateCustomActionRequestDefaultActionConfig = _CreateCustomActionRequestDefaultActionConfig;

// models/CreateEmailCustomizationRequest.ts
var _CreateEmailCustomizationRequest = class _CreateEmailCustomizationRequest {
  static getAttributeTypeMap() {
    return _CreateEmailCustomizationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateEmailCustomizationRequest.discriminator = void 0;
_CreateEmailCustomizationRequest.attributeTypeMap = [
  {
    "name": "template_properties",
    "baseName": "template_properties",
    "type": "CreateEmailCustomizationRequestTemplateProperties",
    "format": ""
  },
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  }
];
var CreateEmailCustomizationRequest = _CreateEmailCustomizationRequest;

// models/CreateEmailCustomizationRequestTemplateProperties.ts
var _CreateEmailCustomizationRequestTemplateProperties = class _CreateEmailCustomizationRequestTemplateProperties {
  static getAttributeTypeMap() {
    return _CreateEmailCustomizationRequestTemplateProperties.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateEmailCustomizationRequestTemplateProperties.discriminator = void 0;
_CreateEmailCustomizationRequestTemplateProperties.attributeTypeMap = [
  {
    "name": "cta_button_bg_color",
    "baseName": "cta_button_bg_color",
    "type": "string",
    "format": ""
  },
  {
    "name": "cta_text_font_color",
    "baseName": "cta_text_font_color",
    "type": "string",
    "format": ""
  },
  {
    "name": "primary_bg_color",
    "baseName": "primary_bg_color",
    "type": "string",
    "format": ""
  },
  {
    "name": "home_url",
    "baseName": "home_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "logo_url",
    "baseName": "logo_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "font_family",
    "baseName": "font_family",
    "type": "string",
    "format": ""
  },
  {
    "name": "product_name",
    "baseName": "product_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "footer_address",
    "baseName": "footer_address",
    "type": "string",
    "format": ""
  },
  {
    "name": "footer_phone",
    "baseName": "footer_phone",
    "type": "string",
    "format": ""
  },
  {
    "name": "replacement_value_for_liveboard",
    "baseName": "replacement_value_for_liveboard",
    "type": "string",
    "format": ""
  },
  {
    "name": "replacement_value_for_answer",
    "baseName": "replacement_value_for_answer",
    "type": "string",
    "format": ""
  },
  {
    "name": "replacement_value_for_spot_iq",
    "baseName": "replacement_value_for_spot_iq",
    "type": "string",
    "format": ""
  },
  {
    "name": "hide_footer_address",
    "baseName": "hide_footer_address",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_footer_phone",
    "baseName": "hide_footer_phone",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_manage_notification",
    "baseName": "hide_manage_notification",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_mobile_app_nudge",
    "baseName": "hide_mobile_app_nudge",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_privacy_policy",
    "baseName": "hide_privacy_policy",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_product_name",
    "baseName": "hide_product_name",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_ts_vocabulary_definitions",
    "baseName": "hide_ts_vocabulary_definitions",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_notification_status",
    "baseName": "hide_notification_status",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_error_message",
    "baseName": "hide_error_message",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_unsubscribe_link",
    "baseName": "hide_unsubscribe_link",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_modify_alert",
    "baseName": "hide_modify_alert",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "company_privacy_policy_url",
    "baseName": "company_privacy_policy_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "company_website_url",
    "baseName": "company_website_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "contact_support_url",
    "baseName": "contact_support_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "hide_contact_support_url",
    "baseName": "hide_contact_support_url",
    "type": "boolean",
    "format": ""
  }
];
var CreateEmailCustomizationRequestTemplateProperties = _CreateEmailCustomizationRequestTemplateProperties;

// models/CreateEmailCustomizationResponse.ts
var _CreateEmailCustomizationResponse = class _CreateEmailCustomizationResponse {
  static getAttributeTypeMap() {
    return _CreateEmailCustomizationResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateEmailCustomizationResponse.discriminator = void 0;
_CreateEmailCustomizationResponse.attributeTypeMap = [
  {
    "name": "tenant_id",
    "baseName": "tenant_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "org",
    "baseName": "org",
    "type": "OrgType",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "template_properties",
    "baseName": "template_properties",
    "type": "any",
    "format": ""
  }
];
var CreateEmailCustomizationResponse = _CreateEmailCustomizationResponse;

// models/CreateOrgRequest.ts
var _CreateOrgRequest = class _CreateOrgRequest {
  static getAttributeTypeMap() {
    return _CreateOrgRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateOrgRequest.discriminator = void 0;
_CreateOrgRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  }
];
var CreateOrgRequest = _CreateOrgRequest;

// models/CreateRoleRequest.ts
var _CreateRoleRequest = class _CreateRoleRequest {
  static getAttributeTypeMap() {
    return _CreateRoleRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateRoleRequest.discriminator = void 0;
_CreateRoleRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<CreateRoleRequestPrivilegesEnum>",
    "format": ""
  },
  {
    "name": "read_only",
    "baseName": "read_only",
    "type": "boolean",
    "format": ""
  }
];
var CreateRoleRequest = _CreateRoleRequest;

// models/CreateScheduleRequest.ts
var _CreateScheduleRequest = class _CreateScheduleRequest {
  static getAttributeTypeMap() {
    return _CreateScheduleRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateScheduleRequest.discriminator = void 0;
_CreateScheduleRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "CreateScheduleRequestMetadataTypeEnum",
    "format": ""
  },
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "file_format",
    "baseName": "file_format",
    "type": "CreateScheduleRequestFileFormatEnum",
    "format": ""
  },
  {
    "name": "liveboard_options",
    "baseName": "liveboard_options",
    "type": "CreateScheduleRequestLiveboardOptions",
    "format": ""
  },
  {
    "name": "pdf_options",
    "baseName": "pdf_options",
    "type": "CreateScheduleRequestPdfOptions",
    "format": ""
  },
  {
    "name": "time_zone",
    "baseName": "time_zone",
    "type": "CreateScheduleRequestTimeZoneEnum",
    "format": ""
  },
  {
    "name": "frequency",
    "baseName": "frequency",
    "type": "CreateScheduleRequestFrequency",
    "format": ""
  },
  {
    "name": "recipient_details",
    "baseName": "recipient_details",
    "type": "CreateScheduleRequestRecipientDetails",
    "format": ""
  },
  {
    "name": "personalised_view_id",
    "baseName": "personalised_view_id",
    "type": "string",
    "format": ""
  }
];
var CreateScheduleRequest = _CreateScheduleRequest;

// models/CreateScheduleRequestFrequency.ts
var _CreateScheduleRequestFrequency = class _CreateScheduleRequestFrequency {
  static getAttributeTypeMap() {
    return _CreateScheduleRequestFrequency.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateScheduleRequestFrequency.discriminator = void 0;
_CreateScheduleRequestFrequency.attributeTypeMap = [
  {
    "name": "cron_expression",
    "baseName": "cron_expression",
    "type": "CronExpressionInput",
    "format": ""
  }
];
var CreateScheduleRequestFrequency = _CreateScheduleRequestFrequency;

// models/CreateScheduleRequestLiveboardOptions.ts
var _CreateScheduleRequestLiveboardOptions = class _CreateScheduleRequestLiveboardOptions {
  static getAttributeTypeMap() {
    return _CreateScheduleRequestLiveboardOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateScheduleRequestLiveboardOptions.discriminator = void 0;
_CreateScheduleRequestLiveboardOptions.attributeTypeMap = [
  {
    "name": "visualization_identifiers",
    "baseName": "visualization_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var CreateScheduleRequestLiveboardOptions = _CreateScheduleRequestLiveboardOptions;

// models/CreateScheduleRequestPdfOptions.ts
var _CreateScheduleRequestPdfOptions = class _CreateScheduleRequestPdfOptions {
  static getAttributeTypeMap() {
    return _CreateScheduleRequestPdfOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateScheduleRequestPdfOptions.discriminator = void 0;
_CreateScheduleRequestPdfOptions.attributeTypeMap = [
  {
    "name": "complete_liveboard",
    "baseName": "complete_liveboard",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_cover_page",
    "baseName": "include_cover_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_custom_logo",
    "baseName": "include_custom_logo",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_filter_page",
    "baseName": "include_filter_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_page_number",
    "baseName": "include_page_number",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "page_footer_text",
    "baseName": "page_footer_text",
    "type": "string",
    "format": ""
  },
  {
    "name": "page_orientation",
    "baseName": "page_orientation",
    "type": "string",
    "format": ""
  },
  {
    "name": "page_size",
    "baseName": "page_size",
    "type": "CreateScheduleRequestPdfOptionsPageSizeEnum",
    "format": ""
  },
  {
    "name": "truncate_table",
    "baseName": "truncate_table",
    "type": "boolean",
    "format": ""
  }
];
var CreateScheduleRequestPdfOptions = _CreateScheduleRequestPdfOptions;

// models/CreateScheduleRequestRecipientDetails.ts
var _CreateScheduleRequestRecipientDetails = class _CreateScheduleRequestRecipientDetails {
  static getAttributeTypeMap() {
    return _CreateScheduleRequestRecipientDetails.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateScheduleRequestRecipientDetails.discriminator = void 0;
_CreateScheduleRequestRecipientDetails.attributeTypeMap = [
  {
    "name": "emails",
    "baseName": "emails",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "principals",
    "baseName": "principals",
    "type": "Array<PrincipalsListItemInput>",
    "format": ""
  }
];
var CreateScheduleRequestRecipientDetails = _CreateScheduleRequestRecipientDetails;

// models/CreateTagRequest.ts
var _CreateTagRequest = class _CreateTagRequest {
  static getAttributeTypeMap() {
    return _CreateTagRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateTagRequest.discriminator = void 0;
_CreateTagRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "color",
    "baseName": "color",
    "type": "string",
    "format": ""
  }
];
var CreateTagRequest = _CreateTagRequest;

// models/CreateUserGroupRequest.ts
var _CreateUserGroupRequest = class _CreateUserGroupRequest {
  static getAttributeTypeMap() {
    return _CreateUserGroupRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateUserGroupRequest.discriminator = void 0;
_CreateUserGroupRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "default_liveboard_identifiers",
    "baseName": "default_liveboard_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<CreateUserGroupRequestPrivilegesEnum>",
    "format": ""
  },
  {
    "name": "sub_group_identifiers",
    "baseName": "sub_group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "CreateUserGroupRequestTypeEnum",
    "format": ""
  },
  {
    "name": "user_identifiers",
    "baseName": "user_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "CreateUserGroupRequestVisibilityEnum",
    "format": ""
  },
  {
    "name": "role_identifiers",
    "baseName": "role_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var CreateUserGroupRequest = _CreateUserGroupRequest;

// models/CreateUserRequest.ts
var _CreateUserRequest = class _CreateUserRequest {
  static getAttributeTypeMap() {
    return _CreateUserRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateUserRequest.discriminator = void 0;
_CreateUserRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  },
  {
    "name": "email",
    "baseName": "email",
    "type": "string",
    "format": ""
  },
  {
    "name": "account_type",
    "baseName": "account_type",
    "type": "CreateUserRequestAccountTypeEnum",
    "format": ""
  },
  {
    "name": "account_status",
    "baseName": "account_status",
    "type": "CreateUserRequestAccountStatusEnum",
    "format": ""
  },
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "CreateUserRequestVisibilityEnum",
    "format": ""
  },
  {
    "name": "notify_on_share",
    "baseName": "notify_on_share",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "show_onboarding_experience",
    "baseName": "show_onboarding_experience",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "onboarding_experience_completed",
    "baseName": "onboarding_experience_completed",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "home_liveboard_identifier",
    "baseName": "home_liveboard_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "favorite_metadata",
    "baseName": "favorite_metadata",
    "type": "Array<FavoriteMetadataInput>",
    "format": ""
  },
  {
    "name": "preferred_locale",
    "baseName": "preferred_locale",
    "type": "CreateUserRequestPreferredLocaleEnum",
    "format": ""
  },
  {
    "name": "extended_properties",
    "baseName": "extended_properties",
    "type": "any",
    "format": ""
  },
  {
    "name": "extended_preferences",
    "baseName": "extended_preferences",
    "type": "any",
    "format": ""
  },
  {
    "name": "trigger_welcome_email",
    "baseName": "trigger_welcome_email",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "trigger_activation_email",
    "baseName": "trigger_activation_email",
    "type": "boolean",
    "format": ""
  }
];
var CreateUserRequest = _CreateUserRequest;

// models/CreateVariableRequest.ts
var _CreateVariableRequest = class _CreateVariableRequest {
  static getAttributeTypeMap() {
    return _CreateVariableRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateVariableRequest.discriminator = void 0;
_CreateVariableRequest.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "CreateVariableRequestTypeEnum",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "is_sensitive",
    "baseName": "is_sensitive",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "data_type",
    "baseName": "data_type",
    "type": "CreateVariableRequestDataTypeEnum",
    "format": ""
  }
];
var CreateVariableRequest = _CreateVariableRequest;

// models/CreateWebhookConfigurationRequest.ts
var _CreateWebhookConfigurationRequest = class _CreateWebhookConfigurationRequest {
  static getAttributeTypeMap() {
    return _CreateWebhookConfigurationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateWebhookConfigurationRequest.discriminator = void 0;
_CreateWebhookConfigurationRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "url",
    "baseName": "url",
    "type": "string",
    "format": ""
  },
  {
    "name": "url_params",
    "baseName": "url_params",
    "type": "any",
    "format": ""
  },
  {
    "name": "events",
    "baseName": "events",
    "type": "Array<CreateWebhookConfigurationRequestEventsEnum>",
    "format": ""
  },
  {
    "name": "authentication",
    "baseName": "authentication",
    "type": "CreateWebhookConfigurationRequestAuthentication",
    "format": ""
  },
  {
    "name": "signature_verification",
    "baseName": "signature_verification",
    "type": "CreateWebhookConfigurationRequestSignatureVerification",
    "format": ""
  }
];
var CreateWebhookConfigurationRequest = _CreateWebhookConfigurationRequest;

// models/CreateWebhookConfigurationRequestAuthentication.ts
var _CreateWebhookConfigurationRequestAuthentication = class _CreateWebhookConfigurationRequestAuthentication {
  static getAttributeTypeMap() {
    return _CreateWebhookConfigurationRequestAuthentication.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateWebhookConfigurationRequestAuthentication.discriminator = void 0;
_CreateWebhookConfigurationRequestAuthentication.attributeTypeMap = [
  {
    "name": "API_KEY",
    "baseName": "API_KEY",
    "type": "WebhookAuthApiKeyInput",
    "format": ""
  },
  {
    "name": "BASIC_AUTH",
    "baseName": "BASIC_AUTH",
    "type": "WebhookAuthBasicAuthInput",
    "format": ""
  },
  {
    "name": "BEARER_TOKEN",
    "baseName": "BEARER_TOKEN",
    "type": "string",
    "format": ""
  },
  {
    "name": "OAUTH2",
    "baseName": "OAUTH2",
    "type": "WebhookAuthOAuth2Input",
    "format": ""
  }
];
var CreateWebhookConfigurationRequestAuthentication = _CreateWebhookConfigurationRequestAuthentication;

// models/CreateWebhookConfigurationRequestSignatureVerification.ts
var _CreateWebhookConfigurationRequestSignatureVerification = class _CreateWebhookConfigurationRequestSignatureVerification {
  static getAttributeTypeMap() {
    return _CreateWebhookConfigurationRequestSignatureVerification.attributeTypeMap;
  }
  constructor() {
  }
};
_CreateWebhookConfigurationRequestSignatureVerification.discriminator = void 0;
_CreateWebhookConfigurationRequestSignatureVerification.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "CreateWebhookConfigurationRequestSignatureVerificationTypeEnum",
    "format": ""
  },
  {
    "name": "header",
    "baseName": "header",
    "type": "string",
    "format": ""
  },
  {
    "name": "algorithm",
    "baseName": "algorithm",
    "type": "CreateWebhookConfigurationRequestSignatureVerificationAlgorithmEnum",
    "format": ""
  },
  {
    "name": "secret",
    "baseName": "secret",
    "type": "string",
    "format": ""
  }
];
var CreateWebhookConfigurationRequestSignatureVerification = _CreateWebhookConfigurationRequestSignatureVerification;

// models/CronExpression.ts
var _CronExpression = class _CronExpression {
  static getAttributeTypeMap() {
    return _CronExpression.attributeTypeMap;
  }
  constructor() {
  }
};
_CronExpression.discriminator = void 0;
_CronExpression.attributeTypeMap = [
  {
    "name": "day_of_month",
    "baseName": "day_of_month",
    "type": "string",
    "format": ""
  },
  {
    "name": "day_of_week",
    "baseName": "day_of_week",
    "type": "string",
    "format": ""
  },
  {
    "name": "hour",
    "baseName": "hour",
    "type": "string",
    "format": ""
  },
  {
    "name": "minute",
    "baseName": "minute",
    "type": "string",
    "format": ""
  },
  {
    "name": "month",
    "baseName": "month",
    "type": "string",
    "format": ""
  },
  {
    "name": "second",
    "baseName": "second",
    "type": "string",
    "format": ""
  }
];
var CronExpression = _CronExpression;

// models/CronExpressionInput.ts
var _CronExpressionInput = class _CronExpressionInput {
  static getAttributeTypeMap() {
    return _CronExpressionInput.attributeTypeMap;
  }
  constructor() {
  }
};
_CronExpressionInput.discriminator = void 0;
_CronExpressionInput.attributeTypeMap = [
  {
    "name": "day_of_month",
    "baseName": "day_of_month",
    "type": "string",
    "format": ""
  },
  {
    "name": "day_of_week",
    "baseName": "day_of_week",
    "type": "string",
    "format": ""
  },
  {
    "name": "hour",
    "baseName": "hour",
    "type": "string",
    "format": ""
  },
  {
    "name": "minute",
    "baseName": "minute",
    "type": "string",
    "format": ""
  },
  {
    "name": "month",
    "baseName": "month",
    "type": "string",
    "format": ""
  },
  {
    "name": "second",
    "baseName": "second",
    "type": "string",
    "format": ""
  }
];
var CronExpressionInput = _CronExpressionInput;

// models/CspSettings.ts
var _CspSettings = class _CspSettings {
  static getAttributeTypeMap() {
    return _CspSettings.attributeTypeMap;
  }
  constructor() {
  }
};
_CspSettings.discriminator = void 0;
_CspSettings.attributeTypeMap = [
  {
    "name": "connect_src_urls",
    "baseName": "connect_src_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "font_src_urls",
    "baseName": "font_src_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "visual_embed_hosts",
    "baseName": "visual_embed_hosts",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "iframe_src_urls",
    "baseName": "iframe_src_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "img_src_urls",
    "baseName": "img_src_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "script_src_urls",
    "baseName": "script_src_urls",
    "type": "ScriptSrcUrls",
    "format": ""
  },
  {
    "name": "style_src_urls",
    "baseName": "style_src_urls",
    "type": "Array<string>",
    "format": ""
  }
];
var CspSettings = _CspSettings;

// models/CspSettingsInput.ts
var _CspSettingsInput = class _CspSettingsInput {
  static getAttributeTypeMap() {
    return _CspSettingsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_CspSettingsInput.discriminator = void 0;
_CspSettingsInput.attributeTypeMap = [
  {
    "name": "connect_src_urls",
    "baseName": "connect_src_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "font_src_urls",
    "baseName": "font_src_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "visual_embed_hosts",
    "baseName": "visual_embed_hosts",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "iframe_src_urls",
    "baseName": "iframe_src_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "img_src_urls",
    "baseName": "img_src_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "script_src_urls",
    "baseName": "script_src_urls",
    "type": "ScriptSrcUrlsInput",
    "format": ""
  },
  {
    "name": "style_src_urls",
    "baseName": "style_src_urls",
    "type": "Array<string>",
    "format": ""
  }
];
var CspSettingsInput = _CspSettingsInput;

// models/CustomActionMetadataTypeInput.ts
var _CustomActionMetadataTypeInput = class _CustomActionMetadataTypeInput {
  static getAttributeTypeMap() {
    return _CustomActionMetadataTypeInput.attributeTypeMap;
  }
  constructor() {
  }
};
_CustomActionMetadataTypeInput.discriminator = void 0;
_CustomActionMetadataTypeInput.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "CustomActionMetadataTypeInputTypeEnum",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  }
];
var CustomActionMetadataTypeInput = _CustomActionMetadataTypeInput;

// models/DataSource.ts
var _DataSource = class _DataSource {
  static getAttributeTypeMap() {
    return _DataSource.attributeTypeMap;
  }
  constructor() {
  }
};
_DataSource.discriminator = void 0;
_DataSource.attributeTypeMap = [
  {
    "name": "confidence",
    "baseName": "confidence",
    "type": "number",
    "format": "float"
  },
  {
    "name": "details",
    "baseName": "details",
    "type": "EntityHeader",
    "format": ""
  },
  {
    "name": "reasoning",
    "baseName": "reasoning",
    "type": "string",
    "format": ""
  }
];
var DataSource = _DataSource;

// models/DataSourceContextInput.ts
var _DataSourceContextInput = class _DataSourceContextInput {
  static getAttributeTypeMap() {
    return _DataSourceContextInput.attributeTypeMap;
  }
  constructor() {
  }
};
_DataSourceContextInput.discriminator = void 0;
_DataSourceContextInput.attributeTypeMap = [
  {
    "name": "guid",
    "baseName": "guid",
    "type": "string",
    "format": ""
  }
];
var DataSourceContextInput = _DataSourceContextInput;

// models/DataWarehouseObjectInput.ts
var _DataWarehouseObjectInput = class _DataWarehouseObjectInput {
  static getAttributeTypeMap() {
    return _DataWarehouseObjectInput.attributeTypeMap;
  }
  constructor() {
  }
};
_DataWarehouseObjectInput.discriminator = void 0;
_DataWarehouseObjectInput.attributeTypeMap = [
  {
    "name": "database",
    "baseName": "database",
    "type": "string",
    "format": ""
  },
  {
    "name": "schema",
    "baseName": "schema",
    "type": "string",
    "format": ""
  },
  {
    "name": "table",
    "baseName": "table",
    "type": "string",
    "format": ""
  },
  {
    "name": "column",
    "baseName": "column",
    "type": "string",
    "format": ""
  }
];
var DataWarehouseObjectInput = _DataWarehouseObjectInput;

// models/DataWarehouseObjects.ts
var _DataWarehouseObjects = class _DataWarehouseObjects {
  static getAttributeTypeMap() {
    return _DataWarehouseObjects.attributeTypeMap;
  }
  constructor() {
  }
};
_DataWarehouseObjects.discriminator = void 0;
_DataWarehouseObjects.attributeTypeMap = [
  {
    "name": "databases",
    "baseName": "databases",
    "type": "Array<Database>",
    "format": ""
  }
];
var DataWarehouseObjects = _DataWarehouseObjects;

// models/Database.ts
var _Database = class _Database {
  static getAttributeTypeMap() {
    return _Database.attributeTypeMap;
  }
  constructor() {
  }
};
_Database.discriminator = void 0;
_Database.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "schemas",
    "baseName": "schemas",
    "type": "Array<SchemaObject>",
    "format": ""
  },
  {
    "name": "auto_created",
    "baseName": "auto_created",
    "type": "boolean",
    "format": ""
  }
];
var Database = _Database;

// models/DbtSearchResponse.ts
var _DbtSearchResponse = class _DbtSearchResponse {
  static getAttributeTypeMap() {
    return _DbtSearchResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_DbtSearchResponse.discriminator = void 0;
_DbtSearchResponse.attributeTypeMap = [
  {
    "name": "dbt_connection_identifier",
    "baseName": "dbt_connection_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "project_name",
    "baseName": "project_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "connection_id",
    "baseName": "connection_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "connection_name",
    "baseName": "connection_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "cdw_database",
    "baseName": "cdw_database",
    "type": "string",
    "format": ""
  },
  {
    "name": "import_type",
    "baseName": "import_type",
    "type": "string",
    "format": ""
  },
  {
    "name": "author_name",
    "baseName": "author_name",
    "type": "string",
    "format": ""
  }
];
var DbtSearchResponse = _DbtSearchResponse;

// models/DeactivateUserRequest.ts
var _DeactivateUserRequest = class _DeactivateUserRequest {
  static getAttributeTypeMap() {
    return _DeactivateUserRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_DeactivateUserRequest.discriminator = void 0;
_DeactivateUserRequest.attributeTypeMap = [
  {
    "name": "user_identifier",
    "baseName": "user_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "base_url",
    "baseName": "base_url",
    "type": "string",
    "format": ""
  }
];
var DeactivateUserRequest = _DeactivateUserRequest;

// models/DefaultActionConfig.ts
var _DefaultActionConfig = class _DefaultActionConfig {
  static getAttributeTypeMap() {
    return _DefaultActionConfig.attributeTypeMap;
  }
  constructor() {
  }
};
_DefaultActionConfig.discriminator = void 0;
_DefaultActionConfig.attributeTypeMap = [
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "boolean",
    "format": ""
  }
];
var DefaultActionConfig = _DefaultActionConfig;

// models/DefaultActionConfigInput.ts
var _DefaultActionConfigInput = class _DefaultActionConfigInput {
  static getAttributeTypeMap() {
    return _DefaultActionConfigInput.attributeTypeMap;
  }
  constructor() {
  }
};
_DefaultActionConfigInput.discriminator = void 0;
_DefaultActionConfigInput.attributeTypeMap = [
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "boolean",
    "format": ""
  }
];
var DefaultActionConfigInput = _DefaultActionConfigInput;

// models/DefaultActionConfigInputCreate.ts
var _DefaultActionConfigInputCreate = class _DefaultActionConfigInputCreate {
  static getAttributeTypeMap() {
    return _DefaultActionConfigInputCreate.attributeTypeMap;
  }
  constructor() {
  }
};
_DefaultActionConfigInputCreate.discriminator = void 0;
_DefaultActionConfigInputCreate.attributeTypeMap = [
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "boolean",
    "format": ""
  }
];
var DefaultActionConfigInputCreate = _DefaultActionConfigInputCreate;

// models/DefaultActionConfigSearchInput.ts
var _DefaultActionConfigSearchInput = class _DefaultActionConfigSearchInput {
  static getAttributeTypeMap() {
    return _DefaultActionConfigSearchInput.attributeTypeMap;
  }
  constructor() {
  }
};
_DefaultActionConfigSearchInput.discriminator = void 0;
_DefaultActionConfigSearchInput.attributeTypeMap = [
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "boolean",
    "format": ""
  }
];
var DefaultActionConfigSearchInput = _DefaultActionConfigSearchInput;

// models/DeleteConfigRequest.ts
var _DeleteConfigRequest = class _DeleteConfigRequest {
  static getAttributeTypeMap() {
    return _DeleteConfigRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_DeleteConfigRequest.discriminator = void 0;
_DeleteConfigRequest.attributeTypeMap = [
  {
    "name": "cluster_level",
    "baseName": "cluster_level",
    "type": "boolean",
    "format": ""
  }
];
var DeleteConfigRequest = _DeleteConfigRequest;

// models/DeleteConnectionConfigurationRequest.ts
var _DeleteConnectionConfigurationRequest = class _DeleteConnectionConfigurationRequest {
  static getAttributeTypeMap() {
    return _DeleteConnectionConfigurationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_DeleteConnectionConfigurationRequest.discriminator = void 0;
_DeleteConnectionConfigurationRequest.attributeTypeMap = [
  {
    "name": "configuration_identifier",
    "baseName": "configuration_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "connection_identifier",
    "baseName": "connection_identifier",
    "type": "string",
    "format": ""
  }
];
var DeleteConnectionConfigurationRequest = _DeleteConnectionConfigurationRequest;

// models/DeleteConnectionRequest.ts
var _DeleteConnectionRequest = class _DeleteConnectionRequest {
  static getAttributeTypeMap() {
    return _DeleteConnectionRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_DeleteConnectionRequest.discriminator = void 0;
_DeleteConnectionRequest.attributeTypeMap = [
  {
    "name": "connection_identifier",
    "baseName": "connection_identifier",
    "type": "string",
    "format": ""
  }
];
var DeleteConnectionRequest = _DeleteConnectionRequest;

// models/DeleteMetadataRequest.ts
var _DeleteMetadataRequest = class _DeleteMetadataRequest {
  static getAttributeTypeMap() {
    return _DeleteMetadataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_DeleteMetadataRequest.discriminator = void 0;
_DeleteMetadataRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<DeleteMetadataTypeInput>",
    "format": ""
  },
  {
    "name": "delete_disabled_objects",
    "baseName": "delete_disabled_objects",
    "type": "boolean",
    "format": ""
  }
];
var DeleteMetadataRequest = _DeleteMetadataRequest;

// models/DeleteMetadataTypeInput.ts
var _DeleteMetadataTypeInput = class _DeleteMetadataTypeInput {
  static getAttributeTypeMap() {
    return _DeleteMetadataTypeInput.attributeTypeMap;
  }
  constructor() {
  }
};
_DeleteMetadataTypeInput.discriminator = void 0;
_DeleteMetadataTypeInput.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "DeleteMetadataTypeInputTypeEnum",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  }
];
var DeleteMetadataTypeInput = _DeleteMetadataTypeInput;

// models/DeleteOrgEmailCustomizationRequest.ts
var _DeleteOrgEmailCustomizationRequest = class _DeleteOrgEmailCustomizationRequest {
  static getAttributeTypeMap() {
    return _DeleteOrgEmailCustomizationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_DeleteOrgEmailCustomizationRequest.discriminator = void 0;
_DeleteOrgEmailCustomizationRequest.attributeTypeMap = [
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var DeleteOrgEmailCustomizationRequest = _DeleteOrgEmailCustomizationRequest;

// models/DeleteWebhookConfigurationsRequest.ts
var _DeleteWebhookConfigurationsRequest = class _DeleteWebhookConfigurationsRequest {
  static getAttributeTypeMap() {
    return _DeleteWebhookConfigurationsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_DeleteWebhookConfigurationsRequest.discriminator = void 0;
_DeleteWebhookConfigurationsRequest.attributeTypeMap = [
  {
    "name": "webhook_identifiers",
    "baseName": "webhook_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var DeleteWebhookConfigurationsRequest = _DeleteWebhookConfigurationsRequest;

// models/DeployCommitRequest.ts
var _DeployCommitRequest = class _DeployCommitRequest {
  static getAttributeTypeMap() {
    return _DeployCommitRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_DeployCommitRequest.discriminator = void 0;
_DeployCommitRequest.attributeTypeMap = [
  {
    "name": "commit_id",
    "baseName": "commit_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "branch_name",
    "baseName": "branch_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "deploy_type",
    "baseName": "deploy_type",
    "type": "DeployCommitRequestDeployTypeEnum",
    "format": ""
  },
  {
    "name": "deploy_policy",
    "baseName": "deploy_policy",
    "type": "DeployCommitRequestDeployPolicyEnum",
    "format": ""
  }
];
var DeployCommitRequest = _DeployCommitRequest;

// models/DeployResponse.ts
var _DeployResponse = class _DeployResponse {
  static getAttributeTypeMap() {
    return _DeployResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_DeployResponse.discriminator = void 0;
_DeployResponse.attributeTypeMap = [
  {
    "name": "file_name",
    "baseName": "file_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_name",
    "baseName": "metadata_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "string",
    "format": ""
  },
  {
    "name": "status_code",
    "baseName": "status_code",
    "type": "string",
    "format": ""
  },
  {
    "name": "status_message",
    "baseName": "status_message",
    "type": "string",
    "format": ""
  }
];
var DeployResponse = _DeployResponse;

// models/EntityHeader.ts
var _EntityHeader = class _EntityHeader {
  static getAttributeTypeMap() {
    return _EntityHeader.attributeTypeMap;
  }
  constructor() {
  }
};
_EntityHeader.discriminator = void 0;
_EntityHeader.attributeTypeMap = [
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_source_name",
    "baseName": "data_source_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_source_identifier",
    "baseName": "data_source_identifier",
    "type": "string",
    "format": ""
  }
];
var EntityHeader = _EntityHeader;

// models/ErrorResponse.ts
var _ErrorResponse = class _ErrorResponse {
  static getAttributeTypeMap() {
    return _ErrorResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_ErrorResponse.discriminator = void 0;
_ErrorResponse.attributeTypeMap = [
  {
    "name": "error",
    "baseName": "error",
    "type": "any",
    "format": ""
  }
];
var ErrorResponse = _ErrorResponse;

// models/EurekaDataSourceSuggestionResponse.ts
var _EurekaDataSourceSuggestionResponse = class _EurekaDataSourceSuggestionResponse {
  static getAttributeTypeMap() {
    return _EurekaDataSourceSuggestionResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_EurekaDataSourceSuggestionResponse.discriminator = void 0;
_EurekaDataSourceSuggestionResponse.attributeTypeMap = [
  {
    "name": "data_sources",
    "baseName": "data_sources",
    "type": "Array<DataSource>",
    "format": ""
  }
];
var EurekaDataSourceSuggestionResponse = _EurekaDataSourceSuggestionResponse;

// models/EurekaDecomposeQueryResponse.ts
var _EurekaDecomposeQueryResponse = class _EurekaDecomposeQueryResponse {
  static getAttributeTypeMap() {
    return _EurekaDecomposeQueryResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_EurekaDecomposeQueryResponse.discriminator = void 0;
_EurekaDecomposeQueryResponse.attributeTypeMap = [
  {
    "name": "decomposedQueryResponse",
    "baseName": "decomposedQueryResponse",
    "type": "EurekaLLMDecomposeQueryResponse",
    "format": ""
  }
];
var EurekaDecomposeQueryResponse = _EurekaDecomposeQueryResponse;

// models/EurekaGetNLInstructionsResponse.ts
var _EurekaGetNLInstructionsResponse = class _EurekaGetNLInstructionsResponse {
  static getAttributeTypeMap() {
    return _EurekaGetNLInstructionsResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_EurekaGetNLInstructionsResponse.discriminator = void 0;
_EurekaGetNLInstructionsResponse.attributeTypeMap = [
  {
    "name": "nl_instructions_info",
    "baseName": "nl_instructions_info",
    "type": "Array<NLInstructionsInfo>",
    "format": ""
  }
];
var EurekaGetNLInstructionsResponse = _EurekaGetNLInstructionsResponse;

// models/EurekaGetRelevantQuestionsResponse.ts
var _EurekaGetRelevantQuestionsResponse = class _EurekaGetRelevantQuestionsResponse {
  static getAttributeTypeMap() {
    return _EurekaGetRelevantQuestionsResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_EurekaGetRelevantQuestionsResponse.discriminator = void 0;
_EurekaGetRelevantQuestionsResponse.attributeTypeMap = [
  {
    "name": "relevant_questions",
    "baseName": "relevant_questions",
    "type": "Array<EurekaRelevantQuestion>",
    "format": ""
  }
];
var EurekaGetRelevantQuestionsResponse = _EurekaGetRelevantQuestionsResponse;

// models/EurekaLLMDecomposeQueryResponse.ts
var _EurekaLLMDecomposeQueryResponse = class _EurekaLLMDecomposeQueryResponse {
  static getAttributeTypeMap() {
    return _EurekaLLMDecomposeQueryResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_EurekaLLMDecomposeQueryResponse.discriminator = void 0;
_EurekaLLMDecomposeQueryResponse.attributeTypeMap = [
  {
    "name": "decomposedQueries",
    "baseName": "decomposedQueries",
    "type": "Array<EurekaLLMSuggestedQuery>",
    "format": ""
  }
];
var EurekaLLMDecomposeQueryResponse = _EurekaLLMDecomposeQueryResponse;

// models/EurekaLLMSuggestedQuery.ts
var _EurekaLLMSuggestedQuery = class _EurekaLLMSuggestedQuery {
  static getAttributeTypeMap() {
    return _EurekaLLMSuggestedQuery.attributeTypeMap;
  }
  constructor() {
  }
};
_EurekaLLMSuggestedQuery.discriminator = void 0;
_EurekaLLMSuggestedQuery.attributeTypeMap = [
  {
    "name": "query",
    "baseName": "query",
    "type": "string",
    "format": ""
  },
  {
    "name": "worksheetId",
    "baseName": "worksheetId",
    "type": "string",
    "format": ""
  },
  {
    "name": "worksheetName",
    "baseName": "worksheetName",
    "type": "string",
    "format": ""
  }
];
var EurekaLLMSuggestedQuery = _EurekaLLMSuggestedQuery;

// models/EurekaRelevantQuestion.ts
var _EurekaRelevantQuestion = class _EurekaRelevantQuestion {
  static getAttributeTypeMap() {
    return _EurekaRelevantQuestion.attributeTypeMap;
  }
  constructor() {
  }
};
_EurekaRelevantQuestion.discriminator = void 0;
_EurekaRelevantQuestion.attributeTypeMap = [
  {
    "name": "query",
    "baseName": "query",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_source_identifier",
    "baseName": "data_source_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_source_name",
    "baseName": "data_source_name",
    "type": "string",
    "format": ""
  }
];
var EurekaRelevantQuestion = _EurekaRelevantQuestion;

// models/EurekaSetNLInstructionsResponse.ts
var _EurekaSetNLInstructionsResponse = class _EurekaSetNLInstructionsResponse {
  static getAttributeTypeMap() {
    return _EurekaSetNLInstructionsResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_EurekaSetNLInstructionsResponse.discriminator = void 0;
_EurekaSetNLInstructionsResponse.attributeTypeMap = [
  {
    "name": "success",
    "baseName": "success",
    "type": "boolean",
    "format": ""
  }
];
var EurekaSetNLInstructionsResponse = _EurekaSetNLInstructionsResponse;

// models/EventChannelConfig.ts
var _EventChannelConfig = class _EventChannelConfig {
  static getAttributeTypeMap() {
    return _EventChannelConfig.attributeTypeMap;
  }
  constructor() {
  }
};
_EventChannelConfig.discriminator = void 0;
_EventChannelConfig.attributeTypeMap = [
  {
    "name": "event_type",
    "baseName": "event_type",
    "type": "EventChannelConfigEventTypeEnum",
    "format": ""
  },
  {
    "name": "channels",
    "baseName": "channels",
    "type": "Array<EventChannelConfigChannelsEnum>",
    "format": ""
  }
];
var EventChannelConfig = _EventChannelConfig;

// models/EventChannelConfigInput.ts
var _EventChannelConfigInput = class _EventChannelConfigInput {
  static getAttributeTypeMap() {
    return _EventChannelConfigInput.attributeTypeMap;
  }
  constructor() {
  }
};
_EventChannelConfigInput.discriminator = void 0;
_EventChannelConfigInput.attributeTypeMap = [
  {
    "name": "event_type",
    "baseName": "event_type",
    "type": "EventChannelConfigInputEventTypeEnum",
    "format": ""
  },
  {
    "name": "channels",
    "baseName": "channels",
    "type": "Array<EventChannelConfigInputChannelsEnum>",
    "format": ""
  }
];
var EventChannelConfigInput = _EventChannelConfigInput;

// models/ExcludeMetadataListItemInput.ts
var _ExcludeMetadataListItemInput = class _ExcludeMetadataListItemInput {
  static getAttributeTypeMap() {
    return _ExcludeMetadataListItemInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ExcludeMetadataListItemInput.discriminator = void 0;
_ExcludeMetadataListItemInput.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "ExcludeMetadataListItemInputTypeEnum",
    "format": ""
  }
];
var ExcludeMetadataListItemInput = _ExcludeMetadataListItemInput;

// models/ExportAnswerReportRequest.ts
var _ExportAnswerReportRequest = class _ExportAnswerReportRequest {
  static getAttributeTypeMap() {
    return _ExportAnswerReportRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ExportAnswerReportRequest.discriminator = void 0;
_ExportAnswerReportRequest.attributeTypeMap = [
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "session_identifier",
    "baseName": "session_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "generation_number",
    "baseName": "generation_number",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "file_format",
    "baseName": "file_format",
    "type": "ExportAnswerReportRequestFileFormatEnum",
    "format": ""
  },
  {
    "name": "runtime_filter",
    "baseName": "runtime_filter",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_sort",
    "baseName": "runtime_sort",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_param_override",
    "baseName": "runtime_param_override",
    "type": "any",
    "format": ""
  },
  {
    "name": "regional_settings",
    "baseName": "regional_settings",
    "type": "ExportAnswerReportRequestRegionalSettings",
    "format": ""
  }
];
var ExportAnswerReportRequest = _ExportAnswerReportRequest;

// models/ExportAnswerReportRequestRegionalSettings.ts
var _ExportAnswerReportRequestRegionalSettings = class _ExportAnswerReportRequestRegionalSettings {
  static getAttributeTypeMap() {
    return _ExportAnswerReportRequestRegionalSettings.attributeTypeMap;
  }
  constructor() {
  }
};
_ExportAnswerReportRequestRegionalSettings.discriminator = void 0;
_ExportAnswerReportRequestRegionalSettings.attributeTypeMap = [
  {
    "name": "currency_format",
    "baseName": "currency_format",
    "type": "ExportAnswerReportRequestRegionalSettingsCurrencyFormatEnum",
    "format": ""
  },
  {
    "name": "user_locale",
    "baseName": "user_locale",
    "type": "ExportAnswerReportRequestRegionalSettingsUserLocaleEnum",
    "format": ""
  },
  {
    "name": "number_format_locale",
    "baseName": "number_format_locale",
    "type": "ExportAnswerReportRequestRegionalSettingsNumberFormatLocaleEnum",
    "format": ""
  },
  {
    "name": "date_format_locale",
    "baseName": "date_format_locale",
    "type": "ExportAnswerReportRequestRegionalSettingsDateFormatLocaleEnum",
    "format": ""
  }
];
var ExportAnswerReportRequestRegionalSettings = _ExportAnswerReportRequestRegionalSettings;

// models/ExportLiveboardReportRequest.ts
var _ExportLiveboardReportRequest = class _ExportLiveboardReportRequest {
  static getAttributeTypeMap() {
    return _ExportLiveboardReportRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ExportLiveboardReportRequest.discriminator = void 0;
_ExportLiveboardReportRequest.attributeTypeMap = [
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "tab_identifiers",
    "baseName": "tab_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "personalised_view_identifier",
    "baseName": "personalised_view_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "visualization_identifiers",
    "baseName": "visualization_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "transient_content",
    "baseName": "transient_content",
    "type": "string",
    "format": ""
  },
  {
    "name": "file_format",
    "baseName": "file_format",
    "type": "ExportLiveboardReportRequestFileFormatEnum",
    "format": ""
  },
  {
    "name": "runtime_filter",
    "baseName": "runtime_filter",
    "type": "any",
    "format": ""
  },
  {
    "name": "override_filters",
    "baseName": "override_filters",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_sort",
    "baseName": "runtime_sort",
    "type": "any",
    "format": ""
  },
  {
    "name": "pdf_options",
    "baseName": "pdf_options",
    "type": "ExportLiveboardReportRequestPdfOptions",
    "format": ""
  },
  {
    "name": "png_options",
    "baseName": "png_options",
    "type": "ExportLiveboardReportRequestPngOptions",
    "format": ""
  },
  {
    "name": "runtime_param_override",
    "baseName": "runtime_param_override",
    "type": "any",
    "format": ""
  },
  {
    "name": "regional_settings",
    "baseName": "regional_settings",
    "type": "ExportAnswerReportRequestRegionalSettings",
    "format": ""
  }
];
var ExportLiveboardReportRequest = _ExportLiveboardReportRequest;

// models/ExportLiveboardReportRequestPdfOptions.ts
var _ExportLiveboardReportRequestPdfOptions = class _ExportLiveboardReportRequestPdfOptions {
  static getAttributeTypeMap() {
    return _ExportLiveboardReportRequestPdfOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_ExportLiveboardReportRequestPdfOptions.discriminator = void 0;
_ExportLiveboardReportRequestPdfOptions.attributeTypeMap = [
  {
    "name": "include_cover_page",
    "baseName": "include_cover_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_custom_logo",
    "baseName": "include_custom_logo",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_filter_page",
    "baseName": "include_filter_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_page_number",
    "baseName": "include_page_number",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "page_orientation",
    "baseName": "page_orientation",
    "type": "ExportLiveboardReportRequestPdfOptionsPageOrientationEnum",
    "format": ""
  },
  {
    "name": "truncate_table",
    "baseName": "truncate_table",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "page_footer_text",
    "baseName": "page_footer_text",
    "type": "string",
    "format": ""
  }
];
var ExportLiveboardReportRequestPdfOptions = _ExportLiveboardReportRequestPdfOptions;

// models/ExportLiveboardReportRequestPngOptions.ts
var _ExportLiveboardReportRequestPngOptions = class _ExportLiveboardReportRequestPngOptions {
  static getAttributeTypeMap() {
    return _ExportLiveboardReportRequestPngOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_ExportLiveboardReportRequestPngOptions.discriminator = void 0;
_ExportLiveboardReportRequestPngOptions.attributeTypeMap = [
  {
    "name": "include_cover_page",
    "baseName": "include_cover_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_filter_page",
    "baseName": "include_filter_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "personalised_view_id",
    "baseName": "personalised_view_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "image_resolution",
    "baseName": "image_resolution",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "image_scale",
    "baseName": "image_scale",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "include_header",
    "baseName": "include_header",
    "type": "boolean",
    "format": ""
  }
];
var ExportLiveboardReportRequestPngOptions = _ExportLiveboardReportRequestPngOptions;

// models/ExportMetadataTMLBatchedRequest.ts
var _ExportMetadataTMLBatchedRequest = class _ExportMetadataTMLBatchedRequest {
  static getAttributeTypeMap() {
    return _ExportMetadataTMLBatchedRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ExportMetadataTMLBatchedRequest.discriminator = void 0;
_ExportMetadataTMLBatchedRequest.attributeTypeMap = [
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "ExportMetadataTMLBatchedRequestMetadataTypeEnum",
    "format": ""
  },
  {
    "name": "batch_offset",
    "baseName": "batch_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "batch_size",
    "baseName": "batch_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "edoc_format",
    "baseName": "edoc_format",
    "type": "ExportMetadataTMLBatchedRequestEdocFormatEnum",
    "format": ""
  },
  {
    "name": "export_dependent",
    "baseName": "export_dependent",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "all_orgs_override",
    "baseName": "all_orgs_override",
    "type": "boolean",
    "format": ""
  }
];
var ExportMetadataTMLBatchedRequest = _ExportMetadataTMLBatchedRequest;

// models/ExportMetadataTMLRequest.ts
var _ExportMetadataTMLRequest = class _ExportMetadataTMLRequest {
  static getAttributeTypeMap() {
    return _ExportMetadataTMLRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ExportMetadataTMLRequest.discriminator = void 0;
_ExportMetadataTMLRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<ExportMetadataTypeInput>",
    "format": ""
  },
  {
    "name": "export_associated",
    "baseName": "export_associated",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "export_fqn",
    "baseName": "export_fqn",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "edoc_format",
    "baseName": "edoc_format",
    "type": "ExportMetadataTMLRequestEdocFormatEnum",
    "format": ""
  },
  {
    "name": "export_schema_version",
    "baseName": "export_schema_version",
    "type": "ExportMetadataTMLRequestExportSchemaVersionEnum",
    "format": ""
  },
  {
    "name": "export_dependent",
    "baseName": "export_dependent",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "export_connection_as_dependent",
    "baseName": "export_connection_as_dependent",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "all_orgs_override",
    "baseName": "all_orgs_override",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "export_options",
    "baseName": "export_options",
    "type": "ExportMetadataTMLRequestExportOptions",
    "format": ""
  }
];
var ExportMetadataTMLRequest = _ExportMetadataTMLRequest;

// models/ExportMetadataTMLRequestExportOptions.ts
var _ExportMetadataTMLRequestExportOptions = class _ExportMetadataTMLRequestExportOptions {
  static getAttributeTypeMap() {
    return _ExportMetadataTMLRequestExportOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_ExportMetadataTMLRequestExportOptions.discriminator = void 0;
_ExportMetadataTMLRequestExportOptions.attributeTypeMap = [
  {
    "name": "include_obj_id_ref",
    "baseName": "include_obj_id_ref",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_guid",
    "baseName": "include_guid",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_obj_id",
    "baseName": "include_obj_id",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "export_with_associated_feedbacks",
    "baseName": "export_with_associated_feedbacks",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "export_column_security_rules",
    "baseName": "export_column_security_rules",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "export_with_column_aliases",
    "baseName": "export_with_column_aliases",
    "type": "boolean",
    "format": ""
  }
];
var ExportMetadataTMLRequestExportOptions = _ExportMetadataTMLRequestExportOptions;

// models/ExportMetadataTypeInput.ts
var _ExportMetadataTypeInput = class _ExportMetadataTypeInput {
  static getAttributeTypeMap() {
    return _ExportMetadataTypeInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ExportMetadataTypeInput.discriminator = void 0;
_ExportMetadataTypeInput.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "ExportMetadataTypeInputTypeEnum",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "session_identifier",
    "baseName": "session_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "generation_number",
    "baseName": "generation_number",
    "type": "number",
    "format": "int32"
  }
];
var ExportMetadataTypeInput = _ExportMetadataTypeInput;

// models/ExportOptions.ts
var _ExportOptions = class _ExportOptions {
  static getAttributeTypeMap() {
    return _ExportOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_ExportOptions.discriminator = void 0;
_ExportOptions.attributeTypeMap = [
  {
    "name": "include_obj_id_ref",
    "baseName": "include_obj_id_ref",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_guid",
    "baseName": "include_guid",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_obj_id",
    "baseName": "include_obj_id",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "export_with_associated_feedbacks",
    "baseName": "export_with_associated_feedbacks",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "export_column_security_rules",
    "baseName": "export_column_security_rules",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "export_with_column_aliases",
    "baseName": "export_with_column_aliases",
    "type": "boolean",
    "format": ""
  }
];
var ExportOptions = _ExportOptions;

// models/ExternalTableInput.ts
var _ExternalTableInput = class _ExternalTableInput {
  static getAttributeTypeMap() {
    return _ExternalTableInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ExternalTableInput.discriminator = void 0;
_ExternalTableInput.attributeTypeMap = [
  {
    "name": "connection_identifier",
    "baseName": "connection_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "database_name",
    "baseName": "database_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "schema_name",
    "baseName": "schema_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "table_name",
    "baseName": "table_name",
    "type": "string",
    "format": ""
  }
];
var ExternalTableInput = _ExternalTableInput;

// models/FavoriteMetadataInput.ts
var _FavoriteMetadataInput = class _FavoriteMetadataInput {
  static getAttributeTypeMap() {
    return _FavoriteMetadataInput.attributeTypeMap;
  }
  constructor() {
  }
};
_FavoriteMetadataInput.discriminator = void 0;
_FavoriteMetadataInput.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "FavoriteMetadataInputTypeEnum",
    "format": ""
  }
];
var FavoriteMetadataInput = _FavoriteMetadataInput;

// models/FavoriteMetadataItem.ts
var _FavoriteMetadataItem = class _FavoriteMetadataItem {
  static getAttributeTypeMap() {
    return _FavoriteMetadataItem.attributeTypeMap;
  }
  constructor() {
  }
};
_FavoriteMetadataItem.discriminator = void 0;
_FavoriteMetadataItem.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "FavoriteMetadataItemTypeEnum",
    "format": ""
  }
];
var FavoriteMetadataItem = _FavoriteMetadataItem;

// models/FavoriteObjectOptionsInput.ts
var _FavoriteObjectOptionsInput = class _FavoriteObjectOptionsInput {
  static getAttributeTypeMap() {
    return _FavoriteObjectOptionsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_FavoriteObjectOptionsInput.discriminator = void 0;
_FavoriteObjectOptionsInput.attributeTypeMap = [
  {
    "name": "include",
    "baseName": "include",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "user_identifiers",
    "baseName": "user_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var FavoriteObjectOptionsInput = _FavoriteObjectOptionsInput;

// models/FetchAnswerDataRequest.ts
var _FetchAnswerDataRequest = class _FetchAnswerDataRequest {
  static getAttributeTypeMap() {
    return _FetchAnswerDataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_FetchAnswerDataRequest.discriminator = void 0;
_FetchAnswerDataRequest.attributeTypeMap = [
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_format",
    "baseName": "data_format",
    "type": "FetchAnswerDataRequestDataFormatEnum",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "runtime_filter",
    "baseName": "runtime_filter",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_sort",
    "baseName": "runtime_sort",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_param_override",
    "baseName": "runtime_param_override",
    "type": "any",
    "format": ""
  }
];
var FetchAnswerDataRequest = _FetchAnswerDataRequest;

// models/FetchAnswerSqlQueryRequest.ts
var _FetchAnswerSqlQueryRequest = class _FetchAnswerSqlQueryRequest {
  static getAttributeTypeMap() {
    return _FetchAnswerSqlQueryRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_FetchAnswerSqlQueryRequest.discriminator = void 0;
_FetchAnswerSqlQueryRequest.attributeTypeMap = [
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  }
];
var FetchAnswerSqlQueryRequest = _FetchAnswerSqlQueryRequest;

// models/FetchAsyncImportTaskStatusRequest.ts
var _FetchAsyncImportTaskStatusRequest = class _FetchAsyncImportTaskStatusRequest {
  static getAttributeTypeMap() {
    return _FetchAsyncImportTaskStatusRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_FetchAsyncImportTaskStatusRequest.discriminator = void 0;
_FetchAsyncImportTaskStatusRequest.attributeTypeMap = [
  {
    "name": "task_ids",
    "baseName": "task_ids",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "task_status",
    "baseName": "task_status",
    "type": "Array<FetchAsyncImportTaskStatusRequestTaskStatusEnum>",
    "format": ""
  },
  {
    "name": "author_identifier",
    "baseName": "author_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "include_import_response",
    "baseName": "include_import_response",
    "type": "boolean",
    "format": ""
  }
];
var FetchAsyncImportTaskStatusRequest = _FetchAsyncImportTaskStatusRequest;

// models/FetchColumnSecurityRulesRequest.ts
var _FetchColumnSecurityRulesRequest = class _FetchColumnSecurityRulesRequest {
  static getAttributeTypeMap() {
    return _FetchColumnSecurityRulesRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_FetchColumnSecurityRulesRequest.discriminator = void 0;
_FetchColumnSecurityRulesRequest.attributeTypeMap = [
  {
    "name": "tables",
    "baseName": "tables",
    "type": "Array<ColumnSecurityRuleTableInput>",
    "format": ""
  }
];
var FetchColumnSecurityRulesRequest = _FetchColumnSecurityRulesRequest;

// models/FetchConnectionDiffStatusResponse.ts
var _FetchConnectionDiffStatusResponse = class _FetchConnectionDiffStatusResponse {
  static getAttributeTypeMap() {
    return _FetchConnectionDiffStatusResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_FetchConnectionDiffStatusResponse.discriminator = void 0;
_FetchConnectionDiffStatusResponse.attributeTypeMap = [
  {
    "name": "status",
    "baseName": "status",
    "type": "boolean",
    "format": ""
  }
];
var FetchConnectionDiffStatusResponse = _FetchConnectionDiffStatusResponse;

// models/FetchLiveboardDataRequest.ts
var _FetchLiveboardDataRequest = class _FetchLiveboardDataRequest {
  static getAttributeTypeMap() {
    return _FetchLiveboardDataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_FetchLiveboardDataRequest.discriminator = void 0;
_FetchLiveboardDataRequest.attributeTypeMap = [
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "visualization_identifiers",
    "baseName": "visualization_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "transient_content",
    "baseName": "transient_content",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_format",
    "baseName": "data_format",
    "type": "FetchLiveboardDataRequestDataFormatEnum",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "runtime_filter",
    "baseName": "runtime_filter",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_sort",
    "baseName": "runtime_sort",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_param_override",
    "baseName": "runtime_param_override",
    "type": "any",
    "format": ""
  }
];
var FetchLiveboardDataRequest = _FetchLiveboardDataRequest;

// models/FetchLiveboardSqlQueryRequest.ts
var _FetchLiveboardSqlQueryRequest = class _FetchLiveboardSqlQueryRequest {
  static getAttributeTypeMap() {
    return _FetchLiveboardSqlQueryRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_FetchLiveboardSqlQueryRequest.discriminator = void 0;
_FetchLiveboardSqlQueryRequest.attributeTypeMap = [
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "visualization_identifiers",
    "baseName": "visualization_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var FetchLiveboardSqlQueryRequest = _FetchLiveboardSqlQueryRequest;

// models/FetchLogsRequest.ts
var _FetchLogsRequest = class _FetchLogsRequest {
  static getAttributeTypeMap() {
    return _FetchLogsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_FetchLogsRequest.discriminator = void 0;
_FetchLogsRequest.attributeTypeMap = [
  {
    "name": "log_type",
    "baseName": "log_type",
    "type": "FetchLogsRequestLogTypeEnum",
    "format": ""
  },
  {
    "name": "start_epoch_time_in_millis",
    "baseName": "start_epoch_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "end_epoch_time_in_millis",
    "baseName": "end_epoch_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "get_all_logs",
    "baseName": "get_all_logs",
    "type": "boolean",
    "format": ""
  }
];
var FetchLogsRequest = _FetchLogsRequest;

// models/FetchPermissionsOfPrincipalsRequest.ts
var _FetchPermissionsOfPrincipalsRequest = class _FetchPermissionsOfPrincipalsRequest {
  static getAttributeTypeMap() {
    return _FetchPermissionsOfPrincipalsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_FetchPermissionsOfPrincipalsRequest.discriminator = void 0;
_FetchPermissionsOfPrincipalsRequest.attributeTypeMap = [
  {
    "name": "principals",
    "baseName": "principals",
    "type": "Array<PrincipalsInput>",
    "format": ""
  },
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<PermissionsMetadataTypeInput>",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "default_metadata_type",
    "baseName": "default_metadata_type",
    "type": "FetchPermissionsOfPrincipalsRequestDefaultMetadataTypeEnum",
    "format": ""
  }
];
var FetchPermissionsOfPrincipalsRequest = _FetchPermissionsOfPrincipalsRequest;

// models/FetchPermissionsOnMetadataRequest.ts
var _FetchPermissionsOnMetadataRequest = class _FetchPermissionsOnMetadataRequest {
  static getAttributeTypeMap() {
    return _FetchPermissionsOnMetadataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_FetchPermissionsOnMetadataRequest.discriminator = void 0;
_FetchPermissionsOnMetadataRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<PermissionsMetadataTypeInput>",
    "format": ""
  },
  {
    "name": "principals",
    "baseName": "principals",
    "type": "Array<PrincipalsInput>",
    "format": ""
  },
  {
    "name": "include_dependent_objects",
    "baseName": "include_dependent_objects",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "permission_type",
    "baseName": "permission_type",
    "type": "string",
    "format": ""
  }
];
var FetchPermissionsOnMetadataRequest = _FetchPermissionsOnMetadataRequest;

// models/FilterRules.ts
var _FilterRules = class _FilterRules {
  static getAttributeTypeMap() {
    return _FilterRules.attributeTypeMap;
  }
  constructor() {
  }
};
_FilterRules.discriminator = void 0;
_FilterRules.attributeTypeMap = [
  {
    "name": "column_name",
    "baseName": "column_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "operator",
    "baseName": "operator",
    "type": "FilterRulesOperatorEnum",
    "format": ""
  },
  {
    "name": "values",
    "baseName": "values",
    "type": "Array<any>",
    "format": ""
  }
];
var FilterRules = _FilterRules;

// models/ForceLogoutUsersRequest.ts
var _ForceLogoutUsersRequest = class _ForceLogoutUsersRequest {
  static getAttributeTypeMap() {
    return _ForceLogoutUsersRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ForceLogoutUsersRequest.discriminator = void 0;
_ForceLogoutUsersRequest.attributeTypeMap = [
  {
    "name": "user_identifiers",
    "baseName": "user_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var ForceLogoutUsersRequest = _ForceLogoutUsersRequest;

// models/Frequency.ts
var _Frequency = class _Frequency {
  static getAttributeTypeMap() {
    return _Frequency.attributeTypeMap;
  }
  constructor() {
  }
};
_Frequency.discriminator = void 0;
_Frequency.attributeTypeMap = [
  {
    "name": "cron_expression",
    "baseName": "cron_expression",
    "type": "CronExpression",
    "format": ""
  }
];
var Frequency = _Frequency;

// models/FrequencyInput.ts
var _FrequencyInput = class _FrequencyInput {
  static getAttributeTypeMap() {
    return _FrequencyInput.attributeTypeMap;
  }
  constructor() {
  }
};
_FrequencyInput.discriminator = void 0;
_FrequencyInput.attributeTypeMap = [
  {
    "name": "cron_expression",
    "baseName": "cron_expression",
    "type": "CronExpressionInput",
    "format": ""
  }
];
var FrequencyInput = _FrequencyInput;

// models/GenerateCSVRequest.ts
var _GenerateCSVRequest = class _GenerateCSVRequest {
  static getAttributeTypeMap() {
    return _GenerateCSVRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_GenerateCSVRequest.discriminator = void 0;
_GenerateCSVRequest.attributeTypeMap = [
  {
    "name": "start_date",
    "baseName": "start_date",
    "type": "string",
    "format": ""
  },
  {
    "name": "end_date",
    "baseName": "end_date",
    "type": "string",
    "format": ""
  },
  {
    "name": "calendar_type",
    "baseName": "calendar_type",
    "type": "GenerateCSVRequestCalendarTypeEnum",
    "format": ""
  },
  {
    "name": "month_offset",
    "baseName": "month_offset",
    "type": "GenerateCSVRequestMonthOffsetEnum",
    "format": ""
  },
  {
    "name": "start_day_of_week",
    "baseName": "start_day_of_week",
    "type": "GenerateCSVRequestStartDayOfWeekEnum",
    "format": ""
  },
  {
    "name": "quarter_name_prefix",
    "baseName": "quarter_name_prefix",
    "type": "string",
    "format": ""
  },
  {
    "name": "year_name_prefix",
    "baseName": "year_name_prefix",
    "type": "string",
    "format": ""
  }
];
var GenerateCSVRequest = _GenerateCSVRequest;

// models/GenericInfo.ts
var _GenericInfo = class _GenericInfo {
  static getAttributeTypeMap() {
    return _GenericInfo.attributeTypeMap;
  }
  constructor() {
  }
};
_GenericInfo.discriminator = void 0;
_GenericInfo.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var GenericInfo = _GenericInfo;

// models/GetAsyncImportStatusResponse.ts
var _GetAsyncImportStatusResponse = class _GetAsyncImportStatusResponse {
  static getAttributeTypeMap() {
    return _GetAsyncImportStatusResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_GetAsyncImportStatusResponse.discriminator = void 0;
_GetAsyncImportStatusResponse.attributeTypeMap = [
  {
    "name": "status_list",
    "baseName": "status_list",
    "type": "Array<ImportEPackAsyncTaskStatus>",
    "format": ""
  },
  {
    "name": "last_batch",
    "baseName": "last_batch",
    "type": "boolean",
    "format": ""
  }
];
var GetAsyncImportStatusResponse = _GetAsyncImportStatusResponse;

// models/GetCustomAccessTokenRequest.ts
var _GetCustomAccessTokenRequest = class _GetCustomAccessTokenRequest {
  static getAttributeTypeMap() {
    return _GetCustomAccessTokenRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_GetCustomAccessTokenRequest.discriminator = void 0;
_GetCustomAccessTokenRequest.attributeTypeMap = [
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  },
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  },
  {
    "name": "secret_key",
    "baseName": "secret_key",
    "type": "string",
    "format": ""
  },
  {
    "name": "validity_time_in_sec",
    "baseName": "validity_time_in_sec",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "persist_option",
    "baseName": "persist_option",
    "type": "GetCustomAccessTokenRequestPersistOptionEnum",
    "format": ""
  },
  {
    "name": "filter_rules",
    "baseName": "filter_rules",
    "type": "Array<FilterRules>",
    "format": ""
  },
  {
    "name": "parameter_values",
    "baseName": "parameter_values",
    "type": "Array<ParameterValues>",
    "format": ""
  },
  {
    "name": "variable_values",
    "baseName": "variable_values",
    "type": "Array<VariableValues>",
    "format": ""
  },
  {
    "name": "objects",
    "baseName": "objects",
    "type": "Array<TokenAccessScopeObject>",
    "format": ""
  },
  {
    "name": "email",
    "baseName": "email",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "groups",
    "baseName": "groups",
    "type": "Array<GroupObject>",
    "format": ""
  },
  {
    "name": "auto_create",
    "baseName": "auto_create",
    "type": "boolean",
    "format": ""
  }
];
var GetCustomAccessTokenRequest = _GetCustomAccessTokenRequest;

// models/GetFullAccessTokenRequest.ts
var _GetFullAccessTokenRequest = class _GetFullAccessTokenRequest {
  static getAttributeTypeMap() {
    return _GetFullAccessTokenRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_GetFullAccessTokenRequest.discriminator = void 0;
_GetFullAccessTokenRequest.attributeTypeMap = [
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  },
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  },
  {
    "name": "secret_key",
    "baseName": "secret_key",
    "type": "string",
    "format": ""
  },
  {
    "name": "validity_time_in_sec",
    "baseName": "validity_time_in_sec",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "org_id",
    "baseName": "org_id",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "email",
    "baseName": "email",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "auto_create",
    "baseName": "auto_create",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "user_parameters",
    "baseName": "user_parameters",
    "type": "GetFullAccessTokenRequestUserParameters",
    "format": ""
  }
];
var GetFullAccessTokenRequest = _GetFullAccessTokenRequest;

// models/GetFullAccessTokenRequestUserParameters.ts
var _GetFullAccessTokenRequestUserParameters = class _GetFullAccessTokenRequestUserParameters {
  static getAttributeTypeMap() {
    return _GetFullAccessTokenRequestUserParameters.attributeTypeMap;
  }
  constructor() {
  }
};
_GetFullAccessTokenRequestUserParameters.discriminator = void 0;
_GetFullAccessTokenRequestUserParameters.attributeTypeMap = [
  {
    "name": "objects",
    "baseName": "objects",
    "type": "Array<UserObject>",
    "format": ""
  },
  {
    "name": "runtime_filters",
    "baseName": "runtime_filters",
    "type": "Array<RuntimeFilters>",
    "format": ""
  },
  {
    "name": "runtime_sorts",
    "baseName": "runtime_sorts",
    "type": "Array<RuntimeSorts>",
    "format": ""
  },
  {
    "name": "parameters",
    "baseName": "parameters",
    "type": "Array<RuntimeParameters>",
    "format": ""
  }
];
var GetFullAccessTokenRequestUserParameters = _GetFullAccessTokenRequestUserParameters;

// models/GetObjectAccessTokenRequest.ts
var _GetObjectAccessTokenRequest = class _GetObjectAccessTokenRequest {
  static getAttributeTypeMap() {
    return _GetObjectAccessTokenRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_GetObjectAccessTokenRequest.discriminator = void 0;
_GetObjectAccessTokenRequest.attributeTypeMap = [
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  },
  {
    "name": "object_id",
    "baseName": "object_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  },
  {
    "name": "secret_key",
    "baseName": "secret_key",
    "type": "string",
    "format": ""
  },
  {
    "name": "validity_time_in_sec",
    "baseName": "validity_time_in_sec",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "org_id",
    "baseName": "org_id",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "email",
    "baseName": "email",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "auto_create",
    "baseName": "auto_create",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "user_parameters",
    "baseName": "user_parameters",
    "type": "GetFullAccessTokenRequestUserParameters",
    "format": ""
  }
];
var GetObjectAccessTokenRequest = _GetObjectAccessTokenRequest;

// models/GetRelevantQuestionsRequest.ts
var _GetRelevantQuestionsRequest = class _GetRelevantQuestionsRequest {
  static getAttributeTypeMap() {
    return _GetRelevantQuestionsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_GetRelevantQuestionsRequest.discriminator = void 0;
_GetRelevantQuestionsRequest.attributeTypeMap = [
  {
    "name": "metadata_context",
    "baseName": "metadata_context",
    "type": "GetRelevantQuestionsRequestMetadataContext",
    "format": ""
  },
  {
    "name": "limit_relevant_questions",
    "baseName": "limit_relevant_questions",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "bypass_cache",
    "baseName": "bypass_cache",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "query",
    "baseName": "query",
    "type": "string",
    "format": ""
  },
  {
    "name": "ai_context",
    "baseName": "ai_context",
    "type": "GetRelevantQuestionsRequestAiContext",
    "format": ""
  }
];
var GetRelevantQuestionsRequest = _GetRelevantQuestionsRequest;

// models/GetRelevantQuestionsRequestAiContext.ts
var _GetRelevantQuestionsRequestAiContext = class _GetRelevantQuestionsRequestAiContext {
  static getAttributeTypeMap() {
    return _GetRelevantQuestionsRequestAiContext.attributeTypeMap;
  }
  constructor() {
  }
};
_GetRelevantQuestionsRequestAiContext.discriminator = void 0;
_GetRelevantQuestionsRequestAiContext.attributeTypeMap = [
  {
    "name": "instructions",
    "baseName": "instructions",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "content",
    "baseName": "content",
    "type": "Array<string>",
    "format": ""
  }
];
var GetRelevantQuestionsRequestAiContext = _GetRelevantQuestionsRequestAiContext;

// models/GetRelevantQuestionsRequestMetadataContext.ts
var _GetRelevantQuestionsRequestMetadataContext = class _GetRelevantQuestionsRequestMetadataContext {
  static getAttributeTypeMap() {
    return _GetRelevantQuestionsRequestMetadataContext.attributeTypeMap;
  }
  constructor() {
  }
};
_GetRelevantQuestionsRequestMetadataContext.discriminator = void 0;
_GetRelevantQuestionsRequestMetadataContext.attributeTypeMap = [
  {
    "name": "data_source_identifiers",
    "baseName": "data_source_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "answer_identifiers",
    "baseName": "answer_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "conversation_identifier",
    "baseName": "conversation_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "liveboard_identifiers",
    "baseName": "liveboard_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var GetRelevantQuestionsRequestMetadataContext = _GetRelevantQuestionsRequestMetadataContext;

// models/GetTokenResponse.ts
var _GetTokenResponse = class _GetTokenResponse {
  static getAttributeTypeMap() {
    return _GetTokenResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_GetTokenResponse.discriminator = void 0;
_GetTokenResponse.attributeTypeMap = [
  {
    "name": "token",
    "baseName": "token",
    "type": "string",
    "format": ""
  },
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "expiration_time_in_millis",
    "baseName": "expiration_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "valid_for_user_id",
    "baseName": "valid_for_user_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "valid_for_username",
    "baseName": "valid_for_username",
    "type": "string",
    "format": ""
  }
];
var GetTokenResponse = _GetTokenResponse;

// models/GroupInfo.ts
var _GroupInfo = class _GroupInfo {
  static getAttributeTypeMap() {
    return _GroupInfo.attributeTypeMap;
  }
  constructor() {
  }
};
_GroupInfo.discriminator = void 0;
_GroupInfo.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var GroupInfo = _GroupInfo;

// models/GroupObject.ts
var _GroupObject = class _GroupObject {
  static getAttributeTypeMap() {
    return _GroupObject.attributeTypeMap;
  }
  constructor() {
  }
};
_GroupObject.discriminator = void 0;
_GroupObject.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  }
];
var GroupObject = _GroupObject;

// models/GroupsImportListInput.ts
var _GroupsImportListInput = class _GroupsImportListInput {
  static getAttributeTypeMap() {
    return _GroupsImportListInput.attributeTypeMap;
  }
  constructor() {
  }
};
_GroupsImportListInput.discriminator = void 0;
_GroupsImportListInput.attributeTypeMap = [
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "group_identifier",
    "baseName": "group_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "default_liveboard_identifiers",
    "baseName": "default_liveboard_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<GroupsImportListInputPrivilegesEnum>",
    "format": ""
  },
  {
    "name": "sub_group_identifiers",
    "baseName": "sub_group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "GroupsImportListInputTypeEnum",
    "format": ""
  },
  {
    "name": "user_identifiers",
    "baseName": "user_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "GroupsImportListInputVisibilityEnum",
    "format": ""
  }
];
var GroupsImportListInput = _GroupsImportListInput;

// models/HeaderAttributeInput.ts
var _HeaderAttributeInput = class _HeaderAttributeInput {
  static getAttributeTypeMap() {
    return _HeaderAttributeInput.attributeTypeMap;
  }
  constructor() {
  }
};
_HeaderAttributeInput.discriminator = void 0;
_HeaderAttributeInput.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "value",
    "baseName": "value",
    "type": "string",
    "format": ""
  }
];
var HeaderAttributeInput = _HeaderAttributeInput;

// models/HeaderUpdateInput.ts
var _HeaderUpdateInput = class _HeaderUpdateInput {
  static getAttributeTypeMap() {
    return _HeaderUpdateInput.attributeTypeMap;
  }
  constructor() {
  }
};
_HeaderUpdateInput.discriminator = void 0;
_HeaderUpdateInput.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "obj_identifier",
    "baseName": "obj_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "HeaderUpdateInputTypeEnum",
    "format": ""
  },
  {
    "name": "attributes",
    "baseName": "attributes",
    "type": "Array<HeaderAttributeInput>",
    "format": ""
  }
];
var HeaderUpdateInput = _HeaderUpdateInput;

// models/ImportEPackAsyncTaskStatus.ts
var _ImportEPackAsyncTaskStatus = class _ImportEPackAsyncTaskStatus {
  static getAttributeTypeMap() {
    return _ImportEPackAsyncTaskStatus.attributeTypeMap;
  }
  constructor() {
  }
};
_ImportEPackAsyncTaskStatus.discriminator = void 0;
_ImportEPackAsyncTaskStatus.attributeTypeMap = [
  {
    "name": "tenant_id",
    "baseName": "tenant_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "org_id",
    "baseName": "org_id",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "task_id",
    "baseName": "task_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "task_name",
    "baseName": "task_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "import_response",
    "baseName": "import_response",
    "type": "any",
    "format": ""
  },
  {
    "name": "task_status",
    "baseName": "task_status",
    "type": "ImportEPackAsyncTaskStatusTaskStatusEnum",
    "format": ""
  },
  {
    "name": "author_id",
    "baseName": "author_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "import_policy",
    "baseName": "import_policy",
    "type": "ImportEPackAsyncTaskStatusImportPolicyEnum",
    "format": ""
  },
  {
    "name": "created_at",
    "baseName": "created_at",
    "type": "number",
    "format": "float"
  },
  {
    "name": "in_progress_at",
    "baseName": "in_progress_at",
    "type": "number",
    "format": "float"
  },
  {
    "name": "completed_at",
    "baseName": "completed_at",
    "type": "number",
    "format": "float"
  },
  {
    "name": "total_object_count",
    "baseName": "total_object_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "object_processed_count",
    "baseName": "object_processed_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "modified_at",
    "baseName": "modified_at",
    "type": "number",
    "format": "float"
  },
  {
    "name": "author_display_name",
    "baseName": "author_display_name",
    "type": "string",
    "format": ""
  }
];
var ImportEPackAsyncTaskStatus = _ImportEPackAsyncTaskStatus;

// models/ImportMetadataTMLAsyncRequest.ts
var _ImportMetadataTMLAsyncRequest = class _ImportMetadataTMLAsyncRequest {
  static getAttributeTypeMap() {
    return _ImportMetadataTMLAsyncRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ImportMetadataTMLAsyncRequest.discriminator = void 0;
_ImportMetadataTMLAsyncRequest.attributeTypeMap = [
  {
    "name": "metadata_tmls",
    "baseName": "metadata_tmls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "create_new",
    "baseName": "create_new",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "all_orgs_override",
    "baseName": "all_orgs_override",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "import_policy",
    "baseName": "import_policy",
    "type": "ImportMetadataTMLAsyncRequestImportPolicyEnum",
    "format": ""
  },
  {
    "name": "skip_diff_check",
    "baseName": "skip_diff_check",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "enable_large_metadata_validation",
    "baseName": "enable_large_metadata_validation",
    "type": "boolean",
    "format": ""
  }
];
var ImportMetadataTMLAsyncRequest = _ImportMetadataTMLAsyncRequest;

// models/ImportMetadataTMLRequest.ts
var _ImportMetadataTMLRequest = class _ImportMetadataTMLRequest {
  static getAttributeTypeMap() {
    return _ImportMetadataTMLRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ImportMetadataTMLRequest.discriminator = void 0;
_ImportMetadataTMLRequest.attributeTypeMap = [
  {
    "name": "metadata_tmls",
    "baseName": "metadata_tmls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "import_policy",
    "baseName": "import_policy",
    "type": "ImportMetadataTMLRequestImportPolicyEnum",
    "format": ""
  },
  {
    "name": "create_new",
    "baseName": "create_new",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "all_orgs_override",
    "baseName": "all_orgs_override",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "skip_diff_check",
    "baseName": "skip_diff_check",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "enable_large_metadata_validation",
    "baseName": "enable_large_metadata_validation",
    "type": "boolean",
    "format": ""
  }
];
var ImportMetadataTMLRequest = _ImportMetadataTMLRequest;

// models/ImportUser.ts
var _ImportUser = class _ImportUser {
  static getAttributeTypeMap() {
    return _ImportUser.attributeTypeMap;
  }
  constructor() {
  }
};
_ImportUser.discriminator = void 0;
_ImportUser.attributeTypeMap = [
  {
    "name": "user_identifier",
    "baseName": "user_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  },
  {
    "name": "account_type",
    "baseName": "account_type",
    "type": "ImportUserAccountTypeEnum",
    "format": ""
  },
  {
    "name": "account_status",
    "baseName": "account_status",
    "type": "ImportUserAccountStatusEnum",
    "format": ""
  },
  {
    "name": "email",
    "baseName": "email",
    "type": "string",
    "format": ""
  },
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "ImportUserVisibilityEnum",
    "format": ""
  },
  {
    "name": "notify_on_share",
    "baseName": "notify_on_share",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "show_onboarding_experience",
    "baseName": "show_onboarding_experience",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "onboarding_experience_completed",
    "baseName": "onboarding_experience_completed",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "home_liveboard_identifier",
    "baseName": "home_liveboard_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "favorite_metadata",
    "baseName": "favorite_metadata",
    "type": "Array<FavoriteMetadataInput>",
    "format": ""
  }
];
var ImportUser = _ImportUser;

// models/ImportUserGroupsRequest.ts
var _ImportUserGroupsRequest = class _ImportUserGroupsRequest {
  static getAttributeTypeMap() {
    return _ImportUserGroupsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ImportUserGroupsRequest.discriminator = void 0;
_ImportUserGroupsRequest.attributeTypeMap = [
  {
    "name": "groups",
    "baseName": "groups",
    "type": "Array<GroupsImportListInput>",
    "format": ""
  },
  {
    "name": "delete_unspecified_groups",
    "baseName": "delete_unspecified_groups",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "dry_run",
    "baseName": "dry_run",
    "type": "boolean",
    "format": ""
  }
];
var ImportUserGroupsRequest = _ImportUserGroupsRequest;

// models/ImportUserGroupsResponse.ts
var _ImportUserGroupsResponse = class _ImportUserGroupsResponse {
  static getAttributeTypeMap() {
    return _ImportUserGroupsResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_ImportUserGroupsResponse.discriminator = void 0;
_ImportUserGroupsResponse.attributeTypeMap = [
  {
    "name": "groups_added",
    "baseName": "groups_added",
    "type": "Array<UserGroup>",
    "format": ""
  },
  {
    "name": "groups_deleted",
    "baseName": "groups_deleted",
    "type": "Array<UserGroup>",
    "format": ""
  },
  {
    "name": "groups_updated",
    "baseName": "groups_updated",
    "type": "Array<UserGroup>",
    "format": ""
  }
];
var ImportUserGroupsResponse = _ImportUserGroupsResponse;

// models/ImportUserType.ts
var _ImportUserType = class _ImportUserType {
  static getAttributeTypeMap() {
    return _ImportUserType.attributeTypeMap;
  }
  constructor() {
  }
};
_ImportUserType.discriminator = void 0;
_ImportUserType.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var ImportUserType = _ImportUserType;

// models/ImportUsersRequest.ts
var _ImportUsersRequest = class _ImportUsersRequest {
  static getAttributeTypeMap() {
    return _ImportUsersRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ImportUsersRequest.discriminator = void 0;
_ImportUsersRequest.attributeTypeMap = [
  {
    "name": "users",
    "baseName": "users",
    "type": "Array<ImportUser>",
    "format": ""
  },
  {
    "name": "default_password",
    "baseName": "default_password",
    "type": "string",
    "format": ""
  },
  {
    "name": "dry_run",
    "baseName": "dry_run",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "delete_unspecified_users",
    "baseName": "delete_unspecified_users",
    "type": "boolean",
    "format": ""
  }
];
var ImportUsersRequest = _ImportUsersRequest;

// models/ImportUsersResponse.ts
var _ImportUsersResponse = class _ImportUsersResponse {
  static getAttributeTypeMap() {
    return _ImportUsersResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_ImportUsersResponse.discriminator = void 0;
_ImportUsersResponse.attributeTypeMap = [
  {
    "name": "users_added",
    "baseName": "users_added",
    "type": "Array<ImportUserType>",
    "format": ""
  },
  {
    "name": "users_updated",
    "baseName": "users_updated",
    "type": "Array<ImportUserType>",
    "format": ""
  },
  {
    "name": "users_deleted",
    "baseName": "users_deleted",
    "type": "Array<ImportUserType>",
    "format": ""
  }
];
var ImportUsersResponse = _ImportUsersResponse;

// models/InputEurekaNLSRequest.ts
var _InputEurekaNLSRequest = class _InputEurekaNLSRequest {
  static getAttributeTypeMap() {
    return _InputEurekaNLSRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_InputEurekaNLSRequest.discriminator = void 0;
_InputEurekaNLSRequest.attributeTypeMap = [
  {
    "name": "agentVersion",
    "baseName": "agentVersion",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "bypassCache",
    "baseName": "bypassCache",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "instructions",
    "baseName": "instructions",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "query",
    "baseName": "query",
    "type": "string",
    "format": ""
  }
];
var InputEurekaNLSRequest = _InputEurekaNLSRequest;

// models/JWTMetadataObject.ts
var _JWTMetadataObject = class _JWTMetadataObject {
  static getAttributeTypeMap() {
    return _JWTMetadataObject.attributeTypeMap;
  }
  constructor() {
  }
};
_JWTMetadataObject.discriminator = void 0;
_JWTMetadataObject.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "JWTMetadataObjectTypeEnum",
    "format": ""
  }
];
var JWTMetadataObject = _JWTMetadataObject;

// models/JWTParameter.ts
var _JWTParameter = class _JWTParameter {
  static getAttributeTypeMap() {
    return _JWTParameter.attributeTypeMap;
  }
  constructor() {
  }
};
_JWTParameter.discriminator = void 0;
_JWTParameter.attributeTypeMap = [
  {
    "name": "runtime_filter",
    "baseName": "runtime_filter",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_sort",
    "baseName": "runtime_sort",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_param_override",
    "baseName": "runtime_param_override",
    "type": "any",
    "format": ""
  }
];
var JWTParameter = _JWTParameter;

// models/JWTUserOptions.ts
var _JWTUserOptions = class _JWTUserOptions {
  static getAttributeTypeMap() {
    return _JWTUserOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_JWTUserOptions.discriminator = void 0;
_JWTUserOptions.attributeTypeMap = [
  {
    "name": "parameters",
    "baseName": "parameters",
    "type": "Array<any>",
    "format": ""
  },
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<JWTMetadataObject>",
    "format": ""
  }
];
var JWTUserOptions = _JWTUserOptions;

// models/JWTUserOptionsFull.ts
var _JWTUserOptionsFull = class _JWTUserOptionsFull {
  static getAttributeTypeMap() {
    return _JWTUserOptionsFull.attributeTypeMap;
  }
  constructor() {
  }
};
_JWTUserOptionsFull.discriminator = void 0;
_JWTUserOptionsFull.attributeTypeMap = [
  {
    "name": "parameters",
    "baseName": "parameters",
    "type": "Array<JWTParameter>",
    "format": ""
  }
];
var JWTUserOptionsFull = _JWTUserOptionsFull;

// models/LBContextInput.ts
var _LBContextInput = class _LBContextInput {
  static getAttributeTypeMap() {
    return _LBContextInput.attributeTypeMap;
  }
  constructor() {
  }
};
_LBContextInput.discriminator = void 0;
_LBContextInput.attributeTypeMap = [
  {
    "name": "liveboard_identifier",
    "baseName": "liveboard_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "visualization_identifier",
    "baseName": "visualization_identifier",
    "type": "string",
    "format": ""
  }
];
var LBContextInput = _LBContextInput;

// models/LiveboardContent.ts
var _LiveboardContent = class _LiveboardContent {
  static getAttributeTypeMap() {
    return _LiveboardContent.attributeTypeMap;
  }
  constructor() {
  }
};
_LiveboardContent.discriminator = void 0;
_LiveboardContent.attributeTypeMap = [
  {
    "name": "available_data_row_count",
    "baseName": "available_data_row_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "column_names",
    "baseName": "column_names",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "data_rows",
    "baseName": "data_rows",
    "type": "Array<any>",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "returned_data_row_count",
    "baseName": "returned_data_row_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "sampling_ratio",
    "baseName": "sampling_ratio",
    "type": "number",
    "format": "float"
  },
  {
    "name": "visualization_id",
    "baseName": "visualization_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "visualization_name",
    "baseName": "visualization_name",
    "type": "string",
    "format": ""
  }
];
var LiveboardContent = _LiveboardContent;

// models/LiveboardDataResponse.ts
var _LiveboardDataResponse = class _LiveboardDataResponse {
  static getAttributeTypeMap() {
    return _LiveboardDataResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_LiveboardDataResponse.discriminator = void 0;
_LiveboardDataResponse.attributeTypeMap = [
  {
    "name": "metadata_id",
    "baseName": "metadata_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_name",
    "baseName": "metadata_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "contents",
    "baseName": "contents",
    "type": "Array<LiveboardContent>",
    "format": ""
  }
];
var LiveboardDataResponse = _LiveboardDataResponse;

// models/LiveboardOptions.ts
var _LiveboardOptions = class _LiveboardOptions {
  static getAttributeTypeMap() {
    return _LiveboardOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_LiveboardOptions.discriminator = void 0;
_LiveboardOptions.attributeTypeMap = [
  {
    "name": "visualization_identifiers",
    "baseName": "visualization_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var LiveboardOptions = _LiveboardOptions;

// models/LiveboardOptionsInput.ts
var _LiveboardOptionsInput = class _LiveboardOptionsInput {
  static getAttributeTypeMap() {
    return _LiveboardOptionsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_LiveboardOptionsInput.discriminator = void 0;
_LiveboardOptionsInput.attributeTypeMap = [
  {
    "name": "visualization_identifiers",
    "baseName": "visualization_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var LiveboardOptionsInput = _LiveboardOptionsInput;

// models/LogResponse.ts
var _LogResponse = class _LogResponse {
  static getAttributeTypeMap() {
    return _LogResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_LogResponse.discriminator = void 0;
_LogResponse.attributeTypeMap = [
  {
    "name": "date",
    "baseName": "date",
    "type": "string",
    "format": ""
  },
  {
    "name": "log",
    "baseName": "log",
    "type": "string",
    "format": ""
  }
];
var LogResponse = _LogResponse;

// models/LoginRequest.ts
var _LoginRequest = class _LoginRequest {
  static getAttributeTypeMap() {
    return _LoginRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_LoginRequest.discriminator = void 0;
_LoginRequest.attributeTypeMap = [
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  },
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  },
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "remember_me",
    "baseName": "remember_me",
    "type": "boolean",
    "format": ""
  }
];
var LoginRequest = _LoginRequest;

// models/MetadataAssociationItem.ts
var _MetadataAssociationItem = class _MetadataAssociationItem {
  static getAttributeTypeMap() {
    return _MetadataAssociationItem.attributeTypeMap;
  }
  constructor() {
  }
};
_MetadataAssociationItem.discriminator = void 0;
_MetadataAssociationItem.attributeTypeMap = [
  {
    "name": "action_config",
    "baseName": "action_config",
    "type": "ActionConfig",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "string",
    "format": ""
  }
];
var MetadataAssociationItem = _MetadataAssociationItem;

// models/MetadataContext.ts
var _MetadataContext = class _MetadataContext {
  static getAttributeTypeMap() {
    return _MetadataContext.attributeTypeMap;
  }
  constructor() {
  }
};
_MetadataContext.discriminator = void 0;
_MetadataContext.attributeTypeMap = [
  {
    "name": "data_source_identifiers",
    "baseName": "data_source_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "answer_identifiers",
    "baseName": "answer_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "conversation_identifier",
    "baseName": "conversation_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "liveboard_identifiers",
    "baseName": "liveboard_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var MetadataContext = _MetadataContext;

// models/MetadataInput.ts
var _MetadataInput = class _MetadataInput {
  static getAttributeTypeMap() {
    return _MetadataInput.attributeTypeMap;
  }
  constructor() {
  }
};
_MetadataInput.discriminator = void 0;
_MetadataInput.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "MetadataInputTypeEnum",
    "format": ""
  }
];
var MetadataInput = _MetadataInput;

// models/MetadataListItemInput.ts
var _MetadataListItemInput = class _MetadataListItemInput {
  static getAttributeTypeMap() {
    return _MetadataListItemInput.attributeTypeMap;
  }
  constructor() {
  }
};
_MetadataListItemInput.discriminator = void 0;
_MetadataListItemInput.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "obj_identifier",
    "baseName": "obj_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "name_pattern",
    "baseName": "name_pattern",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "MetadataListItemInputTypeEnum",
    "format": ""
  },
  {
    "name": "subtypes",
    "baseName": "subtypes",
    "type": "Array<MetadataListItemInputSubtypesEnum>",
    "format": ""
  }
];
var MetadataListItemInput = _MetadataListItemInput;

// models/MetadataObject.ts
var _MetadataObject = class _MetadataObject {
  static getAttributeTypeMap() {
    return _MetadataObject.attributeTypeMap;
  }
  constructor() {
  }
};
_MetadataObject.discriminator = void 0;
_MetadataObject.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "MetadataObjectTypeEnum",
    "format": ""
  }
];
var MetadataObject = _MetadataObject;

// models/MetadataResponse.ts
var _MetadataResponse = class _MetadataResponse {
  static getAttributeTypeMap() {
    return _MetadataResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_MetadataResponse.discriminator = void 0;
_MetadataResponse.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "MetadataResponseTypeEnum",
    "format": ""
  }
];
var MetadataResponse = _MetadataResponse;

// models/MetadataSearchResponse.ts
var _MetadataSearchResponse = class _MetadataSearchResponse {
  static getAttributeTypeMap() {
    return _MetadataSearchResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_MetadataSearchResponse.discriminator = void 0;
_MetadataSearchResponse.attributeTypeMap = [
  {
    "name": "metadata_id",
    "baseName": "metadata_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_name",
    "baseName": "metadata_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "MetadataSearchResponseMetadataTypeEnum",
    "format": ""
  },
  {
    "name": "metadata_obj_id",
    "baseName": "metadata_obj_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "dependent_objects",
    "baseName": "dependent_objects",
    "type": "any",
    "format": ""
  },
  {
    "name": "incomplete_objects",
    "baseName": "incomplete_objects",
    "type": "Array<any>",
    "format": ""
  },
  {
    "name": "metadata_detail",
    "baseName": "metadata_detail",
    "type": "any",
    "format": ""
  },
  {
    "name": "metadata_header",
    "baseName": "metadata_header",
    "type": "any",
    "format": ""
  },
  {
    "name": "visualization_headers",
    "baseName": "visualization_headers",
    "type": "Array<any>",
    "format": ""
  },
  {
    "name": "stats",
    "baseName": "stats",
    "type": "any",
    "format": ""
  }
];
var MetadataSearchResponse = _MetadataSearchResponse;

// models/MetadataSearchSortOptions.ts
var _MetadataSearchSortOptions = class _MetadataSearchSortOptions {
  static getAttributeTypeMap() {
    return _MetadataSearchSortOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_MetadataSearchSortOptions.discriminator = void 0;
_MetadataSearchSortOptions.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "MetadataSearchSortOptionsFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "MetadataSearchSortOptionsOrderEnum",
    "format": ""
  }
];
var MetadataSearchSortOptions = _MetadataSearchSortOptions;

// models/ModelTableList.ts
var _ModelTableList = class _ModelTableList {
  static getAttributeTypeMap() {
    return _ModelTableList.attributeTypeMap;
  }
  constructor() {
  }
};
_ModelTableList.discriminator = void 0;
_ModelTableList.attributeTypeMap = [
  {
    "name": "model_name",
    "baseName": "model_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "model_path",
    "baseName": "model_path",
    "type": "string",
    "format": ""
  },
  {
    "name": "tables",
    "baseName": "tables",
    "type": "Array<string>",
    "format": ""
  }
];
var ModelTableList = _ModelTableList;

// models/NLInstructionsInfo.ts
var _NLInstructionsInfo = class _NLInstructionsInfo {
  static getAttributeTypeMap() {
    return _NLInstructionsInfo.attributeTypeMap;
  }
  constructor() {
  }
};
_NLInstructionsInfo.discriminator = void 0;
_NLInstructionsInfo.attributeTypeMap = [
  {
    "name": "instructions",
    "baseName": "instructions",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "scope",
    "baseName": "scope",
    "type": "NLInstructionsInfoScopeEnum",
    "format": ""
  }
];
var NLInstructionsInfo = _NLInstructionsInfo;

// models/NLInstructionsInfoInput.ts
var _NLInstructionsInfoInput = class _NLInstructionsInfoInput {
  static getAttributeTypeMap() {
    return _NLInstructionsInfoInput.attributeTypeMap;
  }
  constructor() {
  }
};
_NLInstructionsInfoInput.discriminator = void 0;
_NLInstructionsInfoInput.attributeTypeMap = [
  {
    "name": "instructions",
    "baseName": "instructions",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "scope",
    "baseName": "scope",
    "type": "NLInstructionsInfoInputScopeEnum",
    "format": ""
  }
];
var NLInstructionsInfoInput = _NLInstructionsInfoInput;

// models/ObjectIDAndName.ts
var _ObjectIDAndName = class _ObjectIDAndName {
  static getAttributeTypeMap() {
    return _ObjectIDAndName.attributeTypeMap;
  }
  constructor() {
  }
};
_ObjectIDAndName.discriminator = void 0;
_ObjectIDAndName.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var ObjectIDAndName = _ObjectIDAndName;

// models/Org.ts
var _Org = class _Org {
  static getAttributeTypeMap() {
    return _Org.attributeTypeMap;
  }
  constructor() {
  }
};
_Org.discriminator = void 0;
_Org.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var Org = _Org;

// models/OrgChannelConfigInput.ts
var _OrgChannelConfigInput = class _OrgChannelConfigInput {
  static getAttributeTypeMap() {
    return _OrgChannelConfigInput.attributeTypeMap;
  }
  constructor() {
  }
};
_OrgChannelConfigInput.discriminator = void 0;
_OrgChannelConfigInput.attributeTypeMap = [
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "operation",
    "baseName": "operation",
    "type": "OrgChannelConfigInputOperationEnum",
    "format": ""
  },
  {
    "name": "preferences",
    "baseName": "preferences",
    "type": "Array<EventChannelConfigInput>",
    "format": ""
  },
  {
    "name": "reset_events",
    "baseName": "reset_events",
    "type": "Array<OrgChannelConfigInputResetEventsEnum>",
    "format": ""
  }
];
var OrgChannelConfigInput = _OrgChannelConfigInput;

// models/OrgChannelConfigResponse.ts
var _OrgChannelConfigResponse = class _OrgChannelConfigResponse {
  static getAttributeTypeMap() {
    return _OrgChannelConfigResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_OrgChannelConfigResponse.discriminator = void 0;
_OrgChannelConfigResponse.attributeTypeMap = [
  {
    "name": "org",
    "baseName": "org",
    "type": "OrgDetails",
    "format": ""
  },
  {
    "name": "preferences",
    "baseName": "preferences",
    "type": "Array<EventChannelConfig>",
    "format": ""
  }
];
var OrgChannelConfigResponse = _OrgChannelConfigResponse;

// models/OrgDetails.ts
var _OrgDetails = class _OrgDetails {
  static getAttributeTypeMap() {
    return _OrgDetails.attributeTypeMap;
  }
  constructor() {
  }
};
_OrgDetails.discriminator = void 0;
_OrgDetails.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var OrgDetails = _OrgDetails;

// models/OrgInfo.ts
var _OrgInfo = class _OrgInfo {
  static getAttributeTypeMap() {
    return _OrgInfo.attributeTypeMap;
  }
  constructor() {
  }
};
_OrgInfo.discriminator = void 0;
_OrgInfo.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var OrgInfo = _OrgInfo;

// models/OrgNonEmbedAccess.ts
var _OrgNonEmbedAccess = class _OrgNonEmbedAccess {
  static getAttributeTypeMap() {
    return _OrgNonEmbedAccess.attributeTypeMap;
  }
  constructor() {
  }
};
_OrgNonEmbedAccess.discriminator = void 0;
_OrgNonEmbedAccess.attributeTypeMap = [
  {
    "name": "block_full_app_access",
    "baseName": "block_full_app_access",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "groups_with_access",
    "baseName": "groups_with_access",
    "type": "Array<GroupInfo>",
    "format": ""
  }
];
var OrgNonEmbedAccess = _OrgNonEmbedAccess;

// models/OrgNonEmbedAccessInput.ts
var _OrgNonEmbedAccessInput = class _OrgNonEmbedAccessInput {
  static getAttributeTypeMap() {
    return _OrgNonEmbedAccessInput.attributeTypeMap;
  }
  constructor() {
  }
};
_OrgNonEmbedAccessInput.discriminator = void 0;
_OrgNonEmbedAccessInput.attributeTypeMap = [
  {
    "name": "block_full_app_access",
    "baseName": "block_full_app_access",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "groups_identifiers_with_access",
    "baseName": "groups_identifiers_with_access",
    "type": "Array<string>",
    "format": ""
  }
];
var OrgNonEmbedAccessInput = _OrgNonEmbedAccessInput;

// models/OrgPreferenceSearchCriteriaInput.ts
var _OrgPreferenceSearchCriteriaInput = class _OrgPreferenceSearchCriteriaInput {
  static getAttributeTypeMap() {
    return _OrgPreferenceSearchCriteriaInput.attributeTypeMap;
  }
  constructor() {
  }
};
_OrgPreferenceSearchCriteriaInput.discriminator = void 0;
_OrgPreferenceSearchCriteriaInput.attributeTypeMap = [
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "event_types",
    "baseName": "event_types",
    "type": "Array<OrgPreferenceSearchCriteriaInputEventTypesEnum>",
    "format": ""
  }
];
var OrgPreferenceSearchCriteriaInput = _OrgPreferenceSearchCriteriaInput;

// models/OrgResponse.ts
var _OrgResponse = class _OrgResponse {
  static getAttributeTypeMap() {
    return _OrgResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_OrgResponse.discriminator = void 0;
_OrgResponse.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "status",
    "baseName": "status",
    "type": "OrgResponseStatusEnum",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "OrgResponseVisibilityEnum",
    "format": ""
  }
];
var OrgResponse = _OrgResponse;

// models/OrgType.ts
var _OrgType = class _OrgType {
  static getAttributeTypeMap() {
    return _OrgType.attributeTypeMap;
  }
  constructor() {
  }
};
_OrgType.discriminator = void 0;
_OrgType.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "id",
    "baseName": "id",
    "type": "number",
    "format": "int32"
  }
];
var OrgType = _OrgType;

// models/ParameterValues.ts
var _ParameterValues = class _ParameterValues {
  static getAttributeTypeMap() {
    return _ParameterValues.attributeTypeMap;
  }
  constructor() {
  }
};
_ParameterValues.discriminator = void 0;
_ParameterValues.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "values",
    "baseName": "values",
    "type": "Array<any>",
    "format": ""
  }
];
var ParameterValues = _ParameterValues;

// models/ParameterizeMetadataRequest.ts
var _ParameterizeMetadataRequest = class _ParameterizeMetadataRequest {
  static getAttributeTypeMap() {
    return _ParameterizeMetadataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ParameterizeMetadataRequest.discriminator = void 0;
_ParameterizeMetadataRequest.attributeTypeMap = [
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "ParameterizeMetadataRequestMetadataTypeEnum",
    "format": ""
  },
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "field_type",
    "baseName": "field_type",
    "type": "ParameterizeMetadataRequestFieldTypeEnum",
    "format": ""
  },
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "variable_identifier",
    "baseName": "variable_identifier",
    "type": "string",
    "format": ""
  }
];
var ParameterizeMetadataRequest = _ParameterizeMetadataRequest;

// models/ParametersListItem.ts
var _ParametersListItem = class _ParametersListItem {
  static getAttributeTypeMap() {
    return _ParametersListItem.attributeTypeMap;
  }
  constructor() {
  }
};
_ParametersListItem.discriminator = void 0;
_ParametersListItem.attributeTypeMap = [
  {
    "name": "key",
    "baseName": "key",
    "type": "string",
    "format": ""
  },
  {
    "name": "value",
    "baseName": "value",
    "type": "string",
    "format": ""
  }
];
var ParametersListItem = _ParametersListItem;

// models/ParametersListItemInput.ts
var _ParametersListItemInput = class _ParametersListItemInput {
  static getAttributeTypeMap() {
    return _ParametersListItemInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ParametersListItemInput.discriminator = void 0;
_ParametersListItemInput.attributeTypeMap = [
  {
    "name": "key",
    "baseName": "key",
    "type": "string",
    "format": ""
  },
  {
    "name": "value",
    "baseName": "value",
    "type": "string",
    "format": ""
  }
];
var ParametersListItemInput = _ParametersListItemInput;

// models/PdfOptions.ts
var _PdfOptions = class _PdfOptions {
  static getAttributeTypeMap() {
    return _PdfOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_PdfOptions.discriminator = void 0;
_PdfOptions.attributeTypeMap = [
  {
    "name": "complete_liveboard",
    "baseName": "complete_liveboard",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_cover_page",
    "baseName": "include_cover_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_custom_logo",
    "baseName": "include_custom_logo",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_filter_page",
    "baseName": "include_filter_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_page_number",
    "baseName": "include_page_number",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "page_footer_text",
    "baseName": "page_footer_text",
    "type": "string",
    "format": ""
  },
  {
    "name": "page_orientation",
    "baseName": "page_orientation",
    "type": "string",
    "format": ""
  },
  {
    "name": "page_size",
    "baseName": "page_size",
    "type": "PdfOptionsPageSizeEnum",
    "format": ""
  },
  {
    "name": "truncate_table",
    "baseName": "truncate_table",
    "type": "boolean",
    "format": ""
  }
];
var PdfOptions = _PdfOptions;

// models/PdfOptionsInput.ts
var _PdfOptionsInput = class _PdfOptionsInput {
  static getAttributeTypeMap() {
    return _PdfOptionsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_PdfOptionsInput.discriminator = void 0;
_PdfOptionsInput.attributeTypeMap = [
  {
    "name": "include_cover_page",
    "baseName": "include_cover_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_custom_logo",
    "baseName": "include_custom_logo",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_filter_page",
    "baseName": "include_filter_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_page_number",
    "baseName": "include_page_number",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "page_orientation",
    "baseName": "page_orientation",
    "type": "PdfOptionsInputPageOrientationEnum",
    "format": ""
  },
  {
    "name": "truncate_table",
    "baseName": "truncate_table",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "page_footer_text",
    "baseName": "page_footer_text",
    "type": "string",
    "format": ""
  }
];
var PdfOptionsInput = _PdfOptionsInput;

// models/PermissionInput.ts
var _PermissionInput = class _PermissionInput {
  static getAttributeTypeMap() {
    return _PermissionInput.attributeTypeMap;
  }
  constructor() {
  }
};
_PermissionInput.discriminator = void 0;
_PermissionInput.attributeTypeMap = [
  {
    "name": "principal",
    "baseName": "principal",
    "type": "PrincipalsInput",
    "format": ""
  },
  {
    "name": "share_mode",
    "baseName": "share_mode",
    "type": "PermissionInputShareModeEnum",
    "format": ""
  }
];
var PermissionInput = _PermissionInput;

// models/PermissionOfMetadataResponse.ts
var _PermissionOfMetadataResponse = class _PermissionOfMetadataResponse {
  static getAttributeTypeMap() {
    return _PermissionOfMetadataResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_PermissionOfMetadataResponse.discriminator = void 0;
_PermissionOfMetadataResponse.attributeTypeMap = [
  {
    "name": "metadata_permission_details",
    "baseName": "metadata_permission_details",
    "type": "any",
    "format": ""
  }
];
var PermissionOfMetadataResponse = _PermissionOfMetadataResponse;

// models/PermissionOfPrincipalsResponse.ts
var _PermissionOfPrincipalsResponse = class _PermissionOfPrincipalsResponse {
  static getAttributeTypeMap() {
    return _PermissionOfPrincipalsResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_PermissionOfPrincipalsResponse.discriminator = void 0;
_PermissionOfPrincipalsResponse.attributeTypeMap = [
  {
    "name": "principal_permission_details",
    "baseName": "principal_permission_details",
    "type": "any",
    "format": ""
  }
];
var PermissionOfPrincipalsResponse = _PermissionOfPrincipalsResponse;

// models/PermissionsMetadataTypeInput.ts
var _PermissionsMetadataTypeInput = class _PermissionsMetadataTypeInput {
  static getAttributeTypeMap() {
    return _PermissionsMetadataTypeInput.attributeTypeMap;
  }
  constructor() {
  }
};
_PermissionsMetadataTypeInput.discriminator = void 0;
_PermissionsMetadataTypeInput.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "PermissionsMetadataTypeInputTypeEnum",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  }
];
var PermissionsMetadataTypeInput = _PermissionsMetadataTypeInput;

// models/PngOptionsInput.ts
var _PngOptionsInput = class _PngOptionsInput {
  static getAttributeTypeMap() {
    return _PngOptionsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_PngOptionsInput.discriminator = void 0;
_PngOptionsInput.attributeTypeMap = [
  {
    "name": "include_cover_page",
    "baseName": "include_cover_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_filter_page",
    "baseName": "include_filter_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "personalised_view_id",
    "baseName": "personalised_view_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "image_resolution",
    "baseName": "image_resolution",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "image_scale",
    "baseName": "image_scale",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "include_header",
    "baseName": "include_header",
    "type": "boolean",
    "format": ""
  }
];
var PngOptionsInput = _PngOptionsInput;

// models/PolicyProcessOptions.ts
var _PolicyProcessOptions = class _PolicyProcessOptions {
  static getAttributeTypeMap() {
    return _PolicyProcessOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_PolicyProcessOptions.discriminator = void 0;
_PolicyProcessOptions.attributeTypeMap = [
  {
    "name": "impersonate_user",
    "baseName": "impersonate_user",
    "type": "string",
    "format": ""
  }
];
var PolicyProcessOptions = _PolicyProcessOptions;

// models/PolicyProcessOptionsInput.ts
var _PolicyProcessOptionsInput = class _PolicyProcessOptionsInput {
  static getAttributeTypeMap() {
    return _PolicyProcessOptionsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_PolicyProcessOptionsInput.discriminator = void 0;
_PolicyProcessOptionsInput.attributeTypeMap = [
  {
    "name": "impersonate_user",
    "baseName": "impersonate_user",
    "type": "string",
    "format": ""
  }
];
var PolicyProcessOptionsInput = _PolicyProcessOptionsInput;

// models/PrincipalsInput.ts
var _PrincipalsInput = class _PrincipalsInput {
  static getAttributeTypeMap() {
    return _PrincipalsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_PrincipalsInput.discriminator = void 0;
_PrincipalsInput.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "PrincipalsInputTypeEnum",
    "format": ""
  }
];
var PrincipalsInput = _PrincipalsInput;

// models/PrincipalsListItem.ts
var _PrincipalsListItem = class _PrincipalsListItem {
  static getAttributeTypeMap() {
    return _PrincipalsListItem.attributeTypeMap;
  }
  constructor() {
  }
};
_PrincipalsListItem.discriminator = void 0;
_PrincipalsListItem.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "string",
    "format": ""
  }
];
var PrincipalsListItem = _PrincipalsListItem;

// models/PrincipalsListItemInput.ts
var _PrincipalsListItemInput = class _PrincipalsListItemInput {
  static getAttributeTypeMap() {
    return _PrincipalsListItemInput.attributeTypeMap;
  }
  constructor() {
  }
};
_PrincipalsListItemInput.discriminator = void 0;
_PrincipalsListItemInput.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "string",
    "format": ""
  }
];
var PrincipalsListItemInput = _PrincipalsListItemInput;

// models/PublishMetadataListItem.ts
var _PublishMetadataListItem = class _PublishMetadataListItem {
  static getAttributeTypeMap() {
    return _PublishMetadataListItem.attributeTypeMap;
  }
  constructor() {
  }
};
_PublishMetadataListItem.discriminator = void 0;
_PublishMetadataListItem.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "PublishMetadataListItemTypeEnum",
    "format": ""
  }
];
var PublishMetadataListItem = _PublishMetadataListItem;

// models/PublishMetadataRequest.ts
var _PublishMetadataRequest = class _PublishMetadataRequest {
  static getAttributeTypeMap() {
    return _PublishMetadataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_PublishMetadataRequest.discriminator = void 0;
_PublishMetadataRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<PublishMetadataListItem>",
    "format": ""
  },
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "skip_validation",
    "baseName": "skip_validation",
    "type": "boolean",
    "format": ""
  }
];
var PublishMetadataRequest = _PublishMetadataRequest;

// models/QueryGetDecomposedQueryRequest.ts
var _QueryGetDecomposedQueryRequest = class _QueryGetDecomposedQueryRequest {
  static getAttributeTypeMap() {
    return _QueryGetDecomposedQueryRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_QueryGetDecomposedQueryRequest.discriminator = void 0;
_QueryGetDecomposedQueryRequest.attributeTypeMap = [
  {
    "name": "answerIds",
    "baseName": "answerIds",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "content",
    "baseName": "content",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "conversationId",
    "baseName": "conversationId",
    "type": "string",
    "format": ""
  },
  {
    "name": "liveboardIds",
    "baseName": "liveboardIds",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "maxDecomposedQueries",
    "baseName": "maxDecomposedQueries",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "nlsRequest",
    "baseName": "nlsRequest",
    "type": "QueryGetDecomposedQueryRequestNlsRequest",
    "format": ""
  },
  {
    "name": "worksheetIds",
    "baseName": "worksheetIds",
    "type": "Array<string>",
    "format": ""
  }
];
var QueryGetDecomposedQueryRequest = _QueryGetDecomposedQueryRequest;

// models/QueryGetDecomposedQueryRequestNlsRequest.ts
var _QueryGetDecomposedQueryRequestNlsRequest = class _QueryGetDecomposedQueryRequestNlsRequest {
  static getAttributeTypeMap() {
    return _QueryGetDecomposedQueryRequestNlsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_QueryGetDecomposedQueryRequestNlsRequest.discriminator = void 0;
_QueryGetDecomposedQueryRequestNlsRequest.attributeTypeMap = [
  {
    "name": "agentVersion",
    "baseName": "agentVersion",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "bypassCache",
    "baseName": "bypassCache",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "instructions",
    "baseName": "instructions",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "query",
    "baseName": "query",
    "type": "string",
    "format": ""
  }
];
var QueryGetDecomposedQueryRequestNlsRequest = _QueryGetDecomposedQueryRequestNlsRequest;

// models/RecipientDetails.ts
var _RecipientDetails = class _RecipientDetails {
  static getAttributeTypeMap() {
    return _RecipientDetails.attributeTypeMap;
  }
  constructor() {
  }
};
_RecipientDetails.discriminator = void 0;
_RecipientDetails.attributeTypeMap = [
  {
    "name": "emails",
    "baseName": "emails",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "principals",
    "baseName": "principals",
    "type": "Array<PrincipalsListItem>",
    "format": ""
  }
];
var RecipientDetails = _RecipientDetails;

// models/RecipientDetailsInput.ts
var _RecipientDetailsInput = class _RecipientDetailsInput {
  static getAttributeTypeMap() {
    return _RecipientDetailsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_RecipientDetailsInput.discriminator = void 0;
_RecipientDetailsInput.attributeTypeMap = [
  {
    "name": "emails",
    "baseName": "emails",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "principals",
    "baseName": "principals",
    "type": "Array<PrincipalsListItemInput>",
    "format": ""
  }
];
var RecipientDetailsInput = _RecipientDetailsInput;

// models/RegionalSettingsInput.ts
var _RegionalSettingsInput = class _RegionalSettingsInput {
  static getAttributeTypeMap() {
    return _RegionalSettingsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_RegionalSettingsInput.discriminator = void 0;
_RegionalSettingsInput.attributeTypeMap = [
  {
    "name": "currency_format",
    "baseName": "currency_format",
    "type": "RegionalSettingsInputCurrencyFormatEnum",
    "format": ""
  },
  {
    "name": "user_locale",
    "baseName": "user_locale",
    "type": "RegionalSettingsInputUserLocaleEnum",
    "format": ""
  },
  {
    "name": "number_format_locale",
    "baseName": "number_format_locale",
    "type": "RegionalSettingsInputNumberFormatLocaleEnum",
    "format": ""
  },
  {
    "name": "date_format_locale",
    "baseName": "date_format_locale",
    "type": "RegionalSettingsInputDateFormatLocaleEnum",
    "format": ""
  }
];
var RegionalSettingsInput = _RegionalSettingsInput;

// models/RepoConfigObject.ts
var _RepoConfigObject = class _RepoConfigObject {
  static getAttributeTypeMap() {
    return _RepoConfigObject.attributeTypeMap;
  }
  constructor() {
  }
};
_RepoConfigObject.discriminator = void 0;
_RepoConfigObject.attributeTypeMap = [
  {
    "name": "repository_url",
    "baseName": "repository_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  },
  {
    "name": "commit_branch_name",
    "baseName": "commit_branch_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "branches",
    "baseName": "branches",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "enable_guid_mapping",
    "baseName": "enable_guid_mapping",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "configuration_branch_name",
    "baseName": "configuration_branch_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "org",
    "baseName": "org",
    "type": "Org",
    "format": ""
  }
];
var RepoConfigObject = _RepoConfigObject;

// models/ResetUserPasswordRequest.ts
var _ResetUserPasswordRequest = class _ResetUserPasswordRequest {
  static getAttributeTypeMap() {
    return _ResetUserPasswordRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ResetUserPasswordRequest.discriminator = void 0;
_ResetUserPasswordRequest.attributeTypeMap = [
  {
    "name": "new_password",
    "baseName": "new_password",
    "type": "string",
    "format": ""
  },
  {
    "name": "user_identifier",
    "baseName": "user_identifier",
    "type": "string",
    "format": ""
  }
];
var ResetUserPasswordRequest = _ResetUserPasswordRequest;

// models/ResponseActivationURL.ts
var _ResponseActivationURL = class _ResponseActivationURL {
  static getAttributeTypeMap() {
    return _ResponseActivationURL.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseActivationURL.discriminator = void 0;
_ResponseActivationURL.attributeTypeMap = [
  {
    "name": "activation_link",
    "baseName": "activation_link",
    "type": "string",
    "format": ""
  }
];
var ResponseActivationURL = _ResponseActivationURL;

// models/ResponseCopyObject.ts
var _ResponseCopyObject = class _ResponseCopyObject {
  static getAttributeTypeMap() {
    return _ResponseCopyObject.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseCopyObject.discriminator = void 0;
_ResponseCopyObject.attributeTypeMap = [
  {
    "name": "metadata_id",
    "baseName": "metadata_id",
    "type": "string",
    "format": ""
  }
];
var ResponseCopyObject = _ResponseCopyObject;

// models/ResponseCustomAction.ts
var _ResponseCustomAction = class _ResponseCustomAction {
  static getAttributeTypeMap() {
    return _ResponseCustomAction.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseCustomAction.discriminator = void 0;
_ResponseCustomAction.attributeTypeMap = [
  {
    "name": "action_details",
    "baseName": "action_details",
    "type": "ActionDetails",
    "format": ""
  },
  {
    "name": "default_action_config",
    "baseName": "default_action_config",
    "type": "DefaultActionConfig",
    "format": ""
  },
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_association",
    "baseName": "metadata_association",
    "type": "Array<MetadataAssociationItem>",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "user_groups",
    "baseName": "user_groups",
    "type": "Array<ObjectIDAndName>",
    "format": ""
  }
];
var ResponseCustomAction = _ResponseCustomAction;

// models/ResponseFailedEntities.ts
var _ResponseFailedEntities = class _ResponseFailedEntities {
  static getAttributeTypeMap() {
    return _ResponseFailedEntities.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseFailedEntities.discriminator = void 0;
_ResponseFailedEntities.attributeTypeMap = [
  {
    "name": "data",
    "baseName": "data",
    "type": "Array<ResponseFailedEntity>",
    "format": ""
  }
];
var ResponseFailedEntities = _ResponseFailedEntities;

// models/ResponseFailedEntity.ts
var _ResponseFailedEntity = class _ResponseFailedEntity {
  static getAttributeTypeMap() {
    return _ResponseFailedEntity.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseFailedEntity.discriminator = void 0;
_ResponseFailedEntity.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "error",
    "baseName": "error",
    "type": "string",
    "format": ""
  }
];
var ResponseFailedEntity = _ResponseFailedEntity;

// models/ResponseIncompleteEntities.ts
var _ResponseIncompleteEntities = class _ResponseIncompleteEntities {
  static getAttributeTypeMap() {
    return _ResponseIncompleteEntities.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseIncompleteEntities.discriminator = void 0;
_ResponseIncompleteEntities.attributeTypeMap = [
  {
    "name": "data",
    "baseName": "data",
    "type": "Array<ResponseIncompleteEntity>",
    "format": ""
  }
];
var ResponseIncompleteEntities = _ResponseIncompleteEntities;

// models/ResponseIncompleteEntity.ts
var _ResponseIncompleteEntity = class _ResponseIncompleteEntity {
  static getAttributeTypeMap() {
    return _ResponseIncompleteEntity.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseIncompleteEntity.discriminator = void 0;
_ResponseIncompleteEntity.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "error",
    "baseName": "error",
    "type": "string",
    "format": ""
  }
];
var ResponseIncompleteEntity = _ResponseIncompleteEntity;

// models/ResponseMessage.ts
var _ResponseMessage = class _ResponseMessage {
  static getAttributeTypeMap() {
    return _ResponseMessage.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseMessage.discriminator = void 0;
_ResponseMessage.attributeTypeMap = [
  {
    "name": "session_identifier",
    "baseName": "session_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "generation_number",
    "baseName": "generation_number",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "message_type",
    "baseName": "message_type",
    "type": "ResponseMessageMessageTypeEnum",
    "format": ""
  },
  {
    "name": "visualization_type",
    "baseName": "visualization_type",
    "type": "ResponseMessageVisualizationTypeEnum",
    "format": ""
  },
  {
    "name": "tokens",
    "baseName": "tokens",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_tokens",
    "baseName": "display_tokens",
    "type": "string",
    "format": ""
  }
];
var ResponseMessage = _ResponseMessage;

// models/ResponsePostUpgradeFailedEntities.ts
var _ResponsePostUpgradeFailedEntities = class _ResponsePostUpgradeFailedEntities {
  static getAttributeTypeMap() {
    return _ResponsePostUpgradeFailedEntities.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponsePostUpgradeFailedEntities.discriminator = void 0;
_ResponsePostUpgradeFailedEntities.attributeTypeMap = [
  {
    "name": "data",
    "baseName": "data",
    "type": "Array<ResponsePostUpgradeFailedEntity>",
    "format": ""
  }
];
var ResponsePostUpgradeFailedEntities = _ResponsePostUpgradeFailedEntities;

// models/ResponsePostUpgradeFailedEntity.ts
var _ResponsePostUpgradeFailedEntity = class _ResponsePostUpgradeFailedEntity {
  static getAttributeTypeMap() {
    return _ResponsePostUpgradeFailedEntity.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponsePostUpgradeFailedEntity.discriminator = void 0;
_ResponsePostUpgradeFailedEntity.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "error",
    "baseName": "error",
    "type": "string",
    "format": ""
  }
];
var ResponsePostUpgradeFailedEntity = _ResponsePostUpgradeFailedEntity;

// models/ResponseSchedule.ts
var _ResponseSchedule = class _ResponseSchedule {
  static getAttributeTypeMap() {
    return _ResponseSchedule.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseSchedule.discriminator = void 0;
_ResponseSchedule.attributeTypeMap = [
  {
    "name": "author",
    "baseName": "author",
    "type": "Author",
    "format": ""
  },
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "any",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "file_format",
    "baseName": "file_format",
    "type": "string",
    "format": ""
  },
  {
    "name": "frequency",
    "baseName": "frequency",
    "type": "Frequency",
    "format": ""
  },
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "liveboard_options",
    "baseName": "liveboard_options",
    "type": "LiveboardOptions",
    "format": ""
  },
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "MetadataResponse",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "pdf_options",
    "baseName": "pdf_options",
    "type": "PdfOptions",
    "format": ""
  },
  {
    "name": "recipient_details",
    "baseName": "recipient_details",
    "type": "RecipientDetails",
    "format": ""
  },
  {
    "name": "status",
    "baseName": "status",
    "type": "string",
    "format": ""
  },
  {
    "name": "time_zone",
    "baseName": "time_zone",
    "type": "string",
    "format": ""
  },
  {
    "name": "history_runs",
    "baseName": "history_runs",
    "type": "Array<ResponseScheduleRun>",
    "format": ""
  },
  {
    "name": "personalised_view_id",
    "baseName": "personalised_view_id",
    "type": "string",
    "format": ""
  }
];
var ResponseSchedule = _ResponseSchedule;

// models/ResponseScheduleRun.ts
var _ResponseScheduleRun = class _ResponseScheduleRun {
  static getAttributeTypeMap() {
    return _ResponseScheduleRun.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseScheduleRun.discriminator = void 0;
_ResponseScheduleRun.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "start_time_in_millis",
    "baseName": "start_time_in_millis",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "end_time_in_millis",
    "baseName": "end_time_in_millis",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "status",
    "baseName": "status",
    "type": "string",
    "format": ""
  },
  {
    "name": "detail",
    "baseName": "detail",
    "type": "string",
    "format": ""
  }
];
var ResponseScheduleRun = _ResponseScheduleRun;

// models/ResponseSuccessfulEntities.ts
var _ResponseSuccessfulEntities = class _ResponseSuccessfulEntities {
  static getAttributeTypeMap() {
    return _ResponseSuccessfulEntities.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseSuccessfulEntities.discriminator = void 0;
_ResponseSuccessfulEntities.attributeTypeMap = [
  {
    "name": "data",
    "baseName": "data",
    "type": "Array<ResponseSuccessfulEntity>",
    "format": ""
  }
];
var ResponseSuccessfulEntities = _ResponseSuccessfulEntities;

// models/ResponseSuccessfulEntity.ts
var _ResponseSuccessfulEntity = class _ResponseSuccessfulEntity {
  static getAttributeTypeMap() {
    return _ResponseSuccessfulEntity.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseSuccessfulEntity.discriminator = void 0;
_ResponseSuccessfulEntity.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var ResponseSuccessfulEntity = _ResponseSuccessfulEntity;

// models/ResponseWorksheetToModelConversion.ts
var _ResponseWorksheetToModelConversion = class _ResponseWorksheetToModelConversion {
  static getAttributeTypeMap() {
    return _ResponseWorksheetToModelConversion.attributeTypeMap;
  }
  constructor() {
  }
};
_ResponseWorksheetToModelConversion.discriminator = void 0;
_ResponseWorksheetToModelConversion.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "success_count",
    "baseName": "success_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "failure_count",
    "baseName": "failure_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "incomplete_count",
    "baseName": "incomplete_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "post_upgrade_failed_count",
    "baseName": "post_upgrade_failed_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "total_time_in_millis",
    "baseName": "total_time_in_millis",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "successful_entities",
    "baseName": "successful_entities",
    "type": "ResponseSuccessfulEntities",
    "format": ""
  },
  {
    "name": "failed_entities",
    "baseName": "failed_entities",
    "type": "ResponseFailedEntities",
    "format": ""
  },
  {
    "name": "incomplete_entities",
    "baseName": "incomplete_entities",
    "type": "ResponseIncompleteEntities",
    "format": ""
  },
  {
    "name": "post_upgrade_failed_entities",
    "baseName": "post_upgrade_failed_entities",
    "type": "ResponsePostUpgradeFailedEntities",
    "format": ""
  }
];
var ResponseWorksheetToModelConversion = _ResponseWorksheetToModelConversion;

// models/RevertCommitRequest.ts
var _RevertCommitRequest = class _RevertCommitRequest {
  static getAttributeTypeMap() {
    return _RevertCommitRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_RevertCommitRequest.discriminator = void 0;
_RevertCommitRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<MetadataObject>",
    "format": ""
  },
  {
    "name": "branch_name",
    "baseName": "branch_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "revert_policy",
    "baseName": "revert_policy",
    "type": "RevertCommitRequestRevertPolicyEnum",
    "format": ""
  }
];
var RevertCommitRequest = _RevertCommitRequest;

// models/RevertResponse.ts
var _RevertResponse = class _RevertResponse {
  static getAttributeTypeMap() {
    return _RevertResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_RevertResponse.discriminator = void 0;
_RevertResponse.attributeTypeMap = [
  {
    "name": "committer",
    "baseName": "committer",
    "type": "CommiterType",
    "format": ""
  },
  {
    "name": "author",
    "baseName": "author",
    "type": "AuthorType",
    "format": ""
  },
  {
    "name": "comment",
    "baseName": "comment",
    "type": "string",
    "format": ""
  },
  {
    "name": "commit_time",
    "baseName": "commit_time",
    "type": "string",
    "format": ""
  },
  {
    "name": "commit_id",
    "baseName": "commit_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "branch",
    "baseName": "branch",
    "type": "string",
    "format": ""
  },
  {
    "name": "committed_files",
    "baseName": "committed_files",
    "type": "Array<CommitFileType>",
    "format": ""
  },
  {
    "name": "reverted_metadata",
    "baseName": "reverted_metadata",
    "type": "Array<RevertedMetadata>",
    "format": ""
  }
];
var RevertResponse = _RevertResponse;

// models/RevertedMetadata.ts
var _RevertedMetadata = class _RevertedMetadata {
  static getAttributeTypeMap() {
    return _RevertedMetadata.attributeTypeMap;
  }
  constructor() {
  }
};
_RevertedMetadata.discriminator = void 0;
_RevertedMetadata.attributeTypeMap = [
  {
    "name": "file_name",
    "baseName": "file_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_name",
    "baseName": "metadata_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "string",
    "format": ""
  },
  {
    "name": "status_code",
    "baseName": "status_code",
    "type": "string",
    "format": ""
  },
  {
    "name": "status_message",
    "baseName": "status_message",
    "type": "string",
    "format": ""
  }
];
var RevertedMetadata = _RevertedMetadata;

// models/RevokeRefreshTokensResponse.ts
var _RevokeRefreshTokensResponse = class _RevokeRefreshTokensResponse {
  static getAttributeTypeMap() {
    return _RevokeRefreshTokensResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_RevokeRefreshTokensResponse.discriminator = void 0;
_RevokeRefreshTokensResponse.attributeTypeMap = [
  {
    "name": "data",
    "baseName": "data",
    "type": "string",
    "format": ""
  }
];
var RevokeRefreshTokensResponse = _RevokeRefreshTokensResponse;

// models/RevokeTokenRequest.ts
var _RevokeTokenRequest = class _RevokeTokenRequest {
  static getAttributeTypeMap() {
    return _RevokeTokenRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_RevokeTokenRequest.discriminator = void 0;
_RevokeTokenRequest.attributeTypeMap = [
  {
    "name": "user_identifier",
    "baseName": "user_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "token",
    "baseName": "token",
    "type": "string",
    "format": ""
  }
];
var RevokeTokenRequest = _RevokeTokenRequest;

// models/RiseGQLArgWrapper.ts
var _RiseGQLArgWrapper = class _RiseGQLArgWrapper {
  static getAttributeTypeMap() {
    return _RiseGQLArgWrapper.attributeTypeMap;
  }
  constructor() {
  }
};
_RiseGQLArgWrapper.discriminator = void 0;
_RiseGQLArgWrapper.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "string",
    "format": ""
  }
];
var RiseGQLArgWrapper = _RiseGQLArgWrapper;

// models/RiseSetter.ts
var _RiseSetter = class _RiseSetter {
  static getAttributeTypeMap() {
    return _RiseSetter.attributeTypeMap;
  }
  constructor() {
  }
};
_RiseSetter.discriminator = void 0;
_RiseSetter.attributeTypeMap = [
  {
    "name": "field",
    "baseName": "field",
    "type": "string",
    "format": ""
  },
  {
    "name": "path",
    "baseName": "path",
    "type": "string",
    "format": ""
  }
];
var RiseSetter = _RiseSetter;

// models/Role.ts
var _Role = class _Role {
  static getAttributeTypeMap() {
    return _Role.attributeTypeMap;
  }
  constructor() {
  }
};
_Role.discriminator = void 0;
_Role.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var Role = _Role;

// models/RoleResponse.ts
var _RoleResponse = class _RoleResponse {
  static getAttributeTypeMap() {
    return _RoleResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_RoleResponse.discriminator = void 0;
_RoleResponse.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "groups_assigned_count",
    "baseName": "groups_assigned_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "orgs",
    "baseName": "orgs",
    "type": "Array<GenericInfo>",
    "format": ""
  },
  {
    "name": "groups",
    "baseName": "groups",
    "type": "Array<GenericInfo>",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<RoleResponsePrivilegesEnum>",
    "format": ""
  },
  {
    "name": "permission",
    "baseName": "permission",
    "type": "RoleResponsePermissionEnum",
    "format": ""
  },
  {
    "name": "author_id",
    "baseName": "author_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "modifier_id",
    "baseName": "modifier_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "any",
    "format": ""
  },
  {
    "name": "modification_time_in_millis",
    "baseName": "modification_time_in_millis",
    "type": "any",
    "format": ""
  },
  {
    "name": "deleted",
    "baseName": "deleted",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "deprecated",
    "baseName": "deprecated",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "external",
    "baseName": "external",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hidden",
    "baseName": "hidden",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "shared_via_connection",
    "baseName": "shared_via_connection",
    "type": "boolean",
    "format": ""
  }
];
var RoleResponse = _RoleResponse;

// models/RuntimeFilter.ts
var _RuntimeFilter = class _RuntimeFilter {
  static getAttributeTypeMap() {
    return _RuntimeFilter.attributeTypeMap;
  }
  constructor() {
  }
};
_RuntimeFilter.discriminator = void 0;
_RuntimeFilter.attributeTypeMap = [
  {
    "name": "runtime_filter",
    "baseName": "runtime_filter",
    "type": "any",
    "format": ""
  }
];
var RuntimeFilter = _RuntimeFilter;

// models/RuntimeFilters.ts
var _RuntimeFilters = class _RuntimeFilters {
  static getAttributeTypeMap() {
    return _RuntimeFilters.attributeTypeMap;
  }
  constructor() {
  }
};
_RuntimeFilters.discriminator = void 0;
_RuntimeFilters.attributeTypeMap = [
  {
    "name": "column_name",
    "baseName": "column_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "values",
    "baseName": "values",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "operator",
    "baseName": "operator",
    "type": "RuntimeFiltersOperatorEnum",
    "format": ""
  },
  {
    "name": "persist",
    "baseName": "persist",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "objects",
    "baseName": "objects",
    "type": "Array<UserObject>",
    "format": ""
  }
];
var RuntimeFilters = _RuntimeFilters;

// models/RuntimeParamOverride.ts
var _RuntimeParamOverride = class _RuntimeParamOverride {
  static getAttributeTypeMap() {
    return _RuntimeParamOverride.attributeTypeMap;
  }
  constructor() {
  }
};
_RuntimeParamOverride.discriminator = void 0;
_RuntimeParamOverride.attributeTypeMap = [
  {
    "name": "runtime_param_override",
    "baseName": "runtime_param_override",
    "type": "any",
    "format": ""
  }
];
var RuntimeParamOverride = _RuntimeParamOverride;

// models/RuntimeParameters.ts
var _RuntimeParameters = class _RuntimeParameters {
  static getAttributeTypeMap() {
    return _RuntimeParameters.attributeTypeMap;
  }
  constructor() {
  }
};
_RuntimeParameters.discriminator = void 0;
_RuntimeParameters.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "values",
    "baseName": "values",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "persist",
    "baseName": "persist",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "objects",
    "baseName": "objects",
    "type": "Array<UserObject>",
    "format": ""
  }
];
var RuntimeParameters = _RuntimeParameters;

// models/RuntimeSort.ts
var _RuntimeSort = class _RuntimeSort {
  static getAttributeTypeMap() {
    return _RuntimeSort.attributeTypeMap;
  }
  constructor() {
  }
};
_RuntimeSort.discriminator = void 0;
_RuntimeSort.attributeTypeMap = [
  {
    "name": "runtime_sort",
    "baseName": "runtime_sort",
    "type": "any",
    "format": ""
  }
];
var RuntimeSort = _RuntimeSort;

// models/RuntimeSorts.ts
var _RuntimeSorts = class _RuntimeSorts {
  static getAttributeTypeMap() {
    return _RuntimeSorts.attributeTypeMap;
  }
  constructor() {
  }
};
_RuntimeSorts.discriminator = void 0;
_RuntimeSorts.attributeTypeMap = [
  {
    "name": "column_name",
    "baseName": "column_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "RuntimeSortsOrderEnum",
    "format": ""
  },
  {
    "name": "persist",
    "baseName": "persist",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "objects",
    "baseName": "objects",
    "type": "Array<UserObject>",
    "format": ""
  }
];
var RuntimeSorts = _RuntimeSorts;

// models/ScheduleHistoryRunsOptionsInput.ts
var _ScheduleHistoryRunsOptionsInput = class _ScheduleHistoryRunsOptionsInput {
  static getAttributeTypeMap() {
    return _ScheduleHistoryRunsOptionsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ScheduleHistoryRunsOptionsInput.discriminator = void 0;
_ScheduleHistoryRunsOptionsInput.attributeTypeMap = [
  {
    "name": "include_history_runs",
    "baseName": "include_history_runs",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  }
];
var ScheduleHistoryRunsOptionsInput = _ScheduleHistoryRunsOptionsInput;

// models/SchedulesPdfOptionsInput.ts
var _SchedulesPdfOptionsInput = class _SchedulesPdfOptionsInput {
  static getAttributeTypeMap() {
    return _SchedulesPdfOptionsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_SchedulesPdfOptionsInput.discriminator = void 0;
_SchedulesPdfOptionsInput.attributeTypeMap = [
  {
    "name": "complete_liveboard",
    "baseName": "complete_liveboard",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_cover_page",
    "baseName": "include_cover_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_custom_logo",
    "baseName": "include_custom_logo",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_filter_page",
    "baseName": "include_filter_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_page_number",
    "baseName": "include_page_number",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "page_footer_text",
    "baseName": "page_footer_text",
    "type": "string",
    "format": ""
  },
  {
    "name": "page_orientation",
    "baseName": "page_orientation",
    "type": "string",
    "format": ""
  },
  {
    "name": "page_size",
    "baseName": "page_size",
    "type": "SchedulesPdfOptionsInputPageSizeEnum",
    "format": ""
  },
  {
    "name": "truncate_table",
    "baseName": "truncate_table",
    "type": "boolean",
    "format": ""
  }
];
var SchedulesPdfOptionsInput = _SchedulesPdfOptionsInput;

// models/SchemaObject.ts
var _SchemaObject = class _SchemaObject {
  static getAttributeTypeMap() {
    return _SchemaObject.attributeTypeMap;
  }
  constructor() {
  }
};
_SchemaObject.discriminator = void 0;
_SchemaObject.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "tables",
    "baseName": "tables",
    "type": "Array<Table>",
    "format": ""
  }
];
var SchemaObject = _SchemaObject;

// models/Scope.ts
var _Scope = class _Scope {
  static getAttributeTypeMap() {
    return _Scope.attributeTypeMap;
  }
  constructor() {
  }
};
_Scope.discriminator = void 0;
_Scope.attributeTypeMap = [
  {
    "name": "access_type",
    "baseName": "access_type",
    "type": "string",
    "format": ""
  },
  {
    "name": "org_id",
    "baseName": "org_id",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "metadata_id",
    "baseName": "metadata_id",
    "type": "string",
    "format": ""
  }
];
var Scope = _Scope;

// models/ScriptSrcUrls.ts
var _ScriptSrcUrls = class _ScriptSrcUrls {
  static getAttributeTypeMap() {
    return _ScriptSrcUrls.attributeTypeMap;
  }
  constructor() {
  }
};
_ScriptSrcUrls.discriminator = void 0;
_ScriptSrcUrls.attributeTypeMap = [
  {
    "name": "enabled",
    "baseName": "enabled",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "urls",
    "baseName": "urls",
    "type": "Array<string>",
    "format": ""
  }
];
var ScriptSrcUrls = _ScriptSrcUrls;

// models/ScriptSrcUrlsInput.ts
var _ScriptSrcUrlsInput = class _ScriptSrcUrlsInput {
  static getAttributeTypeMap() {
    return _ScriptSrcUrlsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ScriptSrcUrlsInput.discriminator = void 0;
_ScriptSrcUrlsInput.attributeTypeMap = [
  {
    "name": "enabled",
    "baseName": "enabled",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "urls",
    "baseName": "urls",
    "type": "Array<string>",
    "format": ""
  }
];
var ScriptSrcUrlsInput = _ScriptSrcUrlsInput;

// models/SearchCalendarsRequest.ts
var _SearchCalendarsRequest = class _SearchCalendarsRequest {
  static getAttributeTypeMap() {
    return _SearchCalendarsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchCalendarsRequest.discriminator = void 0;
_SearchCalendarsRequest.attributeTypeMap = [
  {
    "name": "connection_identifier",
    "baseName": "connection_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "name_pattern",
    "baseName": "name_pattern",
    "type": "string",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "sort_options",
    "baseName": "sort_options",
    "type": "SearchCalendarsRequestSortOptions",
    "format": ""
  }
];
var SearchCalendarsRequest = _SearchCalendarsRequest;

// models/SearchCalendarsRequestSortOptions.ts
var _SearchCalendarsRequestSortOptions = class _SearchCalendarsRequestSortOptions {
  static getAttributeTypeMap() {
    return _SearchCalendarsRequestSortOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchCalendarsRequestSortOptions.discriminator = void 0;
_SearchCalendarsRequestSortOptions.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "SearchCalendarsRequestSortOptionsFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "SearchCalendarsRequestSortOptionsOrderEnum",
    "format": ""
  }
];
var SearchCalendarsRequestSortOptions = _SearchCalendarsRequestSortOptions;

// models/SearchCommitsRequest.ts
var _SearchCommitsRequest = class _SearchCommitsRequest {
  static getAttributeTypeMap() {
    return _SearchCommitsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchCommitsRequest.discriminator = void 0;
_SearchCommitsRequest.attributeTypeMap = [
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "SearchCommitsRequestMetadataTypeEnum",
    "format": ""
  },
  {
    "name": "branch_name",
    "baseName": "branch_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  }
];
var SearchCommitsRequest = _SearchCommitsRequest;

// models/SearchCommunicationChannelPreferencesRequest.ts
var _SearchCommunicationChannelPreferencesRequest = class _SearchCommunicationChannelPreferencesRequest {
  static getAttributeTypeMap() {
    return _SearchCommunicationChannelPreferencesRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchCommunicationChannelPreferencesRequest.discriminator = void 0;
_SearchCommunicationChannelPreferencesRequest.attributeTypeMap = [
  {
    "name": "cluster_preferences",
    "baseName": "cluster_preferences",
    "type": "Array<SearchCommunicationChannelPreferencesRequestClusterPreferencesEnum>",
    "format": ""
  },
  {
    "name": "org_preferences",
    "baseName": "org_preferences",
    "type": "Array<OrgPreferenceSearchCriteriaInput>",
    "format": ""
  }
];
var SearchCommunicationChannelPreferencesRequest = _SearchCommunicationChannelPreferencesRequest;

// models/SearchConfigRequest.ts
var _SearchConfigRequest = class _SearchConfigRequest {
  static getAttributeTypeMap() {
    return _SearchConfigRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchConfigRequest.discriminator = void 0;
_SearchConfigRequest.attributeTypeMap = [
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var SearchConfigRequest = _SearchConfigRequest;

// models/SearchConnectionRequest.ts
var _SearchConnectionRequest = class _SearchConnectionRequest {
  static getAttributeTypeMap() {
    return _SearchConnectionRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchConnectionRequest.discriminator = void 0;
_SearchConnectionRequest.attributeTypeMap = [
  {
    "name": "connections",
    "baseName": "connections",
    "type": "Array<ConnectionInput>",
    "format": ""
  },
  {
    "name": "data_warehouse_types",
    "baseName": "data_warehouse_types",
    "type": "Array<SearchConnectionRequestDataWarehouseTypesEnum>",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "tag_identifiers",
    "baseName": "tag_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "data_warehouse_object_type",
    "baseName": "data_warehouse_object_type",
    "type": "SearchConnectionRequestDataWarehouseObjectTypeEnum",
    "format": ""
  },
  {
    "name": "sort_options",
    "baseName": "sort_options",
    "type": "SearchConnectionRequestSortOptions",
    "format": ""
  },
  {
    "name": "include_details",
    "baseName": "include_details",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "configuration",
    "baseName": "configuration",
    "type": "any",
    "format": ""
  },
  {
    "name": "authentication_type",
    "baseName": "authentication_type",
    "type": "SearchConnectionRequestAuthenticationTypeEnum",
    "format": ""
  },
  {
    "name": "show_resolved_parameters",
    "baseName": "show_resolved_parameters",
    "type": "boolean",
    "format": ""
  }
];
var SearchConnectionRequest = _SearchConnectionRequest;

// models/SearchConnectionRequestSortOptions.ts
var _SearchConnectionRequestSortOptions = class _SearchConnectionRequestSortOptions {
  static getAttributeTypeMap() {
    return _SearchConnectionRequestSortOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchConnectionRequestSortOptions.discriminator = void 0;
_SearchConnectionRequestSortOptions.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "SearchConnectionRequestSortOptionsFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "SearchConnectionRequestSortOptionsOrderEnum",
    "format": ""
  }
];
var SearchConnectionRequestSortOptions = _SearchConnectionRequestSortOptions;

// models/SearchConnectionResponse.ts
var _SearchConnectionResponse = class _SearchConnectionResponse {
  static getAttributeTypeMap() {
    return _SearchConnectionResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchConnectionResponse.discriminator = void 0;
_SearchConnectionResponse.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_warehouse_type",
    "baseName": "data_warehouse_type",
    "type": "SearchConnectionResponseDataWarehouseTypeEnum",
    "format": ""
  },
  {
    "name": "data_warehouse_objects",
    "baseName": "data_warehouse_objects",
    "type": "DataWarehouseObjects",
    "format": ""
  },
  {
    "name": "details",
    "baseName": "details",
    "type": "any",
    "format": ""
  }
];
var SearchConnectionResponse = _SearchConnectionResponse;

// models/SearchCustomActionsRequest.ts
var _SearchCustomActionsRequest = class _SearchCustomActionsRequest {
  static getAttributeTypeMap() {
    return _SearchCustomActionsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchCustomActionsRequest.discriminator = void 0;
_SearchCustomActionsRequest.attributeTypeMap = [
  {
    "name": "custom_action_identifier",
    "baseName": "custom_action_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "name_pattern",
    "baseName": "name_pattern",
    "type": "string",
    "format": ""
  },
  {
    "name": "default_action_config",
    "baseName": "default_action_config",
    "type": "SearchCustomActionsRequestDefaultActionConfig",
    "format": ""
  },
  {
    "name": "include_group_associations",
    "baseName": "include_group_associations",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_metadata_associations",
    "baseName": "include_metadata_associations",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<CustomActionMetadataTypeInput>",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "SearchCustomActionsRequestTypeEnum",
    "format": ""
  }
];
var SearchCustomActionsRequest = _SearchCustomActionsRequest;

// models/SearchCustomActionsRequestDefaultActionConfig.ts
var _SearchCustomActionsRequestDefaultActionConfig = class _SearchCustomActionsRequestDefaultActionConfig {
  static getAttributeTypeMap() {
    return _SearchCustomActionsRequestDefaultActionConfig.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchCustomActionsRequestDefaultActionConfig.discriminator = void 0;
_SearchCustomActionsRequestDefaultActionConfig.attributeTypeMap = [
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "boolean",
    "format": ""
  }
];
var SearchCustomActionsRequestDefaultActionConfig = _SearchCustomActionsRequestDefaultActionConfig;

// models/SearchDataRequest.ts
var _SearchDataRequest = class _SearchDataRequest {
  static getAttributeTypeMap() {
    return _SearchDataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchDataRequest.discriminator = void 0;
_SearchDataRequest.attributeTypeMap = [
  {
    "name": "query_string",
    "baseName": "query_string",
    "type": "string",
    "format": ""
  },
  {
    "name": "logical_table_identifier",
    "baseName": "logical_table_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_format",
    "baseName": "data_format",
    "type": "SearchDataRequestDataFormatEnum",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "runtime_filter",
    "baseName": "runtime_filter",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_sort",
    "baseName": "runtime_sort",
    "type": "any",
    "format": ""
  },
  {
    "name": "runtime_param_override",
    "baseName": "runtime_param_override",
    "type": "any",
    "format": ""
  }
];
var SearchDataRequest = _SearchDataRequest;

// models/SearchDataResponse.ts
var _SearchDataResponse = class _SearchDataResponse {
  static getAttributeTypeMap() {
    return _SearchDataResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchDataResponse.discriminator = void 0;
_SearchDataResponse.attributeTypeMap = [
  {
    "name": "contents",
    "baseName": "contents",
    "type": "Array<AnswerContent>",
    "format": ""
  }
];
var SearchDataResponse = _SearchDataResponse;

// models/SearchEmailCustomizationRequest.ts
var _SearchEmailCustomizationRequest = class _SearchEmailCustomizationRequest {
  static getAttributeTypeMap() {
    return _SearchEmailCustomizationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchEmailCustomizationRequest.discriminator = void 0;
_SearchEmailCustomizationRequest.attributeTypeMap = [
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var SearchEmailCustomizationRequest = _SearchEmailCustomizationRequest;

// models/SearchMetadataRequest.ts
var _SearchMetadataRequest = class _SearchMetadataRequest {
  static getAttributeTypeMap() {
    return _SearchMetadataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchMetadataRequest.discriminator = void 0;
_SearchMetadataRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<MetadataListItemInput>",
    "format": ""
  },
  {
    "name": "permissions",
    "baseName": "permissions",
    "type": "Array<PermissionInput>",
    "format": ""
  },
  {
    "name": "created_by_user_identifiers",
    "baseName": "created_by_user_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "dependent_object_version",
    "baseName": "dependent_object_version",
    "type": "SearchMetadataRequestDependentObjectVersionEnum",
    "format": ""
  },
  {
    "name": "exclude_objects",
    "baseName": "exclude_objects",
    "type": "Array<ExcludeMetadataListItemInput>",
    "format": ""
  },
  {
    "name": "favorite_object_options",
    "baseName": "favorite_object_options",
    "type": "SearchMetadataRequestFavoriteObjectOptions",
    "format": ""
  },
  {
    "name": "include_auto_created_objects",
    "baseName": "include_auto_created_objects",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_dependent_objects",
    "baseName": "include_dependent_objects",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "dependent_objects_record_size",
    "baseName": "dependent_objects_record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "include_details",
    "baseName": "include_details",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_headers",
    "baseName": "include_headers",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_hidden_objects",
    "baseName": "include_hidden_objects",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_incomplete_objects",
    "baseName": "include_incomplete_objects",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_visualization_headers",
    "baseName": "include_visualization_headers",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_worksheet_search_assist_data",
    "baseName": "include_worksheet_search_assist_data",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "modified_by_user_identifiers",
    "baseName": "modified_by_user_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "sort_options",
    "baseName": "sort_options",
    "type": "SearchMetadataRequestSortOptions",
    "format": ""
  },
  {
    "name": "tag_identifiers",
    "baseName": "tag_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "include_stats",
    "baseName": "include_stats",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_discoverable_objects",
    "baseName": "include_discoverable_objects",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "show_resolved_parameters",
    "baseName": "show_resolved_parameters",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "liveboard_response_version",
    "baseName": "liveboard_response_version",
    "type": "SearchMetadataRequestLiveboardResponseVersionEnum",
    "format": ""
  },
  {
    "name": "include_only_published_objects",
    "baseName": "include_only_published_objects",
    "type": "boolean",
    "format": ""
  }
];
var SearchMetadataRequest = _SearchMetadataRequest;

// models/SearchMetadataRequestFavoriteObjectOptions.ts
var _SearchMetadataRequestFavoriteObjectOptions = class _SearchMetadataRequestFavoriteObjectOptions {
  static getAttributeTypeMap() {
    return _SearchMetadataRequestFavoriteObjectOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchMetadataRequestFavoriteObjectOptions.discriminator = void 0;
_SearchMetadataRequestFavoriteObjectOptions.attributeTypeMap = [
  {
    "name": "include",
    "baseName": "include",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "user_identifiers",
    "baseName": "user_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var SearchMetadataRequestFavoriteObjectOptions = _SearchMetadataRequestFavoriteObjectOptions;

// models/SearchMetadataRequestSortOptions.ts
var _SearchMetadataRequestSortOptions = class _SearchMetadataRequestSortOptions {
  static getAttributeTypeMap() {
    return _SearchMetadataRequestSortOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchMetadataRequestSortOptions.discriminator = void 0;
_SearchMetadataRequestSortOptions.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "SearchMetadataRequestSortOptionsFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "SearchMetadataRequestSortOptionsOrderEnum",
    "format": ""
  }
];
var SearchMetadataRequestSortOptions = _SearchMetadataRequestSortOptions;

// models/SearchOrgsRequest.ts
var _SearchOrgsRequest = class _SearchOrgsRequest {
  static getAttributeTypeMap() {
    return _SearchOrgsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchOrgsRequest.discriminator = void 0;
_SearchOrgsRequest.attributeTypeMap = [
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "SearchOrgsRequestVisibilityEnum",
    "format": ""
  },
  {
    "name": "status",
    "baseName": "status",
    "type": "SearchOrgsRequestStatusEnum",
    "format": ""
  },
  {
    "name": "user_identifiers",
    "baseName": "user_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var SearchOrgsRequest = _SearchOrgsRequest;

// models/SearchRoleResponse.ts
var _SearchRoleResponse = class _SearchRoleResponse {
  static getAttributeTypeMap() {
    return _SearchRoleResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchRoleResponse.discriminator = void 0;
_SearchRoleResponse.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "groups_assigned_count",
    "baseName": "groups_assigned_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "orgs",
    "baseName": "orgs",
    "type": "Array<GenericInfo>",
    "format": ""
  },
  {
    "name": "groups",
    "baseName": "groups",
    "type": "Array<GenericInfo>",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<SearchRoleResponsePrivilegesEnum>",
    "format": ""
  },
  {
    "name": "permission",
    "baseName": "permission",
    "type": "SearchRoleResponsePermissionEnum",
    "format": ""
  },
  {
    "name": "author_id",
    "baseName": "author_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "modifier_id",
    "baseName": "modifier_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "any",
    "format": ""
  },
  {
    "name": "modification_time_in_millis",
    "baseName": "modification_time_in_millis",
    "type": "any",
    "format": ""
  },
  {
    "name": "deleted",
    "baseName": "deleted",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "deprecated",
    "baseName": "deprecated",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "external",
    "baseName": "external",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hidden",
    "baseName": "hidden",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "shared_via_connection",
    "baseName": "shared_via_connection",
    "type": "boolean",
    "format": ""
  }
];
var SearchRoleResponse = _SearchRoleResponse;

// models/SearchRolesRequest.ts
var _SearchRolesRequest = class _SearchRolesRequest {
  static getAttributeTypeMap() {
    return _SearchRolesRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchRolesRequest.discriminator = void 0;
_SearchRolesRequest.attributeTypeMap = [
  {
    "name": "role_identifiers",
    "baseName": "role_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<SearchRolesRequestPrivilegesEnum>",
    "format": ""
  },
  {
    "name": "deprecated",
    "baseName": "deprecated",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "external",
    "baseName": "external",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "shared_via_connection",
    "baseName": "shared_via_connection",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "permissions",
    "baseName": "permissions",
    "type": "Array<SearchRolesRequestPermissionsEnum>",
    "format": ""
  }
];
var SearchRolesRequest = _SearchRolesRequest;

// models/SearchSchedulesRequest.ts
var _SearchSchedulesRequest = class _SearchSchedulesRequest {
  static getAttributeTypeMap() {
    return _SearchSchedulesRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchSchedulesRequest.discriminator = void 0;
_SearchSchedulesRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<MetadataInput>",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "sort_options",
    "baseName": "sort_options",
    "type": "SearchSchedulesRequestSortOptions",
    "format": ""
  },
  {
    "name": "history_runs_options",
    "baseName": "history_runs_options",
    "type": "SearchSchedulesRequestHistoryRunsOptions",
    "format": ""
  },
  {
    "name": "schedule_identifiers",
    "baseName": "schedule_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var SearchSchedulesRequest = _SearchSchedulesRequest;

// models/SearchSchedulesRequestHistoryRunsOptions.ts
var _SearchSchedulesRequestHistoryRunsOptions = class _SearchSchedulesRequestHistoryRunsOptions {
  static getAttributeTypeMap() {
    return _SearchSchedulesRequestHistoryRunsOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchSchedulesRequestHistoryRunsOptions.discriminator = void 0;
_SearchSchedulesRequestHistoryRunsOptions.attributeTypeMap = [
  {
    "name": "include_history_runs",
    "baseName": "include_history_runs",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  }
];
var SearchSchedulesRequestHistoryRunsOptions = _SearchSchedulesRequestHistoryRunsOptions;

// models/SearchSchedulesRequestSortOptions.ts
var _SearchSchedulesRequestSortOptions = class _SearchSchedulesRequestSortOptions {
  static getAttributeTypeMap() {
    return _SearchSchedulesRequestSortOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchSchedulesRequestSortOptions.discriminator = void 0;
_SearchSchedulesRequestSortOptions.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "string",
    "format": ""
  }
];
var SearchSchedulesRequestSortOptions = _SearchSchedulesRequestSortOptions;

// models/SearchTagsRequest.ts
var _SearchTagsRequest = class _SearchTagsRequest {
  static getAttributeTypeMap() {
    return _SearchTagsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchTagsRequest.discriminator = void 0;
_SearchTagsRequest.attributeTypeMap = [
  {
    "name": "tag_identifier",
    "baseName": "tag_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "name_pattern",
    "baseName": "name_pattern",
    "type": "string",
    "format": ""
  },
  {
    "name": "color",
    "baseName": "color",
    "type": "string",
    "format": ""
  }
];
var SearchTagsRequest = _SearchTagsRequest;

// models/SearchUserGroupsRequest.ts
var _SearchUserGroupsRequest = class _SearchUserGroupsRequest {
  static getAttributeTypeMap() {
    return _SearchUserGroupsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchUserGroupsRequest.discriminator = void 0;
_SearchUserGroupsRequest.attributeTypeMap = [
  {
    "name": "default_liveboard_identifiers",
    "baseName": "default_liveboard_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "name_pattern",
    "baseName": "name_pattern",
    "type": "string",
    "format": ""
  },
  {
    "name": "group_identifier",
    "baseName": "group_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<SearchUserGroupsRequestPrivilegesEnum>",
    "format": ""
  },
  {
    "name": "sub_group_identifiers",
    "baseName": "sub_group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "SearchUserGroupsRequestTypeEnum",
    "format": ""
  },
  {
    "name": "user_identifiers",
    "baseName": "user_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "SearchUserGroupsRequestVisibilityEnum",
    "format": ""
  },
  {
    "name": "role_identifiers",
    "baseName": "role_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "sort_options",
    "baseName": "sort_options",
    "type": "SearchUserGroupsRequestSortOptions",
    "format": ""
  },
  {
    "name": "include_users",
    "baseName": "include_users",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_sub_groups",
    "baseName": "include_sub_groups",
    "type": "boolean",
    "format": ""
  }
];
var SearchUserGroupsRequest = _SearchUserGroupsRequest;

// models/SearchUserGroupsRequestSortOptions.ts
var _SearchUserGroupsRequestSortOptions = class _SearchUserGroupsRequestSortOptions {
  static getAttributeTypeMap() {
    return _SearchUserGroupsRequestSortOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchUserGroupsRequestSortOptions.discriminator = void 0;
_SearchUserGroupsRequestSortOptions.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "SearchUserGroupsRequestSortOptionsFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "SearchUserGroupsRequestSortOptionsOrderEnum",
    "format": ""
  }
];
var SearchUserGroupsRequestSortOptions = _SearchUserGroupsRequestSortOptions;

// models/SearchUsersRequest.ts
var _SearchUsersRequest = class _SearchUsersRequest {
  static getAttributeTypeMap() {
    return _SearchUsersRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchUsersRequest.discriminator = void 0;
_SearchUsersRequest.attributeTypeMap = [
  {
    "name": "user_identifier",
    "baseName": "user_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "name_pattern",
    "baseName": "name_pattern",
    "type": "string",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "SearchUsersRequestVisibilityEnum",
    "format": ""
  },
  {
    "name": "email",
    "baseName": "email",
    "type": "string",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<SearchUsersRequestPrivilegesEnum>",
    "format": ""
  },
  {
    "name": "account_type",
    "baseName": "account_type",
    "type": "SearchUsersRequestAccountTypeEnum",
    "format": ""
  },
  {
    "name": "account_status",
    "baseName": "account_status",
    "type": "SearchUsersRequestAccountStatusEnum",
    "format": ""
  },
  {
    "name": "notify_on_share",
    "baseName": "notify_on_share",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "show_onboarding_experience",
    "baseName": "show_onboarding_experience",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "onboarding_experience_completed",
    "baseName": "onboarding_experience_completed",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "home_liveboard_identifier",
    "baseName": "home_liveboard_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "favorite_metadata",
    "baseName": "favorite_metadata",
    "type": "Array<FavoriteMetadataInput>",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "sort_options",
    "baseName": "sort_options",
    "type": "SearchUsersRequestSortOptions",
    "format": ""
  },
  {
    "name": "role_identifiers",
    "baseName": "role_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "include_favorite_metadata",
    "baseName": "include_favorite_metadata",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_variable_values",
    "baseName": "include_variable_values",
    "type": "boolean",
    "format": ""
  }
];
var SearchUsersRequest = _SearchUsersRequest;

// models/SearchUsersRequestSortOptions.ts
var _SearchUsersRequestSortOptions = class _SearchUsersRequestSortOptions {
  static getAttributeTypeMap() {
    return _SearchUsersRequestSortOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchUsersRequestSortOptions.discriminator = void 0;
_SearchUsersRequestSortOptions.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "SearchUsersRequestSortOptionsFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "SearchUsersRequestSortOptionsOrderEnum",
    "format": ""
  }
];
var SearchUsersRequestSortOptions = _SearchUsersRequestSortOptions;

// models/SearchVariablesRequest.ts
var _SearchVariablesRequest = class _SearchVariablesRequest {
  static getAttributeTypeMap() {
    return _SearchVariablesRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchVariablesRequest.discriminator = void 0;
_SearchVariablesRequest.attributeTypeMap = [
  {
    "name": "variable_details",
    "baseName": "variable_details",
    "type": "Array<VariableDetailInput>",
    "format": ""
  },
  {
    "name": "value_scope",
    "baseName": "value_scope",
    "type": "Array<ValueScopeInput>",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "response_content",
    "baseName": "response_content",
    "type": "SearchVariablesRequestResponseContentEnum",
    "format": ""
  }
];
var SearchVariablesRequest = _SearchVariablesRequest;

// models/SearchWebhookConfigurationsRequest.ts
var _SearchWebhookConfigurationsRequest = class _SearchWebhookConfigurationsRequest {
  static getAttributeTypeMap() {
    return _SearchWebhookConfigurationsRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchWebhookConfigurationsRequest.discriminator = void 0;
_SearchWebhookConfigurationsRequest.attributeTypeMap = [
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "webhook_identifier",
    "baseName": "webhook_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "event_type",
    "baseName": "event_type",
    "type": "SearchWebhookConfigurationsRequestEventTypeEnum",
    "format": ""
  },
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "sort_options",
    "baseName": "sort_options",
    "type": "SearchWebhookConfigurationsRequestSortOptions",
    "format": ""
  }
];
var SearchWebhookConfigurationsRequest = _SearchWebhookConfigurationsRequest;

// models/SearchWebhookConfigurationsRequestSortOptions.ts
var _SearchWebhookConfigurationsRequestSortOptions = class _SearchWebhookConfigurationsRequestSortOptions {
  static getAttributeTypeMap() {
    return _SearchWebhookConfigurationsRequestSortOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SearchWebhookConfigurationsRequestSortOptions.discriminator = void 0;
_SearchWebhookConfigurationsRequestSortOptions.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "SearchWebhookConfigurationsRequestSortOptionsFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "SearchWebhookConfigurationsRequestSortOptionsOrderEnum",
    "format": ""
  }
];
var SearchWebhookConfigurationsRequestSortOptions = _SearchWebhookConfigurationsRequestSortOptions;

// models/SecuritySettingsClusterPreferences.ts
var _SecuritySettingsClusterPreferences = class _SecuritySettingsClusterPreferences {
  static getAttributeTypeMap() {
    return _SecuritySettingsClusterPreferences.attributeTypeMap;
  }
  constructor() {
  }
};
_SecuritySettingsClusterPreferences.discriminator = void 0;
_SecuritySettingsClusterPreferences.attributeTypeMap = [
  {
    "name": "enable_partitioned_cookies",
    "baseName": "enable_partitioned_cookies",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "cors_whitelisted_urls",
    "baseName": "cors_whitelisted_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "csp_settings",
    "baseName": "csp_settings",
    "type": "CspSettings",
    "format": ""
  },
  {
    "name": "saml_redirect_urls",
    "baseName": "saml_redirect_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "non_embed_access",
    "baseName": "non_embed_access",
    "type": "ClusterNonEmbedAccess",
    "format": ""
  }
];
var SecuritySettingsClusterPreferences = _SecuritySettingsClusterPreferences;

// models/SecuritySettingsClusterPreferencesInput.ts
var _SecuritySettingsClusterPreferencesInput = class _SecuritySettingsClusterPreferencesInput {
  static getAttributeTypeMap() {
    return _SecuritySettingsClusterPreferencesInput.attributeTypeMap;
  }
  constructor() {
  }
};
_SecuritySettingsClusterPreferencesInput.discriminator = void 0;
_SecuritySettingsClusterPreferencesInput.attributeTypeMap = [
  {
    "name": "enable_partitioned_cookies",
    "baseName": "enable_partitioned_cookies",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "cors_whitelisted_urls",
    "baseName": "cors_whitelisted_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "csp_settings",
    "baseName": "csp_settings",
    "type": "CspSettingsInput",
    "format": ""
  },
  {
    "name": "saml_redirect_urls",
    "baseName": "saml_redirect_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "non_embed_access",
    "baseName": "non_embed_access",
    "type": "ClusterNonEmbedAccessInput",
    "format": ""
  }
];
var SecuritySettingsClusterPreferencesInput = _SecuritySettingsClusterPreferencesInput;

// models/SecuritySettingsOrgDetails.ts
var _SecuritySettingsOrgDetails = class _SecuritySettingsOrgDetails {
  static getAttributeTypeMap() {
    return _SecuritySettingsOrgDetails.attributeTypeMap;
  }
  constructor() {
  }
};
_SecuritySettingsOrgDetails.discriminator = void 0;
_SecuritySettingsOrgDetails.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var SecuritySettingsOrgDetails = _SecuritySettingsOrgDetails;

// models/SecuritySettingsOrgPreferences.ts
var _SecuritySettingsOrgPreferences = class _SecuritySettingsOrgPreferences {
  static getAttributeTypeMap() {
    return _SecuritySettingsOrgPreferences.attributeTypeMap;
  }
  constructor() {
  }
};
_SecuritySettingsOrgPreferences.discriminator = void 0;
_SecuritySettingsOrgPreferences.attributeTypeMap = [
  {
    "name": "org",
    "baseName": "org",
    "type": "SecuritySettingsOrgDetails",
    "format": ""
  },
  {
    "name": "cors_whitelisted_urls",
    "baseName": "cors_whitelisted_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "non_embed_access",
    "baseName": "non_embed_access",
    "type": "OrgNonEmbedAccess",
    "format": ""
  }
];
var SecuritySettingsOrgPreferences = _SecuritySettingsOrgPreferences;

// models/SecuritySettingsOrgPreferencesInput.ts
var _SecuritySettingsOrgPreferencesInput = class _SecuritySettingsOrgPreferencesInput {
  static getAttributeTypeMap() {
    return _SecuritySettingsOrgPreferencesInput.attributeTypeMap;
  }
  constructor() {
  }
};
_SecuritySettingsOrgPreferencesInput.discriminator = void 0;
_SecuritySettingsOrgPreferencesInput.attributeTypeMap = [
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "cors_whitelisted_urls",
    "baseName": "cors_whitelisted_urls",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "non_embed_access",
    "baseName": "non_embed_access",
    "type": "OrgNonEmbedAccessInput",
    "format": ""
  }
];
var SecuritySettingsOrgPreferencesInput = _SecuritySettingsOrgPreferencesInput;

// models/SecuritySettingsResponse.ts
var _SecuritySettingsResponse = class _SecuritySettingsResponse {
  static getAttributeTypeMap() {
    return _SecuritySettingsResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_SecuritySettingsResponse.discriminator = void 0;
_SecuritySettingsResponse.attributeTypeMap = [
  {
    "name": "cluster_preferences",
    "baseName": "cluster_preferences",
    "type": "SecuritySettingsClusterPreferences",
    "format": ""
  },
  {
    "name": "org_preferences",
    "baseName": "org_preferences",
    "type": "Array<SecuritySettingsOrgPreferences>",
    "format": ""
  }
];
var SecuritySettingsResponse = _SecuritySettingsResponse;

// models/SendAgentMessageResponse.ts
var _SendAgentMessageResponse = class _SendAgentMessageResponse {
  static getAttributeTypeMap() {
    return _SendAgentMessageResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_SendAgentMessageResponse.discriminator = void 0;
_SendAgentMessageResponse.attributeTypeMap = [
  {
    "name": "success",
    "baseName": "success",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "message",
    "baseName": "message",
    "type": "string",
    "format": ""
  }
];
var SendAgentMessageResponse = _SendAgentMessageResponse;

// models/SendAgentMessageStreamingRequest.ts
var _SendAgentMessageStreamingRequest = class _SendAgentMessageStreamingRequest {
  static getAttributeTypeMap() {
    return _SendAgentMessageStreamingRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SendAgentMessageStreamingRequest.discriminator = void 0;
_SendAgentMessageStreamingRequest.attributeTypeMap = [
  {
    "name": "conversation_identifier",
    "baseName": "conversation_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "messages",
    "baseName": "messages",
    "type": "Array<string>",
    "format": ""
  }
];
var SendAgentMessageStreamingRequest = _SendAgentMessageStreamingRequest;

// models/SendMessageRequest.ts
var _SendMessageRequest = class _SendMessageRequest {
  static getAttributeTypeMap() {
    return _SendMessageRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SendMessageRequest.discriminator = void 0;
_SendMessageRequest.attributeTypeMap = [
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "message",
    "baseName": "message",
    "type": "string",
    "format": ""
  }
];
var SendMessageRequest = _SendMessageRequest;

// models/ShareMetadataRequest.ts
var _ShareMetadataRequest = class _ShareMetadataRequest {
  static getAttributeTypeMap() {
    return _ShareMetadataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ShareMetadataRequest.discriminator = void 0;
_ShareMetadataRequest.attributeTypeMap = [
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "ShareMetadataRequestMetadataTypeEnum",
    "format": ""
  },
  {
    "name": "metadata_identifiers",
    "baseName": "metadata_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<ShareMetadataTypeInput>",
    "format": ""
  },
  {
    "name": "permissions",
    "baseName": "permissions",
    "type": "Array<SharePermissionsInput>",
    "format": ""
  },
  {
    "name": "visualization_identifiers",
    "baseName": "visualization_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "emails",
    "baseName": "emails",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "message",
    "baseName": "message",
    "type": "string",
    "format": ""
  },
  {
    "name": "enable_custom_url",
    "baseName": "enable_custom_url",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "notify_on_share",
    "baseName": "notify_on_share",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "has_lenient_discoverability",
    "baseName": "has_lenient_discoverability",
    "type": "boolean",
    "format": ""
  }
];
var ShareMetadataRequest = _ShareMetadataRequest;

// models/ShareMetadataTypeInput.ts
var _ShareMetadataTypeInput = class _ShareMetadataTypeInput {
  static getAttributeTypeMap() {
    return _ShareMetadataTypeInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ShareMetadataTypeInput.discriminator = void 0;
_ShareMetadataTypeInput.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "ShareMetadataTypeInputTypeEnum",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  }
];
var ShareMetadataTypeInput = _ShareMetadataTypeInput;

// models/SharePermissionsInput.ts
var _SharePermissionsInput = class _SharePermissionsInput {
  static getAttributeTypeMap() {
    return _SharePermissionsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_SharePermissionsInput.discriminator = void 0;
_SharePermissionsInput.attributeTypeMap = [
  {
    "name": "principal",
    "baseName": "principal",
    "type": "PrincipalsInput",
    "format": ""
  },
  {
    "name": "share_mode",
    "baseName": "share_mode",
    "type": "SharePermissionsInputShareModeEnum",
    "format": ""
  }
];
var SharePermissionsInput = _SharePermissionsInput;

// models/SingleAnswerRequest.ts
var _SingleAnswerRequest = class _SingleAnswerRequest {
  static getAttributeTypeMap() {
    return _SingleAnswerRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_SingleAnswerRequest.discriminator = void 0;
_SingleAnswerRequest.attributeTypeMap = [
  {
    "name": "query",
    "baseName": "query",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  }
];
var SingleAnswerRequest = _SingleAnswerRequest;

// models/SortOption.ts
var _SortOption = class _SortOption {
  static getAttributeTypeMap() {
    return _SortOption.attributeTypeMap;
  }
  constructor() {
  }
};
_SortOption.discriminator = void 0;
_SortOption.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "SortOptionFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "SortOptionOrderEnum",
    "format": ""
  }
];
var SortOption = _SortOption;

// models/SortOptionInput.ts
var _SortOptionInput = class _SortOptionInput {
  static getAttributeTypeMap() {
    return _SortOptionInput.attributeTypeMap;
  }
  constructor() {
  }
};
_SortOptionInput.discriminator = void 0;
_SortOptionInput.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "SortOptionInputFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "SortOptionInputOrderEnum",
    "format": ""
  }
];
var SortOptionInput = _SortOptionInput;

// models/SortOptions.ts
var _SortOptions = class _SortOptions {
  static getAttributeTypeMap() {
    return _SortOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SortOptions.discriminator = void 0;
_SortOptions.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "SortOptionsFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "SortOptionsOrderEnum",
    "format": ""
  }
];
var SortOptions = _SortOptions;

// models/SortingOptions.ts
var _SortingOptions = class _SortingOptions {
  static getAttributeTypeMap() {
    return _SortingOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_SortingOptions.discriminator = void 0;
_SortingOptions.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "string",
    "format": ""
  }
];
var SortingOptions = _SortingOptions;

// models/SqlQuery.ts
var _SqlQuery = class _SqlQuery {
  static getAttributeTypeMap() {
    return _SqlQuery.attributeTypeMap;
  }
  constructor() {
  }
};
_SqlQuery.discriminator = void 0;
_SqlQuery.attributeTypeMap = [
  {
    "name": "metadata_id",
    "baseName": "metadata_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_name",
    "baseName": "metadata_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "sql_query",
    "baseName": "sql_query",
    "type": "string",
    "format": ""
  }
];
var SqlQuery = _SqlQuery;

// models/SqlQueryResponse.ts
var _SqlQueryResponse = class _SqlQueryResponse {
  static getAttributeTypeMap() {
    return _SqlQueryResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_SqlQueryResponse.discriminator = void 0;
_SqlQueryResponse.attributeTypeMap = [
  {
    "name": "metadata_id",
    "baseName": "metadata_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_name",
    "baseName": "metadata_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "SqlQueryResponseMetadataTypeEnum",
    "format": ""
  },
  {
    "name": "sql_queries",
    "baseName": "sql_queries",
    "type": "Array<SqlQuery>",
    "format": ""
  }
];
var SqlQueryResponse = _SqlQueryResponse;

// models/SystemConfig.ts
var _SystemConfig = class _SystemConfig {
  static getAttributeTypeMap() {
    return _SystemConfig.attributeTypeMap;
  }
  constructor() {
  }
};
_SystemConfig.discriminator = void 0;
_SystemConfig.attributeTypeMap = [
  {
    "name": "onboarding_content_url",
    "baseName": "onboarding_content_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "saml_enabled",
    "baseName": "saml_enabled",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "okta_enabled",
    "baseName": "okta_enabled",
    "type": "boolean",
    "format": ""
  }
];
var SystemConfig = _SystemConfig;

// models/SystemInfo.ts
var _SystemInfo = class _SystemInfo {
  static getAttributeTypeMap() {
    return _SystemInfo.attributeTypeMap;
  }
  constructor() {
  }
};
_SystemInfo.discriminator = void 0;
_SystemInfo.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "release_version",
    "baseName": "release_version",
    "type": "string",
    "format": ""
  },
  {
    "name": "time_zone",
    "baseName": "time_zone",
    "type": "string",
    "format": ""
  },
  {
    "name": "locale",
    "baseName": "locale",
    "type": "string",
    "format": ""
  },
  {
    "name": "date_format",
    "baseName": "date_format",
    "type": "string",
    "format": ""
  },
  {
    "name": "api_version",
    "baseName": "api_version",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "string",
    "format": ""
  },
  {
    "name": "environment",
    "baseName": "environment",
    "type": "string",
    "format": ""
  },
  {
    "name": "license",
    "baseName": "license",
    "type": "string",
    "format": ""
  },
  {
    "name": "date_time_format",
    "baseName": "date_time_format",
    "type": "string",
    "format": ""
  },
  {
    "name": "time_format",
    "baseName": "time_format",
    "type": "string",
    "format": ""
  },
  {
    "name": "system_user_id",
    "baseName": "system_user_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "super_user_id",
    "baseName": "super_user_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "hidden_object_id",
    "baseName": "hidden_object_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "system_group_id",
    "baseName": "system_group_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "tsadmin_user_id",
    "baseName": "tsadmin_user_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "admin_group_id",
    "baseName": "admin_group_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "all_tables_connection_id",
    "baseName": "all_tables_connection_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "all_user_group_id",
    "baseName": "all_user_group_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "accept_language",
    "baseName": "accept_language",
    "type": "string",
    "format": ""
  },
  {
    "name": "all_user_group_member_user_count",
    "baseName": "all_user_group_member_user_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "logical_model_version",
    "baseName": "logical_model_version",
    "type": "number",
    "format": "int32"
  }
];
var SystemInfo = _SystemInfo;

// models/SystemOverrideInfo.ts
var _SystemOverrideInfo = class _SystemOverrideInfo {
  static getAttributeTypeMap() {
    return _SystemOverrideInfo.attributeTypeMap;
  }
  constructor() {
  }
};
_SystemOverrideInfo.discriminator = void 0;
_SystemOverrideInfo.attributeTypeMap = [
  {
    "name": "config_override_info",
    "baseName": "config_override_info",
    "type": "any",
    "format": ""
  }
];
var SystemOverrideInfo = _SystemOverrideInfo;

// models/Table.ts
var _Table = class _Table {
  static getAttributeTypeMap() {
    return _Table.attributeTypeMap;
  }
  constructor() {
  }
};
_Table.discriminator = void 0;
_Table.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "columns",
    "baseName": "columns",
    "type": "Array<Column>",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "selected",
    "baseName": "selected",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "linked",
    "baseName": "linked",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "relationships",
    "baseName": "relationships",
    "type": "Array<any>",
    "format": ""
  }
];
var Table = _Table;

// models/Tag.ts
var _Tag = class _Tag {
  static getAttributeTypeMap() {
    return _Tag.attributeTypeMap;
  }
  constructor() {
  }
};
_Tag.discriminator = void 0;
_Tag.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "color",
    "baseName": "color",
    "type": "string",
    "format": ""
  },
  {
    "name": "deleted",
    "baseName": "deleted",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hidden",
    "baseName": "hidden",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "external",
    "baseName": "external",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "deprecated",
    "baseName": "deprecated",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "modification_time_in_millis",
    "baseName": "modification_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "author_id",
    "baseName": "author_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "modifier_id",
    "baseName": "modifier_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "owner_id",
    "baseName": "owner_id",
    "type": "string",
    "format": ""
  }
];
var Tag = _Tag;

// models/TagMetadataTypeInput.ts
var _TagMetadataTypeInput = class _TagMetadataTypeInput {
  static getAttributeTypeMap() {
    return _TagMetadataTypeInput.attributeTypeMap;
  }
  constructor() {
  }
};
_TagMetadataTypeInput.discriminator = void 0;
_TagMetadataTypeInput.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "TagMetadataTypeInputTypeEnum",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  }
];
var TagMetadataTypeInput = _TagMetadataTypeInput;

// models/TemplatePropertiesInputCreate.ts
var _TemplatePropertiesInputCreate = class _TemplatePropertiesInputCreate {
  static getAttributeTypeMap() {
    return _TemplatePropertiesInputCreate.attributeTypeMap;
  }
  constructor() {
  }
};
_TemplatePropertiesInputCreate.discriminator = void 0;
_TemplatePropertiesInputCreate.attributeTypeMap = [
  {
    "name": "cta_button_bg_color",
    "baseName": "cta_button_bg_color",
    "type": "string",
    "format": ""
  },
  {
    "name": "cta_text_font_color",
    "baseName": "cta_text_font_color",
    "type": "string",
    "format": ""
  },
  {
    "name": "primary_bg_color",
    "baseName": "primary_bg_color",
    "type": "string",
    "format": ""
  },
  {
    "name": "home_url",
    "baseName": "home_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "logo_url",
    "baseName": "logo_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "font_family",
    "baseName": "font_family",
    "type": "string",
    "format": ""
  },
  {
    "name": "product_name",
    "baseName": "product_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "footer_address",
    "baseName": "footer_address",
    "type": "string",
    "format": ""
  },
  {
    "name": "footer_phone",
    "baseName": "footer_phone",
    "type": "string",
    "format": ""
  },
  {
    "name": "replacement_value_for_liveboard",
    "baseName": "replacement_value_for_liveboard",
    "type": "string",
    "format": ""
  },
  {
    "name": "replacement_value_for_answer",
    "baseName": "replacement_value_for_answer",
    "type": "string",
    "format": ""
  },
  {
    "name": "replacement_value_for_spot_iq",
    "baseName": "replacement_value_for_spot_iq",
    "type": "string",
    "format": ""
  },
  {
    "name": "hide_footer_address",
    "baseName": "hide_footer_address",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_footer_phone",
    "baseName": "hide_footer_phone",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_manage_notification",
    "baseName": "hide_manage_notification",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_mobile_app_nudge",
    "baseName": "hide_mobile_app_nudge",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_privacy_policy",
    "baseName": "hide_privacy_policy",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_product_name",
    "baseName": "hide_product_name",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_ts_vocabulary_definitions",
    "baseName": "hide_ts_vocabulary_definitions",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_notification_status",
    "baseName": "hide_notification_status",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_error_message",
    "baseName": "hide_error_message",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_unsubscribe_link",
    "baseName": "hide_unsubscribe_link",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "hide_modify_alert",
    "baseName": "hide_modify_alert",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "company_privacy_policy_url",
    "baseName": "company_privacy_policy_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "company_website_url",
    "baseName": "company_website_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "contact_support_url",
    "baseName": "contact_support_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "hide_contact_support_url",
    "baseName": "hide_contact_support_url",
    "type": "boolean",
    "format": ""
  }
];
var TemplatePropertiesInputCreate = _TemplatePropertiesInputCreate;

// models/Token.ts
var _Token = class _Token {
  static getAttributeTypeMap() {
    return _Token.attributeTypeMap;
  }
  constructor() {
  }
};
_Token.discriminator = void 0;
_Token.attributeTypeMap = [
  {
    "name": "token",
    "baseName": "token",
    "type": "string",
    "format": ""
  },
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "expiration_time_in_millis",
    "baseName": "expiration_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "scope",
    "baseName": "scope",
    "type": "Scope",
    "format": ""
  },
  {
    "name": "valid_for_user_id",
    "baseName": "valid_for_user_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "valid_for_username",
    "baseName": "valid_for_username",
    "type": "string",
    "format": ""
  }
];
var Token = _Token;

// models/TokenAccessScopeObject.ts
var _TokenAccessScopeObject = class _TokenAccessScopeObject {
  static getAttributeTypeMap() {
    return _TokenAccessScopeObject.attributeTypeMap;
  }
  constructor() {
  }
};
_TokenAccessScopeObject.discriminator = void 0;
_TokenAccessScopeObject.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "TokenAccessScopeObjectTypeEnum",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  }
];
var TokenAccessScopeObject = _TokenAccessScopeObject;

// models/TokenValidationResponse.ts
var _TokenValidationResponse = class _TokenValidationResponse {
  static getAttributeTypeMap() {
    return _TokenValidationResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_TokenValidationResponse.discriminator = void 0;
_TokenValidationResponse.attributeTypeMap = [
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "expiration_time_in_millis",
    "baseName": "expiration_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "scope",
    "baseName": "scope",
    "type": "Scope",
    "format": ""
  },
  {
    "name": "valid_for_user_id",
    "baseName": "valid_for_user_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "token_type",
    "baseName": "token_type",
    "type": "string",
    "format": ""
  }
];
var TokenValidationResponse = _TokenValidationResponse;

// models/URL.ts
var _URL = class _URL {
  static getAttributeTypeMap() {
    return _URL.attributeTypeMap;
  }
  constructor() {
  }
};
_URL.discriminator = void 0;
_URL.attributeTypeMap = [
  {
    "name": "authentication",
    "baseName": "authentication",
    "type": "Authentication",
    "format": ""
  },
  {
    "name": "parameters",
    "baseName": "parameters",
    "type": "Array<ParametersListItem>",
    "format": ""
  },
  {
    "name": "url",
    "baseName": "url",
    "type": "string",
    "format": ""
  },
  {
    "name": "reference",
    "baseName": "reference",
    "type": "string",
    "format": ""
  }
];
var URL2 = _URL;

// models/URLInput.ts
var _URLInput = class _URLInput {
  static getAttributeTypeMap() {
    return _URLInput.attributeTypeMap;
  }
  constructor() {
  }
};
_URLInput.discriminator = void 0;
_URLInput.attributeTypeMap = [
  {
    "name": "authentication",
    "baseName": "authentication",
    "type": "AuthenticationInput",
    "format": ""
  },
  {
    "name": "parameters",
    "baseName": "parameters",
    "type": "Array<ParametersListItemInput>",
    "format": ""
  },
  {
    "name": "url",
    "baseName": "url",
    "type": "string",
    "format": ""
  },
  {
    "name": "reference",
    "baseName": "reference",
    "type": "string",
    "format": ""
  }
];
var URLInput = _URLInput;

// models/URLInputMandatory.ts
var _URLInputMandatory = class _URLInputMandatory {
  static getAttributeTypeMap() {
    return _URLInputMandatory.attributeTypeMap;
  }
  constructor() {
  }
};
_URLInputMandatory.discriminator = void 0;
_URLInputMandatory.attributeTypeMap = [
  {
    "name": "authentication",
    "baseName": "authentication",
    "type": "AuthenticationInput",
    "format": ""
  },
  {
    "name": "parameters",
    "baseName": "parameters",
    "type": "Array<ParametersListItemInput>",
    "format": ""
  },
  {
    "name": "url",
    "baseName": "url",
    "type": "string",
    "format": ""
  },
  {
    "name": "reference",
    "baseName": "reference",
    "type": "string",
    "format": ""
  }
];
var URLInputMandatory = _URLInputMandatory;

// models/UnparameterizeMetadataRequest.ts
var _UnparameterizeMetadataRequest = class _UnparameterizeMetadataRequest {
  static getAttributeTypeMap() {
    return _UnparameterizeMetadataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UnparameterizeMetadataRequest.discriminator = void 0;
_UnparameterizeMetadataRequest.attributeTypeMap = [
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "UnparameterizeMetadataRequestMetadataTypeEnum",
    "format": ""
  },
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "field_type",
    "baseName": "field_type",
    "type": "UnparameterizeMetadataRequestFieldTypeEnum",
    "format": ""
  },
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "value",
    "baseName": "value",
    "type": "string",
    "format": ""
  }
];
var UnparameterizeMetadataRequest = _UnparameterizeMetadataRequest;

// models/UnpublishMetadataRequest.ts
var _UnpublishMetadataRequest = class _UnpublishMetadataRequest {
  static getAttributeTypeMap() {
    return _UnpublishMetadataRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UnpublishMetadataRequest.discriminator = void 0;
_UnpublishMetadataRequest.attributeTypeMap = [
  {
    "name": "force",
    "baseName": "force",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_dependencies",
    "baseName": "include_dependencies",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<PublishMetadataListItem>",
    "format": ""
  },
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var UnpublishMetadataRequest = _UnpublishMetadataRequest;

// models/UpdateCalendarRequest.ts
var _UpdateCalendarRequest = class _UpdateCalendarRequest {
  static getAttributeTypeMap() {
    return _UpdateCalendarRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateCalendarRequest.discriminator = void 0;
_UpdateCalendarRequest.attributeTypeMap = [
  {
    "name": "update_method",
    "baseName": "update_method",
    "type": "UpdateCalendarRequestUpdateMethodEnum",
    "format": ""
  },
  {
    "name": "table_reference",
    "baseName": "table_reference",
    "type": "UpdateCalendarRequestTableReference",
    "format": ""
  },
  {
    "name": "start_date",
    "baseName": "start_date",
    "type": "string",
    "format": ""
  },
  {
    "name": "end_date",
    "baseName": "end_date",
    "type": "string",
    "format": ""
  },
  {
    "name": "calendar_type",
    "baseName": "calendar_type",
    "type": "UpdateCalendarRequestCalendarTypeEnum",
    "format": ""
  },
  {
    "name": "month_offset",
    "baseName": "month_offset",
    "type": "UpdateCalendarRequestMonthOffsetEnum",
    "format": ""
  },
  {
    "name": "start_day_of_week",
    "baseName": "start_day_of_week",
    "type": "UpdateCalendarRequestStartDayOfWeekEnum",
    "format": ""
  },
  {
    "name": "quarter_name_prefix",
    "baseName": "quarter_name_prefix",
    "type": "string",
    "format": ""
  },
  {
    "name": "year_name_prefix",
    "baseName": "year_name_prefix",
    "type": "string",
    "format": ""
  }
];
var UpdateCalendarRequest = _UpdateCalendarRequest;

// models/UpdateCalendarRequestTableReference.ts
var _UpdateCalendarRequestTableReference = class _UpdateCalendarRequestTableReference {
  static getAttributeTypeMap() {
    return _UpdateCalendarRequestTableReference.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateCalendarRequestTableReference.discriminator = void 0;
_UpdateCalendarRequestTableReference.attributeTypeMap = [
  {
    "name": "connection_identifier",
    "baseName": "connection_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "database_name",
    "baseName": "database_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "schema_name",
    "baseName": "schema_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "table_name",
    "baseName": "table_name",
    "type": "string",
    "format": ""
  }
];
var UpdateCalendarRequestTableReference = _UpdateCalendarRequestTableReference;

// models/UpdateColumnSecurityRulesRequest.ts
var _UpdateColumnSecurityRulesRequest = class _UpdateColumnSecurityRulesRequest {
  static getAttributeTypeMap() {
    return _UpdateColumnSecurityRulesRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateColumnSecurityRulesRequest.discriminator = void 0;
_UpdateColumnSecurityRulesRequest.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "obj_identifier",
    "baseName": "obj_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "clear_csr",
    "baseName": "clear_csr",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "column_security_rules",
    "baseName": "column_security_rules",
    "type": "Array<ColumnSecurityRuleUpdate>",
    "format": ""
  }
];
var UpdateColumnSecurityRulesRequest = _UpdateColumnSecurityRulesRequest;

// models/UpdateConfigRequest.ts
var _UpdateConfigRequest = class _UpdateConfigRequest {
  static getAttributeTypeMap() {
    return _UpdateConfigRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateConfigRequest.discriminator = void 0;
_UpdateConfigRequest.attributeTypeMap = [
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  },
  {
    "name": "access_token",
    "baseName": "access_token",
    "type": "string",
    "format": ""
  },
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "branch_names",
    "baseName": "branch_names",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "commit_branch_name",
    "baseName": "commit_branch_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "enable_guid_mapping",
    "baseName": "enable_guid_mapping",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "configuration_branch_name",
    "baseName": "configuration_branch_name",
    "type": "string",
    "format": ""
  }
];
var UpdateConfigRequest = _UpdateConfigRequest;

// models/UpdateConnectionConfigurationRequest.ts
var _UpdateConnectionConfigurationRequest = class _UpdateConnectionConfigurationRequest {
  static getAttributeTypeMap() {
    return _UpdateConnectionConfigurationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateConnectionConfigurationRequest.discriminator = void 0;
_UpdateConnectionConfigurationRequest.attributeTypeMap = [
  {
    "name": "connection_identifier",
    "baseName": "connection_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "same_as_parent",
    "baseName": "same_as_parent",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "policy_process_options",
    "baseName": "policy_process_options",
    "type": "CreateConnectionConfigurationRequestPolicyProcessOptions",
    "format": ""
  },
  {
    "name": "authentication_type",
    "baseName": "authentication_type",
    "type": "UpdateConnectionConfigurationRequestAuthenticationTypeEnum",
    "format": ""
  },
  {
    "name": "configuration",
    "baseName": "configuration",
    "type": "any",
    "format": ""
  },
  {
    "name": "policy_type",
    "baseName": "policy_type",
    "type": "UpdateConnectionConfigurationRequestPolicyTypeEnum",
    "format": ""
  },
  {
    "name": "policy_principals",
    "baseName": "policy_principals",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "policy_processes",
    "baseName": "policy_processes",
    "type": "Array<UpdateConnectionConfigurationRequestPolicyProcessesEnum>",
    "format": ""
  },
  {
    "name": "disable",
    "baseName": "disable",
    "type": "boolean",
    "format": ""
  }
];
var UpdateConnectionConfigurationRequest = _UpdateConnectionConfigurationRequest;

// models/UpdateConnectionRequest.ts
var _UpdateConnectionRequest = class _UpdateConnectionRequest {
  static getAttributeTypeMap() {
    return _UpdateConnectionRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateConnectionRequest.discriminator = void 0;
_UpdateConnectionRequest.attributeTypeMap = [
  {
    "name": "connection_identifier",
    "baseName": "connection_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_warehouse_config",
    "baseName": "data_warehouse_config",
    "type": "any",
    "format": ""
  },
  {
    "name": "validate",
    "baseName": "validate",
    "type": "boolean",
    "format": ""
  }
];
var UpdateConnectionRequest = _UpdateConnectionRequest;

// models/UpdateConnectionV2Request.ts
var _UpdateConnectionV2Request = class _UpdateConnectionV2Request {
  static getAttributeTypeMap() {
    return _UpdateConnectionV2Request.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateConnectionV2Request.discriminator = void 0;
_UpdateConnectionV2Request.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "data_warehouse_config",
    "baseName": "data_warehouse_config",
    "type": "any",
    "format": ""
  },
  {
    "name": "validate",
    "baseName": "validate",
    "type": "boolean",
    "format": ""
  }
];
var UpdateConnectionV2Request = _UpdateConnectionV2Request;

// models/UpdateCustomActionRequest.ts
var _UpdateCustomActionRequest = class _UpdateCustomActionRequest {
  static getAttributeTypeMap() {
    return _UpdateCustomActionRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateCustomActionRequest.discriminator = void 0;
_UpdateCustomActionRequest.attributeTypeMap = [
  {
    "name": "action_details",
    "baseName": "action_details",
    "type": "UpdateCustomActionRequestActionDetails",
    "format": ""
  },
  {
    "name": "associate_metadata",
    "baseName": "associate_metadata",
    "type": "Array<AssociateMetadataInput>",
    "format": ""
  },
  {
    "name": "default_action_config",
    "baseName": "default_action_config",
    "type": "UpdateCustomActionRequestDefaultActionConfig",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "operation",
    "baseName": "operation",
    "type": "UpdateCustomActionRequestOperationEnum",
    "format": ""
  }
];
var UpdateCustomActionRequest = _UpdateCustomActionRequest;

// models/UpdateCustomActionRequestActionDetails.ts
var _UpdateCustomActionRequestActionDetails = class _UpdateCustomActionRequestActionDetails {
  static getAttributeTypeMap() {
    return _UpdateCustomActionRequestActionDetails.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateCustomActionRequestActionDetails.discriminator = void 0;
_UpdateCustomActionRequestActionDetails.attributeTypeMap = [
  {
    "name": "CALLBACK",
    "baseName": "CALLBACK",
    "type": "CALLBACKInput",
    "format": ""
  },
  {
    "name": "URL",
    "baseName": "URL",
    "type": "URLInput",
    "format": ""
  }
];
var UpdateCustomActionRequestActionDetails = _UpdateCustomActionRequestActionDetails;

// models/UpdateCustomActionRequestDefaultActionConfig.ts
var _UpdateCustomActionRequestDefaultActionConfig = class _UpdateCustomActionRequestDefaultActionConfig {
  static getAttributeTypeMap() {
    return _UpdateCustomActionRequestDefaultActionConfig.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateCustomActionRequestDefaultActionConfig.discriminator = void 0;
_UpdateCustomActionRequestDefaultActionConfig.attributeTypeMap = [
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "boolean",
    "format": ""
  }
];
var UpdateCustomActionRequestDefaultActionConfig = _UpdateCustomActionRequestDefaultActionConfig;

// models/UpdateEmailCustomizationRequest.ts
var _UpdateEmailCustomizationRequest = class _UpdateEmailCustomizationRequest {
  static getAttributeTypeMap() {
    return _UpdateEmailCustomizationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateEmailCustomizationRequest.discriminator = void 0;
_UpdateEmailCustomizationRequest.attributeTypeMap = [
  {
    "name": "template_properties",
    "baseName": "template_properties",
    "type": "CreateEmailCustomizationRequestTemplateProperties",
    "format": ""
  },
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  }
];
var UpdateEmailCustomizationRequest = _UpdateEmailCustomizationRequest;

// models/UpdateMetadataHeaderRequest.ts
var _UpdateMetadataHeaderRequest = class _UpdateMetadataHeaderRequest {
  static getAttributeTypeMap() {
    return _UpdateMetadataHeaderRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateMetadataHeaderRequest.discriminator = void 0;
_UpdateMetadataHeaderRequest.attributeTypeMap = [
  {
    "name": "headers_update",
    "baseName": "headers_update",
    "type": "Array<HeaderUpdateInput>",
    "format": ""
  },
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  }
];
var UpdateMetadataHeaderRequest = _UpdateMetadataHeaderRequest;

// models/UpdateMetadataObjIdRequest.ts
var _UpdateMetadataObjIdRequest = class _UpdateMetadataObjIdRequest {
  static getAttributeTypeMap() {
    return _UpdateMetadataObjIdRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateMetadataObjIdRequest.discriminator = void 0;
_UpdateMetadataObjIdRequest.attributeTypeMap = [
  {
    "name": "metadata",
    "baseName": "metadata",
    "type": "Array<UpdateObjIdInput>",
    "format": ""
  }
];
var UpdateMetadataObjIdRequest = _UpdateMetadataObjIdRequest;

// models/UpdateObjIdInput.ts
var _UpdateObjIdInput = class _UpdateObjIdInput {
  static getAttributeTypeMap() {
    return _UpdateObjIdInput.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateObjIdInput.discriminator = void 0;
_UpdateObjIdInput.attributeTypeMap = [
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "UpdateObjIdInputTypeEnum",
    "format": ""
  },
  {
    "name": "current_obj_id",
    "baseName": "current_obj_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "new_obj_id",
    "baseName": "new_obj_id",
    "type": "string",
    "format": ""
  }
];
var UpdateObjIdInput = _UpdateObjIdInput;

// models/UpdateOrgRequest.ts
var _UpdateOrgRequest = class _UpdateOrgRequest {
  static getAttributeTypeMap() {
    return _UpdateOrgRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateOrgRequest.discriminator = void 0;
_UpdateOrgRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "user_identifiers",
    "baseName": "user_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "operation",
    "baseName": "operation",
    "type": "UpdateOrgRequestOperationEnum",
    "format": ""
  }
];
var UpdateOrgRequest = _UpdateOrgRequest;

// models/UpdateRoleRequest.ts
var _UpdateRoleRequest = class _UpdateRoleRequest {
  static getAttributeTypeMap() {
    return _UpdateRoleRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateRoleRequest.discriminator = void 0;
_UpdateRoleRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<UpdateRoleRequestPrivilegesEnum>",
    "format": ""
  }
];
var UpdateRoleRequest = _UpdateRoleRequest;

// models/UpdateScheduleRequest.ts
var _UpdateScheduleRequest = class _UpdateScheduleRequest {
  static getAttributeTypeMap() {
    return _UpdateScheduleRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateScheduleRequest.discriminator = void 0;
_UpdateScheduleRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "metadata_type",
    "baseName": "metadata_type",
    "type": "UpdateScheduleRequestMetadataTypeEnum",
    "format": ""
  },
  {
    "name": "metadata_identifier",
    "baseName": "metadata_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "file_format",
    "baseName": "file_format",
    "type": "UpdateScheduleRequestFileFormatEnum",
    "format": ""
  },
  {
    "name": "liveboard_options",
    "baseName": "liveboard_options",
    "type": "UpdateScheduleRequestLiveboardOptions",
    "format": ""
  },
  {
    "name": "pdf_options",
    "baseName": "pdf_options",
    "type": "UpdateScheduleRequestPdfOptions",
    "format": ""
  },
  {
    "name": "time_zone",
    "baseName": "time_zone",
    "type": "UpdateScheduleRequestTimeZoneEnum",
    "format": ""
  },
  {
    "name": "frequency",
    "baseName": "frequency",
    "type": "UpdateScheduleRequestFrequency",
    "format": ""
  },
  {
    "name": "recipient_details",
    "baseName": "recipient_details",
    "type": "UpdateScheduleRequestRecipientDetails",
    "format": ""
  },
  {
    "name": "status",
    "baseName": "status",
    "type": "UpdateScheduleRequestStatusEnum",
    "format": ""
  },
  {
    "name": "personalised_view_id",
    "baseName": "personalised_view_id",
    "type": "string",
    "format": ""
  }
];
var UpdateScheduleRequest = _UpdateScheduleRequest;

// models/UpdateScheduleRequestFrequency.ts
var _UpdateScheduleRequestFrequency = class _UpdateScheduleRequestFrequency {
  static getAttributeTypeMap() {
    return _UpdateScheduleRequestFrequency.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateScheduleRequestFrequency.discriminator = void 0;
_UpdateScheduleRequestFrequency.attributeTypeMap = [
  {
    "name": "cron_expression",
    "baseName": "cron_expression",
    "type": "CronExpressionInput",
    "format": ""
  }
];
var UpdateScheduleRequestFrequency = _UpdateScheduleRequestFrequency;

// models/UpdateScheduleRequestLiveboardOptions.ts
var _UpdateScheduleRequestLiveboardOptions = class _UpdateScheduleRequestLiveboardOptions {
  static getAttributeTypeMap() {
    return _UpdateScheduleRequestLiveboardOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateScheduleRequestLiveboardOptions.discriminator = void 0;
_UpdateScheduleRequestLiveboardOptions.attributeTypeMap = [
  {
    "name": "visualization_identifiers",
    "baseName": "visualization_identifiers",
    "type": "Array<string>",
    "format": ""
  }
];
var UpdateScheduleRequestLiveboardOptions = _UpdateScheduleRequestLiveboardOptions;

// models/UpdateScheduleRequestPdfOptions.ts
var _UpdateScheduleRequestPdfOptions = class _UpdateScheduleRequestPdfOptions {
  static getAttributeTypeMap() {
    return _UpdateScheduleRequestPdfOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateScheduleRequestPdfOptions.discriminator = void 0;
_UpdateScheduleRequestPdfOptions.attributeTypeMap = [
  {
    "name": "complete_liveboard",
    "baseName": "complete_liveboard",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_cover_page",
    "baseName": "include_cover_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_custom_logo",
    "baseName": "include_custom_logo",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_filter_page",
    "baseName": "include_filter_page",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "include_page_number",
    "baseName": "include_page_number",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "page_footer_text",
    "baseName": "page_footer_text",
    "type": "string",
    "format": ""
  },
  {
    "name": "page_orientation",
    "baseName": "page_orientation",
    "type": "string",
    "format": ""
  },
  {
    "name": "page_size",
    "baseName": "page_size",
    "type": "UpdateScheduleRequestPdfOptionsPageSizeEnum",
    "format": ""
  },
  {
    "name": "truncate_table",
    "baseName": "truncate_table",
    "type": "boolean",
    "format": ""
  }
];
var UpdateScheduleRequestPdfOptions = _UpdateScheduleRequestPdfOptions;

// models/UpdateScheduleRequestRecipientDetails.ts
var _UpdateScheduleRequestRecipientDetails = class _UpdateScheduleRequestRecipientDetails {
  static getAttributeTypeMap() {
    return _UpdateScheduleRequestRecipientDetails.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateScheduleRequestRecipientDetails.discriminator = void 0;
_UpdateScheduleRequestRecipientDetails.attributeTypeMap = [
  {
    "name": "emails",
    "baseName": "emails",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "principals",
    "baseName": "principals",
    "type": "Array<PrincipalsListItemInput>",
    "format": ""
  }
];
var UpdateScheduleRequestRecipientDetails = _UpdateScheduleRequestRecipientDetails;

// models/UpdateSystemConfigRequest.ts
var _UpdateSystemConfigRequest = class _UpdateSystemConfigRequest {
  static getAttributeTypeMap() {
    return _UpdateSystemConfigRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateSystemConfigRequest.discriminator = void 0;
_UpdateSystemConfigRequest.attributeTypeMap = [
  {
    "name": "configuration",
    "baseName": "configuration",
    "type": "any",
    "format": ""
  }
];
var UpdateSystemConfigRequest = _UpdateSystemConfigRequest;

// models/UpdateTagRequest.ts
var _UpdateTagRequest = class _UpdateTagRequest {
  static getAttributeTypeMap() {
    return _UpdateTagRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateTagRequest.discriminator = void 0;
_UpdateTagRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "color",
    "baseName": "color",
    "type": "string",
    "format": ""
  }
];
var UpdateTagRequest = _UpdateTagRequest;

// models/UpdateUserGroupRequest.ts
var _UpdateUserGroupRequest = class _UpdateUserGroupRequest {
  static getAttributeTypeMap() {
    return _UpdateUserGroupRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateUserGroupRequest.discriminator = void 0;
_UpdateUserGroupRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "default_liveboard_identifiers",
    "baseName": "default_liveboard_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<UpdateUserGroupRequestPrivilegesEnum>",
    "format": ""
  },
  {
    "name": "sub_group_identifiers",
    "baseName": "sub_group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "UpdateUserGroupRequestTypeEnum",
    "format": ""
  },
  {
    "name": "user_identifiers",
    "baseName": "user_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "UpdateUserGroupRequestVisibilityEnum",
    "format": ""
  },
  {
    "name": "role_identifiers",
    "baseName": "role_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "operation",
    "baseName": "operation",
    "type": "UpdateUserGroupRequestOperationEnum",
    "format": ""
  }
];
var UpdateUserGroupRequest = _UpdateUserGroupRequest;

// models/UpdateUserRequest.ts
var _UpdateUserRequest = class _UpdateUserRequest {
  static getAttributeTypeMap() {
    return _UpdateUserRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateUserRequest.discriminator = void 0;
_UpdateUserRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "UpdateUserRequestVisibilityEnum",
    "format": ""
  },
  {
    "name": "email",
    "baseName": "email",
    "type": "string",
    "format": ""
  },
  {
    "name": "account_status",
    "baseName": "account_status",
    "type": "UpdateUserRequestAccountStatusEnum",
    "format": ""
  },
  {
    "name": "notify_on_share",
    "baseName": "notify_on_share",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "show_onboarding_experience",
    "baseName": "show_onboarding_experience",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "onboarding_experience_completed",
    "baseName": "onboarding_experience_completed",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "account_type",
    "baseName": "account_type",
    "type": "UpdateUserRequestAccountTypeEnum",
    "format": ""
  },
  {
    "name": "group_identifiers",
    "baseName": "group_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "home_liveboard_identifier",
    "baseName": "home_liveboard_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "favorite_metadata",
    "baseName": "favorite_metadata",
    "type": "Array<FavoriteMetadataInput>",
    "format": ""
  },
  {
    "name": "org_identifiers",
    "baseName": "org_identifiers",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "operation",
    "baseName": "operation",
    "type": "UpdateUserRequestOperationEnum",
    "format": ""
  },
  {
    "name": "preferred_locale",
    "baseName": "preferred_locale",
    "type": "UpdateUserRequestPreferredLocaleEnum",
    "format": ""
  },
  {
    "name": "extended_properties",
    "baseName": "extended_properties",
    "type": "any",
    "format": ""
  },
  {
    "name": "extended_preferences",
    "baseName": "extended_preferences",
    "type": "any",
    "format": ""
  }
];
var UpdateUserRequest = _UpdateUserRequest;

// models/UpdateVariableRequest.ts
var _UpdateVariableRequest = class _UpdateVariableRequest {
  static getAttributeTypeMap() {
    return _UpdateVariableRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateVariableRequest.discriminator = void 0;
_UpdateVariableRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var UpdateVariableRequest = _UpdateVariableRequest;

// models/UpdateVariableValuesRequest.ts
var _UpdateVariableValuesRequest = class _UpdateVariableValuesRequest {
  static getAttributeTypeMap() {
    return _UpdateVariableValuesRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateVariableValuesRequest.discriminator = void 0;
_UpdateVariableValuesRequest.attributeTypeMap = [
  {
    "name": "variable_assignment",
    "baseName": "variable_assignment",
    "type": "Array<VariableUpdateAssignmentInput>",
    "format": ""
  },
  {
    "name": "variable_value_scope",
    "baseName": "variable_value_scope",
    "type": "Array<VariableUpdateScopeInput>",
    "format": ""
  }
];
var UpdateVariableValuesRequest = _UpdateVariableValuesRequest;

// models/UpdateWebhookConfigurationRequest.ts
var _UpdateWebhookConfigurationRequest = class _UpdateWebhookConfigurationRequest {
  static getAttributeTypeMap() {
    return _UpdateWebhookConfigurationRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_UpdateWebhookConfigurationRequest.discriminator = void 0;
_UpdateWebhookConfigurationRequest.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "url",
    "baseName": "url",
    "type": "string",
    "format": ""
  },
  {
    "name": "url_params",
    "baseName": "url_params",
    "type": "any",
    "format": ""
  },
  {
    "name": "events",
    "baseName": "events",
    "type": "Array<UpdateWebhookConfigurationRequestEventsEnum>",
    "format": ""
  },
  {
    "name": "authentication",
    "baseName": "authentication",
    "type": "CreateWebhookConfigurationRequestAuthentication",
    "format": ""
  },
  {
    "name": "signature_verification",
    "baseName": "signature_verification",
    "type": "CreateWebhookConfigurationRequestSignatureVerification",
    "format": ""
  }
];
var UpdateWebhookConfigurationRequest = _UpdateWebhookConfigurationRequest;

// models/User.ts
var _User = class _User {
  static getAttributeTypeMap() {
    return _User.attributeTypeMap;
  }
  constructor() {
  }
};
_User.discriminator = void 0;
_User.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "UserVisibilityEnum",
    "format": ""
  },
  {
    "name": "author_id",
    "baseName": "author_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "can_change_password",
    "baseName": "can_change_password",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "complete_detail",
    "baseName": "complete_detail",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "current_org",
    "baseName": "current_org",
    "type": "Org",
    "format": ""
  },
  {
    "name": "deleted",
    "baseName": "deleted",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "deprecated",
    "baseName": "deprecated",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "account_type",
    "baseName": "account_type",
    "type": "UserAccountTypeEnum",
    "format": ""
  },
  {
    "name": "account_status",
    "baseName": "account_status",
    "type": "UserAccountStatusEnum",
    "format": ""
  },
  {
    "name": "email",
    "baseName": "email",
    "type": "string",
    "format": ""
  },
  {
    "name": "expiration_time_in_millis",
    "baseName": "expiration_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "external",
    "baseName": "external",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "favorite_metadata",
    "baseName": "favorite_metadata",
    "type": "Array<FavoriteMetadataItem>",
    "format": ""
  },
  {
    "name": "first_login_time_in_millis",
    "baseName": "first_login_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "group_mask",
    "baseName": "group_mask",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "hidden",
    "baseName": "hidden",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "home_liveboard",
    "baseName": "home_liveboard",
    "type": "ObjectIDAndName",
    "format": ""
  },
  {
    "name": "incomplete_details",
    "baseName": "incomplete_details",
    "type": "any",
    "format": ""
  },
  {
    "name": "is_first_login",
    "baseName": "is_first_login",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "modification_time_in_millis",
    "baseName": "modification_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "modifier_id",
    "baseName": "modifier_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "notify_on_share",
    "baseName": "notify_on_share",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "onboarding_experience_completed",
    "baseName": "onboarding_experience_completed",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "orgs",
    "baseName": "orgs",
    "type": "Array<Org>",
    "format": ""
  },
  {
    "name": "owner_id",
    "baseName": "owner_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "parent_type",
    "baseName": "parent_type",
    "type": "UserParentTypeEnum",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "show_onboarding_experience",
    "baseName": "show_onboarding_experience",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "super_user",
    "baseName": "super_user",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "system_user",
    "baseName": "system_user",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "tags",
    "baseName": "tags",
    "type": "Array<ObjectIDAndName>",
    "format": ""
  },
  {
    "name": "tenant_id",
    "baseName": "tenant_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "user_groups",
    "baseName": "user_groups",
    "type": "Array<ObjectIDAndName>",
    "format": ""
  },
  {
    "name": "user_inherited_groups",
    "baseName": "user_inherited_groups",
    "type": "Array<ObjectIDAndName>",
    "format": ""
  },
  {
    "name": "welcome_email_sent",
    "baseName": "welcome_email_sent",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "org_privileges",
    "baseName": "org_privileges",
    "type": "any",
    "format": ""
  },
  {
    "name": "preferred_locale",
    "baseName": "preferred_locale",
    "type": "string",
    "format": ""
  },
  {
    "name": "extended_properties",
    "baseName": "extended_properties",
    "type": "any",
    "format": ""
  },
  {
    "name": "extended_preferences",
    "baseName": "extended_preferences",
    "type": "any",
    "format": ""
  },
  {
    "name": "user_parameters",
    "baseName": "user_parameters",
    "type": "any",
    "format": ""
  },
  {
    "name": "access_control_properties",
    "baseName": "access_control_properties",
    "type": "any",
    "format": ""
  },
  {
    "name": "variable_values",
    "baseName": "variable_values",
    "type": "any",
    "format": ""
  }
];
var User = _User;

// models/UserGroup.ts
var _UserGroup = class _UserGroup {
  static getAttributeTypeMap() {
    return _UserGroup.attributeTypeMap;
  }
  constructor() {
  }
};
_UserGroup.discriminator = void 0;
_UserGroup.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var UserGroup = _UserGroup;

// models/UserGroupResponse.ts
var _UserGroupResponse = class _UserGroupResponse {
  static getAttributeTypeMap() {
    return _UserGroupResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_UserGroupResponse.discriminator = void 0;
_UserGroupResponse.attributeTypeMap = [
  {
    "name": "author_id",
    "baseName": "author_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "complete_detail",
    "baseName": "complete_detail",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "content",
    "baseName": "content",
    "type": "any",
    "format": ""
  },
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "default_liveboards",
    "baseName": "default_liveboards",
    "type": "Array<UserGroup>",
    "format": ""
  },
  {
    "name": "deleted",
    "baseName": "deleted",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "deprecated",
    "baseName": "deprecated",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "display_name",
    "baseName": "display_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "external",
    "baseName": "external",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "generation_number",
    "baseName": "generation_number",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "hidden",
    "baseName": "hidden",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "index",
    "baseName": "index",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "index_version",
    "baseName": "index_version",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "metadata_version",
    "baseName": "metadata_version",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "modification_time_in_millis",
    "baseName": "modification_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "modifier_id",
    "baseName": "modifier_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "orgs",
    "baseName": "orgs",
    "type": "Array<UserGroup>",
    "format": ""
  },
  {
    "name": "owner_id",
    "baseName": "owner_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "parent_type",
    "baseName": "parent_type",
    "type": "UserGroupResponseParentTypeEnum",
    "format": ""
  },
  {
    "name": "privileges",
    "baseName": "privileges",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "sub_groups",
    "baseName": "sub_groups",
    "type": "Array<UserGroup>",
    "format": ""
  },
  {
    "name": "system_group",
    "baseName": "system_group",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "tags",
    "baseName": "tags",
    "type": "Array<UserGroup>",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "UserGroupResponseTypeEnum",
    "format": ""
  },
  {
    "name": "users",
    "baseName": "users",
    "type": "Array<UserGroup>",
    "format": ""
  },
  {
    "name": "visibility",
    "baseName": "visibility",
    "type": "UserGroupResponseVisibilityEnum",
    "format": ""
  },
  {
    "name": "roles",
    "baseName": "roles",
    "type": "Array<Role>",
    "format": ""
  }
];
var UserGroupResponse = _UserGroupResponse;

// models/UserInfo.ts
var _UserInfo = class _UserInfo {
  static getAttributeTypeMap() {
    return _UserInfo.attributeTypeMap;
  }
  constructor() {
  }
};
_UserInfo.discriminator = void 0;
_UserInfo.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var UserInfo = _UserInfo;

// models/UserObject.ts
var _UserObject = class _UserObject {
  static getAttributeTypeMap() {
    return _UserObject.attributeTypeMap;
  }
  constructor() {
  }
};
_UserObject.discriminator = void 0;
_UserObject.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "UserObjectTypeEnum",
    "format": ""
  },
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  }
];
var UserObject = _UserObject;

// models/UserParameterOptions.ts
var _UserParameterOptions = class _UserParameterOptions {
  static getAttributeTypeMap() {
    return _UserParameterOptions.attributeTypeMap;
  }
  constructor() {
  }
};
_UserParameterOptions.discriminator = void 0;
_UserParameterOptions.attributeTypeMap = [
  {
    "name": "objects",
    "baseName": "objects",
    "type": "Array<UserObject>",
    "format": ""
  },
  {
    "name": "runtime_filters",
    "baseName": "runtime_filters",
    "type": "Array<RuntimeFilters>",
    "format": ""
  },
  {
    "name": "runtime_sorts",
    "baseName": "runtime_sorts",
    "type": "Array<RuntimeSorts>",
    "format": ""
  },
  {
    "name": "parameters",
    "baseName": "parameters",
    "type": "Array<RuntimeParameters>",
    "format": ""
  }
];
var UserParameterOptions = _UserParameterOptions;

// models/UserPrincipal.ts
var _UserPrincipal = class _UserPrincipal {
  static getAttributeTypeMap() {
    return _UserPrincipal.attributeTypeMap;
  }
  constructor() {
  }
};
_UserPrincipal.discriminator = void 0;
_UserPrincipal.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "string",
    "format": ""
  }
];
var UserPrincipal = _UserPrincipal;

// models/ValidateMergeRequest.ts
var _ValidateMergeRequest = class _ValidateMergeRequest {
  static getAttributeTypeMap() {
    return _ValidateMergeRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ValidateMergeRequest.discriminator = void 0;
_ValidateMergeRequest.attributeTypeMap = [
  {
    "name": "source_branch_name",
    "baseName": "source_branch_name",
    "type": "string",
    "format": ""
  },
  {
    "name": "target_branch_name",
    "baseName": "target_branch_name",
    "type": "string",
    "format": ""
  }
];
var ValidateMergeRequest = _ValidateMergeRequest;

// models/ValidateTokenRequest.ts
var _ValidateTokenRequest = class _ValidateTokenRequest {
  static getAttributeTypeMap() {
    return _ValidateTokenRequest.attributeTypeMap;
  }
  constructor() {
  }
};
_ValidateTokenRequest.discriminator = void 0;
_ValidateTokenRequest.attributeTypeMap = [
  {
    "name": "token",
    "baseName": "token",
    "type": "string",
    "format": ""
  }
];
var ValidateTokenRequest = _ValidateTokenRequest;

// models/ValueScopeInput.ts
var _ValueScopeInput = class _ValueScopeInput {
  static getAttributeTypeMap() {
    return _ValueScopeInput.attributeTypeMap;
  }
  constructor() {
  }
};
_ValueScopeInput.discriminator = void 0;
_ValueScopeInput.attributeTypeMap = [
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "principal_type",
    "baseName": "principal_type",
    "type": "ValueScopeInputPrincipalTypeEnum",
    "format": ""
  },
  {
    "name": "principal_identifier",
    "baseName": "principal_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "model_identifier",
    "baseName": "model_identifier",
    "type": "string",
    "format": ""
  }
];
var ValueScopeInput = _ValueScopeInput;

// models/Variable.ts
var _Variable = class _Variable {
  static getAttributeTypeMap() {
    return _Variable.attributeTypeMap;
  }
  constructor() {
  }
};
_Variable.discriminator = void 0;
_Variable.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "variable_type",
    "baseName": "variable_type",
    "type": "VariableVariableTypeEnum",
    "format": ""
  },
  {
    "name": "sensitive",
    "baseName": "sensitive",
    "type": "boolean",
    "format": ""
  },
  {
    "name": "values",
    "baseName": "values",
    "type": "Array<VariableValue>",
    "format": ""
  }
];
var Variable = _Variable;

// models/VariableDetailInput.ts
var _VariableDetailInput = class _VariableDetailInput {
  static getAttributeTypeMap() {
    return _VariableDetailInput.attributeTypeMap;
  }
  constructor() {
  }
};
_VariableDetailInput.discriminator = void 0;
_VariableDetailInput.attributeTypeMap = [
  {
    "name": "identifier",
    "baseName": "identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "type",
    "baseName": "type",
    "type": "VariableDetailInputTypeEnum",
    "format": ""
  },
  {
    "name": "name_pattern",
    "baseName": "name_pattern",
    "type": "string",
    "format": ""
  }
];
var VariableDetailInput = _VariableDetailInput;

// models/VariableUpdateAssignmentInput.ts
var _VariableUpdateAssignmentInput = class _VariableUpdateAssignmentInput {
  static getAttributeTypeMap() {
    return _VariableUpdateAssignmentInput.attributeTypeMap;
  }
  constructor() {
  }
};
_VariableUpdateAssignmentInput.discriminator = void 0;
_VariableUpdateAssignmentInput.attributeTypeMap = [
  {
    "name": "variable_identifier",
    "baseName": "variable_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "variable_values",
    "baseName": "variable_values",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "operation",
    "baseName": "operation",
    "type": "VariableUpdateAssignmentInputOperationEnum",
    "format": ""
  }
];
var VariableUpdateAssignmentInput = _VariableUpdateAssignmentInput;

// models/VariableUpdateScopeInput.ts
var _VariableUpdateScopeInput = class _VariableUpdateScopeInput {
  static getAttributeTypeMap() {
    return _VariableUpdateScopeInput.attributeTypeMap;
  }
  constructor() {
  }
};
_VariableUpdateScopeInput.discriminator = void 0;
_VariableUpdateScopeInput.attributeTypeMap = [
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "principal_type",
    "baseName": "principal_type",
    "type": "VariableUpdateScopeInputPrincipalTypeEnum",
    "format": ""
  },
  {
    "name": "principal_identifier",
    "baseName": "principal_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "model_identifier",
    "baseName": "model_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "priority",
    "baseName": "priority",
    "type": "number",
    "format": "int32"
  }
];
var VariableUpdateScopeInput = _VariableUpdateScopeInput;

// models/VariableValue.ts
var _VariableValue = class _VariableValue {
  static getAttributeTypeMap() {
    return _VariableValue.attributeTypeMap;
  }
  constructor() {
  }
};
_VariableValue.discriminator = void 0;
_VariableValue.attributeTypeMap = [
  {
    "name": "value",
    "baseName": "value",
    "type": "string",
    "format": ""
  },
  {
    "name": "value_list",
    "baseName": "value_list",
    "type": "Array<string>",
    "format": ""
  },
  {
    "name": "org_identifier",
    "baseName": "org_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "principal_type",
    "baseName": "principal_type",
    "type": "VariableValuePrincipalTypeEnum",
    "format": ""
  },
  {
    "name": "principal_identifier",
    "baseName": "principal_identifier",
    "type": "string",
    "format": ""
  },
  {
    "name": "priority",
    "baseName": "priority",
    "type": "number",
    "format": "int32"
  }
];
var VariableValue = _VariableValue;

// models/VariableValues.ts
var _VariableValues = class _VariableValues {
  static getAttributeTypeMap() {
    return _VariableValues.attributeTypeMap;
  }
  constructor() {
  }
};
_VariableValues.discriminator = void 0;
_VariableValues.attributeTypeMap = [
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "values",
    "baseName": "values",
    "type": "Array<any>",
    "format": ""
  }
];
var VariableValues = _VariableValues;

// models/WebhookAuthApiKey.ts
var _WebhookAuthApiKey = class _WebhookAuthApiKey {
  static getAttributeTypeMap() {
    return _WebhookAuthApiKey.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookAuthApiKey.discriminator = void 0;
_WebhookAuthApiKey.attributeTypeMap = [
  {
    "name": "key",
    "baseName": "key",
    "type": "string",
    "format": ""
  },
  {
    "name": "value",
    "baseName": "value",
    "type": "string",
    "format": ""
  }
];
var WebhookAuthApiKey = _WebhookAuthApiKey;

// models/WebhookAuthApiKeyInput.ts
var _WebhookAuthApiKeyInput = class _WebhookAuthApiKeyInput {
  static getAttributeTypeMap() {
    return _WebhookAuthApiKeyInput.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookAuthApiKeyInput.discriminator = void 0;
_WebhookAuthApiKeyInput.attributeTypeMap = [
  {
    "name": "key",
    "baseName": "key",
    "type": "string",
    "format": ""
  },
  {
    "name": "value",
    "baseName": "value",
    "type": "string",
    "format": ""
  }
];
var WebhookAuthApiKeyInput = _WebhookAuthApiKeyInput;

// models/WebhookAuthBasicAuth.ts
var _WebhookAuthBasicAuth = class _WebhookAuthBasicAuth {
  static getAttributeTypeMap() {
    return _WebhookAuthBasicAuth.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookAuthBasicAuth.discriminator = void 0;
_WebhookAuthBasicAuth.attributeTypeMap = [
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  },
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  }
];
var WebhookAuthBasicAuth = _WebhookAuthBasicAuth;

// models/WebhookAuthBasicAuthInput.ts
var _WebhookAuthBasicAuthInput = class _WebhookAuthBasicAuthInput {
  static getAttributeTypeMap() {
    return _WebhookAuthBasicAuthInput.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookAuthBasicAuthInput.discriminator = void 0;
_WebhookAuthBasicAuthInput.attributeTypeMap = [
  {
    "name": "username",
    "baseName": "username",
    "type": "string",
    "format": ""
  },
  {
    "name": "password",
    "baseName": "password",
    "type": "string",
    "format": ""
  }
];
var WebhookAuthBasicAuthInput = _WebhookAuthBasicAuthInput;

// models/WebhookAuthOAuth2.ts
var _WebhookAuthOAuth2 = class _WebhookAuthOAuth2 {
  static getAttributeTypeMap() {
    return _WebhookAuthOAuth2.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookAuthOAuth2.discriminator = void 0;
_WebhookAuthOAuth2.attributeTypeMap = [
  {
    "name": "authorization_url",
    "baseName": "authorization_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "client_id",
    "baseName": "client_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "client_secret",
    "baseName": "client_secret",
    "type": "string",
    "format": ""
  }
];
var WebhookAuthOAuth2 = _WebhookAuthOAuth2;

// models/WebhookAuthOAuth2Input.ts
var _WebhookAuthOAuth2Input = class _WebhookAuthOAuth2Input {
  static getAttributeTypeMap() {
    return _WebhookAuthOAuth2Input.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookAuthOAuth2Input.discriminator = void 0;
_WebhookAuthOAuth2Input.attributeTypeMap = [
  {
    "name": "authorization_url",
    "baseName": "authorization_url",
    "type": "string",
    "format": ""
  },
  {
    "name": "client_id",
    "baseName": "client_id",
    "type": "string",
    "format": ""
  },
  {
    "name": "client_secret",
    "baseName": "client_secret",
    "type": "string",
    "format": ""
  }
];
var WebhookAuthOAuth2Input = _WebhookAuthOAuth2Input;

// models/WebhookAuthentication.ts
var _WebhookAuthentication = class _WebhookAuthentication {
  static getAttributeTypeMap() {
    return _WebhookAuthentication.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookAuthentication.discriminator = void 0;
_WebhookAuthentication.attributeTypeMap = [
  {
    "name": "API_KEY",
    "baseName": "API_KEY",
    "type": "WebhookAuthApiKey",
    "format": ""
  },
  {
    "name": "BASIC_AUTH",
    "baseName": "BASIC_AUTH",
    "type": "WebhookAuthBasicAuth",
    "format": ""
  },
  {
    "name": "BEARER_TOKEN",
    "baseName": "BEARER_TOKEN",
    "type": "string",
    "format": ""
  },
  {
    "name": "OAUTH2",
    "baseName": "OAUTH2",
    "type": "WebhookAuthOAuth2",
    "format": ""
  }
];
var WebhookAuthentication = _WebhookAuthentication;

// models/WebhookAuthenticationInput.ts
var _WebhookAuthenticationInput = class _WebhookAuthenticationInput {
  static getAttributeTypeMap() {
    return _WebhookAuthenticationInput.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookAuthenticationInput.discriminator = void 0;
_WebhookAuthenticationInput.attributeTypeMap = [
  {
    "name": "API_KEY",
    "baseName": "API_KEY",
    "type": "WebhookAuthApiKeyInput",
    "format": ""
  },
  {
    "name": "BASIC_AUTH",
    "baseName": "BASIC_AUTH",
    "type": "WebhookAuthBasicAuthInput",
    "format": ""
  },
  {
    "name": "BEARER_TOKEN",
    "baseName": "BEARER_TOKEN",
    "type": "string",
    "format": ""
  },
  {
    "name": "OAUTH2",
    "baseName": "OAUTH2",
    "type": "WebhookAuthOAuth2Input",
    "format": ""
  }
];
var WebhookAuthenticationInput = _WebhookAuthenticationInput;

// models/WebhookDeleteFailure.ts
var _WebhookDeleteFailure = class _WebhookDeleteFailure {
  static getAttributeTypeMap() {
    return _WebhookDeleteFailure.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookDeleteFailure.discriminator = void 0;
_WebhookDeleteFailure.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "error",
    "baseName": "error",
    "type": "string",
    "format": ""
  }
];
var WebhookDeleteFailure = _WebhookDeleteFailure;

// models/WebhookDeleteResponse.ts
var _WebhookDeleteResponse = class _WebhookDeleteResponse {
  static getAttributeTypeMap() {
    return _WebhookDeleteResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookDeleteResponse.discriminator = void 0;
_WebhookDeleteResponse.attributeTypeMap = [
  {
    "name": "deleted_count",
    "baseName": "deleted_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "failed_count",
    "baseName": "failed_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "deleted_webhooks",
    "baseName": "deleted_webhooks",
    "type": "Array<WebhookResponse>",
    "format": ""
  },
  {
    "name": "failed_webhooks",
    "baseName": "failed_webhooks",
    "type": "Array<WebhookDeleteFailure>",
    "format": ""
  }
];
var WebhookDeleteResponse = _WebhookDeleteResponse;

// models/WebhookOrg.ts
var _WebhookOrg = class _WebhookOrg {
  static getAttributeTypeMap() {
    return _WebhookOrg.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookOrg.discriminator = void 0;
_WebhookOrg.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var WebhookOrg = _WebhookOrg;

// models/WebhookPagination.ts
var _WebhookPagination = class _WebhookPagination {
  static getAttributeTypeMap() {
    return _WebhookPagination.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookPagination.discriminator = void 0;
_WebhookPagination.attributeTypeMap = [
  {
    "name": "record_offset",
    "baseName": "record_offset",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "record_size",
    "baseName": "record_size",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "total_count",
    "baseName": "total_count",
    "type": "number",
    "format": "int32"
  },
  {
    "name": "has_more",
    "baseName": "has_more",
    "type": "boolean",
    "format": ""
  }
];
var WebhookPagination = _WebhookPagination;

// models/WebhookResponse.ts
var _WebhookResponse = class _WebhookResponse {
  static getAttributeTypeMap() {
    return _WebhookResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookResponse.discriminator = void 0;
_WebhookResponse.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  },
  {
    "name": "description",
    "baseName": "description",
    "type": "string",
    "format": ""
  },
  {
    "name": "org",
    "baseName": "org",
    "type": "WebhookOrg",
    "format": ""
  },
  {
    "name": "url",
    "baseName": "url",
    "type": "string",
    "format": ""
  },
  {
    "name": "url_params",
    "baseName": "url_params",
    "type": "any",
    "format": ""
  },
  {
    "name": "events",
    "baseName": "events",
    "type": "Array<WebhookResponseEventsEnum>",
    "format": ""
  },
  {
    "name": "authentication",
    "baseName": "authentication",
    "type": "WebhookAuthentication",
    "format": ""
  },
  {
    "name": "signature_verification",
    "baseName": "signature_verification",
    "type": "WebhookSignatureVerification",
    "format": ""
  },
  {
    "name": "creation_time_in_millis",
    "baseName": "creation_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "modification_time_in_millis",
    "baseName": "modification_time_in_millis",
    "type": "number",
    "format": "float"
  },
  {
    "name": "created_by",
    "baseName": "created_by",
    "type": "WebhookUser",
    "format": ""
  },
  {
    "name": "last_modified_by",
    "baseName": "last_modified_by",
    "type": "WebhookUser",
    "format": ""
  }
];
var WebhookResponse = _WebhookResponse;

// models/WebhookSearchResponse.ts
var _WebhookSearchResponse = class _WebhookSearchResponse {
  static getAttributeTypeMap() {
    return _WebhookSearchResponse.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookSearchResponse.discriminator = void 0;
_WebhookSearchResponse.attributeTypeMap = [
  {
    "name": "webhooks",
    "baseName": "webhooks",
    "type": "Array<WebhookResponse>",
    "format": ""
  },
  {
    "name": "pagination",
    "baseName": "pagination",
    "type": "WebhookPagination",
    "format": ""
  }
];
var WebhookSearchResponse = _WebhookSearchResponse;

// models/WebhookSignatureVerification.ts
var _WebhookSignatureVerification = class _WebhookSignatureVerification {
  static getAttributeTypeMap() {
    return _WebhookSignatureVerification.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookSignatureVerification.discriminator = void 0;
_WebhookSignatureVerification.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "WebhookSignatureVerificationTypeEnum",
    "format": ""
  },
  {
    "name": "header",
    "baseName": "header",
    "type": "string",
    "format": ""
  },
  {
    "name": "algorithm",
    "baseName": "algorithm",
    "type": "WebhookSignatureVerificationAlgorithmEnum",
    "format": ""
  },
  {
    "name": "secret",
    "baseName": "secret",
    "type": "string",
    "format": ""
  }
];
var WebhookSignatureVerification = _WebhookSignatureVerification;

// models/WebhookSignatureVerificationInput.ts
var _WebhookSignatureVerificationInput = class _WebhookSignatureVerificationInput {
  static getAttributeTypeMap() {
    return _WebhookSignatureVerificationInput.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookSignatureVerificationInput.discriminator = void 0;
_WebhookSignatureVerificationInput.attributeTypeMap = [
  {
    "name": "type",
    "baseName": "type",
    "type": "WebhookSignatureVerificationInputTypeEnum",
    "format": ""
  },
  {
    "name": "header",
    "baseName": "header",
    "type": "string",
    "format": ""
  },
  {
    "name": "algorithm",
    "baseName": "algorithm",
    "type": "WebhookSignatureVerificationInputAlgorithmEnum",
    "format": ""
  },
  {
    "name": "secret",
    "baseName": "secret",
    "type": "string",
    "format": ""
  }
];
var WebhookSignatureVerificationInput = _WebhookSignatureVerificationInput;

// models/WebhookSortOptionsInput.ts
var _WebhookSortOptionsInput = class _WebhookSortOptionsInput {
  static getAttributeTypeMap() {
    return _WebhookSortOptionsInput.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookSortOptionsInput.discriminator = void 0;
_WebhookSortOptionsInput.attributeTypeMap = [
  {
    "name": "field_name",
    "baseName": "field_name",
    "type": "WebhookSortOptionsInputFieldNameEnum",
    "format": ""
  },
  {
    "name": "order",
    "baseName": "order",
    "type": "WebhookSortOptionsInputOrderEnum",
    "format": ""
  }
];
var WebhookSortOptionsInput = _WebhookSortOptionsInput;

// models/WebhookUser.ts
var _WebhookUser = class _WebhookUser {
  static getAttributeTypeMap() {
    return _WebhookUser.attributeTypeMap;
  }
  constructor() {
  }
};
_WebhookUser.discriminator = void 0;
_WebhookUser.attributeTypeMap = [
  {
    "name": "id",
    "baseName": "id",
    "type": "string",
    "format": ""
  },
  {
    "name": "name",
    "baseName": "name",
    "type": "string",
    "format": ""
  }
];
var WebhookUser = _WebhookUser;

// middleware.ts
var PromiseMiddlewareWrapper = class {
  constructor(middleware) {
    this.middleware = middleware;
  }
  pre(context) {
    return from(this.middleware.pre(context));
  }
  post(context) {
    return from(this.middleware.post(context));
  }
};

// servers.ts
var ServerConfiguration = class {
  constructor(url, variableConfiguration) {
    this.url = url;
    this.variableConfiguration = variableConfiguration;
  }
  /**
   * Sets the value of the variables of this server. Variables are included in 
   * the `url` of this ServerConfiguration in the form `{variableName}`
   *
   * @param variableConfiguration a partial variable configuration for the 
   * variables contained in the url
   */
  setVariables(variableConfiguration) {
    Object.assign(this.variableConfiguration, variableConfiguration);
  }
  getConfiguration() {
    return this.variableConfiguration;
  }
  getUrl() {
    let replacedUrl = this.url;
    for (const key in this.variableConfiguration) {
      var re = new RegExp("{" + key + "}", "g");
      replacedUrl = replacedUrl.replace(re, this.variableConfiguration[key]);
    }
    return replacedUrl;
  }
  /**
   * Creates a new request context for this server using the url with variables
   * replaced with their respective values and the endpoint of the request appended.
   *
   * @param endpoint the endpoint to be queried on the server
   * @param httpMethod httpMethod to be used
   *
   */
  makeRequestContext(endpoint, httpMethod) {
    return new RequestContext2(this.getUrl() + endpoint, httpMethod);
  }
};
var server1 = new ServerConfiguration("{base-url}", { "base-url": "https://localhost:443" });
var servers = [server1];

// configuration.ts
function createConfiguration(conf = {}) {
  const configuration = {
    baseServer: conf.baseServer !== void 0 ? conf.baseServer : server1,
    httpApi: conf.httpApi || new IsomorphicFetchHttpLibrary(),
    middleware: conf.middleware || [],
    authMethods: configureAuthMethods(conf.authMethods)
  };
  if (conf.promiseMiddleware) {
    conf.promiseMiddleware.forEach(
      (m) => configuration.middleware.push(new PromiseMiddlewareWrapper(m))
    );
  }
  return configuration;
}

// apis/exception.ts
var ApiException = class extends Error {
  constructor(code, message, body, headers) {
    super("HTTP-Code: " + code + "\nMessage: " + message + "\nBody: " + JSON.stringify(body) + "\nHeaders: " + JSON.stringify(headers));
    this.code = code;
    this.body = body;
    this.headers = headers;
  }
};

// apis/baseapi.ts
var BaseAPIRequestFactory = class {
  constructor(configuration) {
    this.configuration = configuration;
  }
};
var RequiredError = class extends Error {
  constructor(api, method, field) {
    super("Required parameter " + field + " was null or undefined when calling " + api + "." + method + ".");
    this.api = api;
    this.method = method;
    this.field = field;
    this.name = "RequiredError";
  }
};

// models/ObjectSerializer.ts
var primitives = [
  "string",
  "boolean",
  "double",
  "integer",
  "long",
  "float",
  "number",
  "any"
];
var supportedMediaTypes = {
  "application/json": Infinity,
  "application/octet-stream": 0,
  "application/x-www-form-urlencoded": 0
};
var enumsMap = /* @__PURE__ */ new Set([
  "ActionConfigInputPositionEnum",
  "ActionConfigInputCreatePositionEnum",
  "AssociateMetadataInputTypeEnum",
  "AssociateMetadataInputCreateTypeEnum",
  "AuthorMetadataTypeInputTypeEnum",
  "ColumnSecurityRuleGroupOperationOperationEnum",
  "ConnectionConfigurationResponsePolicyProcessesEnum",
  "ConnectionConfigurationResponseDataWarehouseTypeEnum",
  "ConnectionConfigurationResponsePolicyTypeEnum",
  "ConnectionConfigurationSearchRequestPolicyTypeEnum",
  "ContextPayloadV2InputTypeEnum",
  "CopyObjectRequestTypeEnum",
  "CreateAgentConversationRequestMetadataContextTypeEnum",
  "CreateCalendarRequestCreationMethodEnum",
  "CreateCalendarRequestCalendarTypeEnum",
  "CreateCalendarRequestMonthOffsetEnum",
  "CreateCalendarRequestStartDayOfWeekEnum",
  "CreateConnectionConfigurationRequestAuthenticationTypeEnum",
  "CreateConnectionConfigurationRequestPolicyTypeEnum",
  "CreateConnectionConfigurationRequestPolicyProcessesEnum",
  "CreateConnectionRequestDataWarehouseTypeEnum",
  "CreateConnectionResponseDataWarehouseTypeEnum",
  "CreateRoleRequestPrivilegesEnum",
  "CreateScheduleRequestMetadataTypeEnum",
  "CreateScheduleRequestFileFormatEnum",
  "CreateScheduleRequestTimeZoneEnum",
  "CreateScheduleRequestPdfOptionsPageSizeEnum",
  "CreateUserGroupRequestPrivilegesEnum",
  "CreateUserGroupRequestTypeEnum",
  "CreateUserGroupRequestVisibilityEnum",
  "CreateUserRequestAccountTypeEnum",
  "CreateUserRequestAccountStatusEnum",
  "CreateUserRequestVisibilityEnum",
  "CreateUserRequestPreferredLocaleEnum",
  "CreateVariableRequestTypeEnum",
  "CreateVariableRequestDataTypeEnum",
  "CreateWebhookConfigurationRequestEventsEnum",
  "CreateWebhookConfigurationRequestSignatureVerificationTypeEnum",
  "CreateWebhookConfigurationRequestSignatureVerificationAlgorithmEnum",
  "CustomActionMetadataTypeInputTypeEnum",
  "DeleteMetadataTypeInputTypeEnum",
  "DeployCommitRequestDeployTypeEnum",
  "DeployCommitRequestDeployPolicyEnum",
  "EventChannelConfigEventTypeEnum",
  "EventChannelConfigChannelsEnum",
  "EventChannelConfigInputEventTypeEnum",
  "EventChannelConfigInputChannelsEnum",
  "ExcludeMetadataListItemInputTypeEnum",
  "ExportAnswerReportRequestFileFormatEnum",
  "ExportAnswerReportRequestRegionalSettingsCurrencyFormatEnum",
  "ExportAnswerReportRequestRegionalSettingsUserLocaleEnum",
  "ExportAnswerReportRequestRegionalSettingsNumberFormatLocaleEnum",
  "ExportAnswerReportRequestRegionalSettingsDateFormatLocaleEnum",
  "ExportLiveboardReportRequestFileFormatEnum",
  "ExportLiveboardReportRequestPdfOptionsPageOrientationEnum",
  "ExportMetadataTMLBatchedRequestMetadataTypeEnum",
  "ExportMetadataTMLBatchedRequestEdocFormatEnum",
  "ExportMetadataTMLRequestEdocFormatEnum",
  "ExportMetadataTMLRequestExportSchemaVersionEnum",
  "ExportMetadataTypeInputTypeEnum",
  "FavoriteMetadataInputTypeEnum",
  "FavoriteMetadataItemTypeEnum",
  "FetchAnswerDataRequestDataFormatEnum",
  "FetchAsyncImportTaskStatusRequestTaskStatusEnum",
  "FetchLiveboardDataRequestDataFormatEnum",
  "FetchLogsRequestLogTypeEnum",
  "FetchPermissionsOfPrincipalsRequestDefaultMetadataTypeEnum",
  "FilterRulesOperatorEnum",
  "GenerateCSVRequestCalendarTypeEnum",
  "GenerateCSVRequestMonthOffsetEnum",
  "GenerateCSVRequestStartDayOfWeekEnum",
  "GetCustomAccessTokenRequestPersistOptionEnum",
  "GroupsImportListInputPrivilegesEnum",
  "GroupsImportListInputTypeEnum",
  "GroupsImportListInputVisibilityEnum",
  "HeaderUpdateInputTypeEnum",
  "ImportEPackAsyncTaskStatusTaskStatusEnum",
  "ImportEPackAsyncTaskStatusImportPolicyEnum",
  "ImportMetadataTMLAsyncRequestImportPolicyEnum",
  "ImportMetadataTMLRequestImportPolicyEnum",
  "ImportUserAccountTypeEnum",
  "ImportUserAccountStatusEnum",
  "ImportUserVisibilityEnum",
  "JWTMetadataObjectTypeEnum",
  "MetadataInputTypeEnum",
  "MetadataListItemInputTypeEnum",
  "MetadataListItemInputSubtypesEnum",
  "MetadataObjectTypeEnum",
  "MetadataResponseTypeEnum",
  "MetadataSearchResponseMetadataTypeEnum",
  "MetadataSearchSortOptionsFieldNameEnum",
  "MetadataSearchSortOptionsOrderEnum",
  "NLInstructionsInfoScopeEnum",
  "NLInstructionsInfoInputScopeEnum",
  "OrgChannelConfigInputOperationEnum",
  "OrgChannelConfigInputResetEventsEnum",
  "OrgPreferenceSearchCriteriaInputEventTypesEnum",
  "OrgResponseStatusEnum",
  "OrgResponseVisibilityEnum",
  "ParameterizeMetadataRequestMetadataTypeEnum",
  "ParameterizeMetadataRequestFieldTypeEnum",
  "PdfOptionsPageSizeEnum",
  "PdfOptionsInputPageOrientationEnum",
  "PermissionInputShareModeEnum",
  "PermissionsMetadataTypeInputTypeEnum",
  "PrincipalsInputTypeEnum",
  "PublishMetadataListItemTypeEnum",
  "RegionalSettingsInputCurrencyFormatEnum",
  "RegionalSettingsInputUserLocaleEnum",
  "RegionalSettingsInputNumberFormatLocaleEnum",
  "RegionalSettingsInputDateFormatLocaleEnum",
  "ResponseMessageMessageTypeEnum",
  "ResponseMessageVisualizationTypeEnum",
  "RevertCommitRequestRevertPolicyEnum",
  "RoleResponsePrivilegesEnum",
  "RoleResponsePermissionEnum",
  "RuntimeFiltersOperatorEnum",
  "RuntimeSortsOrderEnum",
  "SchedulesPdfOptionsInputPageSizeEnum",
  "SearchCalendarsRequestSortOptionsFieldNameEnum",
  "SearchCalendarsRequestSortOptionsOrderEnum",
  "SearchCommitsRequestMetadataTypeEnum",
  "SearchCommunicationChannelPreferencesRequestClusterPreferencesEnum",
  "SearchConnectionRequestDataWarehouseTypesEnum",
  "SearchConnectionRequestDataWarehouseObjectTypeEnum",
  "SearchConnectionRequestAuthenticationTypeEnum",
  "SearchConnectionRequestSortOptionsFieldNameEnum",
  "SearchConnectionRequestSortOptionsOrderEnum",
  "SearchConnectionResponseDataWarehouseTypeEnum",
  "SearchCustomActionsRequestTypeEnum",
  "SearchDataRequestDataFormatEnum",
  "SearchMetadataRequestDependentObjectVersionEnum",
  "SearchMetadataRequestLiveboardResponseVersionEnum",
  "SearchMetadataRequestSortOptionsFieldNameEnum",
  "SearchMetadataRequestSortOptionsOrderEnum",
  "SearchOrgsRequestVisibilityEnum",
  "SearchOrgsRequestStatusEnum",
  "SearchRoleResponsePrivilegesEnum",
  "SearchRoleResponsePermissionEnum",
  "SearchRolesRequestPrivilegesEnum",
  "SearchRolesRequestPermissionsEnum",
  "SearchUserGroupsRequestPrivilegesEnum",
  "SearchUserGroupsRequestTypeEnum",
  "SearchUserGroupsRequestVisibilityEnum",
  "SearchUserGroupsRequestSortOptionsFieldNameEnum",
  "SearchUserGroupsRequestSortOptionsOrderEnum",
  "SearchUsersRequestVisibilityEnum",
  "SearchUsersRequestPrivilegesEnum",
  "SearchUsersRequestAccountTypeEnum",
  "SearchUsersRequestAccountStatusEnum",
  "SearchUsersRequestSortOptionsFieldNameEnum",
  "SearchUsersRequestSortOptionsOrderEnum",
  "SearchVariablesRequestResponseContentEnum",
  "SearchWebhookConfigurationsRequestEventTypeEnum",
  "SearchWebhookConfigurationsRequestSortOptionsFieldNameEnum",
  "SearchWebhookConfigurationsRequestSortOptionsOrderEnum",
  "ShareMetadataRequestMetadataTypeEnum",
  "ShareMetadataTypeInputTypeEnum",
  "SharePermissionsInputShareModeEnum",
  "SortOptionFieldNameEnum",
  "SortOptionOrderEnum",
  "SortOptionInputFieldNameEnum",
  "SortOptionInputOrderEnum",
  "SortOptionsFieldNameEnum",
  "SortOptionsOrderEnum",
  "SqlQueryResponseMetadataTypeEnum",
  "TagMetadataTypeInputTypeEnum",
  "TokenAccessScopeObjectTypeEnum",
  "UnparameterizeMetadataRequestMetadataTypeEnum",
  "UnparameterizeMetadataRequestFieldTypeEnum",
  "UpdateCalendarRequestUpdateMethodEnum",
  "UpdateCalendarRequestCalendarTypeEnum",
  "UpdateCalendarRequestMonthOffsetEnum",
  "UpdateCalendarRequestStartDayOfWeekEnum",
  "UpdateConnectionConfigurationRequestAuthenticationTypeEnum",
  "UpdateConnectionConfigurationRequestPolicyTypeEnum",
  "UpdateConnectionConfigurationRequestPolicyProcessesEnum",
  "UpdateCustomActionRequestOperationEnum",
  "UpdateObjIdInputTypeEnum",
  "UpdateOrgRequestOperationEnum",
  "UpdateRoleRequestPrivilegesEnum",
  "UpdateScheduleRequestMetadataTypeEnum",
  "UpdateScheduleRequestFileFormatEnum",
  "UpdateScheduleRequestTimeZoneEnum",
  "UpdateScheduleRequestStatusEnum",
  "UpdateScheduleRequestPdfOptionsPageSizeEnum",
  "UpdateUserGroupRequestPrivilegesEnum",
  "UpdateUserGroupRequestTypeEnum",
  "UpdateUserGroupRequestVisibilityEnum",
  "UpdateUserGroupRequestOperationEnum",
  "UpdateUserRequestVisibilityEnum",
  "UpdateUserRequestAccountStatusEnum",
  "UpdateUserRequestAccountTypeEnum",
  "UpdateUserRequestOperationEnum",
  "UpdateUserRequestPreferredLocaleEnum",
  "UpdateWebhookConfigurationRequestEventsEnum",
  "UserVisibilityEnum",
  "UserAccountTypeEnum",
  "UserAccountStatusEnum",
  "UserParentTypeEnum",
  "UserGroupResponseParentTypeEnum",
  "UserGroupResponseTypeEnum",
  "UserGroupResponseVisibilityEnum",
  "UserObjectTypeEnum",
  "ValueScopeInputPrincipalTypeEnum",
  "VariableVariableTypeEnum",
  "VariableDetailInputTypeEnum",
  "VariableUpdateAssignmentInputOperationEnum",
  "VariableUpdateScopeInputPrincipalTypeEnum",
  "VariableValuePrincipalTypeEnum",
  "WebhookResponseEventsEnum",
  "WebhookSignatureVerificationTypeEnum",
  "WebhookSignatureVerificationAlgorithmEnum",
  "WebhookSignatureVerificationInputTypeEnum",
  "WebhookSignatureVerificationInputAlgorithmEnum",
  "WebhookSortOptionsInputFieldNameEnum",
  "WebhookSortOptionsInputOrderEnum"
]);
var typeMap = {
  "AIContext": AIContext,
  "APIKey": APIKey,
  "APIKeyInput": APIKeyInput,
  "AccessToken": AccessToken,
  "ActionConfig": ActionConfig,
  "ActionConfigInput": ActionConfigInput,
  "ActionConfigInputCreate": ActionConfigInputCreate,
  "ActionDetails": ActionDetails,
  "ActionDetailsInput": ActionDetailsInput,
  "ActionDetailsInputCreate": ActionDetailsInputCreate,
  "ActivateUserRequest": ActivateUserRequest,
  "AgentConversation": AgentConversation,
  "AnswerContent": AnswerContent,
  "AnswerContextInput": AnswerContextInput,
  "AnswerDataResponse": AnswerDataResponse,
  "AssignChangeAuthorRequest": AssignChangeAuthorRequest,
  "AssignTagRequest": AssignTagRequest,
  "AssociateMetadataInput": AssociateMetadataInput,
  "AssociateMetadataInputCreate": AssociateMetadataInputCreate,
  "Authentication": Authentication,
  "AuthenticationInput": AuthenticationInput,
  "Author": Author,
  "AuthorMetadataTypeInput": AuthorMetadataTypeInput,
  "AuthorType": AuthorType,
  "BasicAuth": BasicAuth,
  "BasicAuthInput": BasicAuthInput,
  "CALLBACK": CALLBACK,
  "CALLBACKInput": CALLBACKInput,
  "CALLBACKInputMandatory": CALLBACKInputMandatory,
  "CalendarResponse": CalendarResponse,
  "ChangeUserPasswordRequest": ChangeUserPasswordRequest,
  "ClusterNonEmbedAccess": ClusterNonEmbedAccess,
  "ClusterNonEmbedAccessInput": ClusterNonEmbedAccessInput,
  "Column": Column,
  "ColumnSecurityRule": ColumnSecurityRule,
  "ColumnSecurityRuleColumn": ColumnSecurityRuleColumn,
  "ColumnSecurityRuleGroup": ColumnSecurityRuleGroup,
  "ColumnSecurityRuleGroupOperation": ColumnSecurityRuleGroupOperation,
  "ColumnSecurityRuleResponse": ColumnSecurityRuleResponse,
  "ColumnSecurityRuleSourceTable": ColumnSecurityRuleSourceTable,
  "ColumnSecurityRuleTableInput": ColumnSecurityRuleTableInput,
  "ColumnSecurityRuleUpdate": ColumnSecurityRuleUpdate,
  "CommitBranchRequest": CommitBranchRequest,
  "CommitFileType": CommitFileType,
  "CommitHistoryResponse": CommitHistoryResponse,
  "CommitResponse": CommitResponse,
  "CommiterType": CommiterType,
  "CommunicationChannelPreferencesResponse": CommunicationChannelPreferencesResponse,
  "ConfigureCommunicationChannelPreferencesRequest": ConfigureCommunicationChannelPreferencesRequest,
  "ConnectionConfigurationResponse": ConnectionConfigurationResponse,
  "ConnectionConfigurationSearchRequest": ConnectionConfigurationSearchRequest,
  "ConnectionInput": ConnectionInput,
  "ContextPayloadV2Input": ContextPayloadV2Input,
  "Conversation": Conversation,
  "ConversationSettingsInput": ConversationSettingsInput,
  "ConvertWorksheetToModelRequest": ConvertWorksheetToModelRequest,
  "CopyObjectRequest": CopyObjectRequest,
  "CreateAgentConversationRequest": CreateAgentConversationRequest,
  "CreateAgentConversationRequestConversationSettings": CreateAgentConversationRequestConversationSettings,
  "CreateAgentConversationRequestMetadataContext": CreateAgentConversationRequestMetadataContext,
  "CreateCalendarRequest": CreateCalendarRequest,
  "CreateCalendarRequestTableReference": CreateCalendarRequestTableReference,
  "CreateConfigRequest": CreateConfigRequest,
  "CreateConnectionConfigurationRequest": CreateConnectionConfigurationRequest,
  "CreateConnectionConfigurationRequestPolicyProcessOptions": CreateConnectionConfigurationRequestPolicyProcessOptions,
  "CreateConnectionRequest": CreateConnectionRequest,
  "CreateConnectionResponse": CreateConnectionResponse,
  "CreateConversationRequest": CreateConversationRequest,
  "CreateCustomActionRequest": CreateCustomActionRequest,
  "CreateCustomActionRequestActionDetails": CreateCustomActionRequestActionDetails,
  "CreateCustomActionRequestDefaultActionConfig": CreateCustomActionRequestDefaultActionConfig,
  "CreateEmailCustomizationRequest": CreateEmailCustomizationRequest,
  "CreateEmailCustomizationRequestTemplateProperties": CreateEmailCustomizationRequestTemplateProperties,
  "CreateEmailCustomizationResponse": CreateEmailCustomizationResponse,
  "CreateOrgRequest": CreateOrgRequest,
  "CreateRoleRequest": CreateRoleRequest,
  "CreateScheduleRequest": CreateScheduleRequest,
  "CreateScheduleRequestFrequency": CreateScheduleRequestFrequency,
  "CreateScheduleRequestLiveboardOptions": CreateScheduleRequestLiveboardOptions,
  "CreateScheduleRequestPdfOptions": CreateScheduleRequestPdfOptions,
  "CreateScheduleRequestRecipientDetails": CreateScheduleRequestRecipientDetails,
  "CreateTagRequest": CreateTagRequest,
  "CreateUserGroupRequest": CreateUserGroupRequest,
  "CreateUserRequest": CreateUserRequest,
  "CreateVariableRequest": CreateVariableRequest,
  "CreateWebhookConfigurationRequest": CreateWebhookConfigurationRequest,
  "CreateWebhookConfigurationRequestAuthentication": CreateWebhookConfigurationRequestAuthentication,
  "CreateWebhookConfigurationRequestSignatureVerification": CreateWebhookConfigurationRequestSignatureVerification,
  "CronExpression": CronExpression,
  "CronExpressionInput": CronExpressionInput,
  "CspSettings": CspSettings,
  "CspSettingsInput": CspSettingsInput,
  "CustomActionMetadataTypeInput": CustomActionMetadataTypeInput,
  "DataSource": DataSource,
  "DataSourceContextInput": DataSourceContextInput,
  "DataWarehouseObjectInput": DataWarehouseObjectInput,
  "DataWarehouseObjects": DataWarehouseObjects,
  "Database": Database,
  "DbtSearchResponse": DbtSearchResponse,
  "DeactivateUserRequest": DeactivateUserRequest,
  "DefaultActionConfig": DefaultActionConfig,
  "DefaultActionConfigInput": DefaultActionConfigInput,
  "DefaultActionConfigInputCreate": DefaultActionConfigInputCreate,
  "DefaultActionConfigSearchInput": DefaultActionConfigSearchInput,
  "DeleteConfigRequest": DeleteConfigRequest,
  "DeleteConnectionConfigurationRequest": DeleteConnectionConfigurationRequest,
  "DeleteConnectionRequest": DeleteConnectionRequest,
  "DeleteMetadataRequest": DeleteMetadataRequest,
  "DeleteMetadataTypeInput": DeleteMetadataTypeInput,
  "DeleteOrgEmailCustomizationRequest": DeleteOrgEmailCustomizationRequest,
  "DeleteWebhookConfigurationsRequest": DeleteWebhookConfigurationsRequest,
  "DeployCommitRequest": DeployCommitRequest,
  "DeployResponse": DeployResponse,
  "EntityHeader": EntityHeader,
  "ErrorResponse": ErrorResponse,
  "EurekaDataSourceSuggestionResponse": EurekaDataSourceSuggestionResponse,
  "EurekaDecomposeQueryResponse": EurekaDecomposeQueryResponse,
  "EurekaGetNLInstructionsResponse": EurekaGetNLInstructionsResponse,
  "EurekaGetRelevantQuestionsResponse": EurekaGetRelevantQuestionsResponse,
  "EurekaLLMDecomposeQueryResponse": EurekaLLMDecomposeQueryResponse,
  "EurekaLLMSuggestedQuery": EurekaLLMSuggestedQuery,
  "EurekaRelevantQuestion": EurekaRelevantQuestion,
  "EurekaSetNLInstructionsResponse": EurekaSetNLInstructionsResponse,
  "EventChannelConfig": EventChannelConfig,
  "EventChannelConfigInput": EventChannelConfigInput,
  "ExcludeMetadataListItemInput": ExcludeMetadataListItemInput,
  "ExportAnswerReportRequest": ExportAnswerReportRequest,
  "ExportAnswerReportRequestRegionalSettings": ExportAnswerReportRequestRegionalSettings,
  "ExportLiveboardReportRequest": ExportLiveboardReportRequest,
  "ExportLiveboardReportRequestPdfOptions": ExportLiveboardReportRequestPdfOptions,
  "ExportLiveboardReportRequestPngOptions": ExportLiveboardReportRequestPngOptions,
  "ExportMetadataTMLBatchedRequest": ExportMetadataTMLBatchedRequest,
  "ExportMetadataTMLRequest": ExportMetadataTMLRequest,
  "ExportMetadataTMLRequestExportOptions": ExportMetadataTMLRequestExportOptions,
  "ExportMetadataTypeInput": ExportMetadataTypeInput,
  "ExportOptions": ExportOptions,
  "ExternalTableInput": ExternalTableInput,
  "FavoriteMetadataInput": FavoriteMetadataInput,
  "FavoriteMetadataItem": FavoriteMetadataItem,
  "FavoriteObjectOptionsInput": FavoriteObjectOptionsInput,
  "FetchAnswerDataRequest": FetchAnswerDataRequest,
  "FetchAnswerSqlQueryRequest": FetchAnswerSqlQueryRequest,
  "FetchAsyncImportTaskStatusRequest": FetchAsyncImportTaskStatusRequest,
  "FetchColumnSecurityRulesRequest": FetchColumnSecurityRulesRequest,
  "FetchConnectionDiffStatusResponse": FetchConnectionDiffStatusResponse,
  "FetchLiveboardDataRequest": FetchLiveboardDataRequest,
  "FetchLiveboardSqlQueryRequest": FetchLiveboardSqlQueryRequest,
  "FetchLogsRequest": FetchLogsRequest,
  "FetchPermissionsOfPrincipalsRequest": FetchPermissionsOfPrincipalsRequest,
  "FetchPermissionsOnMetadataRequest": FetchPermissionsOnMetadataRequest,
  "FilterRules": FilterRules,
  "ForceLogoutUsersRequest": ForceLogoutUsersRequest,
  "Frequency": Frequency,
  "FrequencyInput": FrequencyInput,
  "GenerateCSVRequest": GenerateCSVRequest,
  "GenericInfo": GenericInfo,
  "GetAsyncImportStatusResponse": GetAsyncImportStatusResponse,
  "GetCustomAccessTokenRequest": GetCustomAccessTokenRequest,
  "GetFullAccessTokenRequest": GetFullAccessTokenRequest,
  "GetFullAccessTokenRequestUserParameters": GetFullAccessTokenRequestUserParameters,
  "GetObjectAccessTokenRequest": GetObjectAccessTokenRequest,
  "GetRelevantQuestionsRequest": GetRelevantQuestionsRequest,
  "GetRelevantQuestionsRequestAiContext": GetRelevantQuestionsRequestAiContext,
  "GetRelevantQuestionsRequestMetadataContext": GetRelevantQuestionsRequestMetadataContext,
  "GetTokenResponse": GetTokenResponse,
  "GroupInfo": GroupInfo,
  "GroupObject": GroupObject,
  "GroupsImportListInput": GroupsImportListInput,
  "HeaderAttributeInput": HeaderAttributeInput,
  "HeaderUpdateInput": HeaderUpdateInput,
  "ImportEPackAsyncTaskStatus": ImportEPackAsyncTaskStatus,
  "ImportMetadataTMLAsyncRequest": ImportMetadataTMLAsyncRequest,
  "ImportMetadataTMLRequest": ImportMetadataTMLRequest,
  "ImportUser": ImportUser,
  "ImportUserGroupsRequest": ImportUserGroupsRequest,
  "ImportUserGroupsResponse": ImportUserGroupsResponse,
  "ImportUserType": ImportUserType,
  "ImportUsersRequest": ImportUsersRequest,
  "ImportUsersResponse": ImportUsersResponse,
  "InputEurekaNLSRequest": InputEurekaNLSRequest,
  "JWTMetadataObject": JWTMetadataObject,
  "JWTParameter": JWTParameter,
  "JWTUserOptions": JWTUserOptions,
  "JWTUserOptionsFull": JWTUserOptionsFull,
  "LBContextInput": LBContextInput,
  "LiveboardContent": LiveboardContent,
  "LiveboardDataResponse": LiveboardDataResponse,
  "LiveboardOptions": LiveboardOptions,
  "LiveboardOptionsInput": LiveboardOptionsInput,
  "LogResponse": LogResponse,
  "LoginRequest": LoginRequest,
  "MetadataAssociationItem": MetadataAssociationItem,
  "MetadataContext": MetadataContext,
  "MetadataInput": MetadataInput,
  "MetadataListItemInput": MetadataListItemInput,
  "MetadataObject": MetadataObject,
  "MetadataResponse": MetadataResponse,
  "MetadataSearchResponse": MetadataSearchResponse,
  "MetadataSearchSortOptions": MetadataSearchSortOptions,
  "ModelTableList": ModelTableList,
  "NLInstructionsInfo": NLInstructionsInfo,
  "NLInstructionsInfoInput": NLInstructionsInfoInput,
  "ObjectIDAndName": ObjectIDAndName,
  "Org": Org,
  "OrgChannelConfigInput": OrgChannelConfigInput,
  "OrgChannelConfigResponse": OrgChannelConfigResponse,
  "OrgDetails": OrgDetails,
  "OrgInfo": OrgInfo,
  "OrgNonEmbedAccess": OrgNonEmbedAccess,
  "OrgNonEmbedAccessInput": OrgNonEmbedAccessInput,
  "OrgPreferenceSearchCriteriaInput": OrgPreferenceSearchCriteriaInput,
  "OrgResponse": OrgResponse,
  "OrgType": OrgType,
  "ParameterValues": ParameterValues,
  "ParameterizeMetadataRequest": ParameterizeMetadataRequest,
  "ParametersListItem": ParametersListItem,
  "ParametersListItemInput": ParametersListItemInput,
  "PdfOptions": PdfOptions,
  "PdfOptionsInput": PdfOptionsInput,
  "PermissionInput": PermissionInput,
  "PermissionOfMetadataResponse": PermissionOfMetadataResponse,
  "PermissionOfPrincipalsResponse": PermissionOfPrincipalsResponse,
  "PermissionsMetadataTypeInput": PermissionsMetadataTypeInput,
  "PngOptionsInput": PngOptionsInput,
  "PolicyProcessOptions": PolicyProcessOptions,
  "PolicyProcessOptionsInput": PolicyProcessOptionsInput,
  "PrincipalsInput": PrincipalsInput,
  "PrincipalsListItem": PrincipalsListItem,
  "PrincipalsListItemInput": PrincipalsListItemInput,
  "PublishMetadataListItem": PublishMetadataListItem,
  "PublishMetadataRequest": PublishMetadataRequest,
  "QueryGetDecomposedQueryRequest": QueryGetDecomposedQueryRequest,
  "QueryGetDecomposedQueryRequestNlsRequest": QueryGetDecomposedQueryRequestNlsRequest,
  "RecipientDetails": RecipientDetails,
  "RecipientDetailsInput": RecipientDetailsInput,
  "RegionalSettingsInput": RegionalSettingsInput,
  "RepoConfigObject": RepoConfigObject,
  "ResetUserPasswordRequest": ResetUserPasswordRequest,
  "ResponseActivationURL": ResponseActivationURL,
  "ResponseCopyObject": ResponseCopyObject,
  "ResponseCustomAction": ResponseCustomAction,
  "ResponseFailedEntities": ResponseFailedEntities,
  "ResponseFailedEntity": ResponseFailedEntity,
  "ResponseIncompleteEntities": ResponseIncompleteEntities,
  "ResponseIncompleteEntity": ResponseIncompleteEntity,
  "ResponseMessage": ResponseMessage,
  "ResponsePostUpgradeFailedEntities": ResponsePostUpgradeFailedEntities,
  "ResponsePostUpgradeFailedEntity": ResponsePostUpgradeFailedEntity,
  "ResponseSchedule": ResponseSchedule,
  "ResponseScheduleRun": ResponseScheduleRun,
  "ResponseSuccessfulEntities": ResponseSuccessfulEntities,
  "ResponseSuccessfulEntity": ResponseSuccessfulEntity,
  "ResponseWorksheetToModelConversion": ResponseWorksheetToModelConversion,
  "RevertCommitRequest": RevertCommitRequest,
  "RevertResponse": RevertResponse,
  "RevertedMetadata": RevertedMetadata,
  "RevokeRefreshTokensResponse": RevokeRefreshTokensResponse,
  "RevokeTokenRequest": RevokeTokenRequest,
  "RiseGQLArgWrapper": RiseGQLArgWrapper,
  "RiseSetter": RiseSetter,
  "Role": Role,
  "RoleResponse": RoleResponse,
  "RuntimeFilter": RuntimeFilter,
  "RuntimeFilters": RuntimeFilters,
  "RuntimeParamOverride": RuntimeParamOverride,
  "RuntimeParameters": RuntimeParameters,
  "RuntimeSort": RuntimeSort,
  "RuntimeSorts": RuntimeSorts,
  "ScheduleHistoryRunsOptionsInput": ScheduleHistoryRunsOptionsInput,
  "SchedulesPdfOptionsInput": SchedulesPdfOptionsInput,
  "SchemaObject": SchemaObject,
  "Scope": Scope,
  "ScriptSrcUrls": ScriptSrcUrls,
  "ScriptSrcUrlsInput": ScriptSrcUrlsInput,
  "SearchCalendarsRequest": SearchCalendarsRequest,
  "SearchCalendarsRequestSortOptions": SearchCalendarsRequestSortOptions,
  "SearchCommitsRequest": SearchCommitsRequest,
  "SearchCommunicationChannelPreferencesRequest": SearchCommunicationChannelPreferencesRequest,
  "SearchConfigRequest": SearchConfigRequest,
  "SearchConnectionRequest": SearchConnectionRequest,
  "SearchConnectionRequestSortOptions": SearchConnectionRequestSortOptions,
  "SearchConnectionResponse": SearchConnectionResponse,
  "SearchCustomActionsRequest": SearchCustomActionsRequest,
  "SearchCustomActionsRequestDefaultActionConfig": SearchCustomActionsRequestDefaultActionConfig,
  "SearchDataRequest": SearchDataRequest,
  "SearchDataResponse": SearchDataResponse,
  "SearchEmailCustomizationRequest": SearchEmailCustomizationRequest,
  "SearchMetadataRequest": SearchMetadataRequest,
  "SearchMetadataRequestFavoriteObjectOptions": SearchMetadataRequestFavoriteObjectOptions,
  "SearchMetadataRequestSortOptions": SearchMetadataRequestSortOptions,
  "SearchOrgsRequest": SearchOrgsRequest,
  "SearchRoleResponse": SearchRoleResponse,
  "SearchRolesRequest": SearchRolesRequest,
  "SearchSchedulesRequest": SearchSchedulesRequest,
  "SearchSchedulesRequestHistoryRunsOptions": SearchSchedulesRequestHistoryRunsOptions,
  "SearchSchedulesRequestSortOptions": SearchSchedulesRequestSortOptions,
  "SearchTagsRequest": SearchTagsRequest,
  "SearchUserGroupsRequest": SearchUserGroupsRequest,
  "SearchUserGroupsRequestSortOptions": SearchUserGroupsRequestSortOptions,
  "SearchUsersRequest": SearchUsersRequest,
  "SearchUsersRequestSortOptions": SearchUsersRequestSortOptions,
  "SearchVariablesRequest": SearchVariablesRequest,
  "SearchWebhookConfigurationsRequest": SearchWebhookConfigurationsRequest,
  "SearchWebhookConfigurationsRequestSortOptions": SearchWebhookConfigurationsRequestSortOptions,
  "SecuritySettingsClusterPreferences": SecuritySettingsClusterPreferences,
  "SecuritySettingsClusterPreferencesInput": SecuritySettingsClusterPreferencesInput,
  "SecuritySettingsOrgDetails": SecuritySettingsOrgDetails,
  "SecuritySettingsOrgPreferences": SecuritySettingsOrgPreferences,
  "SecuritySettingsOrgPreferencesInput": SecuritySettingsOrgPreferencesInput,
  "SecuritySettingsResponse": SecuritySettingsResponse,
  "SendAgentMessageResponse": SendAgentMessageResponse,
  "SendAgentMessageStreamingRequest": SendAgentMessageStreamingRequest,
  "SendMessageRequest": SendMessageRequest,
  "ShareMetadataRequest": ShareMetadataRequest,
  "ShareMetadataTypeInput": ShareMetadataTypeInput,
  "SharePermissionsInput": SharePermissionsInput,
  "SingleAnswerRequest": SingleAnswerRequest,
  "SortOption": SortOption,
  "SortOptionInput": SortOptionInput,
  "SortOptions": SortOptions,
  "SortingOptions": SortingOptions,
  "SqlQuery": SqlQuery,
  "SqlQueryResponse": SqlQueryResponse,
  "SystemConfig": SystemConfig,
  "SystemInfo": SystemInfo,
  "SystemOverrideInfo": SystemOverrideInfo,
  "Table": Table,
  "Tag": Tag,
  "TagMetadataTypeInput": TagMetadataTypeInput,
  "TemplatePropertiesInputCreate": TemplatePropertiesInputCreate,
  "Token": Token,
  "TokenAccessScopeObject": TokenAccessScopeObject,
  "TokenValidationResponse": TokenValidationResponse,
  "URL": URL2,
  "URLInput": URLInput,
  "URLInputMandatory": URLInputMandatory,
  "UnparameterizeMetadataRequest": UnparameterizeMetadataRequest,
  "UnpublishMetadataRequest": UnpublishMetadataRequest,
  "UpdateCalendarRequest": UpdateCalendarRequest,
  "UpdateCalendarRequestTableReference": UpdateCalendarRequestTableReference,
  "UpdateColumnSecurityRulesRequest": UpdateColumnSecurityRulesRequest,
  "UpdateConfigRequest": UpdateConfigRequest,
  "UpdateConnectionConfigurationRequest": UpdateConnectionConfigurationRequest,
  "UpdateConnectionRequest": UpdateConnectionRequest,
  "UpdateConnectionV2Request": UpdateConnectionV2Request,
  "UpdateCustomActionRequest": UpdateCustomActionRequest,
  "UpdateCustomActionRequestActionDetails": UpdateCustomActionRequestActionDetails,
  "UpdateCustomActionRequestDefaultActionConfig": UpdateCustomActionRequestDefaultActionConfig,
  "UpdateEmailCustomizationRequest": UpdateEmailCustomizationRequest,
  "UpdateMetadataHeaderRequest": UpdateMetadataHeaderRequest,
  "UpdateMetadataObjIdRequest": UpdateMetadataObjIdRequest,
  "UpdateObjIdInput": UpdateObjIdInput,
  "UpdateOrgRequest": UpdateOrgRequest,
  "UpdateRoleRequest": UpdateRoleRequest,
  "UpdateScheduleRequest": UpdateScheduleRequest,
  "UpdateScheduleRequestFrequency": UpdateScheduleRequestFrequency,
  "UpdateScheduleRequestLiveboardOptions": UpdateScheduleRequestLiveboardOptions,
  "UpdateScheduleRequestPdfOptions": UpdateScheduleRequestPdfOptions,
  "UpdateScheduleRequestRecipientDetails": UpdateScheduleRequestRecipientDetails,
  "UpdateSystemConfigRequest": UpdateSystemConfigRequest,
  "UpdateTagRequest": UpdateTagRequest,
  "UpdateUserGroupRequest": UpdateUserGroupRequest,
  "UpdateUserRequest": UpdateUserRequest,
  "UpdateVariableRequest": UpdateVariableRequest,
  "UpdateVariableValuesRequest": UpdateVariableValuesRequest,
  "UpdateWebhookConfigurationRequest": UpdateWebhookConfigurationRequest,
  "User": User,
  "UserGroup": UserGroup,
  "UserGroupResponse": UserGroupResponse,
  "UserInfo": UserInfo,
  "UserObject": UserObject,
  "UserParameterOptions": UserParameterOptions,
  "UserPrincipal": UserPrincipal,
  "ValidateMergeRequest": ValidateMergeRequest,
  "ValidateTokenRequest": ValidateTokenRequest,
  "ValueScopeInput": ValueScopeInput,
  "Variable": Variable,
  "VariableDetailInput": VariableDetailInput,
  "VariableUpdateAssignmentInput": VariableUpdateAssignmentInput,
  "VariableUpdateScopeInput": VariableUpdateScopeInput,
  "VariableValue": VariableValue,
  "VariableValues": VariableValues,
  "WebhookAuthApiKey": WebhookAuthApiKey,
  "WebhookAuthApiKeyInput": WebhookAuthApiKeyInput,
  "WebhookAuthBasicAuth": WebhookAuthBasicAuth,
  "WebhookAuthBasicAuthInput": WebhookAuthBasicAuthInput,
  "WebhookAuthOAuth2": WebhookAuthOAuth2,
  "WebhookAuthOAuth2Input": WebhookAuthOAuth2Input,
  "WebhookAuthentication": WebhookAuthentication,
  "WebhookAuthenticationInput": WebhookAuthenticationInput,
  "WebhookDeleteFailure": WebhookDeleteFailure,
  "WebhookDeleteResponse": WebhookDeleteResponse,
  "WebhookOrg": WebhookOrg,
  "WebhookPagination": WebhookPagination,
  "WebhookResponse": WebhookResponse,
  "WebhookSearchResponse": WebhookSearchResponse,
  "WebhookSignatureVerification": WebhookSignatureVerification,
  "WebhookSignatureVerificationInput": WebhookSignatureVerificationInput,
  "WebhookSortOptionsInput": WebhookSortOptionsInput,
  "WebhookUser": WebhookUser
};
var ObjectSerializer = class _ObjectSerializer {
  static findCorrectType(data, expectedType) {
    if (data == void 0) {
      return expectedType;
    } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {
      return expectedType;
    } else if (expectedType === "Date") {
      return expectedType;
    } else {
      if (enumsMap.has(expectedType)) {
        return expectedType;
      }
      if (!typeMap[expectedType]) {
        return expectedType;
      }
      let discriminatorProperty = typeMap[expectedType].discriminator;
      if (discriminatorProperty == null) {
        return expectedType;
      } else {
        if (data[discriminatorProperty]) {
          var discriminatorType = data[discriminatorProperty];
          if (typeMap[discriminatorType]) {
            return discriminatorType;
          } else {
            return expectedType;
          }
        } else {
          return expectedType;
        }
      }
    }
  }
  static serialize(data, type, format) {
    if (data == void 0) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      let subType = type.replace("Array<", "");
      subType = subType.substring(0, subType.length - 1);
      let transformedData = [];
      for (let date of data) {
        transformedData.push(_ObjectSerializer.serialize(date, subType, format));
      }
      return transformedData;
    } else if (type === "Date") {
      if (format == "date") {
        let month = data.getMonth() + 1;
        month = month < 10 ? "0" + month.toString() : month.toString();
        let day = data.getDate();
        day = day < 10 ? "0" + day.toString() : day.toString();
        return data.getFullYear() + "-" + month + "-" + day;
      } else {
        return data.toISOString();
      }
    } else {
      if (enumsMap.has(type)) {
        return data;
      }
      if (!typeMap[type]) {
        return data;
      }
      type = this.findCorrectType(data, type);
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      let instance = {};
      for (let attributeType of attributeTypes) {
        instance[attributeType.baseName] = _ObjectSerializer.serialize(data[attributeType.name], attributeType.type, attributeType.format);
      }
      return instance;
    }
  }
  static deserialize(data, type, format) {
    type = _ObjectSerializer.findCorrectType(data, type);
    if (data == void 0) {
      return data;
    } else if (primitives.indexOf(type.toLowerCase()) !== -1) {
      return data;
    } else if (type.lastIndexOf("Array<", 0) === 0) {
      let subType = type.replace("Array<", "");
      subType = subType.substring(0, subType.length - 1);
      let transformedData = [];
      for (let date of data) {
        transformedData.push(_ObjectSerializer.deserialize(date, subType, format));
      }
      return transformedData;
    } else if (type === "Date") {
      return new Date(data);
    } else {
      if (enumsMap.has(type)) {
        return data;
      }
      if (!typeMap[type]) {
        return data;
      }
      let instance = new typeMap[type]();
      let attributeTypes = typeMap[type].getAttributeTypeMap();
      for (let attributeType of attributeTypes) {
        let value = _ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);
        if (value !== void 0) {
          instance[attributeType.name] = value;
        }
      }
      return instance;
    }
  }
  /**
   * Normalize media type
   *
   * We currently do not handle any media types attributes, i.e. anything
   * after a semicolon. All content is assumed to be UTF-8 compatible.
   */
  static normalizeMediaType(mediaType) {
    if (mediaType === void 0) {
      return void 0;
    }
    return mediaType.split(";")[0].trim().toLowerCase();
  }
  /**
   * From a list of possible media types, choose the one we can handle best.
   *
   * The order of the given media types does not have any impact on the choice
   * made.
   */
  static getPreferredMediaType(mediaTypes) {
    if (!mediaTypes) {
      return "application/json";
    }
    const normalMediaTypes = mediaTypes.map(this.normalizeMediaType);
    let selectedMediaType = void 0;
    let selectedRank = -Infinity;
    for (const mediaType of normalMediaTypes) {
      if (supportedMediaTypes[mediaType] > selectedRank) {
        selectedMediaType = mediaType;
        selectedRank = supportedMediaTypes[mediaType];
      }
    }
    if (selectedMediaType === void 0) {
      throw new Error("None of the given media types are supported: " + mediaTypes.join(", "));
    }
    return selectedMediaType;
  }
  /**
   * Convert data to a string according the given media type
   */
  static stringify(data, mediaType) {
    if (mediaType === "text/plain") {
      return String(data);
    }
    if (mediaType === "application/json") {
      return JSON.stringify(data);
    }
    throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.stringify.");
  }
  /**
   * Parse data from a string according to the given media type
   */
  static parse(rawData, mediaType) {
    if (mediaType === void 0) {
      throw new Error("Cannot parse content. No Content-Type defined.");
    }
    if (mediaType === "text/plain") {
      return rawData;
    }
    if (mediaType === "application/json") {
      return JSON.parse(rawData);
    }
    if (mediaType === "text/html") {
      return rawData;
    }
    throw new Error("The mediaType " + mediaType + " is not supported by ObjectSerializer.parse.");
  }
};

// util.ts
function isCodeInRange(codeRange, code) {
  if (codeRange === "0") {
    return true;
  }
  if (codeRange == code.toString()) {
    return true;
  } else {
    const codeString = code.toString();
    if (codeString.length != codeRange.length) {
      return false;
    }
    for (let i = 0; i < codeString.length; i++) {
      if (codeRange.charAt(i) != "X" && codeRange.charAt(i) != codeString.charAt(i)) {
        return false;
      }
    }
    return true;
  }
}
function canConsumeForm(contentTypes) {
  return contentTypes.indexOf("multipart/form-data") !== -1;
}

// apis/AIApi.ts
var AIApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   * Version: 10.13.0.cl or later 
   * @param createAgentConversationRequest 
   */
  createAgentConversation(createAgentConversationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createAgentConversationRequest === null || createAgentConversationRequest === void 0) {
        throw new RequiredError("AIApi", "createAgentConversation", "createAgentConversationRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/agent/conversation/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createAgentConversationRequest, "CreateAgentConversationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.4.0.cl or later   Creates a Conversation object to start an AI-driven conversation based on a specific data model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  This API requires the `metadata_identifier` parameter to define the context for the conversation.  You can also specify the tokens to initiate the conversation as shown in this example:  `\"tokens\": \"[tea],[sales],[type]\"`  If the API request is successful, ThoughtSpot returns the ID of the conversation.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param createConversationRequest 
   */
  createConversation(createConversationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createConversationRequest === null || createConversationRequest === void 0) {
        throw new RequiredError("AIApi", "createConversation", "createConversationRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/conversation/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createConversationRequest, "CreateConversationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.13.0.cl or later   Breaks down a user-submitted query into a series of analytical sub-questions using relevant contextual metadata.  To use this API, the user must have at least view-level access to the referenced metadata objects.  #### Usage guidelines  To accurately generate relevant questions, the request must include at least one of the following metadata identifiers within `metadata_context` : `conversation_identifier`, `answer_identifiers`, `liveboard_identifiers`, or `data_source_identifiers`.  You can further enhance the quality and precision of breakdown by providing additional `ai_context` such as:  - `content`: User provided content like text data, csv data as a string message to provide context & potentially improve the quality of the response. - `instructions`: User specific text instructions sent to AI system for processing the query.  Additional optional parameters include:  - `limit_relevant_questions`: Controls the maximum number of relevant questions returned. Defaults to 5 if not specified. - `bypass_cache`: If set to true, forces fresh computation instead of returning cached results.  If the API request is successful, ThoughtSpot returns a list of relevant analytical queries, each aligned with the user\'s original question. Each returned question includes the query string, along with the identifier and name of the corresponding data source.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.     
   * @param getRelevantQuestionsRequest 
   */
  getRelevantQuestions(getRelevantQuestionsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (getRelevantQuestionsRequest === null || getRelevantQuestionsRequest === void 0) {
        throw new RequiredError("AIApi", "getRelevantQuestions", "getRelevantQuestionsRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/relevant-questions/";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(getRelevantQuestionsRequest, "GetRelevantQuestionsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   * Version: 10.7.0.cl or later 
   * @param queryGetDecomposedQueryRequest 
   */
  queryGetDecomposedQuery(queryGetDecomposedQueryRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (queryGetDecomposedQueryRequest === null || queryGetDecomposedQueryRequest === void 0) {
        throw new RequiredError("AIApi", "queryGetDecomposedQuery", "queryGetDecomposedQueryRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/analytical-questions";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(queryGetDecomposedQueryRequest, "QueryGetDecomposedQueryRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.13.0.cl or later   This API allows users to initiate or continue an agent (Spotter) conversation by submitting one or more natural language messages.  To use this API, the user must have access to the relevant conversational session (via conversation_identifier) and submit at least one message.   #### Usage guidelines  To initiate or continue a conversation, the request must include: - `conversation_identifier`: a unique session ID for continuity and message tracking - `messages`: an array of one or more text messages, each with a value and type  Additionally, user can specify what tool can be included `conversation_settings` parameter, which supports: - `enable_contextual_change_analysis` (default: false) - `enable_natural_language_answer_generation` (default: true) - `enable_reasoning` (default: false)  If the request is valid, the API returns a stream of messages in real time, including: - `ack`: confirms receipt of the request - `text / text-chunk`: content chunks, optionally formatted (e.g., markdown) - `answer`: the final structured response with metadata and analytics - `error`: if a failure occurs - `notification`: notification messages for operation being performed  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster. > * The streaming protocol uses Server-Sent Events (SSE)     
   * @param sendAgentMessageStreamingRequest 
   */
  sendAgentMessageStreaming(sendAgentMessageStreamingRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (sendAgentMessageStreamingRequest === null || sendAgentMessageStreamingRequest === void 0) {
        throw new RequiredError("AIApi", "sendAgentMessageStreaming", "sendAgentMessageStreamingRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/agent/converse/sse";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(sendAgentMessageStreamingRequest, "SendAgentMessageStreamingRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.4.0.cl or later   Allows sending a follow-up message to an ongoing conversation within the context of the metadata model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  The API requires you to specify the `conversation_identifier` in the request path, and a `metadata_identifier` and `message` string in the request body.  If the API request is successful, ThoughtSpot returns the session ID, tokens used in the conversation, and visualization type.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param conversationIdentifier Unique identifier of the conversation.
   * @param sendMessageRequest 
   */
  sendMessage(conversationIdentifier, sendMessageRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (conversationIdentifier === null || conversationIdentifier === void 0) {
        throw new RequiredError("AIApi", "sendMessage", "conversationIdentifier");
      }
      if (sendMessageRequest === null || sendMessageRequest === void 0) {
        throw new RequiredError("AIApi", "sendMessage", "sendMessageRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/conversation/{conversation_identifier}/converse".replace("{conversation_identifier}", encodeURIComponent(String(conversationIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(sendMessageRequest, "SendMessageRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.4.0.cl or later   Processes a natural language query and returns an AI-generated response based on a specified data model.  Requires at least view access to the metadata object specified in the request.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param singleAnswerRequest 
   */
  singleAnswer(singleAnswerRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (singleAnswerRequest === null || singleAnswerRequest === void 0) {
        throw new RequiredError("AIApi", "singleAnswer", "singleAnswerRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/answer/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(singleAnswerRequest, "SingleAnswerRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var AIApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createAgentConversation
   * @throws ApiException if the response code was not in [200, 299]
   */
  createAgentConversation(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AgentConversation",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AgentConversation",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AgentConversation",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createConversation
   * @throws ApiException if the response code was not in [200, 299]
   */
  createConversation(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Conversation",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Conversation",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Conversation",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getRelevantQuestions
   * @throws ApiException if the response code was not in [200, 299]
   */
  getRelevantQuestions(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaGetRelevantQuestionsResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaGetRelevantQuestionsResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaGetRelevantQuestionsResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to queryGetDecomposedQuery
   * @throws ApiException if the response code was not in [200, 299]
   */
  queryGetDecomposedQuery(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaDecomposeQueryResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaDecomposeQueryResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaDecomposeQueryResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to sendAgentMessageStreaming
   * @throws ApiException if the response code was not in [200, 299]
   */
  sendAgentMessageStreaming(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SendAgentMessageResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SendAgentMessageResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SendAgentMessageResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to sendMessage
   * @throws ApiException if the response code was not in [200, 299]
   */
  sendMessage(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseMessage>",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseMessage>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseMessage>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to singleAnswer
   * @throws ApiException if the response code was not in [200, 299]
   */
  singleAnswer(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseMessage",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseMessage",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseMessage",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/AuthenticationApi.ts
var AuthenticationApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.0.0.cl or later   Retrieves details of the current user session for the token provided in the request header.  Any ThoughtSpot user can access this endpoint and send an API request. The data returned in the API response varies according to user\'s privilege and object access permissions.     
   */
  getCurrentUserInfo(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/auth/session/user";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "GET" /* GET */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.4.0.cl or later   Retrieves details of the current session token for the bearer token provided in the request header.  This API endpoint does not create a new token. Instead, it returns details about the token, including the token string, creation time, expiration time, and the associated user.  Use this endpoint to introspect your current session token, debug authentication issues, or when a frontend application needs session token details.  Any ThoughtSpot user with a valid bearer token can access this endpoint and send an API request      
   */
  getCurrentUserToken(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/auth/session/token";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "GET" /* GET */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.4.0.cl or later   Gets an authentication token with custom rules and security attributes and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  To add a new user and assign privileges during auto creation, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  To assign security attributes with filter rules and Parameters to the JWT token, you\'ll need administrator privileges and edit access to the data source (Worksheet or Model). If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  #### Usage guidelines  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key`.  To generate a `secret_key` on your cluster, the administrator must enable [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable) in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  ##### Attribute-Based Access Control (ABAC) with tokens  To implement Attribute-Based Access Control (ABAC) and assign security entitlements to users during session creation, you can generate a token with custom filtering rules and Parameters in the `filter_rules` and `parameter_values` array respectively. These attributes can be configured to persist on a specific set of objects for user sessions initiated using the token. Once defined, the rules are added to the user\'s `access_control_properties` object, after which all sessions will use the persisted values.  Specify the object type as `LOGICAL_TABLE`.   For more information, see [ABAC via tokens Documentation](https://developers.thoughtspot.com/docs/api-authv2#_get_tokens_with_custom_rules_and_filter_conditions).  ##### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `groups`  Set `auto_create` to `true` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true` in the API request, the user properties such as the display name, email, Org and group assignment will not be updated with new values. If `auto_create` is set to `true`, it won\'t create formula variables and hence won\'t be applicable for `variable_values`.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  ##### Important point to note All options in the token creation APIs that define access to the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created. Persist options such as  `APPEND`, `REPLACE`, `RESET` will persist security parameters on the user profile when the token is created, while Persist option `NONE` will not persist anything but will be honoured in the session.  ##### Formula Variables Before using variables_values, variables must be created using Create Variable API with type as Formula_Variable (/api/rest/2.0/template/variables/create) The persist_option RESET and NONE cannot be used when variable_values are provided in the request. If you are working with variable_values, you must use other (APPEND, REPLACE) supported modes. If you want to use RESET or NONE, do not pass any variable_values. In such cases, variable_values will remain unaffected. When using object_id with variable_values, models are supported.      
   * @param getCustomAccessTokenRequest 
   */
  getCustomAccessToken(getCustomAccessTokenRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (getCustomAccessTokenRequest === null || getCustomAccessTokenRequest === void 0) {
        throw new RequiredError("AuthenticationApi", "getCustomAccessToken", "getCustomAccessTokenRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/token/custom";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(getCustomAccessTokenRequest, "GetCustomAccessTokenRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page. For more information, see [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable).  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getFullAccessTokenRequest 
   */
  getFullAccessToken(getFullAccessTokenRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (getFullAccessTokenRequest === null || getFullAccessTokenRequest === void 0) {
        throw new RequiredError("AuthenticationApi", "getFullAccessToken", "getFullAccessTokenRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/token/full";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(getFullAccessTokenRequest, "GetFullAccessTokenRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token that provides access to a specific metadata object. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request,  `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getObjectAccessTokenRequest 
   */
  getObjectAccessToken(getObjectAccessTokenRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (getObjectAccessTokenRequest === null || getObjectAccessTokenRequest === void 0) {
        throw new RequiredError("AuthenticationApi", "getObjectAccessToken", "getObjectAccessTokenRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/token/object";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(getObjectAccessTokenRequest, "GetObjectAccessTokenRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a login session for a ThoughtSpot user with Basic authentication.  In Basic authentication method, REST clients log in to ThoughtSpot using `username` and `password` attributes. On a multi-tenant cluster with Orgs, users can pass the ID of the Org in the API request to log in to a specific Org context.  **Note**: If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. Contact ThoughtSpot Support for assistance.  A successful login returns a session cookie that can be used in your subsequent API requests.     
   * @param loginRequest 
   */
  login(loginRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (loginRequest === null || loginRequest === void 0) {
        throw new RequiredError("AuthenticationApi", "login", "loginRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/session/login";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(loginRequest, "LoginRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later    Logs out a user from their current session.      
   */
  logout(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/auth/session/logout";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later    Revokes the authentication token issued for current user session.  The token of your current session expires when you make a call to the `/api/rest/2.0/auth/token/revoke` endpoint. the users will not be able to access ThoughtSpot objects until a new token is obtained.  To restart your session, request for a new token from ThoughtSpot. See [Get Full Access Token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param revokeTokenRequest 
   */
  revokeToken(revokeTokenRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (revokeTokenRequest === null || revokeTokenRequest === void 0) {
        throw new RequiredError("AuthenticationApi", "revokeToken", "revokeTokenRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/token/revoke";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(revokeTokenRequest, "RevokeTokenRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.12.0.cl or later    Validates the authentication token specified in the API request.  If your token is not valid, [Get a new token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param validateTokenRequest 
   */
  validateToken(validateTokenRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (validateTokenRequest === null || validateTokenRequest === void 0) {
        throw new RequiredError("AuthenticationApi", "validateToken", "validateTokenRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/token/validate";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(validateTokenRequest, "ValidateTokenRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var AuthenticationApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getCurrentUserInfo
   * @throws ApiException if the response code was not in [200, 299]
   */
  getCurrentUserInfo(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getCurrentUserToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  getCurrentUserToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "GetTokenResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "GetTokenResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getCustomAccessToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  getCustomAccessToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AccessToken",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request. This could be due to missing or incorrect parameters.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access. The request could not be authenticated.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access. The user does not have permission to access this resource.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "An unexpected error occurred on the server.", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AccessToken",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getFullAccessToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  getFullAccessToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Token",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Token",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getObjectAccessToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  getObjectAccessToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Token",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Token",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to login
   * @throws ApiException if the response code was not in [200, 299]
   */
  login(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to logout
   * @throws ApiException if the response code was not in [200, 299]
   */
  logout(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to revokeToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  revokeToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to validateToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  validateToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "TokenValidationResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "TokenValidationResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/ConnectionConfigurationsApi.ts
var ConnectionConfigurationsApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 10.12.0.cl or later   Gets connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines * To get a list of all configurations available in the ThoughtSpot system, send the API request with only the connection name or GUID in the request body. * To fetch details of a configuration object, specify the configuration object name or GUID.      
   * @param connectionConfigurationSearchRequest 
   */
  connectionConfigurationSearch(connectionConfigurationSearchRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionConfigurationSearchRequest === null || connectionConfigurationSearchRequest === void 0) {
        throw new RequiredError("ConnectionConfigurationsApi", "connectionConfigurationSearch", "connectionConfigurationSearchRequest");
      }
      const localVarPath = "/api/rest/2.0/connection-configurations/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(connectionConfigurationSearchRequest, "ConnectionConfigurationSearchRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Creates an additional configuration to an existing connection to a data warehouse.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines   * A JSON map of configuration attributes in `configuration`. The following example shows the configuration attributes:   ```    {      \"user\":\"DEV_USER\",      \"password\":\"TestConn123\",      \"role\":\"DEV\",      \"warehouse\":\"DEV_WH\"     }   ```  * If the `policy_type` is `PRINCIPALS`, then `policy_principals` is a required field. * If the `policy_type` is `PROCESSES`, then `policy_processes` is a required field. * If the `policy_type` is `NO_POLICY`, then `policy_principals` and `policy_processes` are not required fields.  #### Parameterized Connection Support For parameterized connections that use OAuth authentication, only the same_as_parent and policy_process_options  attributes are allowed in the API request. These attributes are not applicable to connections that are not parameterized.       
   * @param createConnectionConfigurationRequest 
   */
  createConnectionConfiguration(createConnectionConfigurationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createConnectionConfigurationRequest === null || createConnectionConfigurationRequest === void 0) {
        throw new RequiredError("ConnectionConfigurationsApi", "createConnectionConfiguration", "createConnectionConfigurationRequest");
      }
      const localVarPath = "/api/rest/2.0/connection-configurations/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createConnectionConfigurationRequest, "CreateConnectionConfigurationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param deleteConnectionConfigurationRequest 
   */
  deleteConnectionConfiguration(deleteConnectionConfigurationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteConnectionConfigurationRequest === null || deleteConnectionConfigurationRequest === void 0) {
        throw new RequiredError("ConnectionConfigurationsApi", "deleteConnectionConfiguration", "deleteConnectionConfigurationRequest");
      }
      const localVarPath = "/api/rest/2.0/connection-configurations/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteConnectionConfigurationRequest, "DeleteConnectionConfigurationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Updates a connection configuration object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Supported operations This API endpoint lets you perform the following operations in a single API request:   * Edit the name or description of the configuration  * Edit the configuration properties  * Edit the `policy_type`  * Edit the type of authentication  * Enable or disable a configuration  #### Parameterized Connection Support For parameterized oauth based connections, only the `same_as_parent` and `policy_process_options` attributes are allowed. These attributes are not applicable to connections that are not parameterized.   **NOTE**: When updating a configuration where `disabled` is `true`, you must reset `disabled` to `true` in your update request payload. If not explicitly set again, the API will default `disabled` to `false`.      
   * @param configurationIdentifier Unique ID or name of the configuration.
   * @param updateConnectionConfigurationRequest 
   */
  updateConnectionConfiguration(configurationIdentifier, updateConnectionConfigurationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (configurationIdentifier === null || configurationIdentifier === void 0) {
        throw new RequiredError("ConnectionConfigurationsApi", "updateConnectionConfiguration", "configurationIdentifier");
      }
      if (updateConnectionConfigurationRequest === null || updateConnectionConfigurationRequest === void 0) {
        throw new RequiredError("ConnectionConfigurationsApi", "updateConnectionConfiguration", "updateConnectionConfigurationRequest");
      }
      const localVarPath = "/api/rest/2.0/connection-configurations/{configuration_identifier}/update".replace("{configuration_identifier}", encodeURIComponent(String(configurationIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateConnectionConfigurationRequest, "UpdateConnectionConfigurationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var ConnectionConfigurationsApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to connectionConfigurationSearch
   * @throws ApiException if the response code was not in [200, 299]
   */
  connectionConfigurationSearch(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ConnectionConfigurationResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ConnectionConfigurationResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createConnectionConfiguration
   * @throws ApiException if the response code was not in [200, 299]
   */
  createConnectionConfiguration(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ConnectionConfigurationResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ConnectionConfigurationResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteConnectionConfiguration
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteConnectionConfiguration(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateConnectionConfiguration
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateConnectionConfiguration(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/ConnectionsApi.ts
var ConnectionsApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.2.0.cl or later   Creates a connection to a data warehouse for live query services.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Create a connection without tables  To create a connection without tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a SnowFlake connection:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[       ]   }   ``` 2. Set `validate` to `false`.  #### Create a connection with tables  To create a connection with tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[         {            \"name\":\"AllDatatypes\",            \"isAutoCreated\":false,            \"schemas\":[               {                  \"name\":\"alldatatypes\",                  \"tables\":[                     {                        \"name\":\"allDatatypes\",                        \"type\":\"TABLE\",                        \"description\":\"\",                        \"selected\":true,                        \"linked\":true,                        \"columns\":[                           {                              \"name\":\"CNUMBER\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           },                           {                              \"name\":\"CDECIMAL\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           }                        ]                     }                  ]               }            ]         }      ]   }   ``` 2. Set `validate` to `true`.      
   * @param createConnectionRequest 
   */
  createConnection(createConnectionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createConnectionRequest === null || createConnectionRequest === void 0) {
        throw new RequiredError("ConnectionsApi", "createConnection", "createConnectionRequest");
      }
      const localVarPath = "/api/rest/2.0/connection/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createConnectionRequest, "CreateConnectionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later    **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Delete Connection V2](#/http/api-endpoints/connections/delete-connection-v2) endpoint to delete your connection objects.    #### Usage guidelines  Deletes a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.     
   * @param deleteConnectionRequest 
   */
  deleteConnection(deleteConnectionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteConnectionRequest === null || deleteConnectionRequest === void 0) {
        throw new RequiredError("ConnectionsApi", "deleteConnection", "deleteConnectionRequest");
      }
      const localVarPath = "/api/rest/2.0/connection/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteConnectionRequest, "DeleteConnectionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.4.0.cl or later   Deletes a connection object.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param connectionIdentifier Unique ID or name of the connection.
   */
  deleteConnectionV2(connectionIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionIdentifier === null || connectionIdentifier === void 0) {
        throw new RequiredError("ConnectionsApi", "deleteConnectionV2", "connectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/connections/{connection_identifier}/delete".replace("{connection_identifier}", encodeURIComponent(String(connectionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Exports the difference in connection metadata between CDW and ThoughtSpot  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:   - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  To download the connection metadata difference between ThoughtSpot and CDW, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  downloadConnectionMetadataChanges(connectionIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionIdentifier === null || connectionIdentifier === void 0) {
        throw new RequiredError("ConnectionsApi", "downloadConnectionMetadataChanges", "connectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/connections/download-connection-metadata-changes/{connection_identifier}".replace("{connection_identifier}", encodeURIComponent(String(connectionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Validates the difference in connection metadata between CDW and ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  Returns a boolean indicating whether there is any difference between the connection metadata at ThoughtSpot and CDW.  To get the connection metadata difference status, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  fetchConnectionDiffStatus(connectionIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionIdentifier === null || connectionIdentifier === void 0) {
        throw new RequiredError("ConnectionsApi", "fetchConnectionDiffStatus", "connectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/connections/fetch-connection-diff-status/{connection_identifier}".replace("{connection_identifier}", encodeURIComponent(String(connectionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Gets connection objects. Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  - To get a list of all connections available in the ThoughtSpot system, send the API request without any attributes in the request body. - To get the connection objects for a specific type of data warehouse, specify the type in `data_warehouse_types`. - To fetch details of a connection object, specify the connection object GUID or name. The `name_pattern` attribute allows passing partial text with `%` for a wildcard match. - To get details of the database, schemas, tables, or columns from a data connection object, specify `data_warehouse_object_type`. - To get a specific database, schema, table, or column from a connection object, define the object type in `data_warehouse_object_type` and object properties in the `data_warehouse_objects` array. For example, to search for a column, you must pass the database, schema, and table names in the API request.   Note that in the following example, object properties are set in a hierarchical order (`database` > `schema` > `table` > `column`).  ``` {   \"connections\": [     {       \"identifier\": \"b9d1f2ef-fa65-4a4b-994e-30fa2d57b0c2\",       \"data_warehouse_objects\": [         {           \"database\": \"NEBULADEV\",           \"schema\": \"INFORMATION_SCHEMA\",           \"table\": \"APPLICABLE_ROLES\",           \"column\": \"ROLE_NAME\"         }       ]     }   ],   \"data_warehouse_object_type\": \"COLUMN\" } ```  - To fetch data by `configuration`, specify `data_warehouse_object_type`. For example, to fetch columns from the `DEVELOPMENT` database, specify the `data_warehouse_object_type` as `DATABASE` and define the `configuration` string as `{\"database\":\"DEVELOPMENT\"}`. To get column data for a specific table, specify the table, for example,`{\"database\":\"RETAILAPPAREL\",\"table\":\"PIPES\"}`. - To query connections by `authentication_type`, specify `data_warehouse_object_type`. Supported values for `authentication_type` are:   - `SERVICE_ACCOUNT`: For connections that require service account credentials to authenticate to the Cloud Data Warehouse and fetch data.   - `OAUTH`: For connections that require OAuth credentials to authenticate to the Cloud Data Warehouse and fetch data. Teradata, Oracle, and Presto Cloud Data Warehouses do not support the OAuth authentication type.   - `IAM`: For connections that have the IAM OAuth set up. This authentication type is supported on Amazon Redshift connections only.   - `EXTOAUTH`: For connections that have External OAuth set up. ThoughtSpot supports external [OAuth with Microsoft Azure Active Directory (AD)](https://docs.thoughtspot.com/cloud/latest/ connections-snowflake-azure-ad-oauth) and [Okta for Snowflake data connections](https://docs.thoughtspot.com/cloud/latest/connections-snowflake-okta-oauth).   - `KEY_PAIR`: For connections that require Key Pair account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PKCE`: For connections that require OAuth with PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake, Starburst, Databricks, Denodo  connections only.   - `EXTOAUTH_WITH_PKCE`: For connections that require External OAuth With PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PEZ`: For connections that require OAuth With PEZ account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Amazon Redshift connections only.   - `OAUTH_WITH_SERVICE_PRINCIPAL`: For connections that require OAuth With Service Principal account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `PERSONAL_ACCESS_TOKEN`: For connections that require Personal Access Token account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `OAUTH_CLIENT_CREDENTIALS`: For connections that require OAuth Client Credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only. - To include more details about connection objects in the API response, set `include_details` to `true`. - You can also sort the output by field names and filter connections by tags.  **NOTE**: When filtering connection records by parameters other than `data_warehouse_types` or `tag_identifiers`, ensure that you set `record_size` to `-1` and `record_offset` to `0` for precise results.      
   * @param searchConnectionRequest 
   */
  searchConnection(searchConnectionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchConnectionRequest === null || searchConnectionRequest === void 0) {
        throw new RequiredError("ConnectionsApi", "searchConnection", "searchConnectionRequest");
      }
      const localVarPath = "/api/rest/2.0/connection/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchConnectionRequest, "SearchConnectionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Update connection V2](#/http/api-endpoints/connections/update-connection-v2) endpoint to update your connection objects.  #### Usage guidelines  Updates a connection object.    Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`. 3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.      
   * @param updateConnectionRequest 
   */
  updateConnection(updateConnectionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateConnectionRequest === null || updateConnectionRequest === void 0) {
        throw new RequiredError("ConnectionsApi", "updateConnection", "updateConnectionRequest");
      }
      const localVarPath = "/api/rest/2.0/connection/update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateConnectionRequest, "UpdateConnectionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.4.0.cl or later   Updates a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`.        **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.     * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:    * This is an example of updating a single table in a empty connection:           ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"DEMORENAME\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"Col1\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col2\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col3\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col312\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col4\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```        * This is an example of updating a single table in an existing connection with tables:            ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"CUSTOMER\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [],                     \"relationships\": []                   },                   {                     \"name\": \"tpch5k_falcon_default_schema_users\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"user_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"product_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"user_cost\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```  3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.    **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not  specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.    * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a Snowflake connection:    ```    {       \"configuration\":{          \"accountName\":\"thoughtspot_partner\",          \"user\":\"tsadmin\",          \"password\":\"TestConn123\",          \"role\":\"sysadmin\",          \"warehouse\":\"MEDIUM_WH\"       },       \"externalDatabases\":[        ]    }    ```      
   * @param connectionIdentifier Unique ID or name of the connection.
   * @param updateConnectionV2Request 
   */
  updateConnectionV2(connectionIdentifier, updateConnectionV2Request, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionIdentifier === null || connectionIdentifier === void 0) {
        throw new RequiredError("ConnectionsApi", "updateConnectionV2", "connectionIdentifier");
      }
      if (updateConnectionV2Request === null || updateConnectionV2Request === void 0) {
        throw new RequiredError("ConnectionsApi", "updateConnectionV2", "updateConnectionV2Request");
      }
      const localVarPath = "/api/rest/2.0/connections/{connection_identifier}/update".replace("{connection_identifier}", encodeURIComponent(String(connectionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateConnectionV2Request, "UpdateConnectionV2Request", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var ConnectionsApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  createConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CreateConnectionResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CreateConnectionResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteConnectionV2
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteConnectionV2(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to downloadConnectionMetadataChanges
   * @throws ApiException if the response code was not in [200, 299]
   */
  downloadConnectionMetadataChanges(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = yield response.getBodyAsFile();
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "HttpFile",
          "binary"
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchConnectionDiffStatus
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchConnectionDiffStatus(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "FetchConnectionDiffStatusResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "FetchConnectionDiffStatusResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<SearchConnectionResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<SearchConnectionResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateConnectionV2
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateConnectionV2(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/CustomActionApi.ts
var CustomActionApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.6.0.cl or later   Creates a custom action that appears as a menu action on a saved Answer or Liveboard visualization.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API lets you create the following types of custom actions:  * URL-based action        Allows pushing data to an external URL. * Callback action           Triggers a callback to the host application and initiates a response payload on an embedded ThoughtSpot instance.  By default, custom actions are visible to only administrator or developer users. To make a custom action available to other users, and specify the groups in `group_identifiers`.  By default, the custom action is set as a _global_ action on all visualizations and saved Answers. To assign a custom action to specific Liveboard visualization, saved Answer, or Worksheet, set `visibility` to `false` in `default_action_config` property and specify the GUID or name of the object in `associate_metadata`.  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param createCustomActionRequest 
   */
  createCustomAction(createCustomActionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createCustomActionRequest === null || createCustomActionRequest === void 0) {
        throw new RequiredError("CustomActionApi", "createCustomAction", "createCustomActionRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/custom-actions";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createCustomActionRequest, "CreateCustomActionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.6.0.cl or later   Removes the custom action specified in the API request.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param customActionIdentifier Unique ID or name of the custom action.
   */
  deleteCustomAction(customActionIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (customActionIdentifier === null || customActionIdentifier === void 0) {
        throw new RequiredError("CustomActionApi", "deleteCustomAction", "customActionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/customization/custom-actions/{custom_action_identifier}/delete".replace("{custom_action_identifier}", encodeURIComponent(String(customActionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.6.0.cl or later   Gets custom actions configured on the cluster.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param searchCustomActionsRequest 
   */
  searchCustomActions(searchCustomActionsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchCustomActionsRequest === null || searchCustomActionsRequest === void 0) {
        throw new RequiredError("CustomActionApi", "searchCustomActions", "searchCustomActionsRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/custom-actions/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchCustomActionsRequest, "SearchCustomActionsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.6.0.cl or later   Updates a custom action.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API allows you to modify the following properties:  * Name of the custom action * Action availability to groups * Association to metadata objects * Authentication settings for a URL-based action  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param customActionIdentifier Unique ID or name of the custom action.
   * @param updateCustomActionRequest 
   */
  updateCustomAction(customActionIdentifier, updateCustomActionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (customActionIdentifier === null || customActionIdentifier === void 0) {
        throw new RequiredError("CustomActionApi", "updateCustomAction", "customActionIdentifier");
      }
      if (updateCustomActionRequest === null || updateCustomActionRequest === void 0) {
        throw new RequiredError("CustomActionApi", "updateCustomAction", "updateCustomActionRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/custom-actions/{custom_action_identifier}/update".replace("{custom_action_identifier}", encodeURIComponent(String(customActionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateCustomActionRequest, "UpdateCustomActionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var CustomActionApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createCustomAction
   * @throws ApiException if the response code was not in [200, 299]
   */
  createCustomAction(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseCustomAction",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseCustomAction",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteCustomAction
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteCustomAction(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchCustomActions
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchCustomActions(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseCustomAction>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseCustomAction>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateCustomAction
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateCustomAction(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/CustomCalendarsApi.ts
var CustomCalendarsApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 10.12.0.cl or later   Creates a new [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.   #### Usage guidelines  You can create a custom calendar from scratch or an existing Table in ThoughtSpot. For both methods of calendar creation, the following parameters are required:  * Name of the custom calendar. * Calendar creation method. To create a calendar from an existing table, specify the method:   - `FROM_EXISTING_TABLE` - Creates calendar from the table reference provided in the API request.  - `FROM_INPUT_PARAMS` - Creates a calendar from the parameters defined in the API request.  * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  **NOTE**: If you are creating a calendar from an existing table, ensure that the referenced table matches the required DDL for custom calendars. If the schema does not match, the API returns an error.  ##### Calendar type The API allows you to create the following types of calendars:  * `MONTH_OFFSET`. The default calendar type. A `MONTH_OFFSET` calendar is offset by a few months from the standard calendar months (January to December) and the year begins with the month defined in the request. For example, if the `month_offset` value is set as `April`, the calendar year begins in April.  * `4-4-5`. Each quarter in the calendar will include two 4-week months followed by one 5-week month. * `4-5-4`. Each quarter in the calendar will include two 4-week months with a 5-week month between. * `5-4-4`. Each quarter begins with a 5-week month, followed by two 4-week months.  To start and end the calendar on a specific date, specify the dates in the `MM/DD/YYYY` format. For `MONTH_OFFSET` calendars, ensure that the `start_date` matches the month specified in the `month_offset` attribute.  You can also set the starting day of the week and customize the prefixes for year and quarter labels.  #### Examples  To create a calendar from an existing table:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_EXISTING_TABLE\", } ```  To create a calendar from scratch:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_INPUT_PARAMS\",   \"calendar_type\": \"MONTH_OFFSET\",   \"month_offset\": \"April\",   \"start_day_of_week\": \"Monday\",   \"quarter_name_prefix\": \"Q\",   \"year_name_prefix\": \"FY\",   \"start_date\": \"04/01/2025\",   \"end_date\": \"04/31/2025\" } ```      
   * @param createCalendarRequest 
   */
  createCalendar(createCalendarRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createCalendarRequest === null || createCalendarRequest === void 0) {
        throw new RequiredError("CustomCalendarsApi", "createCalendar", "createCalendarRequest");
      }
      const localVarPath = "/api/rest/2.0/calendars/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createCalendarRequest, "CreateCalendarRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines To delete a custom calendar, specify the calendar ID as a path parameter in the request URL.        
   * @param calendarIdentifier Unique ID or name of the Calendar.
   */
  deleteCalendar(calendarIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (calendarIdentifier === null || calendarIdentifier === void 0) {
        throw new RequiredError("CustomCalendarsApi", "deleteCalendar", "calendarIdentifier");
      }
      const localVarPath = "/api/rest/2.0/calendars/{calendar_identifier}/delete".replace("{calendar_identifier}", encodeURIComponent(String(calendarIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Exports a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal) in the CSV format.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  Use this API to download a custom calendar in the CSV file format. In your API request, specify the following parameters.  * Start and end date of the calendar. For \"month offset\" calendars, the start date must match the month defined in the `month_offset` attribute.  You can also specify optional parameters such as the starting day of the week and prefixes for the quarter and year labels.      
   * @param generateCSVRequest 
   */
  generateCSV(generateCSVRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (generateCSVRequest === null || generateCSVRequest === void 0) {
        throw new RequiredError("CustomCalendarsApi", "generateCSV", "generateCSVRequest");
      }
      const localVarPath = "/api/rest/2.0/calendars/generate-csv";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(generateCSVRequest, "GenerateCSVRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Gets a list of [custom calendars](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  By default, the API returns a list of custom calendars for all connection objects. To retrieve custom calendar details for a particular connection, specify the connection ID. You can also use other search parameters such as `name_pattern` and `sort_options` as search filters.  The `name_pattern` parameter filters and returns only those objects that match the specified pattern. Use `%` as a wildcard for pattern matching.      
   * @param searchCalendarsRequest 
   */
  searchCalendars(searchCalendarsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchCalendarsRequest === null || searchCalendarsRequest === void 0) {
        throw new RequiredError("CustomCalendarsApi", "searchCalendars", "searchCalendarsRequest");
      }
      const localVarPath = "/api/rest/2.0/calendars/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchCalendarsRequest, "SearchCalendarsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Updates the properties of a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  You can update the properties of a calendar using one of the following methods: * `FROM_INPUT_PARAMS` to update the calendar properties with the values defined in the API request. * `FROM_EXISTING_TABLE` Creates a calendar from the parameters defined in the API request.  To update a custom calendar, specify the calendar ID as a path parameter in the request URL and the following parameters in the request body:    * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  The API allows you to modify the calendar type, month offset value, start and end date, starting day of the week, and prefixes assigned to the year and quarter labels.     #### Examples  Update a custom calendar using an existing Table in ThoughtSpot:  ``` {   \"update_method\": \"FROM_EXISTING_TABLE\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   } } ```  Update a custom calendar with the attributes defined in the API request:  ``` {   \"update_method\": \"FROM_INPUT_PARAMS\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   },   \"month_offset\": \"August\",   \"start_day_of_week\": \"Monday\",   \"start_date\": \"08/01/2025\",   \"end_date\": \"07/31/2026\" } ```      
   * @param calendarIdentifier Unique Id or name of the calendar.
   * @param updateCalendarRequest 
   */
  updateCalendar(calendarIdentifier, updateCalendarRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (calendarIdentifier === null || calendarIdentifier === void 0) {
        throw new RequiredError("CustomCalendarsApi", "updateCalendar", "calendarIdentifier");
      }
      if (updateCalendarRequest === null || updateCalendarRequest === void 0) {
        throw new RequiredError("CustomCalendarsApi", "updateCalendar", "updateCalendarRequest");
      }
      const localVarPath = "/api/rest/2.0/calendars/{calendar_identifier}/update".replace("{calendar_identifier}", encodeURIComponent(String(calendarIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateCalendarRequest, "UpdateCalendarRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var CustomCalendarsApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createCalendar
   * @throws ApiException if the response code was not in [200, 299]
   */
  createCalendar(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CalendarResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CalendarResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteCalendar
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteCalendar(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to generateCSV
   * @throws ApiException if the response code was not in [200, 299]
   */
  generateCSV(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchCalendars
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchCalendars(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CalendarResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CalendarResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateCalendar
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateCalendar(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/DBTApi.ts
var DBTApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.9.0.cl or later   Creates a DBT connection object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About create DBT connection DBT connection in ThoughtSpot is used by the user to define DBT credentials for cloud . The API needs  embrace connection, embrace database name, DBT url, import type, DBT account identifier, DBT project identifier, DBT access token and environment details (or) embrace connection, embrace database name, import type, file_content to create a connection object. To know more about DBT, see ThoughtSpot Product Documentation.      
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  dbtConnection(connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionName === null || connectionName === void 0) {
        throw new RequiredError("DBTApi", "dbtConnection", "connectionName");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("DBTApi", "dbtConnection", "databaseName");
      }
      const localVarPath = "/api/rest/2.0/dbt/dbt-connection";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const useForm = canConsumeForm([
        "multipart/form-data"
      ]);
      let localVarFormParams;
      if (useForm) {
        localVarFormParams = new FormData();
      } else {
        localVarFormParams = new URLSearchParams();
      }
      if (connectionName !== void 0) {
        localVarFormParams.append("connection_name", connectionName);
      }
      if (databaseName !== void 0) {
        localVarFormParams.append("database_name", databaseName);
      }
      if (importType !== void 0) {
        localVarFormParams.append("import_type", importType);
      }
      if (accessToken !== void 0) {
        localVarFormParams.append("access_token", accessToken);
      }
      if (dbtUrl !== void 0) {
        localVarFormParams.append("dbt_url", dbtUrl);
      }
      if (accountId !== void 0) {
        localVarFormParams.append("account_id", accountId);
      }
      if (projectId !== void 0) {
        localVarFormParams.append("project_id", projectId);
      }
      if (dbtEnvId !== void 0) {
        localVarFormParams.append("dbt_env_id", dbtEnvId);
      }
      if (projectName !== void 0) {
        localVarFormParams.append("project_name", projectName);
      }
      if (fileContent !== void 0) {
        if (localVarFormParams instanceof FormData) {
          localVarFormParams.append("file_content", fileContent, fileContent.name);
        }
      }
      requestContext.setBody(localVarFormParams);
      if (!useForm) {
        const contentType = ObjectSerializer.getPreferredMediaType([
          "multipart/form-data"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
      }
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Resynchronize the existing list of models, tables, worksheet tmls and import them to Thoughtspot based on the DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateSyncTml(dbtConnectionIdentifier, fileContent, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (dbtConnectionIdentifier === null || dbtConnectionIdentifier === void 0) {
        throw new RequiredError("DBTApi", "dbtGenerateSyncTml", "dbtConnectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/dbt/generate-sync-tml";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const useForm = canConsumeForm([
        "multipart/form-data"
      ]);
      let localVarFormParams;
      if (useForm) {
        localVarFormParams = new FormData();
      } else {
        localVarFormParams = new URLSearchParams();
      }
      if (dbtConnectionIdentifier !== void 0) {
        localVarFormParams.append("dbt_connection_identifier", dbtConnectionIdentifier);
      }
      if (fileContent !== void 0) {
        if (localVarFormParams instanceof FormData) {
          localVarFormParams.append("file_content", fileContent, fileContent.name);
        }
      }
      requestContext.setBody(localVarFormParams);
      if (!useForm) {
        const contentType = ObjectSerializer.getPreferredMediaType([
          "multipart/form-data"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
      }
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Generate required table and worksheet and import them.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About generate TML Models and Worksheets to be imported can be selected by the user as part of the API.      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param modelTables List of Models and their respective Tables Example: \\\&#39;[{\\\&quot;model_name\\\&quot;: \\\&quot;model_name\\\&quot;, \\\&quot;tables\\\&quot;: [\\\&quot;table_name\\\&quot;]}]\\\&#39;
   * @param importWorksheets Mention the worksheet tmls to import
   * @param worksheets List of worksheets is mandatory when import_Worksheets is type SELECTED Example: [\\\&quot;worksheet_name\\\&quot;]
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateTml(dbtConnectionIdentifier, modelTables, importWorksheets, worksheets, fileContent, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (dbtConnectionIdentifier === null || dbtConnectionIdentifier === void 0) {
        throw new RequiredError("DBTApi", "dbtGenerateTml", "dbtConnectionIdentifier");
      }
      if (modelTables === null || modelTables === void 0) {
        throw new RequiredError("DBTApi", "dbtGenerateTml", "modelTables");
      }
      if (importWorksheets === null || importWorksheets === void 0) {
        throw new RequiredError("DBTApi", "dbtGenerateTml", "importWorksheets");
      }
      const localVarPath = "/api/rest/2.0/dbt/generate-tml";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const useForm = canConsumeForm([
        "multipart/form-data"
      ]);
      let localVarFormParams;
      if (useForm) {
        localVarFormParams = new FormData();
      } else {
        localVarFormParams = new URLSearchParams();
      }
      if (dbtConnectionIdentifier !== void 0) {
        localVarFormParams.append("dbt_connection_identifier", dbtConnectionIdentifier);
      }
      if (modelTables !== void 0) {
        localVarFormParams.append("model_tables", modelTables);
      }
      if (importWorksheets !== void 0) {
        localVarFormParams.append("import_worksheets", importWorksheets);
      }
      if (worksheets !== void 0) {
        localVarFormParams.append("worksheets", worksheets);
      }
      if (fileContent !== void 0) {
        if (localVarFormParams instanceof FormData) {
          localVarFormParams.append("file_content", fileContent, fileContent.name);
        }
      }
      requestContext.setBody(localVarFormParams);
      if (!useForm) {
        const contentType = ObjectSerializer.getPreferredMediaType([
          "multipart/form-data"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
      }
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Gets a list of DBT connection objects by user and organization, available on the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About search DBT connection To get details of a specific DBT connection identifier, database connection identifier, database connection name, database name, project name, project identifier, environment identifier , import type and author.      
   */
  dbtSearch(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/dbt/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Removes the specified DBT connection object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   */
  deleteDbtConnection(dbtConnectionIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (dbtConnectionIdentifier === null || dbtConnectionIdentifier === void 0) {
        throw new RequiredError("DBTApi", "deleteDbtConnection", "dbtConnectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/dbt/{dbt_connection_identifier}/delete".replace("{dbt_connection_identifier}", encodeURIComponent(String(dbtConnectionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Updates a DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About update DBT connection You can modify DBT connection object properties such as embrace connection name, embrace database name, import type, account identifier, access token, project identifier and environment (or) embrace connection, embrace database name, import type, file_content settings.      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  updateDbtConnection(dbtConnectionIdentifier, connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (dbtConnectionIdentifier === null || dbtConnectionIdentifier === void 0) {
        throw new RequiredError("DBTApi", "updateDbtConnection", "dbtConnectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/dbt/update-dbt-connection";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const useForm = canConsumeForm([
        "multipart/form-data"
      ]);
      let localVarFormParams;
      if (useForm) {
        localVarFormParams = new FormData();
      } else {
        localVarFormParams = new URLSearchParams();
      }
      if (dbtConnectionIdentifier !== void 0) {
        localVarFormParams.append("dbt_connection_identifier", dbtConnectionIdentifier);
      }
      if (connectionName !== void 0) {
        localVarFormParams.append("connection_name", connectionName);
      }
      if (databaseName !== void 0) {
        localVarFormParams.append("database_name", databaseName);
      }
      if (importType !== void 0) {
        localVarFormParams.append("import_type", importType);
      }
      if (accessToken !== void 0) {
        localVarFormParams.append("access_token", accessToken);
      }
      if (dbtUrl !== void 0) {
        localVarFormParams.append("dbt_url", dbtUrl);
      }
      if (accountId !== void 0) {
        localVarFormParams.append("account_id", accountId);
      }
      if (projectId !== void 0) {
        localVarFormParams.append("project_id", projectId);
      }
      if (dbtEnvId !== void 0) {
        localVarFormParams.append("dbt_env_id", dbtEnvId);
      }
      if (projectName !== void 0) {
        localVarFormParams.append("project_name", projectName);
      }
      if (fileContent !== void 0) {
        if (localVarFormParams instanceof FormData) {
          localVarFormParams.append("file_content", fileContent, fileContent.name);
        }
      }
      requestContext.setBody(localVarFormParams);
      if (!useForm) {
        const contentType = ObjectSerializer.getPreferredMediaType([
          "multipart/form-data"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
      }
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var DBTApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to dbtConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  dbtConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to dbtGenerateSyncTml
   * @throws ApiException if the response code was not in [200, 299]
   */
  dbtGenerateSyncTml(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to dbtGenerateTml
   * @throws ApiException if the response code was not in [200, 299]
   */
  dbtGenerateTml(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to dbtSearch
   * @throws ApiException if the response code was not in [200, 299]
   */
  dbtSearch(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DbtSearchResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DbtSearchResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteDbtConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteDbtConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateDbtConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateDbtConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/DataApi.ts
var DataApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.0.0.cl or later   Fetches data from a saved Answer.  Requires at least view access to the saved Answer.  The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_apis).     
   * @param fetchAnswerDataRequest 
   */
  fetchAnswerData(fetchAnswerDataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchAnswerDataRequest === null || fetchAnswerDataRequest === void 0) {
        throw new RequiredError("DataApi", "fetchAnswerData", "fetchAnswerDataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/answer/data";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchAnswerDataRequest, "FetchAnswerDataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets data from a Liveboard object and its visualization.    Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To get data for specific visualizations, add the GUIDs or names of the visualizations in the API request.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes. If the new Liveboard experience mode, the transient content includes ad hoc changes to visualizations such as sorting, toggling of legends, and data drill down.  For more information, and see [Liveboard data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_fetch_liveboard_data_api).     
   * @param fetchLiveboardDataRequest 
   */
  fetchLiveboardData(fetchLiveboardDataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchLiveboardDataRequest === null || fetchLiveboardDataRequest === void 0) {
        throw new RequiredError("DataApi", "fetchLiveboardData", "fetchLiveboardDataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/liveboard/data";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchLiveboardDataRequest, "FetchLiveboardDataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Generates an Answer from a given data source.  Requires at least view access to the data source object (Worksheet or View).  #### Usage guidelines  To search data, specify the data source GUID in `logical_table_identifier`. The data source can be a Worksheet, View, Table, or SQL view.  Pass search tokens in the `query_string` attribute in the API request as shown in the following example:  ``` {   \"query_string\": \"[sales] by [store]\",   \"logical_table_identifier\": \"cd252e5c-b552-49a8-821d-3eadaa049cca\", } ```  For more information about the `query_string` format and data source attribute, see [Search data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_search_data_api).    The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_api).       
   * @param searchDataRequest 
   */
  searchData(searchDataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchDataRequest === null || searchDataRequest === void 0) {
        throw new RequiredError("DataApi", "searchData", "searchDataRequest");
      }
      const localVarPath = "/api/rest/2.0/searchdata";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchDataRequest, "SearchDataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var DataApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchAnswerData
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchAnswerData(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AnswerDataResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AnswerDataResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchLiveboardData
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchLiveboardData(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "LiveboardDataResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "LiveboardDataResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchData
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchData(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SearchDataResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SearchDataResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/EmailCustomizationApi.ts
var EmailCustomizationApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *  Version: 10.10.0.cl or later   Creates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To create a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param createEmailCustomizationRequest 
   */
  createEmailCustomization(createEmailCustomizationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createEmailCustomizationRequest === null || createEmailCustomizationRequest === void 0) {
        throw new RequiredError("EmailCustomizationApi", "createEmailCustomization", "createEmailCustomizationRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/email";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createEmailCustomizationRequest, "CreateEmailCustomizationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.10.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `template_identifier` from the response. - Use that `template_identifier` as a parameter in this API request.      
   * @param templateIdentifier Unique ID or name of the email customization.
   */
  deleteEmailCustomization(templateIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (templateIdentifier === null || templateIdentifier === void 0) {
        throw new RequiredError("EmailCustomizationApi", "deleteEmailCustomization", "templateIdentifier");
      }
      const localVarPath = "/api/rest/2.0/customization/email/{template_identifier}/delete".replace("{template_identifier}", encodeURIComponent(String(templateIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.12.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `org_identifier` from the response. - Use that `org_identifier` as a parameter in this API request.      
   * @param deleteOrgEmailCustomizationRequest 
   */
  deleteOrgEmailCustomization(deleteOrgEmailCustomizationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteOrgEmailCustomizationRequest === null || deleteOrgEmailCustomizationRequest === void 0) {
        throw new RequiredError("EmailCustomizationApi", "deleteOrgEmailCustomization", "deleteOrgEmailCustomizationRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/email/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteOrgEmailCustomizationRequest, "DeleteOrgEmailCustomizationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.10.0.cl or later   Search the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   * @param searchEmailCustomizationRequest 
   */
  searchEmailCustomization(searchEmailCustomizationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchEmailCustomizationRequest === null || searchEmailCustomizationRequest === void 0) {
        throw new RequiredError("EmailCustomizationApi", "searchEmailCustomization", "searchEmailCustomizationRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/email/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchEmailCustomizationRequest, "SearchEmailCustomizationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.12.0.cl or later   Updates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To update a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param updateEmailCustomizationRequest 
   */
  updateEmailCustomization(updateEmailCustomizationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateEmailCustomizationRequest === null || updateEmailCustomizationRequest === void 0) {
        throw new RequiredError("EmailCustomizationApi", "updateEmailCustomization", "updateEmailCustomizationRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/email/update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateEmailCustomizationRequest, "UpdateEmailCustomizationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.10.0.cl or later   Validates the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   */
  validateEmailCustomization(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/customization/email/validate";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var EmailCustomizationApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  createEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CreateEmailCustomizationResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CreateEmailCustomizationResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteOrgEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteOrgEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CreateEmailCustomizationResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CreateEmailCustomizationResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to validateEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  validateEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/GroupsApi.ts
var GroupsApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.0.0.cl or later   Creates a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### About groups Groups in ThoughtSpot are used by the administrators to define privileges and organize users based on their roles and access requirements. To know more about groups and privileges, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/groups-privileges).  #### Supported operations  The API endpoint lets you perform the following operations:  * Assign privileges * Add users * Define sharing visibility * Add sub-groups * Assign a default Liveboard      
   * @param createUserGroupRequest 
   */
  createUserGroup(createUserGroupRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createUserGroupRequest === null || createUserGroupRequest === void 0) {
        throw new RequiredError("GroupsApi", "createUserGroup", "createUserGroupRequest");
      }
      const localVarPath = "/api/rest/2.0/groups/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createUserGroupRequest, "CreateUserGroupRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified group object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.      
   * @param groupIdentifier GUID or name of the group.
   */
  deleteUserGroup(groupIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (groupIdentifier === null || groupIdentifier === void 0) {
        throw new RequiredError("GroupsApi", "deleteUserGroup", "groupIdentifier");
      }
      const localVarPath = "/api/rest/2.0/groups/{group_identifier}/delete".replace("{group_identifier}", encodeURIComponent(String(groupIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Imports group objects from external databases into ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  During the import operation:  * If the specified group is not available in ThoughtSpot, it will be added to ThoughtSpot. * If `delete_unspecified_groups` is set to `true`, the groups not specified in the API request, excluding administrator and system user groups, are deleted. * If the specified groups are already available in ThoughtSpot, the object properties of these groups are modified and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.      
   * @param importUserGroupsRequest 
   */
  importUserGroups(importUserGroupsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (importUserGroupsRequest === null || importUserGroupsRequest === void 0) {
        throw new RequiredError("GroupsApi", "importUserGroups", "importUserGroupsRequest");
      }
      const localVarPath = "/api/rest/2.0/groups/import";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(importUserGroupsRequest, "ImportUserGroupsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of user group objects from the ThoughtSpot system.  To get details of a specific user group, specify the user group GUID or name. You can also filter the API response based on User ID, Org ID, Role ID, type of group, sharing visibility, privileges assigned to the group, and the Liveboard IDs assigned to the users in the group.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  **NOTE**: If you do not get precise results, try setting `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchUserGroupsRequest 
   */
  searchUserGroups(searchUserGroupsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchUserGroupsRequest === null || searchUserGroupsRequest === void 0) {
        throw new RequiredError("GroupsApi", "searchUserGroups", "searchUserGroupsRequest");
      }
      const localVarPath = "/api/rest/2.0/groups/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchUserGroupsRequest, "SearchUserGroupsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### Supported operations  This API endpoint lets you perform the following operations in a single API request:  * Edit [privileges](https://developers.thoughtspot.com/docs/?pageid=api-user-management#group-privileges) * Add or remove users * Change sharing visibility settings * Add or remove sub-groups * Assign a default Liveboard  or update the existing settings      
   * @param groupIdentifier GUID or name of the group.
   * @param updateUserGroupRequest 
   */
  updateUserGroup(groupIdentifier, updateUserGroupRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (groupIdentifier === null || groupIdentifier === void 0) {
        throw new RequiredError("GroupsApi", "updateUserGroup", "groupIdentifier");
      }
      if (updateUserGroupRequest === null || updateUserGroupRequest === void 0) {
        throw new RequiredError("GroupsApi", "updateUserGroup", "updateUserGroupRequest");
      }
      const localVarPath = "/api/rest/2.0/groups/{group_identifier}/update".replace("{group_identifier}", encodeURIComponent(String(groupIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateUserGroupRequest, "UpdateUserGroupRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var GroupsApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createUserGroup
   * @throws ApiException if the response code was not in [200, 299]
   */
  createUserGroup(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "UserGroupResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "UserGroupResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteUserGroup
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteUserGroup(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to importUserGroups
   * @throws ApiException if the response code was not in [200, 299]
   */
  importUserGroups(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportUserGroupsResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportUserGroupsResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchUserGroups
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchUserGroups(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<UserGroupResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<UserGroupResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateUserGroup
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateUserGroup(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/LogApi.ts
var LogApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.0.0.cl or later   Fetches security audit logs.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the [Admin Control](https://developers.thoughtspot.com/docs/rbac#_admin_control) privileges are required.   #### Usage guidelines  By default, the API retrieves logs for the last 24 hours. You can set a custom duration in EPOCH time. Make sure the log duration specified in your API request doesnt exceed 24 hours. If you must fetch logs for a longer time range, modify the duration and make multiple sequential API requests.  Upon successful execution, the API returns logs with the following information: * timestamp of the event * event ID * event type * name and GUID of the user * IP address of ThoughtSpot instance  For more information see [Audit logs Documentation](https://developers.thoughtspot.com/docs/audit-logs).      
   * @param fetchLogsRequest 
   */
  fetchLogs(fetchLogsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchLogsRequest === null || fetchLogsRequest === void 0) {
        throw new RequiredError("LogApi", "fetchLogs", "fetchLogsRequest");
      }
      const localVarPath = "/api/rest/2.0/logs/fetch";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchLogsRequest, "FetchLogsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var LogApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchLogs
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchLogs(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<LogResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<LogResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/MetadataApi.ts
var MetadataApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *  Convert worksheets to models    Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (Can manage data models).  ---  ## Usage Guidelines  ### Parameters  1. **worksheet_ids**      - **Description:** A comma-separated list of GUIDs (Globally Unique Identifiers) specifying the Worksheets to be converted.      - **Usage:**        - Used only when `convert_all` is set to `false`.        - Leave empty or omit when `convert_all` is set to `true`.  2. **exclude_worksheet_ids**      - **Description:** A comma-separated list of GUIDs specifying Worksheets to be excluded from conversion.      - **Usage:**        - Useful when `convert_all` is set to `true` and specific Worksheets should not be converted.  3. **convert_all**      - **Description:** Sets the scope of conversion.    - **Options:**        - `true`: Converts all Worksheets in the system, except those specified in `exclude_worksheet_ids`.        - `false`: Converts only the Worksheets listed in `worksheet_ids`.  4. **apply_changes**      - **Description:** Specifies whether to apply changes directly to ThoughtSpot or to generate a preview before applying any changes.Used for validation of conversion.    - **Options:**        - `true`: Applies conversion changes directly to ThoughtSpot.      - `false`: Generates only a preview of the changes and does not apply any changes to ThoughtSpot  ---  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the conversion process  2. **Partial Conversion for Testing:**      Test the conversion process by setting `convert_all` to `false` and specifying a small number of `worksheet_ids`.  3. **Verify Dependencies:**      Check for dependent objects, such as Tables and Connections, to avoid invalid references.  4. **Review Changes:**      Use `apply_changes: false` to preview the impact of the conversion before applying changes.  ---  ## Examples  ### Convert Specific Worksheets ```json {   \"worksheet_ids\": [\"guid1\", \"guid2\", \"guid3\"],   \"exclude_worksheet_ids\": [],   \"convert_all\": false,   \"apply_changes\": true } ```  ### Convert All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [],   \"convert_all\": true,   \"apply_changes\": true } ```  ### Exclude Specific Worksheets While Converting All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [\"abc\"],   \"convert_all\": true,   \"apply_changes\": true } ```     
   * @param convertWorksheetToModelRequest 
   */
  convertWorksheetToModel(convertWorksheetToModelRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (convertWorksheetToModelRequest === null || convertWorksheetToModelRequest === void 0) {
        throw new RequiredError("MetadataApi", "convertWorksheetToModel", "convertWorksheetToModelRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/worksheets/convert";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(convertWorksheetToModelRequest, "ConvertWorksheetToModelRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Makes a copy of an Answer or Liveboard    Version: 10.3.0.cl or later   Creates a copy of a metadata object.  Requires at least view access to the metadata object being copied.  Upon successful execution, the API creates a copy of the metadata object specified in the API request and returns the ID of the new object.      
   * @param copyObjectRequest 
   */
  copyObject(copyObjectRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (copyObjectRequest === null || copyObjectRequest === void 0) {
        throw new RequiredError("MetadataApi", "copyObject", "copyObjectRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/copyobject";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(copyObjectRequest, "CopyObjectRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified metadata object from the ThoughtSpot system.  Requires edit access to the metadata object.       
   * @param deleteMetadataRequest 
   */
  deleteMetadata(deleteMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteMetadataRequest === null || deleteMetadataRequest === void 0) {
        throw new RequiredError("MetadataApi", "deleteMetadata", "deleteMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteMetadataRequest, "DeleteMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  Requires `DATADOWNLOADING` (**Can download Data**) and at least view access to the metadata object.  #### Usage guidelines  * You can export one or several objects by passing metadata object GUIDs in the `metadata` array. * When exporting TML content for a Liveboard or Answer object, you can set `export_associated` to `true` to retrieve TML content for underlying Worksheets, Tables, or Views, including the GUID of each object within the headers. When   `export_associated` is set to `true`, consider retrieving one metadata object at a time. * Set `export_fqns` to `true` to add FQNs of the referenced objects in the TML content. For example, if you send an API request to retrieve TML for a Liveboard and its associated objects, the API returns the TML content with FQNs of the referenced Worksheet. Exporting TML with FQNs is useful if ThoughtSpot has multiple objects with the same name and you want to eliminate ambiguity when importing TML files into ThoughtSpot. It eliminates the need for adding FQNs of the referenced objects manually during the import operation. * To export only the TML of feedbacks associated with an object, set the GUID of the object as `identifier`, and set the `type` as `FEEDBACK` in the `metadata` array. * To export the TML of an object along with the feedbacks associated with it, set the GUID of the object as `identifier`, set the `type` as `LOGIAL_TABLE` in the `metadata` array, and set `export_with_associated_feedbacks` in `export_options` to true.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_export_a_tml).  For more information on feedbacks, see [Feedback Documentation](https://docs.thoughtspot.com/cloud/latest/sage-feedback).     
   * @param exportMetadataTMLRequest 
   */
  exportMetadataTML(exportMetadataTMLRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (exportMetadataTMLRequest === null || exportMetadataTMLRequest === void 0) {
        throw new RequiredError("MetadataApi", "exportMetadataTML", "exportMetadataTMLRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/tml/export";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(exportMetadataTMLRequest, "ExportMetadataTMLRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.1.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  ### **Permissions Required**  Requires `DATAMANAGEMENT` (**Can manage data**) and `USERMANAGEMENT` (**Can manage users**) privileges.  #### **Usage Guidelines**  This API is only applicable for `USER`, `GROUP`, and `ROLES` metadata types.  - `batch_offset` Indicates the starting position within the complete dataset from which the API should begin returning objects. Useful for paginating results efficiently. - `batch_size` Specifies the number of objects or items to retrieve in a single request. Helps control response size for better performance. - `edoc_format` Defines the format of the TML content. The exported metadata can be in JSON or YAML format. - `export_dependent` Specifies whether to include dependent metadata objects in the export. Ensures related objects are also retrieved if needed. - `all_orgs_override` Indicates whether the export operation applies across all organizations. Useful for multi-tenant environments where cross-org exports are required.      
   * @param exportMetadataTMLBatchedRequest 
   */
  exportMetadataTMLBatched(exportMetadataTMLBatchedRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (exportMetadataTMLBatchedRequest === null || exportMetadataTMLBatchedRequest === void 0) {
        throw new RequiredError("MetadataApi", "exportMetadataTMLBatched", "exportMetadataTMLBatchedRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/tml/export/batch";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(exportMetadataTMLBatchedRequest, "ExportMetadataTMLBatchedRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for an Answer object.  Requires at least view access to the Answer object.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {    \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",    \"metadata_name\":\"Total sales\",    \"metadata_type\":\"ANSWER\",    \"sql_queries\":[       {          \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",          \"metadata_name\":\"Total sales -test\",          \"sql_query\":\"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  \\\"ta_2\\\".\\\"PRODUCTNAME\\\" \\\"ca_2\\\", \\n  \\\"ta_1\\\".\\\"STORENAME\\\" \\\"ca_3\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_4\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_5\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_3\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_3\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_PRODUCTS\\\" \\\"ta_2\\\"\\n    ON \\\"ta_3\\\".\\\"PRODUCTID\\\" = \\\"ta_2\\\".\\\"PRODUCTID\\\"\\nGROUP BY \\n  \\\"ca_1\\\", \\n  \\\"ca_2\\\", \\n  \\\"ca_3\\\"\\n\"       }    ] } ```      
   * @param fetchAnswerSqlQueryRequest 
   */
  fetchAnswerSqlQuery(fetchAnswerSqlQueryRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchAnswerSqlQueryRequest === null || fetchAnswerSqlQueryRequest === void 0) {
        throw new RequiredError("MetadataApi", "fetchAnswerSqlQuery", "fetchAnswerSqlQueryRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/answer/sql";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchAnswerSqlQueryRequest, "FetchAnswerSqlQueryRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.4.0.cl or later   Gets information about the status of the TML async import task scheduled using the `/api/rest/2.0/metadata/tml/async/import` API call.  To fetch the task details, specify the ID of the TML async import task.    Requires access to the task ID. The API allows users who initiated the asynchronous TML import via `/api/rest/2.0/metadata/tml/async/import` to view the status of their tasks.  Users with administration privilege can view the status of all import tasks initiated by the users in their Org.  #### Usage guidelines  See [TML API Documentation](https://developers.thoughtspot.com/docs/tml#_fetch_status_of_the_tml_import_task) for usage guidelines.     
   * @param fetchAsyncImportTaskStatusRequest 
   */
  fetchAsyncImportTaskStatus(fetchAsyncImportTaskStatusRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchAsyncImportTaskStatusRequest === null || fetchAsyncImportTaskStatusRequest === void 0) {
        throw new RequiredError("MetadataApi", "fetchAsyncImportTaskStatus", "fetchAsyncImportTaskStatusRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/tml/async/status";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchAsyncImportTaskStatusRequest, "FetchAsyncImportTaskStatusRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for a Liveboard object and its visualizations.  Requires at least view access to the Liveboard object.  To get SQL query data for a Liveboard, specify the GUID of the Liveboard. Optionally, you can add an array of visualization GUIDs to retrieve the SQL query data for visualizations in the Liveboard.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {   \"metadata_id\": \"fa68ae91-7588-4136-bacd-d71fb12dda69\",   \"metadata_name\": \"Total Sales\",   \"metadata_type\": \"LIVEBOARD\",   \"sql_queries\": [     {       \"metadata_id\": \"b3b6d2b9-089a-490c-8e16-b144650b7843\",       \"metadata_name\": \"Total quantity purchased, Total sales by region\",       \"sql_query\": \"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_2\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_3\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_2\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_2\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\nGROUP BY \\\"ca_1\\\"\"     }   ] } ```      
   * @param fetchLiveboardSqlQueryRequest 
   */
  fetchLiveboardSqlQuery(fetchLiveboardSqlQueryRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchLiveboardSqlQueryRequest === null || fetchLiveboardSqlQueryRequest === void 0) {
        throw new RequiredError("MetadataApi", "fetchLiveboardSqlQuery", "fetchLiveboardSqlQueryRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/liveboard/sql";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchLiveboardSqlQueryRequest, "FetchLiveboardSqlQueryRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Imports [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  *  Import all related objects in a single TML Import API call. For example, Tables that use the same Connection object and Worksheets connected to these Tables. * Include the `fqn` property to distinguish objects that have the same name.   For example, if you have multiple Connections or Worksheets with the same name on ThoughtSpot and the Connection or Worksheet referenced in your TML file does not have a unique name to distinguish, it may result in invalid object references.   Adding `fqn` helps ThoughtSpot differentiate a Table from another with the same name.   We recommend [exporting TML with FQNs](#/http/api-endpoints/metadata/export-metadata-tml) and using these during the import operation. * You can upload multiple TML files at a time.   If you import a Worksheet along with Liveboards, Answers, and other dependent objects in a single API call, the imported objects will be immediately available for use.   When you import only a Worksheet object, it may take some time for the Worksheet to become available in the ThoughtSpot system. Please wait for a few minutes, and then proceed to create an Answer and Liveboard from the newly imported Worksheet.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_import_a_tml).      
   * @param importMetadataTMLRequest 
   */
  importMetadataTML(importMetadataTMLRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (importMetadataTMLRequest === null || importMetadataTMLRequest === void 0) {
        throw new RequiredError("MetadataApi", "importMetadataTML", "importMetadataTMLRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/tml/import";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(importMetadataTMLRequest, "ImportMetadataTMLRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.4.0.cl or later   Schedules a task to import [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot. You can use this API endpoint to process TML objects asynchronously when importing TMLs of large and complex metadata objects into ThoughtSpot. Unlike the synchronous import TML operation, the API processes TML data in the background and returns a task ID, which can be used to check the status of the import task via `/api/rest/2.0/metadata/tml/async/status` API endpoint.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege, and edit access to the TML objects.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  See [Async TML API Documentation](https://developers.thoughtspot.com/docs/tml#_import_tml_objects_asynchronously) for usage guidelines.      
   * @param importMetadataTMLAsyncRequest 
   */
  importMetadataTMLAsync(importMetadataTMLAsyncRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (importMetadataTMLAsyncRequest === null || importMetadataTMLAsyncRequest === void 0) {
        throw new RequiredError("MetadataApi", "importMetadataTMLAsync", "importMetadataTMLAsyncRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/tml/async/import";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(importMetadataTMLAsyncRequest, "ImportMetadataTMLAsyncRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Parameterize fields in metadata objects.   Version: 10.9.0.cl or later   Allows parameterizing fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows parameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be parameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param parameterizeMetadataRequest 
   */
  parameterizeMetadata(parameterizeMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (parameterizeMetadataRequest === null || parameterizeMetadataRequest === void 0) {
        throw new RequiredError("MetadataApi", "parameterizeMetadata", "parameterizeMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/parameterize";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(parameterizeMetadataRequest, "ParameterizeMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of metadata objects available on the ThoughtSpot system.  This API endpoint is available to all users who have view access to the object. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view data for all metadata objects, including users and groups.  #### Usage guidelines  - To get all metadata objects, send the API request without any attributes. - To get metadata objects of a specific type, set the `type` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE`. - To filter metadata objects within type `LOGICAL_TABLE`, set the `subtypes` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE` & subtypes as `[WORKSHEET]`. - To get a specific metadata object, specify the GUID. - To customize your search and filter the API response, you can use several parameters.   You can search for objects created or modified by specific users, by tags applied to the objects, or by using the include parameters like `include_auto_created_objects`, `include_dependent_objects`, `include_headers`, `include_incomplete_objects`, and so on.   You can also define sorting options to sort the data retrieved in the API response. - To get discoverable objects when linientmodel is enabled you can use `include_discoverable_objects` as true else false. Default value is true. - For liveboard metadata type, to get the newer format, set the `liveboard_response_format` as V2. Default value is V1. - To retrieve only objects that are published, set the `include_only_published_objects` as true. Default value is false.  **NOTE**: The following parameters support pagination of metadata records:  - `tag_identifiers` - `type` - `subtypes` - `created_by_user_identifiers` - `modified_by_user_identifiers` - `owned_by_user_identifiers` - `exclude_objects` - `include_auto_created_objects` - `favorite_object_options` - `include_only_published_objects` If you are using other parameters to search metadata, set `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchMetadataRequest 
   */
  searchMetadata(searchMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchMetadataRequest === null || searchMetadataRequest === void 0) {
        throw new RequiredError("MetadataApi", "searchMetadata", "searchMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchMetadataRequest, "SearchMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Remove parameterization from fields in metadata objects.   Version: 10.9.0.cl or later   Allows removing parameterization from fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows unparameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be unparameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param unparameterizeMetadataRequest 
   */
  unparameterizeMetadata(unparameterizeMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (unparameterizeMetadataRequest === null || unparameterizeMetadataRequest === void 0) {
        throw new RequiredError("MetadataApi", "unparameterizeMetadata", "unparameterizeMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/unparameterize";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(unparameterizeMetadataRequest, "UnparameterizeMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Update header attributes for a given list of header objects.   Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **headers_update**      - **Description:** List of header objects with their attributes to be updated. Each object contains a list of attributes to be updated in the header.    - **Usage:**       - You must provide either `identifier` or `obj_identifier`, but not both. Both fields cannot be empty.       - When `org_identifier` is set to `-1`, only the `identifier` value is accepted; `obj_identifier` is not allowed.  2. **org_identifier**      - **Description:** GUID (Globally Unique Identifier) or name of the organization.      - **Usage:**      - Leaving this field empty assumes that the changes should be applied to the current organization       - Provide `org_guid` or `org_name` to uniquely identify the organization where changes need to be applied. .      - Provide `-1` if changes have to be applied across all the org.  ---  ## Note Currently, this API is enabled only for updating the `obj_identifier` attribute. Only `text` will be allowed in attribute\'s value.  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the update process  ---  ## Examples  ### Only `identifier` is given  ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"obj_identifier\": \"\",       \"type\": \"LOGICAL_COLUMN\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgGuid\" } ```  ### Only `obj_identifier` is given ```json {   \"headers_update\":   [     {       \"obj_identifier\": \"custom_object_id\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgName\" } ```  ### Executing update for all org `-1` ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```  ### Optional `type` is not provided ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```     
   * @param updateMetadataHeaderRequest 
   */
  updateMetadataHeader(updateMetadataHeaderRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateMetadataHeaderRequest === null || updateMetadataHeaderRequest === void 0) {
        throw new RequiredError("MetadataApi", "updateMetadataHeader", "updateMetadataHeaderRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/headers/update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateMetadataHeaderRequest, "UpdateMetadataHeaderRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Update object IDs for given metadata objects.   Version: 10.8.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **metadata**      - **Description:** List of metadata objects to update their object IDs.    - **Usage:**       - Use either `current_obj_id` alone OR use `metadata_identifier` with `type` (when needed).       - When using `metadata_identifier`, the `type` field is required if using a name instead of a GUID.       - The `new_obj_id` field is always required.  ---  ## Note This API is specifically designed for updating object IDs of metadata objects. It internally uses the header update mechanism to perform the changes.  ## Best Practices  1. **Backup Before Update:**      Always export metadata as a backup before initiating the update process.  2. **Validation:**    - When using `current_obj_id`, ensure it matches the existing object ID exactly.    - When using `metadata_identifier` with a name, ensure the `type` is specified correctly.    - Verify that the `new_obj_id` follows your naming conventions and is unique within your system.  ---  ## Examples  ### Using current_obj_id ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with GUID ```json {   \"metadata\": [     {       \"metadata_identifier\": \"01234567-89ab-cdef-0123-456789abcdef\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with name and type ```json {   \"metadata\": [     {       \"metadata_identifier\": \"My Answer\",       \"type\": \"ANSWER\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Multiple objects update ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id_1\",       \"new_obj_id\": \"new_object_id_1\"     },     {       \"metadata_identifier\": \"My Worksheet\",       \"type\": \"LOGICAL_TABLE\",       \"new_obj_id\": \"new_object_id_2\"     }   ] } ```      
   * @param updateMetadataObjIdRequest 
   */
  updateMetadataObjId(updateMetadataObjIdRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateMetadataObjIdRequest === null || updateMetadataObjIdRequest === void 0) {
        throw new RequiredError("MetadataApi", "updateMetadataObjId", "updateMetadataObjIdRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/update-obj-id";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateMetadataObjIdRequest, "UpdateMetadataObjIdRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var MetadataApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to convertWorksheetToModel
   * @throws ApiException if the response code was not in [200, 299]
   */
  convertWorksheetToModel(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseWorksheetToModelConversion",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseWorksheetToModelConversion",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to copyObject
   * @throws ApiException if the response code was not in [200, 299]
   */
  copyObject(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseCopyObject",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("404", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Object not found", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseCopyObject",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to exportMetadataTML
   * @throws ApiException if the response code was not in [200, 299]
   */
  exportMetadataTML(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<any>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<any>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to exportMetadataTMLBatched
   * @throws ApiException if the response code was not in [200, 299]
   */
  exportMetadataTMLBatched(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchAnswerSqlQuery
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchAnswerSqlQuery(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SqlQueryResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SqlQueryResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchAsyncImportTaskStatus
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchAsyncImportTaskStatus(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "GetAsyncImportStatusResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "GetAsyncImportStatusResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchLiveboardSqlQuery
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchLiveboardSqlQuery(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SqlQueryResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SqlQueryResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to importMetadataTML
   * @throws ApiException if the response code was not in [200, 299]
   */
  importMetadataTML(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<any>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<any>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to importMetadataTMLAsync
   * @throws ApiException if the response code was not in [200, 299]
   */
  importMetadataTMLAsync(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportEPackAsyncTaskStatus",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportEPackAsyncTaskStatus",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to parameterizeMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  parameterizeMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<MetadataSearchResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<MetadataSearchResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to unparameterizeMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  unparameterizeMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateMetadataHeader
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateMetadataHeader(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateMetadataObjId
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateMetadataObjId(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/OrgsApi.ts
var OrgsApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.0.0.cl or later   Creates an Org object.  To use this API, the [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview) feature must be enabled in your cluster.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param createOrgRequest 
   */
  createOrg(createOrgRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createOrgRequest === null || createOrgRequest === void 0) {
        throw new RequiredError("OrgsApi", "createOrg", "createOrgRequest");
      }
      const localVarPath = "/api/rest/2.0/orgs/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createOrgRequest, "CreateOrgRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes an Org object from the ThoughtSpot system.  Requires cluster administration (**Can administer Org**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.  When you delete an Org, all its users and objects created in that Org context are removed. However, if the users in the deleted Org also exists in other Orgs, they are removed only from the deleted Org.      
   * @param orgIdentifier ID or name of the Org
   */
  deleteOrg(orgIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (orgIdentifier === null || orgIdentifier === void 0) {
        throw new RequiredError("OrgsApi", "deleteOrg", "orgIdentifier");
      }
      const localVarPath = "/api/rest/2.0/orgs/{org_identifier}/delete".replace("{org_identifier}", encodeURIComponent(String(orgIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of Orgs configured on the ThoughtSpot system. To get details of a specific Org, specify the Org ID or name. You can also pass parameters such as status, visibility, and user identifiers to get a specific list of Orgs.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param searchOrgsRequest 
   */
  searchOrgs(searchOrgsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchOrgsRequest === null || searchOrgsRequest === void 0) {
        throw new RequiredError("OrgsApi", "searchOrgs", "searchOrgsRequest");
      }
      const localVarPath = "/api/rest/2.0/orgs/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchOrgsRequest, "SearchOrgsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Updates an Org object. You can modify Org properties such as name, description, and user associations.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param orgIdentifier ID or name of the Org
   * @param updateOrgRequest 
   */
  updateOrg(orgIdentifier, updateOrgRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (orgIdentifier === null || orgIdentifier === void 0) {
        throw new RequiredError("OrgsApi", "updateOrg", "orgIdentifier");
      }
      if (updateOrgRequest === null || updateOrgRequest === void 0) {
        throw new RequiredError("OrgsApi", "updateOrg", "updateOrgRequest");
      }
      const localVarPath = "/api/rest/2.0/orgs/{org_identifier}/update".replace("{org_identifier}", encodeURIComponent(String(orgIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateOrgRequest, "UpdateOrgRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var OrgsApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createOrg
   * @throws ApiException if the response code was not in [200, 299]
   */
  createOrg(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "OrgResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "OrgResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteOrg
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteOrg(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchOrgs
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchOrgs(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<OrgResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<OrgResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateOrg
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateOrg(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/ReportsApi.ts
var ReportsApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.0.0.cl or later   Exports an Answer in the given file format. You can download the Answer data as a PDF, PNG, CSV, or XLSX file.  Requires at least view access to the Answer.  #### Usage guidelines  In the request body, the GUID or name of the Answer and set `file_format`. The default file format is CSV.  **NOTE**: * The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension. * HTML rendering is not supported for PDF exports of Answers with tables.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.       
   * @param exportAnswerReportRequest 
   */
  exportAnswerReport(exportAnswerReportRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (exportAnswerReportRequest === null || exportAnswerReportRequest === void 0) {
        throw new RequiredError("ReportsApi", "exportAnswerReport", "exportAnswerReportRequest");
      }
      const localVarPath = "/api/rest/2.0/report/answer";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(exportAnswerReportRequest, "ExportAnswerReportRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Exports a Liveboard and its visualizations in PDF, PNG, CSV, or XLSX file format.  Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To generate a Liveboard report with specific visualizations, add GUIDs or names of the visualizations.  The default `file_format` is CSV. For PDF exports, you can specify additional parameters to customize the page orientation and include or exclude the cover page, logo, footer text, and page numbers. Similar customization options are available for PNG exports. CSV and XLSX exports do not support customization options.  **NOTE**: The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes, including ad hoc changes to visualizations. For more information, see [Liveboard Report API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_liveboard_report_api).    **NOTE**: Starting with ThoughtSpot Cloud 10.9.0.cl release, the Liveboard can be exported in the PNG format in the resolution of your choice. To enable this on your instance, contact ThoughtSpot support. When this feature is enabled, the options `include_cover_page`,`include_filter_page` within the `png_options` will not be available for PNG exports.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in CSV format. All visualizations in the Liveboard can be exported as individual CSV files. If multiple visualizations are selected or if the entire Liveboard is exported, the output is returned as a .zip file containing the CSV files for each visualization.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in XLSX format. All selected visualizations are consolidated into a single Excel workbook (.xlsx), with each visualization placed in its own worksheet (tab). XLSX exports are limited to 255 worksheets (tabs) per workbook.      
   * @param exportLiveboardReportRequest 
   */
  exportLiveboardReport(exportLiveboardReportRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (exportLiveboardReportRequest === null || exportLiveboardReportRequest === void 0) {
        throw new RequiredError("ReportsApi", "exportLiveboardReport", "exportLiveboardReportRequest");
      }
      const localVarPath = "/api/rest/2.0/report/liveboard";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(exportLiveboardReportRequest, "ExportLiveboardReportRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var ReportsApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to exportAnswerReport
   * @throws ApiException if the response code was not in [200, 299]
   */
  exportAnswerReport(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = yield response.getBodyAsFile();
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "HttpFile",
          "binary"
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to exportLiveboardReport
   * @throws ApiException if the response code was not in [200, 299]
   */
  exportLiveboardReport(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = yield response.getBodyAsFile();
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "HttpFile",
          "binary"
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/RolesApi.ts
var RolesApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.5.0.cl or later   Creates a Role object in ThoughtSpot.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To create a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param createRoleRequest 
   */
  createRole(createRoleRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createRoleRequest === null || createRoleRequest === void 0) {
        throw new RequiredError("RolesApi", "createRole", "createRoleRequest");
      }
      const localVarPath = "/api/rest/2.0/roles/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createRoleRequest, "CreateRoleRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.5.0.cl or later   Deletes a Role object from the ThoughtSpot system.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To delete a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role. ReadOnly roles cannot be deleted.
   */
  deleteRole(roleIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (roleIdentifier === null || roleIdentifier === void 0) {
        throw new RequiredError("RolesApi", "deleteRole", "roleIdentifier");
      }
      const localVarPath = "/api/rest/2.0/roles/{role_identifier}/delete".replace("{role_identifier}", encodeURIComponent(String(roleIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.5.0.cl or later   Gets a list of Role objects from the ThoughtSpot system.  Available if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To search for Roles, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.  To get details of a specific Role object, specify the GUID or name. You can also filter the API response based on user group and Org identifiers, privileges assigned to the Role, and deprecation status.      
   * @param searchRolesRequest 
   */
  searchRoles(searchRolesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchRolesRequest === null || searchRolesRequest === void 0) {
        throw new RequiredError("RolesApi", "searchRoles", "searchRolesRequest");
      }
      const localVarPath = "/api/rest/2.0/roles/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchRolesRequest, "SearchRolesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.5.0.cl or later   Updates the properties of a Role object.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To update a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role.
   * @param updateRoleRequest 
   */
  updateRole(roleIdentifier, updateRoleRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (roleIdentifier === null || roleIdentifier === void 0) {
        throw new RequiredError("RolesApi", "updateRole", "roleIdentifier");
      }
      if (updateRoleRequest === null || updateRoleRequest === void 0) {
        throw new RequiredError("RolesApi", "updateRole", "updateRoleRequest");
      }
      const localVarPath = "/api/rest/2.0/roles/{role_identifier}/update".replace("{role_identifier}", encodeURIComponent(String(roleIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateRoleRequest, "UpdateRoleRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var RolesApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createRole
   * @throws ApiException if the response code was not in [200, 299]
   */
  createRole(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RoleResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid parameters.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Internal error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RoleResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteRole
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteRole(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Internal error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchRoles
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchRoles(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<SearchRoleResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Internal error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<SearchRoleResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateRole
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateRole(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RoleResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RoleResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/SchedulesApi.ts
var SchedulesApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *  Create schedule.    Version: 9.4.0.cl or later   Creates a Liveboard schedule job.  Requires at least edit access to Liveboards. To create a schedule on behalf of another user, you need  `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  #### Usage guidelines  * The description text is mandatory.  The description text appears as **Description: <your content>** in the Liveboard schedule email notifications. * For Liveboards with both charts and tables, schedule creation is only supported in PDF and XLS formats. Schedules created in CSV formats for such Liveboards will fail to run. If `PDF` is set as the `file_format`, enable `pdf_options` to get the correct attachment. Not doing so may cause the attachment to be rendered empty. * To include only specific visualizations, specify the visualization GUIDs in the `visualization_identifiers` array. * You can schedule a Liveboard job to run periodically by setting frequency parameters. You can set the schedule to run daily, weekly, monthly or every n minutes or hours. The scheduled job can also be configured to run at a specific time of the day or on specific days of the week or month. Please ensure that when setting the schedule frequency for _minute of the object_, only values that are multiples of 5 are included. * If the `frequency` parameters are defined, you can set the time zone to a value that matches your server\'s time zone. For example, `US/Central`, `Etc/UTC`, `CET`. The default time zone is `America/Los_Angeles`.  For more information about Liveboard jobs, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/liveboard-schedule).     
   * @param createScheduleRequest 
   */
  createSchedule(createScheduleRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createScheduleRequest === null || createScheduleRequest === void 0) {
        throw new RequiredError("SchedulesApi", "createSchedule", "createScheduleRequest");
      }
      const localVarPath = "/api/rest/2.0/schedules/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createScheduleRequest, "CreateScheduleRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Deletes a scheduled job.    Version: 9.4.0.cl or later   Deletes a scheduled Liveboard job.  Requires at least edit access to Liveboard or `ADMINISTRATION` (**Can administer Org**) privilege.    If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.      
   * @param scheduleIdentifier Unique ID or name of the scheduled job.
   */
  deleteSchedule(scheduleIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (scheduleIdentifier === null || scheduleIdentifier === void 0) {
        throw new RequiredError("SchedulesApi", "deleteSchedule", "scheduleIdentifier");
      }
      const localVarPath = "/api/rest/2.0/schedules/{schedule_identifier}/delete".replace("{schedule_identifier}", encodeURIComponent(String(scheduleIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Search Schedules    Version: 9.4.0.cl or later   Gets a list of scheduled jobs configured for a Liveboard.  To get details of a specific scheduled job, specify the name or GUID of the scheduled job.  Requires at least view access to Liveboards.  **NOTE**: When filtering schedules by parameters other than `metadata`, set `record_size` to `-1` and `record_offset` to `0` for accurate results.      
   * @param searchSchedulesRequest 
   */
  searchSchedules(searchSchedulesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchSchedulesRequest === null || searchSchedulesRequest === void 0) {
        throw new RequiredError("SchedulesApi", "searchSchedules", "searchSchedulesRequest");
      }
      const localVarPath = "/api/rest/2.0/schedules/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchSchedulesRequest, "SearchSchedulesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Update schedule.    Version: 9.4.0.cl or later   Updates a scheduled Liveboard job.  Requires at least edit access to Liveboards. To update a schedule on behalf of another user, you need `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  The API endpoint allows you to pause a scheduled job, change the status of a paused job. You can also edit the recipients list, frequency of the job, format of the file to send to the recipients in email notifications, PDF options, and time zone setting.      
   * @param scheduleIdentifier Unique ID or name of the schedule.
   * @param updateScheduleRequest 
   */
  updateSchedule(scheduleIdentifier, updateScheduleRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (scheduleIdentifier === null || scheduleIdentifier === void 0) {
        throw new RequiredError("SchedulesApi", "updateSchedule", "scheduleIdentifier");
      }
      if (updateScheduleRequest === null || updateScheduleRequest === void 0) {
        throw new RequiredError("SchedulesApi", "updateSchedule", "updateScheduleRequest");
      }
      const localVarPath = "/api/rest/2.0/schedules/{schedule_identifier}/update".replace("{schedule_identifier}", encodeURIComponent(String(scheduleIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateScheduleRequest, "UpdateScheduleRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var SchedulesApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createSchedule
   * @throws ApiException if the response code was not in [200, 299]
   */
  createSchedule(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseSchedule",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseSchedule",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteSchedule
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteSchedule(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchSchedules
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchSchedules(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseSchedule>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseSchedule>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateSchedule
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateSchedule(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/SecurityApi.ts
var SecurityApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.0.0.cl or later   Transfers the ownership of one or several objects from one user to another.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege and edit access to the objects are required.      
   * @param assignChangeAuthorRequest 
   */
  assignChangeAuthor(assignChangeAuthorRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (assignChangeAuthorRequest === null || assignChangeAuthorRequest === void 0) {
        throw new RequiredError("SecurityApi", "assignChangeAuthor", "assignChangeAuthorRequest");
      }
      const localVarPath = "/api/rest/2.0/security/metadata/assign";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(assignChangeAuthorRequest, "AssignChangeAuthorRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.12.0.cl or later   Fetches column security rules for specified tables.  This API endpoint retrieves column-level security rules configured for tables. It returns information about which columns are secured and which groups have access to those columns.  #### Usage guidelines  - Provide an array of table identifiers using either `identifier` (GUID or name) or `obj_identifier` (object ID) - At least one of `identifier` or `obj_identifier` must be provided for each table - The API returns column security rules for all specified tables - Users must have appropriate permissions to access security rules for the specified tables  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables  #### Example request  ```json {   \"tables\": [     {       \"identifier\": \"table-guid\",       \"obj_identifier\": \"table-object-id\"     }   ] } ```  #### Response format  The API returns an array of `ColumnSecurityRuleResponse` objects wrapped in a `data` field. Each `ColumnSecurityRuleResponse` object contains: - Table information (GUID and object ID)   - Array of column security rules with column details, group access, and source table information  #### Example response  ```json {   \"data\": [     {       \"guid\": \"table-guid\",       \"objId\": \"table-object-id\",       \"columnSecurityRules\": [         {           \"column\": {             \"id\": \"col_123\",             \"name\": \"Salary\"           },           \"groups\": [             {               \"id\": \"group_1\",               \"name\": \"HR Department\"             }           ],           \"sourceTableDetails\": {             \"id\": \"source-table-guid\",             \"name\": \"Employee_Data\"           }         }       ]     }   ] } ```     
   * @param fetchColumnSecurityRulesRequest 
   */
  fetchColumnSecurityRules(fetchColumnSecurityRulesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchColumnSecurityRulesRequest === null || fetchColumnSecurityRulesRequest === void 0) {
        throw new RequiredError("SecurityApi", "fetchColumnSecurityRules", "fetchColumnSecurityRulesRequest");
      }
      const localVarPath = "/api/rest/2.0/security/column/rules/fetch";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchColumnSecurityRulesRequest, "FetchColumnSecurityRulesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches object permission details for a given principal object such as a user and group.  Requires view access to the metadata object.   #### Usage guidelines  * To get a list of all metadata objects that a user or group can access, specify the `type` and GUID or name of the principal. * To get permission details for a specific object, add the `type` and GUID or name of the metadata object to your API request.  Upon successful execution, the API returns a list of metadata objects and permission details for each object.        
   * @param fetchPermissionsOfPrincipalsRequest 
   */
  fetchPermissionsOfPrincipals(fetchPermissionsOfPrincipalsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchPermissionsOfPrincipalsRequest === null || fetchPermissionsOfPrincipalsRequest === void 0) {
        throw new RequiredError("SecurityApi", "fetchPermissionsOfPrincipals", "fetchPermissionsOfPrincipalsRequest");
      }
      const localVarPath = "/api/rest/2.0/security/principals/fetch-permissions";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchPermissionsOfPrincipalsRequest, "FetchPermissionsOfPrincipalsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches permission details for a given metadata object.  Requires view access to the metadata object.  #### Usage guidelines  * To fetch a list of users and groups for a metadata object, specify `type` and GUID or name of the metadata object. * To get permission details for a specific user or group, add `type` and GUID or name of the principal object to your API request.  Upon successful execution, the API returns permission details and principal information for the object specified in the API request.      
   * @param fetchPermissionsOnMetadataRequest 
   */
  fetchPermissionsOnMetadata(fetchPermissionsOnMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchPermissionsOnMetadataRequest === null || fetchPermissionsOnMetadataRequest === void 0) {
        throw new RequiredError("SecurityApi", "fetchPermissionsOnMetadata", "fetchPermissionsOnMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/security/metadata/fetch-permissions";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchPermissionsOnMetadataRequest, "FetchPermissionsOnMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.9.0.cl or later   Allows publishing metadata objects across organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows publishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  This API will essentially share the objects along with it\'s dependencies to the org admins of the orgs to which it is being published.      
   * @param publishMetadataRequest 
   */
  publishMetadata(publishMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (publishMetadataRequest === null || publishMetadataRequest === void 0) {
        throw new RequiredError("SecurityApi", "publishMetadata", "publishMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/security/metadata/publish";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(publishMetadataRequest, "PublishMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Allows sharing one or several metadata objects with users and groups in ThoughtSpot.  Requires edit access to the metadata object.  The API endpoint allows sharing only the following types of metadata objects: * Liveboards * Visualizations * Answers * Worksheets * Views * Connections  You can provide `READ_ONLY` or `MODIFY` access when sharing an object with another user or group. With `READ_ONLY` access grants view access to the shared object, whereas `MODIFY` provides edit access.  To prevent a user or group from accessing the shared object, specify the GUID or name of the principal and set `shareMode` to `NO_ACCESS`.      
   * @param shareMetadataRequest 
   */
  shareMetadata(shareMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (shareMetadataRequest === null || shareMetadataRequest === void 0) {
        throw new RequiredError("SecurityApi", "shareMetadata", "shareMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/security/metadata/share";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(shareMetadataRequest, "ShareMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.9.0.cl or later   Allows unpublishing metadata objects from organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows unpublishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  When unpublishing objects, you can: * Include dependencies by setting `include_dependencies` to true - this will unpublish all dependent objects if no other published object is using them * Force unpublish by setting `force` to true - this will break all dependent objects in the unpublished organizations      
   * @param unpublishMetadataRequest 
   */
  unpublishMetadata(unpublishMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (unpublishMetadataRequest === null || unpublishMetadataRequest === void 0) {
        throw new RequiredError("SecurityApi", "unpublishMetadata", "unpublishMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/security/metadata/unpublish";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(unpublishMetadataRequest, "UnpublishMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.12.0.cl or later   Creates, updates, or deletes column security rules for specified tables.  This API endpoint allows you to create, update, or delete column-level security rules on columns of a table. The operation follows an \"all or none\" policy: if defining security rules for any of the provided columns fails, the entire operation will be rolled back, and no rules will be created.  #### Usage guidelines  - Provide table identifier using either `identifier` (GUID or name) or `obj_identifier` (object ID) - Use `clear_csr: true` to remove all column security rules from the table - For each column, specify the security rule using `column_security_rules` array - Use `is_unsecured: true` to mark a specific column as unprotected - Use `group_access` operations to manage group associations:   - `ADD`: Add groups to the column\'s access list   - `REMOVE`: Remove groups from the column\'s access list   - `REPLACE`: Replace all existing groups with the specified groups  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data (if RBAC is disabled) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables (if RBAC is enabled)  #### Example request  ```json {   \"identifier\": \"table-guid\",   \"obj_identifier\": \"table-object-id\",   \"clear_csr\": false,   \"column_security_rules\": [     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"ADD\",           \"group_identifiers\": [\"hr_group_id\", \"hr_group_name\", \"finance_group_id\"]         }       ]     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": true     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"REPLACE\",           \"group_identifiers\": [\"management_group_id\", \"management_group_name\"]         }       ]     }   ] } ```  #### Request Body Schema  - `identifier` (string, optional): GUID or name of the table for which we want to create column security rules - `obj_identifier` (string, optional): The object ID of the table - `clear_csr` (boolean, optional): If true, then all the secured columns will be marked as unprotected, and all the group associations will be removed - `column_security_rules` (array of objects, required): An array where each object defines the security rule for a specific column  Each column security rule object contains: - `column_identifier` (string, required): Column identifier (col_id or name) - `is_unsecured` (boolean, optional): If true, the column will be marked as unprotected and all groups associated with it will be removed - `group_access` (array of objects, optional): Array of group operation objects  Each group operation object contains: - `operation` (string, required): Operation type - ADD, REMOVE, or REPLACE - `group_identifiers` (array of strings, required): Array of group identifiers (name or GUID) on which the operation will be performed  #### Response  This API does not return any response body. A successful operation returns HTTP 200 status code.  #### Operation Types  - **ADD**: Adds the specified groups to the column\'s access list - **REMOVE**: Removes the specified groups from the column\'s access list   - **REPLACE**: Replaces all existing groups with the specified groups      
   * @param updateColumnSecurityRulesRequest 
   */
  updateColumnSecurityRules(updateColumnSecurityRulesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateColumnSecurityRulesRequest === null || updateColumnSecurityRulesRequest === void 0) {
        throw new RequiredError("SecurityApi", "updateColumnSecurityRules", "updateColumnSecurityRulesRequest");
      }
      const localVarPath = "/api/rest/2.0/security/column/rules/update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateColumnSecurityRulesRequest, "UpdateColumnSecurityRulesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var SecurityApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to assignChangeAuthor
   * @throws ApiException if the response code was not in [200, 299]
   */
  assignChangeAuthor(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchColumnSecurityRules
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchColumnSecurityRules(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ColumnSecurityRuleResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Bad request - Table not found or invalid parameters", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden - User doesn&#39;t have permission to access security rules for this table", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Internal server error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ColumnSecurityRuleResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchPermissionsOfPrincipals
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchPermissionsOfPrincipals(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "PermissionOfPrincipalsResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "PermissionOfPrincipalsResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchPermissionsOnMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchPermissionsOnMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "PermissionOfMetadataResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "PermissionOfMetadataResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to publishMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  publishMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to shareMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  shareMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to unpublishMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  unpublishMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateColumnSecurityRules
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateColumnSecurityRules(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Bad request - Invalid parameters or table not found", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden - User doesn&#39;t have permission to modify security rules for this table", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Internal server error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/SystemApi.ts
var SystemApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *  Version: 10.14.0.cl or later   Configure communication channel preferences. - Use `cluster_preferences` to update the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to specify Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param configureCommunicationChannelPreferencesRequest 
   */
  configureCommunicationChannelPreferences(configureCommunicationChannelPreferencesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (configureCommunicationChannelPreferencesRequest === null || configureCommunicationChannelPreferencesRequest === void 0) {
        throw new RequiredError("SystemApi", "configureCommunicationChannelPreferences", "configureCommunicationChannelPreferencesRequest");
      }
      const localVarPath = "/api/rest/2.0/system/preferences/communication-channels/configure";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(configureCommunicationChannelPreferencesRequest, "ConfigureCommunicationChannelPreferencesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves the current configuration details of the cluster. If the request is successful, the API returns a list configuration settings applied on the cluster.  Requires `ADMINISTRATION`(**Can administer ThoughtSpot**) privilege to view these complete configuration settings of the cluster. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.      
   */
  getSystemConfig(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/system/config";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "GET" /* GET */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets system information such as the release version, locale, time zone, deployment environment, date format, and date time format of the cluster.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemInformation(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/system";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "GET" /* GET */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of configuration overrides applied on the cluster.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemOverrideInfo(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/system/config-overrides";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "GET" /* GET */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.14.0.cl or later   Fetch communication channel preferences. - Use `cluster_preferences` to fetch the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to fetch any Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param searchCommunicationChannelPreferencesRequest 
   */
  searchCommunicationChannelPreferences(searchCommunicationChannelPreferencesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchCommunicationChannelPreferencesRequest === null || searchCommunicationChannelPreferencesRequest === void 0) {
        throw new RequiredError("SystemApi", "searchCommunicationChannelPreferences", "searchCommunicationChannelPreferencesRequest");
      }
      const localVarPath = "/api/rest/2.0/system/preferences/communication-channels/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchCommunicationChannelPreferencesRequest, "SearchCommunicationChannelPreferencesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Updates the current configuration of the cluster. You must send the configuration data in JSON format.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.      
   * @param updateSystemConfigRequest 
   */
  updateSystemConfig(updateSystemConfigRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateSystemConfigRequest === null || updateSystemConfigRequest === void 0) {
        throw new RequiredError("SystemApi", "updateSystemConfig", "updateSystemConfigRequest");
      }
      const localVarPath = "/api/rest/2.0/system/config-update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateSystemConfigRequest, "UpdateSystemConfigRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var SystemApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to configureCommunicationChannelPreferences
   * @throws ApiException if the response code was not in [200, 299]
   */
  configureCommunicationChannelPreferences(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getSystemConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  getSystemConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemConfig",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemConfig",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getSystemInformation
   * @throws ApiException if the response code was not in [200, 299]
   */
  getSystemInformation(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemInfo",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemInfo",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getSystemOverrideInfo
   * @throws ApiException if the response code was not in [200, 299]
   */
  getSystemOverrideInfo(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemOverrideInfo",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemOverrideInfo",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchCommunicationChannelPreferences
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchCommunicationChannelPreferences(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CommunicationChannelPreferencesResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CommunicationChannelPreferencesResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateSystemConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateSystemConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/TagsApi.ts
var TagsApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.0.0.cl or later   Assigns tags to Liveboards, Answers, Tables, and Worksheets.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  assignTag(assignTagRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (assignTagRequest === null || assignTagRequest === void 0) {
        throw new RequiredError("TagsApi", "assignTag", "assignTagRequest");
      }
      const localVarPath = "/api/rest/2.0/tags/assign";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(assignTagRequest, "AssignTagRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a tag object.  Tags are labels that identify a metadata object. For example, you can create a tag to designate subject areas, such as sales, HR, marketing, and finance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param createTagRequest 
   */
  createTag(createTagRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createTagRequest === null || createTagRequest === void 0) {
        throw new RequiredError("TagsApi", "createTag", "createTagRequest");
      }
      const localVarPath = "/api/rest/2.0/tags/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createTagRequest, "CreateTagRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a tag object from the ThoughtSpot system  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Tag identifier Tag name or Tag id.
   */
  deleteTag(tagIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (tagIdentifier === null || tagIdentifier === void 0) {
        throw new RequiredError("TagsApi", "deleteTag", "tagIdentifier");
      }
      const localVarPath = "/api/rest/2.0/tags/{tag_identifier}/delete".replace("{tag_identifier}", encodeURIComponent(String(tagIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of tag objects available on the ThoughtSpot system. To get details of a specific tag object, specify the GUID or name.  Any authenticated user can search for tag objects.      
   * @param searchTagsRequest 
   */
  searchTags(searchTagsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchTagsRequest === null || searchTagsRequest === void 0) {
        throw new RequiredError("TagsApi", "searchTags", "searchTagsRequest");
      }
      const localVarPath = "/api/rest/2.0/tags/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchTagsRequest, "SearchTagsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the tags applied to a Liveboard, Answer, Table, or Worksheet.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  unassignTag(assignTagRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (assignTagRequest === null || assignTagRequest === void 0) {
        throw new RequiredError("TagsApi", "unassignTag", "assignTagRequest");
      }
      const localVarPath = "/api/rest/2.0/tags/unassign";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(assignTagRequest, "AssignTagRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Updates a tag object.  You can modify the `name` and `color` properties of a tag object.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Name or Id of the tag.
   * @param updateTagRequest 
   */
  updateTag(tagIdentifier, updateTagRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (tagIdentifier === null || tagIdentifier === void 0) {
        throw new RequiredError("TagsApi", "updateTag", "tagIdentifier");
      }
      if (updateTagRequest === null || updateTagRequest === void 0) {
        throw new RequiredError("TagsApi", "updateTag", "updateTagRequest");
      }
      const localVarPath = "/api/rest/2.0/tags/{tag_identifier}/update".replace("{tag_identifier}", encodeURIComponent(String(tagIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateTagRequest, "UpdateTagRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var TagsApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to assignTag
   * @throws ApiException if the response code was not in [200, 299]
   */
  assignTag(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createTag
   * @throws ApiException if the response code was not in [200, 299]
   */
  createTag(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Tag",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Tag",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteTag
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteTag(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchTags
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchTags(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<Tag>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<Tag>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to unassignTag
   * @throws ApiException if the response code was not in [200, 299]
   */
  unassignTag(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateTag
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateTag(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/ThoughtSpotRestApi.ts
var ThoughtSpotRestApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.7.0.cl or later   Activates a deactivated user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To activate an inactive user account, the API request body must include the following information:  - Username or the GUID of the user account. - Auth token generated for the deactivated user. The auth token is sent in the API response when a user is deactivated. - Password for the user account.      
   * @param activateUserRequest 
   */
  activateUser(activateUserRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (activateUserRequest === null || activateUserRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "activateUser", "activateUserRequest");
      }
      const localVarPath = "/api/rest/2.0/users/activate";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(activateUserRequest, "ActivateUserRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Transfers the ownership of one or several objects from one user to another.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege and edit access to the objects are required.      
   * @param assignChangeAuthorRequest 
   */
  assignChangeAuthor(assignChangeAuthorRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (assignChangeAuthorRequest === null || assignChangeAuthorRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "assignChangeAuthor", "assignChangeAuthorRequest");
      }
      const localVarPath = "/api/rest/2.0/security/metadata/assign";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(assignChangeAuthorRequest, "AssignChangeAuthorRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Assigns tags to Liveboards, Answers, Tables, and Worksheets.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  assignTag(assignTagRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (assignTagRequest === null || assignTagRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "assignTag", "assignTagRequest");
      }
      const localVarPath = "/api/rest/2.0/tags/assign";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(assignTagRequest, "AssignTagRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the current password of the user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param changeUserPasswordRequest 
   */
  changeUserPassword(changeUserPasswordRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (changeUserPasswordRequest === null || changeUserPasswordRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "changeUserPassword", "changeUserPasswordRequest");
      }
      const localVarPath = "/api/rest/2.0/users/change-password";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(changeUserPasswordRequest, "ChangeUserPasswordRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Commits TML files of metadata objects to the Git branch configured on your instance.  Requires at least edit access to objects used in the commit operation.  Before using this endpoint to push your commits:  * Enable Git integration on your instance. * Make sure the Git repository and branch details are configured on your instance.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitBranchRequest 
   */
  commitBranch(commitBranchRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (commitBranchRequest === null || commitBranchRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "commitBranch", "commitBranchRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/branches/commit";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(commitBranchRequest, "CommitBranchRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.14.0.cl or later   Configure communication channel preferences. - Use `cluster_preferences` to update the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to specify Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param configureCommunicationChannelPreferencesRequest 
   */
  configureCommunicationChannelPreferences(configureCommunicationChannelPreferencesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (configureCommunicationChannelPreferencesRequest === null || configureCommunicationChannelPreferencesRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "configureCommunicationChannelPreferences", "configureCommunicationChannelPreferencesRequest");
      }
      const localVarPath = "/api/rest/2.0/system/preferences/communication-channels/configure";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(configureCommunicationChannelPreferencesRequest, "ConfigureCommunicationChannelPreferencesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Gets connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines * To get a list of all configurations available in the ThoughtSpot system, send the API request with only the connection name or GUID in the request body. * To fetch details of a configuration object, specify the configuration object name or GUID.      
   * @param connectionConfigurationSearchRequest 
   */
  connectionConfigurationSearch(connectionConfigurationSearchRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionConfigurationSearchRequest === null || connectionConfigurationSearchRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "connectionConfigurationSearch", "connectionConfigurationSearchRequest");
      }
      const localVarPath = "/api/rest/2.0/connection-configurations/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(connectionConfigurationSearchRequest, "ConnectionConfigurationSearchRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Convert worksheets to models    Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (Can manage data models).  ---  ## Usage Guidelines  ### Parameters  1. **worksheet_ids**      - **Description:** A comma-separated list of GUIDs (Globally Unique Identifiers) specifying the Worksheets to be converted.      - **Usage:**        - Used only when `convert_all` is set to `false`.        - Leave empty or omit when `convert_all` is set to `true`.  2. **exclude_worksheet_ids**      - **Description:** A comma-separated list of GUIDs specifying Worksheets to be excluded from conversion.      - **Usage:**        - Useful when `convert_all` is set to `true` and specific Worksheets should not be converted.  3. **convert_all**      - **Description:** Sets the scope of conversion.    - **Options:**        - `true`: Converts all Worksheets in the system, except those specified in `exclude_worksheet_ids`.        - `false`: Converts only the Worksheets listed in `worksheet_ids`.  4. **apply_changes**      - **Description:** Specifies whether to apply changes directly to ThoughtSpot or to generate a preview before applying any changes.Used for validation of conversion.    - **Options:**        - `true`: Applies conversion changes directly to ThoughtSpot.      - `false`: Generates only a preview of the changes and does not apply any changes to ThoughtSpot  ---  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the conversion process  2. **Partial Conversion for Testing:**      Test the conversion process by setting `convert_all` to `false` and specifying a small number of `worksheet_ids`.  3. **Verify Dependencies:**      Check for dependent objects, such as Tables and Connections, to avoid invalid references.  4. **Review Changes:**      Use `apply_changes: false` to preview the impact of the conversion before applying changes.  ---  ## Examples  ### Convert Specific Worksheets ```json {   \"worksheet_ids\": [\"guid1\", \"guid2\", \"guid3\"],   \"exclude_worksheet_ids\": [],   \"convert_all\": false,   \"apply_changes\": true } ```  ### Convert All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [],   \"convert_all\": true,   \"apply_changes\": true } ```  ### Exclude Specific Worksheets While Converting All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [\"abc\"],   \"convert_all\": true,   \"apply_changes\": true } ```     
   * @param convertWorksheetToModelRequest 
   */
  convertWorksheetToModel(convertWorksheetToModelRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (convertWorksheetToModelRequest === null || convertWorksheetToModelRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "convertWorksheetToModel", "convertWorksheetToModelRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/worksheets/convert";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(convertWorksheetToModelRequest, "ConvertWorksheetToModelRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Makes a copy of an Answer or Liveboard    Version: 10.3.0.cl or later   Creates a copy of a metadata object.  Requires at least view access to the metadata object being copied.  Upon successful execution, the API creates a copy of the metadata object specified in the API request and returns the ID of the new object.      
   * @param copyObjectRequest 
   */
  copyObject(copyObjectRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (copyObjectRequest === null || copyObjectRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "copyObject", "copyObjectRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/copyobject";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(copyObjectRequest, "CopyObjectRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   * Version: 10.13.0.cl or later 
   * @param createAgentConversationRequest 
   */
  createAgentConversation(createAgentConversationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createAgentConversationRequest === null || createAgentConversationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createAgentConversation", "createAgentConversationRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/agent/conversation/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createAgentConversationRequest, "CreateAgentConversationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Creates a new [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.   #### Usage guidelines  You can create a custom calendar from scratch or an existing Table in ThoughtSpot. For both methods of calendar creation, the following parameters are required:  * Name of the custom calendar. * Calendar creation method. To create a calendar from an existing table, specify the method:   - `FROM_EXISTING_TABLE` - Creates calendar from the table reference provided in the API request.  - `FROM_INPUT_PARAMS` - Creates a calendar from the parameters defined in the API request.  * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  **NOTE**: If you are creating a calendar from an existing table, ensure that the referenced table matches the required DDL for custom calendars. If the schema does not match, the API returns an error.  ##### Calendar type The API allows you to create the following types of calendars:  * `MONTH_OFFSET`. The default calendar type. A `MONTH_OFFSET` calendar is offset by a few months from the standard calendar months (January to December) and the year begins with the month defined in the request. For example, if the `month_offset` value is set as `April`, the calendar year begins in April.  * `4-4-5`. Each quarter in the calendar will include two 4-week months followed by one 5-week month. * `4-5-4`. Each quarter in the calendar will include two 4-week months with a 5-week month between. * `5-4-4`. Each quarter begins with a 5-week month, followed by two 4-week months.  To start and end the calendar on a specific date, specify the dates in the `MM/DD/YYYY` format. For `MONTH_OFFSET` calendars, ensure that the `start_date` matches the month specified in the `month_offset` attribute.  You can also set the starting day of the week and customize the prefixes for year and quarter labels.  #### Examples  To create a calendar from an existing table:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_EXISTING_TABLE\", } ```  To create a calendar from scratch:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_INPUT_PARAMS\",   \"calendar_type\": \"MONTH_OFFSET\",   \"month_offset\": \"April\",   \"start_day_of_week\": \"Monday\",   \"quarter_name_prefix\": \"Q\",   \"year_name_prefix\": \"FY\",   \"start_date\": \"04/01/2025\",   \"end_date\": \"04/31/2025\" } ```      
   * @param createCalendarRequest 
   */
  createCalendar(createCalendarRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createCalendarRequest === null || createCalendarRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createCalendar", "createCalendarRequest");
      }
      const localVarPath = "/api/rest/2.0/calendars/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createCalendarRequest, "CreateCalendarRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to connect a ThoughtSpot instance to a Git repository.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.  You can use this API endpoint to connect your ThoughtSpot development and production environments to the development and production branches of a Git repository.  Before using this endpoint to connect your ThoughtSpot instance to a Git repository, check the following prerequisites:  * You have a Git repository. If you are using GitHub, make sure you have a valid account and an access token to connect ThoughtSpot to GitHub. For information about generating a token, see [GitHub Documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).  * Your access token has `repo` scope that grants full access to public and private repositories. * Your Git repository has a branch that can be configured as a default branch in ThoughtSpot.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/?pageid=git-integration).  **Note**: ThoughtSpot supports only GitHub / itHub Enterprise for CI/CD.      
   * @param createConfigRequest 
   */
  createConfig(createConfigRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createConfigRequest === null || createConfigRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createConfig", "createConfigRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/config/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createConfigRequest, "CreateConfigRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Creates a connection to a data warehouse for live query services.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Create a connection without tables  To create a connection without tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a SnowFlake connection:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[       ]   }   ``` 2. Set `validate` to `false`.  #### Create a connection with tables  To create a connection with tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[         {            \"name\":\"AllDatatypes\",            \"isAutoCreated\":false,            \"schemas\":[               {                  \"name\":\"alldatatypes\",                  \"tables\":[                     {                        \"name\":\"allDatatypes\",                        \"type\":\"TABLE\",                        \"description\":\"\",                        \"selected\":true,                        \"linked\":true,                        \"columns\":[                           {                              \"name\":\"CNUMBER\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           },                           {                              \"name\":\"CDECIMAL\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           }                        ]                     }                  ]               }            ]         }      ]   }   ``` 2. Set `validate` to `true`.      
   * @param createConnectionRequest 
   */
  createConnection(createConnectionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createConnectionRequest === null || createConnectionRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createConnection", "createConnectionRequest");
      }
      const localVarPath = "/api/rest/2.0/connection/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createConnectionRequest, "CreateConnectionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Creates an additional configuration to an existing connection to a data warehouse.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines   * A JSON map of configuration attributes in `configuration`. The following example shows the configuration attributes:   ```    {      \"user\":\"DEV_USER\",      \"password\":\"TestConn123\",      \"role\":\"DEV\",      \"warehouse\":\"DEV_WH\"     }   ```  * If the `policy_type` is `PRINCIPALS`, then `policy_principals` is a required field. * If the `policy_type` is `PROCESSES`, then `policy_processes` is a required field. * If the `policy_type` is `NO_POLICY`, then `policy_principals` and `policy_processes` are not required fields.  #### Parameterized Connection Support For parameterized connections that use OAuth authentication, only the same_as_parent and policy_process_options  attributes are allowed in the API request. These attributes are not applicable to connections that are not parameterized.       
   * @param createConnectionConfigurationRequest 
   */
  createConnectionConfiguration(createConnectionConfigurationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createConnectionConfigurationRequest === null || createConnectionConfigurationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createConnectionConfiguration", "createConnectionConfigurationRequest");
      }
      const localVarPath = "/api/rest/2.0/connection-configurations/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createConnectionConfigurationRequest, "CreateConnectionConfigurationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.4.0.cl or later   Creates a Conversation object to start an AI-driven conversation based on a specific data model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  This API requires the `metadata_identifier` parameter to define the context for the conversation.  You can also specify the tokens to initiate the conversation as shown in this example:  `\"tokens\": \"[tea],[sales],[type]\"`  If the API request is successful, ThoughtSpot returns the ID of the conversation.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param createConversationRequest 
   */
  createConversation(createConversationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createConversationRequest === null || createConversationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createConversation", "createConversationRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/conversation/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createConversationRequest, "CreateConversationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.6.0.cl or later   Creates a custom action that appears as a menu action on a saved Answer or Liveboard visualization.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API lets you create the following types of custom actions:  * URL-based action        Allows pushing data to an external URL. * Callback action           Triggers a callback to the host application and initiates a response payload on an embedded ThoughtSpot instance.  By default, custom actions are visible to only administrator or developer users. To make a custom action available to other users, and specify the groups in `group_identifiers`.  By default, the custom action is set as a _global_ action on all visualizations and saved Answers. To assign a custom action to specific Liveboard visualization, saved Answer, or Worksheet, set `visibility` to `false` in `default_action_config` property and specify the GUID or name of the object in `associate_metadata`.  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param createCustomActionRequest 
   */
  createCustomAction(createCustomActionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createCustomActionRequest === null || createCustomActionRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createCustomAction", "createCustomActionRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/custom-actions";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createCustomActionRequest, "CreateCustomActionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.10.0.cl or later   Creates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To create a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param createEmailCustomizationRequest 
   */
  createEmailCustomization(createEmailCustomizationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createEmailCustomizationRequest === null || createEmailCustomizationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createEmailCustomization", "createEmailCustomizationRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/email";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createEmailCustomizationRequest, "CreateEmailCustomizationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Creates an Org object.  To use this API, the [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview) feature must be enabled in your cluster.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param createOrgRequest 
   */
  createOrg(createOrgRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createOrgRequest === null || createOrgRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createOrg", "createOrgRequest");
      }
      const localVarPath = "/api/rest/2.0/orgs/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createOrgRequest, "CreateOrgRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.5.0.cl or later   Creates a Role object in ThoughtSpot.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To create a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param createRoleRequest 
   */
  createRole(createRoleRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createRoleRequest === null || createRoleRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createRole", "createRoleRequest");
      }
      const localVarPath = "/api/rest/2.0/roles/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createRoleRequest, "CreateRoleRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Create schedule.    Version: 9.4.0.cl or later   Creates a Liveboard schedule job.  Requires at least edit access to Liveboards. To create a schedule on behalf of another user, you need  `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  #### Usage guidelines  * The description text is mandatory.  The description text appears as **Description: <your content>** in the Liveboard schedule email notifications. * For Liveboards with both charts and tables, schedule creation is only supported in PDF and XLS formats. Schedules created in CSV formats for such Liveboards will fail to run. If `PDF` is set as the `file_format`, enable `pdf_options` to get the correct attachment. Not doing so may cause the attachment to be rendered empty. * To include only specific visualizations, specify the visualization GUIDs in the `visualization_identifiers` array. * You can schedule a Liveboard job to run periodically by setting frequency parameters. You can set the schedule to run daily, weekly, monthly or every n minutes or hours. The scheduled job can also be configured to run at a specific time of the day or on specific days of the week or month. Please ensure that when setting the schedule frequency for _minute of the object_, only values that are multiples of 5 are included. * If the `frequency` parameters are defined, you can set the time zone to a value that matches your server\'s time zone. For example, `US/Central`, `Etc/UTC`, `CET`. The default time zone is `America/Los_Angeles`.  For more information about Liveboard jobs, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/liveboard-schedule).     
   * @param createScheduleRequest 
   */
  createSchedule(createScheduleRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createScheduleRequest === null || createScheduleRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createSchedule", "createScheduleRequest");
      }
      const localVarPath = "/api/rest/2.0/schedules/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createScheduleRequest, "CreateScheduleRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a tag object.  Tags are labels that identify a metadata object. For example, you can create a tag to designate subject areas, such as sales, HR, marketing, and finance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param createTagRequest 
   */
  createTag(createTagRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createTagRequest === null || createTagRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createTag", "createTagRequest");
      }
      const localVarPath = "/api/rest/2.0/tags/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createTagRequest, "CreateTagRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a user in ThoughtSpot.  The API endpoint allows you to configure several user properties such as email address, account status, share notification preferences, and sharing visibility. You can provision the user to [groups](https://docs.thoughtspot.com/cloud/latest/groups-privileges) and [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview). You can also add Liveboard, Answer, and Worksheet objects to the users favorites list, assign a default Liveboard for the user, and set user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param createUserRequest 
   */
  createUser(createUserRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createUserRequest === null || createUserRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createUser", "createUserRequest");
      }
      const localVarPath = "/api/rest/2.0/users/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createUserRequest, "CreateUserRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### About groups Groups in ThoughtSpot are used by the administrators to define privileges and organize users based on their roles and access requirements. To know more about groups and privileges, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/groups-privileges).  #### Supported operations  The API endpoint lets you perform the following operations:  * Assign privileges * Add users * Define sharing visibility * Add sub-groups * Assign a default Liveboard      
   * @param createUserGroupRequest 
   */
  createUserGroup(createUserGroupRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createUserGroupRequest === null || createUserGroupRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createUserGroup", "createUserGroupRequest");
      }
      const localVarPath = "/api/rest/2.0/groups/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createUserGroupRequest, "CreateUserGroupRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Create a variable which can be used for parameterizing metadata objects   Version: 10.14.0.cl or later   Allows creating a variable which can be used for parameterizing metadata objects in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports the following types of variables: * CONNECTION_PROPERTY - For connection properties * TABLE_MAPPING - For table mappings * CONNECTION_PROPERTY_PER_PRINCIPAL - For connection properties per principal. In order to use this please contact support to enable this. * FORMULA_VARIABLE - For Formula variables, introduced in 10.15.0.cl  When creating a variable, you need to specify: * The variable type * A unique name for the variable * Whether the variable contains sensitive values (defaults to false) * The data type of the variable, only specify for formula variables (defaults to null)  The operation will fail if: * The user lacks required permissions * The variable name already exists * The variable type is invalid     
   * @param createVariableRequest 
   */
  createVariable(createVariableRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createVariableRequest === null || createVariableRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createVariable", "createVariableRequest");
      }
      const localVarPath = "/api/rest/2.0/template/variables/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createVariableRequest, "CreateVariableRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.14.0.cl or later   Creates a new webhook configuration to receive notifications for specified events. The webhook will be triggered when the configured events occur in the system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param createWebhookConfigurationRequest 
   */
  createWebhookConfiguration(createWebhookConfigurationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createWebhookConfigurationRequest === null || createWebhookConfigurationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "createWebhookConfiguration", "createWebhookConfigurationRequest");
      }
      const localVarPath = "/api/rest/2.0/webhooks/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createWebhookConfigurationRequest, "CreateWebhookConfigurationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Creates a DBT connection object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About create DBT connection DBT connection in ThoughtSpot is used by the user to define DBT credentials for cloud . The API needs  embrace connection, embrace database name, DBT url, import type, DBT account identifier, DBT project identifier, DBT access token and environment details (or) embrace connection, embrace database name, import type, file_content to create a connection object. To know more about DBT, see ThoughtSpot Product Documentation.      
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  dbtConnection(connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionName === null || connectionName === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "dbtConnection", "connectionName");
      }
      if (databaseName === null || databaseName === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "dbtConnection", "databaseName");
      }
      const localVarPath = "/api/rest/2.0/dbt/dbt-connection";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const useForm = canConsumeForm([
        "multipart/form-data"
      ]);
      let localVarFormParams;
      if (useForm) {
        localVarFormParams = new FormData();
      } else {
        localVarFormParams = new URLSearchParams();
      }
      if (connectionName !== void 0) {
        localVarFormParams.append("connection_name", connectionName);
      }
      if (databaseName !== void 0) {
        localVarFormParams.append("database_name", databaseName);
      }
      if (importType !== void 0) {
        localVarFormParams.append("import_type", importType);
      }
      if (accessToken !== void 0) {
        localVarFormParams.append("access_token", accessToken);
      }
      if (dbtUrl !== void 0) {
        localVarFormParams.append("dbt_url", dbtUrl);
      }
      if (accountId !== void 0) {
        localVarFormParams.append("account_id", accountId);
      }
      if (projectId !== void 0) {
        localVarFormParams.append("project_id", projectId);
      }
      if (dbtEnvId !== void 0) {
        localVarFormParams.append("dbt_env_id", dbtEnvId);
      }
      if (projectName !== void 0) {
        localVarFormParams.append("project_name", projectName);
      }
      if (fileContent !== void 0) {
        if (localVarFormParams instanceof FormData) {
          localVarFormParams.append("file_content", fileContent, fileContent.name);
        }
      }
      requestContext.setBody(localVarFormParams);
      if (!useForm) {
        const contentType = ObjectSerializer.getPreferredMediaType([
          "multipart/form-data"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
      }
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Resynchronize the existing list of models, tables, worksheet tmls and import them to Thoughtspot based on the DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateSyncTml(dbtConnectionIdentifier, fileContent, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (dbtConnectionIdentifier === null || dbtConnectionIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "dbtGenerateSyncTml", "dbtConnectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/dbt/generate-sync-tml";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const useForm = canConsumeForm([
        "multipart/form-data"
      ]);
      let localVarFormParams;
      if (useForm) {
        localVarFormParams = new FormData();
      } else {
        localVarFormParams = new URLSearchParams();
      }
      if (dbtConnectionIdentifier !== void 0) {
        localVarFormParams.append("dbt_connection_identifier", dbtConnectionIdentifier);
      }
      if (fileContent !== void 0) {
        if (localVarFormParams instanceof FormData) {
          localVarFormParams.append("file_content", fileContent, fileContent.name);
        }
      }
      requestContext.setBody(localVarFormParams);
      if (!useForm) {
        const contentType = ObjectSerializer.getPreferredMediaType([
          "multipart/form-data"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
      }
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Generate required table and worksheet and import them.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About generate TML Models and Worksheets to be imported can be selected by the user as part of the API.      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param modelTables List of Models and their respective Tables Example: \\\&#39;[{\\\&quot;model_name\\\&quot;: \\\&quot;model_name\\\&quot;, \\\&quot;tables\\\&quot;: [\\\&quot;table_name\\\&quot;]}]\\\&#39;
   * @param importWorksheets Mention the worksheet tmls to import
   * @param worksheets List of worksheets is mandatory when import_Worksheets is type SELECTED Example: [\\\&quot;worksheet_name\\\&quot;]
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateTml(dbtConnectionIdentifier, modelTables, importWorksheets, worksheets, fileContent, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (dbtConnectionIdentifier === null || dbtConnectionIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "dbtGenerateTml", "dbtConnectionIdentifier");
      }
      if (modelTables === null || modelTables === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "dbtGenerateTml", "modelTables");
      }
      if (importWorksheets === null || importWorksheets === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "dbtGenerateTml", "importWorksheets");
      }
      const localVarPath = "/api/rest/2.0/dbt/generate-tml";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const useForm = canConsumeForm([
        "multipart/form-data"
      ]);
      let localVarFormParams;
      if (useForm) {
        localVarFormParams = new FormData();
      } else {
        localVarFormParams = new URLSearchParams();
      }
      if (dbtConnectionIdentifier !== void 0) {
        localVarFormParams.append("dbt_connection_identifier", dbtConnectionIdentifier);
      }
      if (modelTables !== void 0) {
        localVarFormParams.append("model_tables", modelTables);
      }
      if (importWorksheets !== void 0) {
        localVarFormParams.append("import_worksheets", importWorksheets);
      }
      if (worksheets !== void 0) {
        localVarFormParams.append("worksheets", worksheets);
      }
      if (fileContent !== void 0) {
        if (localVarFormParams instanceof FormData) {
          localVarFormParams.append("file_content", fileContent, fileContent.name);
        }
      }
      requestContext.setBody(localVarFormParams);
      if (!useForm) {
        const contentType = ObjectSerializer.getPreferredMediaType([
          "multipart/form-data"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
      }
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Gets a list of DBT connection objects by user and organization, available on the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About search DBT connection To get details of a specific DBT connection identifier, database connection identifier, database connection name, database name, project name, project identifier, environment identifier , import type and author.      
   */
  dbtSearch(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/dbt/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.7.0.cl or later   Deactivates a user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To deactivate a user account, the API request body must include the following information:  - Username or the GUID of the user account - Base URL of the ThoughtSpot instance  If the API request is successful, ThoughtSpot returns the activation URL in the response. The activation URL is valid for 14 days and can be used to re-activate the account and reset the password of the deactivated account.      
   * @param deactivateUserRequest 
   */
  deactivateUser(deactivateUserRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deactivateUserRequest === null || deactivateUserRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deactivateUser", "deactivateUserRequest");
      }
      const localVarPath = "/api/rest/2.0/users/deactivate";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deactivateUserRequest, "DeactivateUserRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines To delete a custom calendar, specify the calendar ID as a path parameter in the request URL.        
   * @param calendarIdentifier Unique ID or name of the Calendar.
   */
  deleteCalendar(calendarIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (calendarIdentifier === null || calendarIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteCalendar", "calendarIdentifier");
      }
      const localVarPath = "/api/rest/2.0/calendars/{calendar_identifier}/delete".replace("{calendar_identifier}", encodeURIComponent(String(calendarIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Deletes Git repository configuration from your ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param deleteConfigRequest 
   */
  deleteConfig(deleteConfigRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteConfigRequest === null || deleteConfigRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteConfig", "deleteConfigRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/config/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteConfigRequest, "DeleteConfigRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later    **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Delete Connection V2](#/http/api-endpoints/connections/delete-connection-v2) endpoint to delete your connection objects.    #### Usage guidelines  Deletes a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.     
   * @param deleteConnectionRequest 
   */
  deleteConnection(deleteConnectionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteConnectionRequest === null || deleteConnectionRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteConnection", "deleteConnectionRequest");
      }
      const localVarPath = "/api/rest/2.0/connection/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteConnectionRequest, "DeleteConnectionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param deleteConnectionConfigurationRequest 
   */
  deleteConnectionConfiguration(deleteConnectionConfigurationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteConnectionConfigurationRequest === null || deleteConnectionConfigurationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteConnectionConfiguration", "deleteConnectionConfigurationRequest");
      }
      const localVarPath = "/api/rest/2.0/connection-configurations/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteConnectionConfigurationRequest, "DeleteConnectionConfigurationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.4.0.cl or later   Deletes a connection object.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param connectionIdentifier Unique ID or name of the connection.
   */
  deleteConnectionV2(connectionIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionIdentifier === null || connectionIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteConnectionV2", "connectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/connections/{connection_identifier}/delete".replace("{connection_identifier}", encodeURIComponent(String(connectionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.6.0.cl or later   Removes the custom action specified in the API request.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param customActionIdentifier Unique ID or name of the custom action.
   */
  deleteCustomAction(customActionIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (customActionIdentifier === null || customActionIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteCustomAction", "customActionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/customization/custom-actions/{custom_action_identifier}/delete".replace("{custom_action_identifier}", encodeURIComponent(String(customActionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Removes the specified DBT connection object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   */
  deleteDbtConnection(dbtConnectionIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (dbtConnectionIdentifier === null || dbtConnectionIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteDbtConnection", "dbtConnectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/dbt/{dbt_connection_identifier}/delete".replace("{dbt_connection_identifier}", encodeURIComponent(String(dbtConnectionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.10.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `template_identifier` from the response. - Use that `template_identifier` as a parameter in this API request.      
   * @param templateIdentifier Unique ID or name of the email customization.
   */
  deleteEmailCustomization(templateIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (templateIdentifier === null || templateIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteEmailCustomization", "templateIdentifier");
      }
      const localVarPath = "/api/rest/2.0/customization/email/{template_identifier}/delete".replace("{template_identifier}", encodeURIComponent(String(templateIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified metadata object from the ThoughtSpot system.  Requires edit access to the metadata object.       
   * @param deleteMetadataRequest 
   */
  deleteMetadata(deleteMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteMetadataRequest === null || deleteMetadataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteMetadata", "deleteMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteMetadataRequest, "DeleteMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes an Org object from the ThoughtSpot system.  Requires cluster administration (**Can administer Org**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.  When you delete an Org, all its users and objects created in that Org context are removed. However, if the users in the deleted Org also exists in other Orgs, they are removed only from the deleted Org.      
   * @param orgIdentifier ID or name of the Org
   */
  deleteOrg(orgIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (orgIdentifier === null || orgIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteOrg", "orgIdentifier");
      }
      const localVarPath = "/api/rest/2.0/orgs/{org_identifier}/delete".replace("{org_identifier}", encodeURIComponent(String(orgIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.12.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `org_identifier` from the response. - Use that `org_identifier` as a parameter in this API request.      
   * @param deleteOrgEmailCustomizationRequest 
   */
  deleteOrgEmailCustomization(deleteOrgEmailCustomizationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteOrgEmailCustomizationRequest === null || deleteOrgEmailCustomizationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteOrgEmailCustomization", "deleteOrgEmailCustomizationRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/email/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteOrgEmailCustomizationRequest, "DeleteOrgEmailCustomizationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.5.0.cl or later   Deletes a Role object from the ThoughtSpot system.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To delete a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role. ReadOnly roles cannot be deleted.
   */
  deleteRole(roleIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (roleIdentifier === null || roleIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteRole", "roleIdentifier");
      }
      const localVarPath = "/api/rest/2.0/roles/{role_identifier}/delete".replace("{role_identifier}", encodeURIComponent(String(roleIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Deletes a scheduled job.    Version: 9.4.0.cl or later   Deletes a scheduled Liveboard job.  Requires at least edit access to Liveboard or `ADMINISTRATION` (**Can administer Org**) privilege.    If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.      
   * @param scheduleIdentifier Unique ID or name of the scheduled job.
   */
  deleteSchedule(scheduleIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (scheduleIdentifier === null || scheduleIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteSchedule", "scheduleIdentifier");
      }
      const localVarPath = "/api/rest/2.0/schedules/{schedule_identifier}/delete".replace("{schedule_identifier}", encodeURIComponent(String(scheduleIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a tag object from the ThoughtSpot system  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Tag identifier Tag name or Tag id.
   */
  deleteTag(tagIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (tagIdentifier === null || tagIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteTag", "tagIdentifier");
      }
      const localVarPath = "/api/rest/2.0/tags/{tag_identifier}/delete".replace("{tag_identifier}", encodeURIComponent(String(tagIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a user from the ThoughtSpot system.  If you want to remove a user from a specific Org but not from ThoughtSpot, update the group and Org mapping properties of the user object via a POST API call to the [/api/rest/2.0/users/{user_identifier}/update](#/http/api-endpoints/users/update-user) endpoint.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   */
  deleteUser(userIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (userIdentifier === null || userIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteUser", "userIdentifier");
      }
      const localVarPath = "/api/rest/2.0/users/{user_identifier}/delete".replace("{user_identifier}", encodeURIComponent(String(userIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified group object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.      
   * @param groupIdentifier GUID or name of the group.
   */
  deleteUserGroup(groupIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (groupIdentifier === null || groupIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteUserGroup", "groupIdentifier");
      }
      const localVarPath = "/api/rest/2.0/groups/{group_identifier}/delete".replace("{group_identifier}", encodeURIComponent(String(groupIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Delete a variable   Version: 10.14.0.cl or later   Allows deleting a variable from ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint requires: * The variable identifier (ID or name)  The operation will fail if: * The user lacks required permissions * The variable doesn\'t exist * The variable is being used by other objects      
   * @param identifier Unique id or name of the variable
   */
  deleteVariable(identifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (identifier === null || identifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteVariable", "identifier");
      }
      const localVarPath = "/api/rest/2.0/template/variables/{identifier}/delete".replace("{identifier}", encodeURIComponent(String(identifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.14.0.cl or later   Deletes one or more webhook configurations by their unique id or name. Returns status of each deletion operation, including successfully deleted webhooks and any failures with error details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param deleteWebhookConfigurationsRequest 
   */
  deleteWebhookConfigurations(deleteWebhookConfigurationsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteWebhookConfigurationsRequest === null || deleteWebhookConfigurationsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deleteWebhookConfigurations", "deleteWebhookConfigurationsRequest");
      }
      const localVarPath = "/api/rest/2.0/webhooks/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteWebhookConfigurationsRequest, "DeleteWebhookConfigurationsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to deploy a commit and publish TML content to your ThoughtSpot instance.  Requires at least edit access to the objects used in the deploy operation.  The API deploys the head of the branch unless a `commit_id` is specified in the API request. If the branch name is not defined in the request, the default branch is considered for deploying commits.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param deployCommitRequest 
   */
  deployCommit(deployCommitRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deployCommitRequest === null || deployCommitRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "deployCommit", "deployCommitRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/commits/deploy";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deployCommitRequest, "DeployCommitRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Exports the difference in connection metadata between CDW and ThoughtSpot  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:   - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  To download the connection metadata difference between ThoughtSpot and CDW, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  downloadConnectionMetadataChanges(connectionIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionIdentifier === null || connectionIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "downloadConnectionMetadataChanges", "connectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/connections/download-connection-metadata-changes/{connection_identifier}".replace("{connection_identifier}", encodeURIComponent(String(connectionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Exports an Answer in the given file format. You can download the Answer data as a PDF, PNG, CSV, or XLSX file.  Requires at least view access to the Answer.  #### Usage guidelines  In the request body, the GUID or name of the Answer and set `file_format`. The default file format is CSV.  **NOTE**: * The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension. * HTML rendering is not supported for PDF exports of Answers with tables.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.       
   * @param exportAnswerReportRequest 
   */
  exportAnswerReport(exportAnswerReportRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (exportAnswerReportRequest === null || exportAnswerReportRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "exportAnswerReport", "exportAnswerReportRequest");
      }
      const localVarPath = "/api/rest/2.0/report/answer";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(exportAnswerReportRequest, "ExportAnswerReportRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Exports a Liveboard and its visualizations in PDF, PNG, CSV, or XLSX file format.  Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To generate a Liveboard report with specific visualizations, add GUIDs or names of the visualizations.  The default `file_format` is CSV. For PDF exports, you can specify additional parameters to customize the page orientation and include or exclude the cover page, logo, footer text, and page numbers. Similar customization options are available for PNG exports. CSV and XLSX exports do not support customization options.  **NOTE**: The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes, including ad hoc changes to visualizations. For more information, see [Liveboard Report API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_liveboard_report_api).    **NOTE**: Starting with ThoughtSpot Cloud 10.9.0.cl release, the Liveboard can be exported in the PNG format in the resolution of your choice. To enable this on your instance, contact ThoughtSpot support. When this feature is enabled, the options `include_cover_page`,`include_filter_page` within the `png_options` will not be available for PNG exports.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in CSV format. All visualizations in the Liveboard can be exported as individual CSV files. If multiple visualizations are selected or if the entire Liveboard is exported, the output is returned as a .zip file containing the CSV files for each visualization.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in XLSX format. All selected visualizations are consolidated into a single Excel workbook (.xlsx), with each visualization placed in its own worksheet (tab). XLSX exports are limited to 255 worksheets (tabs) per workbook.      
   * @param exportLiveboardReportRequest 
   */
  exportLiveboardReport(exportLiveboardReportRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (exportLiveboardReportRequest === null || exportLiveboardReportRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "exportLiveboardReport", "exportLiveboardReportRequest");
      }
      const localVarPath = "/api/rest/2.0/report/liveboard";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(exportLiveboardReportRequest, "ExportLiveboardReportRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  Requires `DATADOWNLOADING` (**Can download Data**) and at least view access to the metadata object.  #### Usage guidelines  * You can export one or several objects by passing metadata object GUIDs in the `metadata` array. * When exporting TML content for a Liveboard or Answer object, you can set `export_associated` to `true` to retrieve TML content for underlying Worksheets, Tables, or Views, including the GUID of each object within the headers. When   `export_associated` is set to `true`, consider retrieving one metadata object at a time. * Set `export_fqns` to `true` to add FQNs of the referenced objects in the TML content. For example, if you send an API request to retrieve TML for a Liveboard and its associated objects, the API returns the TML content with FQNs of the referenced Worksheet. Exporting TML with FQNs is useful if ThoughtSpot has multiple objects with the same name and you want to eliminate ambiguity when importing TML files into ThoughtSpot. It eliminates the need for adding FQNs of the referenced objects manually during the import operation. * To export only the TML of feedbacks associated with an object, set the GUID of the object as `identifier`, and set the `type` as `FEEDBACK` in the `metadata` array. * To export the TML of an object along with the feedbacks associated with it, set the GUID of the object as `identifier`, set the `type` as `LOGIAL_TABLE` in the `metadata` array, and set `export_with_associated_feedbacks` in `export_options` to true.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_export_a_tml).  For more information on feedbacks, see [Feedback Documentation](https://docs.thoughtspot.com/cloud/latest/sage-feedback).     
   * @param exportMetadataTMLRequest 
   */
  exportMetadataTML(exportMetadataTMLRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (exportMetadataTMLRequest === null || exportMetadataTMLRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "exportMetadataTML", "exportMetadataTMLRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/tml/export";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(exportMetadataTMLRequest, "ExportMetadataTMLRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.1.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  ### **Permissions Required**  Requires `DATAMANAGEMENT` (**Can manage data**) and `USERMANAGEMENT` (**Can manage users**) privileges.  #### **Usage Guidelines**  This API is only applicable for `USER`, `GROUP`, and `ROLES` metadata types.  - `batch_offset` Indicates the starting position within the complete dataset from which the API should begin returning objects. Useful for paginating results efficiently. - `batch_size` Specifies the number of objects or items to retrieve in a single request. Helps control response size for better performance. - `edoc_format` Defines the format of the TML content. The exported metadata can be in JSON or YAML format. - `export_dependent` Specifies whether to include dependent metadata objects in the export. Ensures related objects are also retrieved if needed. - `all_orgs_override` Indicates whether the export operation applies across all organizations. Useful for multi-tenant environments where cross-org exports are required.      
   * @param exportMetadataTMLBatchedRequest 
   */
  exportMetadataTMLBatched(exportMetadataTMLBatchedRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (exportMetadataTMLBatchedRequest === null || exportMetadataTMLBatchedRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "exportMetadataTMLBatched", "exportMetadataTMLBatchedRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/tml/export/batch";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(exportMetadataTMLBatchedRequest, "ExportMetadataTMLBatchedRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches data from a saved Answer.  Requires at least view access to the saved Answer.  The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_apis).     
   * @param fetchAnswerDataRequest 
   */
  fetchAnswerData(fetchAnswerDataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchAnswerDataRequest === null || fetchAnswerDataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "fetchAnswerData", "fetchAnswerDataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/answer/data";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchAnswerDataRequest, "FetchAnswerDataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for an Answer object.  Requires at least view access to the Answer object.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {    \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",    \"metadata_name\":\"Total sales\",    \"metadata_type\":\"ANSWER\",    \"sql_queries\":[       {          \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",          \"metadata_name\":\"Total sales -test\",          \"sql_query\":\"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  \\\"ta_2\\\".\\\"PRODUCTNAME\\\" \\\"ca_2\\\", \\n  \\\"ta_1\\\".\\\"STORENAME\\\" \\\"ca_3\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_4\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_5\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_3\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_3\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_PRODUCTS\\\" \\\"ta_2\\\"\\n    ON \\\"ta_3\\\".\\\"PRODUCTID\\\" = \\\"ta_2\\\".\\\"PRODUCTID\\\"\\nGROUP BY \\n  \\\"ca_1\\\", \\n  \\\"ca_2\\\", \\n  \\\"ca_3\\\"\\n\"       }    ] } ```      
   * @param fetchAnswerSqlQueryRequest 
   */
  fetchAnswerSqlQuery(fetchAnswerSqlQueryRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchAnswerSqlQueryRequest === null || fetchAnswerSqlQueryRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "fetchAnswerSqlQuery", "fetchAnswerSqlQueryRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/answer/sql";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchAnswerSqlQueryRequest, "FetchAnswerSqlQueryRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.4.0.cl or later   Gets information about the status of the TML async import task scheduled using the `/api/rest/2.0/metadata/tml/async/import` API call.  To fetch the task details, specify the ID of the TML async import task.    Requires access to the task ID. The API allows users who initiated the asynchronous TML import via `/api/rest/2.0/metadata/tml/async/import` to view the status of their tasks.  Users with administration privilege can view the status of all import tasks initiated by the users in their Org.  #### Usage guidelines  See [TML API Documentation](https://developers.thoughtspot.com/docs/tml#_fetch_status_of_the_tml_import_task) for usage guidelines.     
   * @param fetchAsyncImportTaskStatusRequest 
   */
  fetchAsyncImportTaskStatus(fetchAsyncImportTaskStatusRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchAsyncImportTaskStatusRequest === null || fetchAsyncImportTaskStatusRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "fetchAsyncImportTaskStatus", "fetchAsyncImportTaskStatusRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/tml/async/status";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchAsyncImportTaskStatusRequest, "FetchAsyncImportTaskStatusRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.12.0.cl or later   Fetches column security rules for specified tables.  This API endpoint retrieves column-level security rules configured for tables. It returns information about which columns are secured and which groups have access to those columns.  #### Usage guidelines  - Provide an array of table identifiers using either `identifier` (GUID or name) or `obj_identifier` (object ID) - At least one of `identifier` or `obj_identifier` must be provided for each table - The API returns column security rules for all specified tables - Users must have appropriate permissions to access security rules for the specified tables  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables  #### Example request  ```json {   \"tables\": [     {       \"identifier\": \"table-guid\",       \"obj_identifier\": \"table-object-id\"     }   ] } ```  #### Response format  The API returns an array of `ColumnSecurityRuleResponse` objects wrapped in a `data` field. Each `ColumnSecurityRuleResponse` object contains: - Table information (GUID and object ID)   - Array of column security rules with column details, group access, and source table information  #### Example response  ```json {   \"data\": [     {       \"guid\": \"table-guid\",       \"objId\": \"table-object-id\",       \"columnSecurityRules\": [         {           \"column\": {             \"id\": \"col_123\",             \"name\": \"Salary\"           },           \"groups\": [             {               \"id\": \"group_1\",               \"name\": \"HR Department\"             }           ],           \"sourceTableDetails\": {             \"id\": \"source-table-guid\",             \"name\": \"Employee_Data\"           }         }       ]     }   ] } ```     
   * @param fetchColumnSecurityRulesRequest 
   */
  fetchColumnSecurityRules(fetchColumnSecurityRulesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchColumnSecurityRulesRequest === null || fetchColumnSecurityRulesRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "fetchColumnSecurityRules", "fetchColumnSecurityRulesRequest");
      }
      const localVarPath = "/api/rest/2.0/security/column/rules/fetch";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchColumnSecurityRulesRequest, "FetchColumnSecurityRulesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Validates the difference in connection metadata between CDW and ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  Returns a boolean indicating whether there is any difference between the connection metadata at ThoughtSpot and CDW.  To get the connection metadata difference status, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  fetchConnectionDiffStatus(connectionIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionIdentifier === null || connectionIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "fetchConnectionDiffStatus", "connectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/connections/fetch-connection-diff-status/{connection_identifier}".replace("{connection_identifier}", encodeURIComponent(String(connectionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets data from a Liveboard object and its visualization.    Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To get data for specific visualizations, add the GUIDs or names of the visualizations in the API request.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes. If the new Liveboard experience mode, the transient content includes ad hoc changes to visualizations such as sorting, toggling of legends, and data drill down.  For more information, and see [Liveboard data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_fetch_liveboard_data_api).     
   * @param fetchLiveboardDataRequest 
   */
  fetchLiveboardData(fetchLiveboardDataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchLiveboardDataRequest === null || fetchLiveboardDataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "fetchLiveboardData", "fetchLiveboardDataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/liveboard/data";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchLiveboardDataRequest, "FetchLiveboardDataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for a Liveboard object and its visualizations.  Requires at least view access to the Liveboard object.  To get SQL query data for a Liveboard, specify the GUID of the Liveboard. Optionally, you can add an array of visualization GUIDs to retrieve the SQL query data for visualizations in the Liveboard.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {   \"metadata_id\": \"fa68ae91-7588-4136-bacd-d71fb12dda69\",   \"metadata_name\": \"Total Sales\",   \"metadata_type\": \"LIVEBOARD\",   \"sql_queries\": [     {       \"metadata_id\": \"b3b6d2b9-089a-490c-8e16-b144650b7843\",       \"metadata_name\": \"Total quantity purchased, Total sales by region\",       \"sql_query\": \"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_2\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_3\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_2\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_2\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\nGROUP BY \\\"ca_1\\\"\"     }   ] } ```      
   * @param fetchLiveboardSqlQueryRequest 
   */
  fetchLiveboardSqlQuery(fetchLiveboardSqlQueryRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchLiveboardSqlQueryRequest === null || fetchLiveboardSqlQueryRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "fetchLiveboardSqlQuery", "fetchLiveboardSqlQueryRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/liveboard/sql";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchLiveboardSqlQueryRequest, "FetchLiveboardSqlQueryRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches security audit logs.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the [Admin Control](https://developers.thoughtspot.com/docs/rbac#_admin_control) privileges are required.   #### Usage guidelines  By default, the API retrieves logs for the last 24 hours. You can set a custom duration in EPOCH time. Make sure the log duration specified in your API request doesnt exceed 24 hours. If you must fetch logs for a longer time range, modify the duration and make multiple sequential API requests.  Upon successful execution, the API returns logs with the following information: * timestamp of the event * event ID * event type * name and GUID of the user * IP address of ThoughtSpot instance  For more information see [Audit logs Documentation](https://developers.thoughtspot.com/docs/audit-logs).      
   * @param fetchLogsRequest 
   */
  fetchLogs(fetchLogsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchLogsRequest === null || fetchLogsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "fetchLogs", "fetchLogsRequest");
      }
      const localVarPath = "/api/rest/2.0/logs/fetch";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchLogsRequest, "FetchLogsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches object permission details for a given principal object such as a user and group.  Requires view access to the metadata object.   #### Usage guidelines  * To get a list of all metadata objects that a user or group can access, specify the `type` and GUID or name of the principal. * To get permission details for a specific object, add the `type` and GUID or name of the metadata object to your API request.  Upon successful execution, the API returns a list of metadata objects and permission details for each object.        
   * @param fetchPermissionsOfPrincipalsRequest 
   */
  fetchPermissionsOfPrincipals(fetchPermissionsOfPrincipalsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchPermissionsOfPrincipalsRequest === null || fetchPermissionsOfPrincipalsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "fetchPermissionsOfPrincipals", "fetchPermissionsOfPrincipalsRequest");
      }
      const localVarPath = "/api/rest/2.0/security/principals/fetch-permissions";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchPermissionsOfPrincipalsRequest, "FetchPermissionsOfPrincipalsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches permission details for a given metadata object.  Requires view access to the metadata object.  #### Usage guidelines  * To fetch a list of users and groups for a metadata object, specify `type` and GUID or name of the metadata object. * To get permission details for a specific user or group, add `type` and GUID or name of the principal object to your API request.  Upon successful execution, the API returns permission details and principal information for the object specified in the API request.      
   * @param fetchPermissionsOnMetadataRequest 
   */
  fetchPermissionsOnMetadata(fetchPermissionsOnMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (fetchPermissionsOnMetadataRequest === null || fetchPermissionsOnMetadataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "fetchPermissionsOnMetadata", "fetchPermissionsOnMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/security/metadata/fetch-permissions";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(fetchPermissionsOnMetadataRequest, "FetchPermissionsOnMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Enforces logout on current user sessions.    Use this API with caution as it may invalidate active user sessions and force users to re-login. Make sure you specify the usernames or GUIDs. If you pass null values in the API call, all user sessions on your cluster become invalid, and the users are forced to re-login.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param forceLogoutUsersRequest 
   */
  forceLogoutUsers(forceLogoutUsersRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (forceLogoutUsersRequest === null || forceLogoutUsersRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "forceLogoutUsers", "forceLogoutUsersRequest");
      }
      const localVarPath = "/api/rest/2.0/users/force-logout";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(forceLogoutUsersRequest, "ForceLogoutUsersRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Exports a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal) in the CSV format.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  Use this API to download a custom calendar in the CSV file format. In your API request, specify the following parameters.  * Start and end date of the calendar. For \"month offset\" calendars, the start date must match the month defined in the `month_offset` attribute.  You can also specify optional parameters such as the starting day of the week and prefixes for the quarter and year labels.      
   * @param generateCSVRequest 
   */
  generateCSV(generateCSVRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (generateCSVRequest === null || generateCSVRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "generateCSV", "generateCSVRequest");
      }
      const localVarPath = "/api/rest/2.0/calendars/generate-csv";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(generateCSVRequest, "GenerateCSVRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves details of the current user session for the token provided in the request header.  Any ThoughtSpot user can access this endpoint and send an API request. The data returned in the API response varies according to user\'s privilege and object access permissions.     
   */
  getCurrentUserInfo(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/auth/session/user";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "GET" /* GET */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.4.0.cl or later   Retrieves details of the current session token for the bearer token provided in the request header.  This API endpoint does not create a new token. Instead, it returns details about the token, including the token string, creation time, expiration time, and the associated user.  Use this endpoint to introspect your current session token, debug authentication issues, or when a frontend application needs session token details.  Any ThoughtSpot user with a valid bearer token can access this endpoint and send an API request      
   */
  getCurrentUserToken(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/auth/session/token";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "GET" /* GET */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.4.0.cl or later   Gets an authentication token with custom rules and security attributes and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  To add a new user and assign privileges during auto creation, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  To assign security attributes with filter rules and Parameters to the JWT token, you\'ll need administrator privileges and edit access to the data source (Worksheet or Model). If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  #### Usage guidelines  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key`.  To generate a `secret_key` on your cluster, the administrator must enable [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable) in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  ##### Attribute-Based Access Control (ABAC) with tokens  To implement Attribute-Based Access Control (ABAC) and assign security entitlements to users during session creation, you can generate a token with custom filtering rules and Parameters in the `filter_rules` and `parameter_values` array respectively. These attributes can be configured to persist on a specific set of objects for user sessions initiated using the token. Once defined, the rules are added to the user\'s `access_control_properties` object, after which all sessions will use the persisted values.  Specify the object type as `LOGICAL_TABLE`.   For more information, see [ABAC via tokens Documentation](https://developers.thoughtspot.com/docs/api-authv2#_get_tokens_with_custom_rules_and_filter_conditions).  ##### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `groups`  Set `auto_create` to `true` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true` in the API request, the user properties such as the display name, email, Org and group assignment will not be updated with new values. If `auto_create` is set to `true`, it won\'t create formula variables and hence won\'t be applicable for `variable_values`.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  ##### Important point to note All options in the token creation APIs that define access to the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created. Persist options such as  `APPEND`, `REPLACE`, `RESET` will persist security parameters on the user profile when the token is created, while Persist option `NONE` will not persist anything but will be honoured in the session.  ##### Formula Variables Before using variables_values, variables must be created using Create Variable API with type as Formula_Variable (/api/rest/2.0/template/variables/create) The persist_option RESET and NONE cannot be used when variable_values are provided in the request. If you are working with variable_values, you must use other (APPEND, REPLACE) supported modes. If you want to use RESET or NONE, do not pass any variable_values. In such cases, variable_values will remain unaffected. When using object_id with variable_values, models are supported.      
   * @param getCustomAccessTokenRequest 
   */
  getCustomAccessToken(getCustomAccessTokenRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (getCustomAccessTokenRequest === null || getCustomAccessTokenRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "getCustomAccessToken", "getCustomAccessTokenRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/token/custom";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(getCustomAccessTokenRequest, "GetCustomAccessTokenRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page. For more information, see [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable).  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getFullAccessTokenRequest 
   */
  getFullAccessToken(getFullAccessTokenRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (getFullAccessTokenRequest === null || getFullAccessTokenRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "getFullAccessToken", "getFullAccessTokenRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/token/full";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(getFullAccessTokenRequest, "GetFullAccessTokenRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token that provides access to a specific metadata object. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request,  `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getObjectAccessTokenRequest 
   */
  getObjectAccessToken(getObjectAccessTokenRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (getObjectAccessTokenRequest === null || getObjectAccessTokenRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "getObjectAccessToken", "getObjectAccessTokenRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/token/object";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(getObjectAccessTokenRequest, "GetObjectAccessTokenRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.13.0.cl or later   Breaks down a user-submitted query into a series of analytical sub-questions using relevant contextual metadata.  To use this API, the user must have at least view-level access to the referenced metadata objects.  #### Usage guidelines  To accurately generate relevant questions, the request must include at least one of the following metadata identifiers within `metadata_context` : `conversation_identifier`, `answer_identifiers`, `liveboard_identifiers`, or `data_source_identifiers`.  You can further enhance the quality and precision of breakdown by providing additional `ai_context` such as:  - `content`: User provided content like text data, csv data as a string message to provide context & potentially improve the quality of the response. - `instructions`: User specific text instructions sent to AI system for processing the query.  Additional optional parameters include:  - `limit_relevant_questions`: Controls the maximum number of relevant questions returned. Defaults to 5 if not specified. - `bypass_cache`: If set to true, forces fresh computation instead of returning cached results.  If the API request is successful, ThoughtSpot returns a list of relevant analytical queries, each aligned with the user\'s original question. Each returned question includes the query string, along with the identifier and name of the corresponding data source.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.     
   * @param getRelevantQuestionsRequest 
   */
  getRelevantQuestions(getRelevantQuestionsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (getRelevantQuestionsRequest === null || getRelevantQuestionsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "getRelevantQuestions", "getRelevantQuestionsRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/relevant-questions/";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(getRelevantQuestionsRequest, "GetRelevantQuestionsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves the current configuration details of the cluster. If the request is successful, the API returns a list configuration settings applied on the cluster.  Requires `ADMINISTRATION`(**Can administer ThoughtSpot**) privilege to view these complete configuration settings of the cluster. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.      
   */
  getSystemConfig(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/system/config";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "GET" /* GET */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets system information such as the release version, locale, time zone, deployment environment, date format, and date time format of the cluster.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemInformation(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/system";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "GET" /* GET */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of configuration overrides applied on the cluster.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemOverrideInfo(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/system/config-overrides";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "GET" /* GET */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Imports [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  *  Import all related objects in a single TML Import API call. For example, Tables that use the same Connection object and Worksheets connected to these Tables. * Include the `fqn` property to distinguish objects that have the same name.   For example, if you have multiple Connections or Worksheets with the same name on ThoughtSpot and the Connection or Worksheet referenced in your TML file does not have a unique name to distinguish, it may result in invalid object references.   Adding `fqn` helps ThoughtSpot differentiate a Table from another with the same name.   We recommend [exporting TML with FQNs](#/http/api-endpoints/metadata/export-metadata-tml) and using these during the import operation. * You can upload multiple TML files at a time.   If you import a Worksheet along with Liveboards, Answers, and other dependent objects in a single API call, the imported objects will be immediately available for use.   When you import only a Worksheet object, it may take some time for the Worksheet to become available in the ThoughtSpot system. Please wait for a few minutes, and then proceed to create an Answer and Liveboard from the newly imported Worksheet.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_import_a_tml).      
   * @param importMetadataTMLRequest 
   */
  importMetadataTML(importMetadataTMLRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (importMetadataTMLRequest === null || importMetadataTMLRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "importMetadataTML", "importMetadataTMLRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/tml/import";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(importMetadataTMLRequest, "ImportMetadataTMLRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.4.0.cl or later   Schedules a task to import [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot. You can use this API endpoint to process TML objects asynchronously when importing TMLs of large and complex metadata objects into ThoughtSpot. Unlike the synchronous import TML operation, the API processes TML data in the background and returns a task ID, which can be used to check the status of the import task via `/api/rest/2.0/metadata/tml/async/status` API endpoint.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege, and edit access to the TML objects.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  See [Async TML API Documentation](https://developers.thoughtspot.com/docs/tml#_import_tml_objects_asynchronously) for usage guidelines.      
   * @param importMetadataTMLAsyncRequest 
   */
  importMetadataTMLAsync(importMetadataTMLAsyncRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (importMetadataTMLAsyncRequest === null || importMetadataTMLAsyncRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "importMetadataTMLAsync", "importMetadataTMLAsyncRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/tml/async/import";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(importMetadataTMLAsyncRequest, "ImportMetadataTMLAsyncRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Imports group objects from external databases into ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  During the import operation:  * If the specified group is not available in ThoughtSpot, it will be added to ThoughtSpot. * If `delete_unspecified_groups` is set to `true`, the groups not specified in the API request, excluding administrator and system user groups, are deleted. * If the specified groups are already available in ThoughtSpot, the object properties of these groups are modified and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.      
   * @param importUserGroupsRequest 
   */
  importUserGroups(importUserGroupsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (importUserGroupsRequest === null || importUserGroupsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "importUserGroups", "importUserGroupsRequest");
      }
      const localVarPath = "/api/rest/2.0/groups/import";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(importUserGroupsRequest, "ImportUserGroupsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Imports user data from external databases into ThoughtSpot. During the user import operation:  * If the specified users are not available in ThoughtSpot, the users are created and assigned a default password. Defining a `default_password` in the API request is optional. * If `delete_unspecified_users` is set to `true`, the users not specified in the API request, excluding the `tsadmin`, `guest`, `system` and `su` users, are deleted. * If the specified user objects are already available in ThoughtSpot, the object properties are updated and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param importUsersRequest 
   */
  importUsers(importUsersRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (importUsersRequest === null || importUsersRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "importUsers", "importUsersRequest");
      }
      const localVarPath = "/api/rest/2.0/users/import";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(importUsersRequest, "ImportUsersRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a login session for a ThoughtSpot user with Basic authentication.  In Basic authentication method, REST clients log in to ThoughtSpot using `username` and `password` attributes. On a multi-tenant cluster with Orgs, users can pass the ID of the Org in the API request to log in to a specific Org context.  **Note**: If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. Contact ThoughtSpot Support for assistance.  A successful login returns a session cookie that can be used in your subsequent API requests.     
   * @param loginRequest 
   */
  login(loginRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (loginRequest === null || loginRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "login", "loginRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/session/login";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(loginRequest, "LoginRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later    Logs out a user from their current session.      
   */
  logout(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/auth/session/logout";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Parameterize fields in metadata objects.   Version: 10.9.0.cl or later   Allows parameterizing fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows parameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be parameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param parameterizeMetadataRequest 
   */
  parameterizeMetadata(parameterizeMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (parameterizeMetadataRequest === null || parameterizeMetadataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "parameterizeMetadata", "parameterizeMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/parameterize";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(parameterizeMetadataRequest, "ParameterizeMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.9.0.cl or later   Allows publishing metadata objects across organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows publishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  This API will essentially share the objects along with it\'s dependencies to the org admins of the orgs to which it is being published.      
   * @param publishMetadataRequest 
   */
  publishMetadata(publishMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (publishMetadataRequest === null || publishMetadataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "publishMetadata", "publishMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/security/metadata/publish";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(publishMetadataRequest, "PublishMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   * Version: 10.7.0.cl or later 
   * @param queryGetDecomposedQueryRequest 
   */
  queryGetDecomposedQuery(queryGetDecomposedQueryRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (queryGetDecomposedQueryRequest === null || queryGetDecomposedQueryRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "queryGetDecomposedQuery", "queryGetDecomposedQueryRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/analytical-questions";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(queryGetDecomposedQueryRequest, "QueryGetDecomposedQueryRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Resets the password of a user account. Administrators can reset password on behalf of a user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param resetUserPasswordRequest 
   */
  resetUserPassword(resetUserPasswordRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (resetUserPasswordRequest === null || resetUserPasswordRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "resetUserPassword", "resetUserPasswordRequest");
      }
      const localVarPath = "/api/rest/2.0/users/reset-password";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(resetUserPasswordRequest, "ResetUserPasswordRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Reverts TML objects to a previous commit specified in the API request.  Requires at least edit access to objects.  In the API request, specify the `commit_id`. If the branch name is not specified in the request, the API will consider the default branch configured on your instance.  By default, the API reverts all objects. If the revert operation fails for one of the objects provided in the commit, the API returns an error and does not revert any object.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitId Commit id to which the object should be reverted
   * @param revertCommitRequest 
   */
  revertCommit(commitId, revertCommitRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (commitId === null || commitId === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "revertCommit", "commitId");
      }
      if (revertCommitRequest === null || revertCommitRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "revertCommit", "revertCommitRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/commits/{commit_id}/revert".replace("{commit_id}", encodeURIComponent(String(commitId)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(revertCommitRequest, "RevertCommitRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later    Revokes the authentication token issued for current user session.  The token of your current session expires when you make a call to the `/api/rest/2.0/auth/token/revoke` endpoint. the users will not be able to access ThoughtSpot objects until a new token is obtained.  To restart your session, request for a new token from ThoughtSpot. See [Get Full Access Token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param revokeTokenRequest 
   */
  revokeToken(revokeTokenRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (revokeTokenRequest === null || revokeTokenRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "revokeToken", "revokeTokenRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/token/revoke";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(revokeTokenRequest, "RevokeTokenRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Gets a list of [custom calendars](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  By default, the API returns a list of custom calendars for all connection objects. To retrieve custom calendar details for a particular connection, specify the connection ID. You can also use other search parameters such as `name_pattern` and `sort_options` as search filters.  The `name_pattern` parameter filters and returns only those objects that match the specified pattern. Use `%` as a wildcard for pattern matching.      
   * @param searchCalendarsRequest 
   */
  searchCalendars(searchCalendarsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchCalendarsRequest === null || searchCalendarsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchCalendars", "searchCalendarsRequest");
      }
      const localVarPath = "/api/rest/2.0/calendars/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchCalendarsRequest, "SearchCalendarsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of commits for a given metadata object.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param searchCommitsRequest 
   */
  searchCommits(searchCommitsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchCommitsRequest === null || searchCommitsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchCommits", "searchCommitsRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/commits/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchCommitsRequest, "SearchCommitsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.14.0.cl or later   Fetch communication channel preferences. - Use `cluster_preferences` to fetch the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to fetch any Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param searchCommunicationChannelPreferencesRequest 
   */
  searchCommunicationChannelPreferences(searchCommunicationChannelPreferencesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchCommunicationChannelPreferencesRequest === null || searchCommunicationChannelPreferencesRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchCommunicationChannelPreferences", "searchCommunicationChannelPreferencesRequest");
      }
      const localVarPath = "/api/rest/2.0/system/preferences/communication-channels/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchCommunicationChannelPreferencesRequest, "SearchCommunicationChannelPreferencesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Gets Git repository connections configured on the ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param searchConfigRequest 
   */
  searchConfig(searchConfigRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchConfigRequest === null || searchConfigRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchConfig", "searchConfigRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/config/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchConfigRequest, "SearchConfigRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Gets connection objects. Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  - To get a list of all connections available in the ThoughtSpot system, send the API request without any attributes in the request body. - To get the connection objects for a specific type of data warehouse, specify the type in `data_warehouse_types`. - To fetch details of a connection object, specify the connection object GUID or name. The `name_pattern` attribute allows passing partial text with `%` for a wildcard match. - To get details of the database, schemas, tables, or columns from a data connection object, specify `data_warehouse_object_type`. - To get a specific database, schema, table, or column from a connection object, define the object type in `data_warehouse_object_type` and object properties in the `data_warehouse_objects` array. For example, to search for a column, you must pass the database, schema, and table names in the API request.   Note that in the following example, object properties are set in a hierarchical order (`database` > `schema` > `table` > `column`).  ``` {   \"connections\": [     {       \"identifier\": \"b9d1f2ef-fa65-4a4b-994e-30fa2d57b0c2\",       \"data_warehouse_objects\": [         {           \"database\": \"NEBULADEV\",           \"schema\": \"INFORMATION_SCHEMA\",           \"table\": \"APPLICABLE_ROLES\",           \"column\": \"ROLE_NAME\"         }       ]     }   ],   \"data_warehouse_object_type\": \"COLUMN\" } ```  - To fetch data by `configuration`, specify `data_warehouse_object_type`. For example, to fetch columns from the `DEVELOPMENT` database, specify the `data_warehouse_object_type` as `DATABASE` and define the `configuration` string as `{\"database\":\"DEVELOPMENT\"}`. To get column data for a specific table, specify the table, for example,`{\"database\":\"RETAILAPPAREL\",\"table\":\"PIPES\"}`. - To query connections by `authentication_type`, specify `data_warehouse_object_type`. Supported values for `authentication_type` are:   - `SERVICE_ACCOUNT`: For connections that require service account credentials to authenticate to the Cloud Data Warehouse and fetch data.   - `OAUTH`: For connections that require OAuth credentials to authenticate to the Cloud Data Warehouse and fetch data. Teradata, Oracle, and Presto Cloud Data Warehouses do not support the OAuth authentication type.   - `IAM`: For connections that have the IAM OAuth set up. This authentication type is supported on Amazon Redshift connections only.   - `EXTOAUTH`: For connections that have External OAuth set up. ThoughtSpot supports external [OAuth with Microsoft Azure Active Directory (AD)](https://docs.thoughtspot.com/cloud/latest/ connections-snowflake-azure-ad-oauth) and [Okta for Snowflake data connections](https://docs.thoughtspot.com/cloud/latest/connections-snowflake-okta-oauth).   - `KEY_PAIR`: For connections that require Key Pair account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PKCE`: For connections that require OAuth with PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake, Starburst, Databricks, Denodo  connections only.   - `EXTOAUTH_WITH_PKCE`: For connections that require External OAuth With PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PEZ`: For connections that require OAuth With PEZ account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Amazon Redshift connections only.   - `OAUTH_WITH_SERVICE_PRINCIPAL`: For connections that require OAuth With Service Principal account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `PERSONAL_ACCESS_TOKEN`: For connections that require Personal Access Token account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `OAUTH_CLIENT_CREDENTIALS`: For connections that require OAuth Client Credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only. - To include more details about connection objects in the API response, set `include_details` to `true`. - You can also sort the output by field names and filter connections by tags.  **NOTE**: When filtering connection records by parameters other than `data_warehouse_types` or `tag_identifiers`, ensure that you set `record_size` to `-1` and `record_offset` to `0` for precise results.      
   * @param searchConnectionRequest 
   */
  searchConnection(searchConnectionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchConnectionRequest === null || searchConnectionRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchConnection", "searchConnectionRequest");
      }
      const localVarPath = "/api/rest/2.0/connection/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchConnectionRequest, "SearchConnectionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.6.0.cl or later   Gets custom actions configured on the cluster.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param searchCustomActionsRequest 
   */
  searchCustomActions(searchCustomActionsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchCustomActionsRequest === null || searchCustomActionsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchCustomActions", "searchCustomActionsRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/custom-actions/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchCustomActionsRequest, "SearchCustomActionsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Generates an Answer from a given data source.  Requires at least view access to the data source object (Worksheet or View).  #### Usage guidelines  To search data, specify the data source GUID in `logical_table_identifier`. The data source can be a Worksheet, View, Table, or SQL view.  Pass search tokens in the `query_string` attribute in the API request as shown in the following example:  ``` {   \"query_string\": \"[sales] by [store]\",   \"logical_table_identifier\": \"cd252e5c-b552-49a8-821d-3eadaa049cca\", } ```  For more information about the `query_string` format and data source attribute, see [Search data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_search_data_api).    The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_api).       
   * @param searchDataRequest 
   */
  searchData(searchDataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchDataRequest === null || searchDataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchData", "searchDataRequest");
      }
      const localVarPath = "/api/rest/2.0/searchdata";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchDataRequest, "SearchDataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.10.0.cl or later   Search the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   * @param searchEmailCustomizationRequest 
   */
  searchEmailCustomization(searchEmailCustomizationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchEmailCustomizationRequest === null || searchEmailCustomizationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchEmailCustomization", "searchEmailCustomizationRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/email/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchEmailCustomizationRequest, "SearchEmailCustomizationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of metadata objects available on the ThoughtSpot system.  This API endpoint is available to all users who have view access to the object. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view data for all metadata objects, including users and groups.  #### Usage guidelines  - To get all metadata objects, send the API request without any attributes. - To get metadata objects of a specific type, set the `type` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE`. - To filter metadata objects within type `LOGICAL_TABLE`, set the `subtypes` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE` & subtypes as `[WORKSHEET]`. - To get a specific metadata object, specify the GUID. - To customize your search and filter the API response, you can use several parameters.   You can search for objects created or modified by specific users, by tags applied to the objects, or by using the include parameters like `include_auto_created_objects`, `include_dependent_objects`, `include_headers`, `include_incomplete_objects`, and so on.   You can also define sorting options to sort the data retrieved in the API response. - To get discoverable objects when linientmodel is enabled you can use `include_discoverable_objects` as true else false. Default value is true. - For liveboard metadata type, to get the newer format, set the `liveboard_response_format` as V2. Default value is V1. - To retrieve only objects that are published, set the `include_only_published_objects` as true. Default value is false.  **NOTE**: The following parameters support pagination of metadata records:  - `tag_identifiers` - `type` - `subtypes` - `created_by_user_identifiers` - `modified_by_user_identifiers` - `owned_by_user_identifiers` - `exclude_objects` - `include_auto_created_objects` - `favorite_object_options` - `include_only_published_objects` If you are using other parameters to search metadata, set `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchMetadataRequest 
   */
  searchMetadata(searchMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchMetadataRequest === null || searchMetadataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchMetadata", "searchMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchMetadataRequest, "SearchMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of Orgs configured on the ThoughtSpot system. To get details of a specific Org, specify the Org ID or name. You can also pass parameters such as status, visibility, and user identifiers to get a specific list of Orgs.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param searchOrgsRequest 
   */
  searchOrgs(searchOrgsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchOrgsRequest === null || searchOrgsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchOrgs", "searchOrgsRequest");
      }
      const localVarPath = "/api/rest/2.0/orgs/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchOrgsRequest, "SearchOrgsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.5.0.cl or later   Gets a list of Role objects from the ThoughtSpot system.  Available if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To search for Roles, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.  To get details of a specific Role object, specify the GUID or name. You can also filter the API response based on user group and Org identifiers, privileges assigned to the Role, and deprecation status.      
   * @param searchRolesRequest 
   */
  searchRoles(searchRolesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchRolesRequest === null || searchRolesRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchRoles", "searchRolesRequest");
      }
      const localVarPath = "/api/rest/2.0/roles/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchRolesRequest, "SearchRolesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Search Schedules    Version: 9.4.0.cl or later   Gets a list of scheduled jobs configured for a Liveboard.  To get details of a specific scheduled job, specify the name or GUID of the scheduled job.  Requires at least view access to Liveboards.  **NOTE**: When filtering schedules by parameters other than `metadata`, set `record_size` to `-1` and `record_offset` to `0` for accurate results.      
   * @param searchSchedulesRequest 
   */
  searchSchedules(searchSchedulesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchSchedulesRequest === null || searchSchedulesRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchSchedules", "searchSchedulesRequest");
      }
      const localVarPath = "/api/rest/2.0/schedules/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchSchedulesRequest, "SearchSchedulesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of tag objects available on the ThoughtSpot system. To get details of a specific tag object, specify the GUID or name.  Any authenticated user can search for tag objects.      
   * @param searchTagsRequest 
   */
  searchTags(searchTagsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchTagsRequest === null || searchTagsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchTags", "searchTagsRequest");
      }
      const localVarPath = "/api/rest/2.0/tags/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchTagsRequest, "SearchTagsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of user group objects from the ThoughtSpot system.  To get details of a specific user group, specify the user group GUID or name. You can also filter the API response based on User ID, Org ID, Role ID, type of group, sharing visibility, privileges assigned to the group, and the Liveboard IDs assigned to the users in the group.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  **NOTE**: If you do not get precise results, try setting `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchUserGroupsRequest 
   */
  searchUserGroups(searchUserGroupsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchUserGroupsRequest === null || searchUserGroupsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchUserGroups", "searchUserGroupsRequest");
      }
      const localVarPath = "/api/rest/2.0/groups/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchUserGroupsRequest, "SearchUserGroupsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of users available on the ThoughtSpot system.  To get details of a specific user, specify the user GUID or name. You can also filter the API response based on groups, Org ID, user visibility, account status, user type, and user preference settings and favorites.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  **NOTE**: If the API returns an empty list, consider increasing the value of the `record_size` parameter. To search across all available users, set `record_size` to `-1`.      
   * @param searchUsersRequest 
   */
  searchUsers(searchUsersRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchUsersRequest === null || searchUsersRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchUsers", "searchUsersRequest");
      }
      const localVarPath = "/api/rest/2.0/users/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchUsersRequest, "SearchUsersRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Search variables   Version: 10.14.0.cl or later   Allows searching for variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports searching variables by: * Variable identifier (ID or name) * Variable type * Name pattern (case-insensitive, supports % for wildcard)  The search results can be formatted in three ways: * METADATA - Returns only variable metadata (default) * METADATA_AND_VALUES - Returns variable metadata and values  The values can be filtered by scope: * org_identifier * principal_identifier * model_identifier      
   * @param searchVariablesRequest 
   */
  searchVariables(searchVariablesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchVariablesRequest === null || searchVariablesRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchVariables", "searchVariablesRequest");
      }
      const localVarPath = "/api/rest/2.0/template/variables/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchVariablesRequest, "SearchVariablesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.14.0.cl or later   Searches for webhook configurations based on various criteria such as Org, webhook identifier, event type, with support for pagination and sorting. Returns matching webhook configurations with their complete details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param searchWebhookConfigurationsRequest 
   */
  searchWebhookConfigurations(searchWebhookConfigurationsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchWebhookConfigurationsRequest === null || searchWebhookConfigurationsRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "searchWebhookConfigurations", "searchWebhookConfigurationsRequest");
      }
      const localVarPath = "/api/rest/2.0/webhooks/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchWebhookConfigurationsRequest, "SearchWebhookConfigurationsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.13.0.cl or later   This API allows users to initiate or continue an agent (Spotter) conversation by submitting one or more natural language messages.  To use this API, the user must have access to the relevant conversational session (via conversation_identifier) and submit at least one message.   #### Usage guidelines  To initiate or continue a conversation, the request must include: - `conversation_identifier`: a unique session ID for continuity and message tracking - `messages`: an array of one or more text messages, each with a value and type  Additionally, user can specify what tool can be included `conversation_settings` parameter, which supports: - `enable_contextual_change_analysis` (default: false) - `enable_natural_language_answer_generation` (default: true) - `enable_reasoning` (default: false)  If the request is valid, the API returns a stream of messages in real time, including: - `ack`: confirms receipt of the request - `text / text-chunk`: content chunks, optionally formatted (e.g., markdown) - `answer`: the final structured response with metadata and analytics - `error`: if a failure occurs - `notification`: notification messages for operation being performed  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster. > * The streaming protocol uses Server-Sent Events (SSE)     
   * @param sendAgentMessageStreamingRequest 
   */
  sendAgentMessageStreaming(sendAgentMessageStreamingRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (sendAgentMessageStreamingRequest === null || sendAgentMessageStreamingRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "sendAgentMessageStreaming", "sendAgentMessageStreamingRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/agent/converse/sse";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(sendAgentMessageStreamingRequest, "SendAgentMessageStreamingRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.4.0.cl or later   Allows sending a follow-up message to an ongoing conversation within the context of the metadata model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  The API requires you to specify the `conversation_identifier` in the request path, and a `metadata_identifier` and `message` string in the request body.  If the API request is successful, ThoughtSpot returns the session ID, tokens used in the conversation, and visualization type.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param conversationIdentifier Unique identifier of the conversation.
   * @param sendMessageRequest 
   */
  sendMessage(conversationIdentifier, sendMessageRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (conversationIdentifier === null || conversationIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "sendMessage", "conversationIdentifier");
      }
      if (sendMessageRequest === null || sendMessageRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "sendMessage", "sendMessageRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/conversation/{conversation_identifier}/converse".replace("{conversation_identifier}", encodeURIComponent(String(conversationIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(sendMessageRequest, "SendMessageRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Allows sharing one or several metadata objects with users and groups in ThoughtSpot.  Requires edit access to the metadata object.  The API endpoint allows sharing only the following types of metadata objects: * Liveboards * Visualizations * Answers * Worksheets * Views * Connections  You can provide `READ_ONLY` or `MODIFY` access when sharing an object with another user or group. With `READ_ONLY` access grants view access to the shared object, whereas `MODIFY` provides edit access.  To prevent a user or group from accessing the shared object, specify the GUID or name of the principal and set `shareMode` to `NO_ACCESS`.      
   * @param shareMetadataRequest 
   */
  shareMetadata(shareMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (shareMetadataRequest === null || shareMetadataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "shareMetadata", "shareMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/security/metadata/share";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(shareMetadataRequest, "ShareMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.4.0.cl or later   Processes a natural language query and returns an AI-generated response based on a specified data model.  Requires at least view access to the metadata object specified in the request.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param singleAnswerRequest 
   */
  singleAnswer(singleAnswerRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (singleAnswerRequest === null || singleAnswerRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "singleAnswer", "singleAnswerRequest");
      }
      const localVarPath = "/api/rest/2.0/ai/answer/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(singleAnswerRequest, "SingleAnswerRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the tags applied to a Liveboard, Answer, Table, or Worksheet.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  unassignTag(assignTagRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (assignTagRequest === null || assignTagRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "unassignTag", "assignTagRequest");
      }
      const localVarPath = "/api/rest/2.0/tags/unassign";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(assignTagRequest, "AssignTagRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Remove parameterization from fields in metadata objects.   Version: 10.9.0.cl or later   Allows removing parameterization from fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows unparameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be unparameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param unparameterizeMetadataRequest 
   */
  unparameterizeMetadata(unparameterizeMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (unparameterizeMetadataRequest === null || unparameterizeMetadataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "unparameterizeMetadata", "unparameterizeMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/unparameterize";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(unparameterizeMetadataRequest, "UnparameterizeMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.9.0.cl or later   Allows unpublishing metadata objects from organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows unpublishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  When unpublishing objects, you can: * Include dependencies by setting `include_dependencies` to true - this will unpublish all dependent objects if no other published object is using them * Force unpublish by setting `force` to true - this will break all dependent objects in the unpublished organizations      
   * @param unpublishMetadataRequest 
   */
  unpublishMetadata(unpublishMetadataRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (unpublishMetadataRequest === null || unpublishMetadataRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "unpublishMetadata", "unpublishMetadataRequest");
      }
      const localVarPath = "/api/rest/2.0/security/metadata/unpublish";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(unpublishMetadataRequest, "UnpublishMetadataRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Updates the properties of a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  You can update the properties of a calendar using one of the following methods: * `FROM_INPUT_PARAMS` to update the calendar properties with the values defined in the API request. * `FROM_EXISTING_TABLE` Creates a calendar from the parameters defined in the API request.  To update a custom calendar, specify the calendar ID as a path parameter in the request URL and the following parameters in the request body:    * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  The API allows you to modify the calendar type, month offset value, start and end date, starting day of the week, and prefixes assigned to the year and quarter labels.     #### Examples  Update a custom calendar using an existing Table in ThoughtSpot:  ``` {   \"update_method\": \"FROM_EXISTING_TABLE\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   } } ```  Update a custom calendar with the attributes defined in the API request:  ``` {   \"update_method\": \"FROM_INPUT_PARAMS\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   },   \"month_offset\": \"August\",   \"start_day_of_week\": \"Monday\",   \"start_date\": \"08/01/2025\",   \"end_date\": \"07/31/2026\" } ```      
   * @param calendarIdentifier Unique Id or name of the calendar.
   * @param updateCalendarRequest 
   */
  updateCalendar(calendarIdentifier, updateCalendarRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (calendarIdentifier === null || calendarIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateCalendar", "calendarIdentifier");
      }
      if (updateCalendarRequest === null || updateCalendarRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateCalendar", "updateCalendarRequest");
      }
      const localVarPath = "/api/rest/2.0/calendars/{calendar_identifier}/update".replace("{calendar_identifier}", encodeURIComponent(String(calendarIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateCalendarRequest, "UpdateCalendarRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.12.0.cl or later   Creates, updates, or deletes column security rules for specified tables.  This API endpoint allows you to create, update, or delete column-level security rules on columns of a table. The operation follows an \"all or none\" policy: if defining security rules for any of the provided columns fails, the entire operation will be rolled back, and no rules will be created.  #### Usage guidelines  - Provide table identifier using either `identifier` (GUID or name) or `obj_identifier` (object ID) - Use `clear_csr: true` to remove all column security rules from the table - For each column, specify the security rule using `column_security_rules` array - Use `is_unsecured: true` to mark a specific column as unprotected - Use `group_access` operations to manage group associations:   - `ADD`: Add groups to the column\'s access list   - `REMOVE`: Remove groups from the column\'s access list   - `REPLACE`: Replace all existing groups with the specified groups  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data (if RBAC is disabled) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables (if RBAC is enabled)  #### Example request  ```json {   \"identifier\": \"table-guid\",   \"obj_identifier\": \"table-object-id\",   \"clear_csr\": false,   \"column_security_rules\": [     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"ADD\",           \"group_identifiers\": [\"hr_group_id\", \"hr_group_name\", \"finance_group_id\"]         }       ]     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": true     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"REPLACE\",           \"group_identifiers\": [\"management_group_id\", \"management_group_name\"]         }       ]     }   ] } ```  #### Request Body Schema  - `identifier` (string, optional): GUID or name of the table for which we want to create column security rules - `obj_identifier` (string, optional): The object ID of the table - `clear_csr` (boolean, optional): If true, then all the secured columns will be marked as unprotected, and all the group associations will be removed - `column_security_rules` (array of objects, required): An array where each object defines the security rule for a specific column  Each column security rule object contains: - `column_identifier` (string, required): Column identifier (col_id or name) - `is_unsecured` (boolean, optional): If true, the column will be marked as unprotected and all groups associated with it will be removed - `group_access` (array of objects, optional): Array of group operation objects  Each group operation object contains: - `operation` (string, required): Operation type - ADD, REMOVE, or REPLACE - `group_identifiers` (array of strings, required): Array of group identifiers (name or GUID) on which the operation will be performed  #### Response  This API does not return any response body. A successful operation returns HTTP 200 status code.  #### Operation Types  - **ADD**: Adds the specified groups to the column\'s access list - **REMOVE**: Removes the specified groups from the column\'s access list   - **REPLACE**: Replaces all existing groups with the specified groups      
   * @param updateColumnSecurityRulesRequest 
   */
  updateColumnSecurityRules(updateColumnSecurityRulesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateColumnSecurityRulesRequest === null || updateColumnSecurityRulesRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateColumnSecurityRules", "updateColumnSecurityRulesRequest");
      }
      const localVarPath = "/api/rest/2.0/security/column/rules/update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateColumnSecurityRulesRequest, "UpdateColumnSecurityRulesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Updates Git repository configuration settings.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param updateConfigRequest 
   */
  updateConfig(updateConfigRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateConfigRequest === null || updateConfigRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateConfig", "updateConfigRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/config/update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateConfigRequest, "UpdateConfigRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Update connection V2](#/http/api-endpoints/connections/update-connection-v2) endpoint to update your connection objects.  #### Usage guidelines  Updates a connection object.    Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`. 3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.      
   * @param updateConnectionRequest 
   */
  updateConnection(updateConnectionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateConnectionRequest === null || updateConnectionRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateConnection", "updateConnectionRequest");
      }
      const localVarPath = "/api/rest/2.0/connection/update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateConnectionRequest, "UpdateConnectionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.12.0.cl or later   Updates a connection configuration object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Supported operations This API endpoint lets you perform the following operations in a single API request:   * Edit the name or description of the configuration  * Edit the configuration properties  * Edit the `policy_type`  * Edit the type of authentication  * Enable or disable a configuration  #### Parameterized Connection Support For parameterized oauth based connections, only the `same_as_parent` and `policy_process_options` attributes are allowed. These attributes are not applicable to connections that are not parameterized.   **NOTE**: When updating a configuration where `disabled` is `true`, you must reset `disabled` to `true` in your update request payload. If not explicitly set again, the API will default `disabled` to `false`.      
   * @param configurationIdentifier Unique ID or name of the configuration.
   * @param updateConnectionConfigurationRequest 
   */
  updateConnectionConfiguration(configurationIdentifier, updateConnectionConfigurationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (configurationIdentifier === null || configurationIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateConnectionConfiguration", "configurationIdentifier");
      }
      if (updateConnectionConfigurationRequest === null || updateConnectionConfigurationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateConnectionConfiguration", "updateConnectionConfigurationRequest");
      }
      const localVarPath = "/api/rest/2.0/connection-configurations/{configuration_identifier}/update".replace("{configuration_identifier}", encodeURIComponent(String(configurationIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateConnectionConfigurationRequest, "UpdateConnectionConfigurationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 10.4.0.cl or later   Updates a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`.        **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.     * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:    * This is an example of updating a single table in a empty connection:           ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"DEMORENAME\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"Col1\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col2\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col3\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col312\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col4\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```        * This is an example of updating a single table in an existing connection with tables:            ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"CUSTOMER\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [],                     \"relationships\": []                   },                   {                     \"name\": \"tpch5k_falcon_default_schema_users\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"user_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"product_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"user_cost\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```  3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.    **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not  specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.    * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a Snowflake connection:    ```    {       \"configuration\":{          \"accountName\":\"thoughtspot_partner\",          \"user\":\"tsadmin\",          \"password\":\"TestConn123\",          \"role\":\"sysadmin\",          \"warehouse\":\"MEDIUM_WH\"       },       \"externalDatabases\":[        ]    }    ```      
   * @param connectionIdentifier Unique ID or name of the connection.
   * @param updateConnectionV2Request 
   */
  updateConnectionV2(connectionIdentifier, updateConnectionV2Request, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (connectionIdentifier === null || connectionIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateConnectionV2", "connectionIdentifier");
      }
      if (updateConnectionV2Request === null || updateConnectionV2Request === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateConnectionV2", "updateConnectionV2Request");
      }
      const localVarPath = "/api/rest/2.0/connections/{connection_identifier}/update".replace("{connection_identifier}", encodeURIComponent(String(connectionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateConnectionV2Request, "UpdateConnectionV2Request", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.6.0.cl or later   Updates a custom action.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API allows you to modify the following properties:  * Name of the custom action * Action availability to groups * Association to metadata objects * Authentication settings for a URL-based action  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param customActionIdentifier Unique ID or name of the custom action.
   * @param updateCustomActionRequest 
   */
  updateCustomAction(customActionIdentifier, updateCustomActionRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (customActionIdentifier === null || customActionIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateCustomAction", "customActionIdentifier");
      }
      if (updateCustomActionRequest === null || updateCustomActionRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateCustomAction", "updateCustomActionRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/custom-actions/{custom_action_identifier}/update".replace("{custom_action_identifier}", encodeURIComponent(String(customActionIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateCustomActionRequest, "UpdateCustomActionRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.9.0.cl or later   Updates a DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About update DBT connection You can modify DBT connection object properties such as embrace connection name, embrace database name, import type, account identifier, access token, project identifier and environment (or) embrace connection, embrace database name, import type, file_content settings.      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  updateDbtConnection(dbtConnectionIdentifier, connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (dbtConnectionIdentifier === null || dbtConnectionIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateDbtConnection", "dbtConnectionIdentifier");
      }
      const localVarPath = "/api/rest/2.0/dbt/update-dbt-connection";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const useForm = canConsumeForm([
        "multipart/form-data"
      ]);
      let localVarFormParams;
      if (useForm) {
        localVarFormParams = new FormData();
      } else {
        localVarFormParams = new URLSearchParams();
      }
      if (dbtConnectionIdentifier !== void 0) {
        localVarFormParams.append("dbt_connection_identifier", dbtConnectionIdentifier);
      }
      if (connectionName !== void 0) {
        localVarFormParams.append("connection_name", connectionName);
      }
      if (databaseName !== void 0) {
        localVarFormParams.append("database_name", databaseName);
      }
      if (importType !== void 0) {
        localVarFormParams.append("import_type", importType);
      }
      if (accessToken !== void 0) {
        localVarFormParams.append("access_token", accessToken);
      }
      if (dbtUrl !== void 0) {
        localVarFormParams.append("dbt_url", dbtUrl);
      }
      if (accountId !== void 0) {
        localVarFormParams.append("account_id", accountId);
      }
      if (projectId !== void 0) {
        localVarFormParams.append("project_id", projectId);
      }
      if (dbtEnvId !== void 0) {
        localVarFormParams.append("dbt_env_id", dbtEnvId);
      }
      if (projectName !== void 0) {
        localVarFormParams.append("project_name", projectName);
      }
      if (fileContent !== void 0) {
        if (localVarFormParams instanceof FormData) {
          localVarFormParams.append("file_content", fileContent, fileContent.name);
        }
      }
      requestContext.setBody(localVarFormParams);
      if (!useForm) {
        const contentType = ObjectSerializer.getPreferredMediaType([
          "multipart/form-data"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
      }
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.12.0.cl or later   Updates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To update a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param updateEmailCustomizationRequest 
   */
  updateEmailCustomization(updateEmailCustomizationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateEmailCustomizationRequest === null || updateEmailCustomizationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateEmailCustomization", "updateEmailCustomizationRequest");
      }
      const localVarPath = "/api/rest/2.0/customization/email/update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateEmailCustomizationRequest, "UpdateEmailCustomizationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Update header attributes for a given list of header objects.   Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **headers_update**      - **Description:** List of header objects with their attributes to be updated. Each object contains a list of attributes to be updated in the header.    - **Usage:**       - You must provide either `identifier` or `obj_identifier`, but not both. Both fields cannot be empty.       - When `org_identifier` is set to `-1`, only the `identifier` value is accepted; `obj_identifier` is not allowed.  2. **org_identifier**      - **Description:** GUID (Globally Unique Identifier) or name of the organization.      - **Usage:**      - Leaving this field empty assumes that the changes should be applied to the current organization       - Provide `org_guid` or `org_name` to uniquely identify the organization where changes need to be applied. .      - Provide `-1` if changes have to be applied across all the org.  ---  ## Note Currently, this API is enabled only for updating the `obj_identifier` attribute. Only `text` will be allowed in attribute\'s value.  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the update process  ---  ## Examples  ### Only `identifier` is given  ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"obj_identifier\": \"\",       \"type\": \"LOGICAL_COLUMN\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgGuid\" } ```  ### Only `obj_identifier` is given ```json {   \"headers_update\":   [     {       \"obj_identifier\": \"custom_object_id\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgName\" } ```  ### Executing update for all org `-1` ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```  ### Optional `type` is not provided ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```     
   * @param updateMetadataHeaderRequest 
   */
  updateMetadataHeader(updateMetadataHeaderRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateMetadataHeaderRequest === null || updateMetadataHeaderRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateMetadataHeader", "updateMetadataHeaderRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/headers/update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateMetadataHeaderRequest, "UpdateMetadataHeaderRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Update object IDs for given metadata objects.   Version: 10.8.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **metadata**      - **Description:** List of metadata objects to update their object IDs.    - **Usage:**       - Use either `current_obj_id` alone OR use `metadata_identifier` with `type` (when needed).       - When using `metadata_identifier`, the `type` field is required if using a name instead of a GUID.       - The `new_obj_id` field is always required.  ---  ## Note This API is specifically designed for updating object IDs of metadata objects. It internally uses the header update mechanism to perform the changes.  ## Best Practices  1. **Backup Before Update:**      Always export metadata as a backup before initiating the update process.  2. **Validation:**    - When using `current_obj_id`, ensure it matches the existing object ID exactly.    - When using `metadata_identifier` with a name, ensure the `type` is specified correctly.    - Verify that the `new_obj_id` follows your naming conventions and is unique within your system.  ---  ## Examples  ### Using current_obj_id ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with GUID ```json {   \"metadata\": [     {       \"metadata_identifier\": \"01234567-89ab-cdef-0123-456789abcdef\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with name and type ```json {   \"metadata\": [     {       \"metadata_identifier\": \"My Answer\",       \"type\": \"ANSWER\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Multiple objects update ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id_1\",       \"new_obj_id\": \"new_object_id_1\"     },     {       \"metadata_identifier\": \"My Worksheet\",       \"type\": \"LOGICAL_TABLE\",       \"new_obj_id\": \"new_object_id_2\"     }   ] } ```      
   * @param updateMetadataObjIdRequest 
   */
  updateMetadataObjId(updateMetadataObjIdRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateMetadataObjIdRequest === null || updateMetadataObjIdRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateMetadataObjId", "updateMetadataObjIdRequest");
      }
      const localVarPath = "/api/rest/2.0/metadata/update-obj-id";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateMetadataObjIdRequest, "UpdateMetadataObjIdRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Updates an Org object. You can modify Org properties such as name, description, and user associations.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param orgIdentifier ID or name of the Org
   * @param updateOrgRequest 
   */
  updateOrg(orgIdentifier, updateOrgRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (orgIdentifier === null || orgIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateOrg", "orgIdentifier");
      }
      if (updateOrgRequest === null || updateOrgRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateOrg", "updateOrgRequest");
      }
      const localVarPath = "/api/rest/2.0/orgs/{org_identifier}/update".replace("{org_identifier}", encodeURIComponent(String(orgIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateOrgRequest, "UpdateOrgRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.5.0.cl or later   Updates the properties of a Role object.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To update a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role.
   * @param updateRoleRequest 
   */
  updateRole(roleIdentifier, updateRoleRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (roleIdentifier === null || roleIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateRole", "roleIdentifier");
      }
      if (updateRoleRequest === null || updateRoleRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateRole", "updateRoleRequest");
      }
      const localVarPath = "/api/rest/2.0/roles/{role_identifier}/update".replace("{role_identifier}", encodeURIComponent(String(roleIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateRoleRequest, "UpdateRoleRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Update schedule.    Version: 9.4.0.cl or later   Updates a scheduled Liveboard job.  Requires at least edit access to Liveboards. To update a schedule on behalf of another user, you need `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  The API endpoint allows you to pause a scheduled job, change the status of a paused job. You can also edit the recipients list, frequency of the job, format of the file to send to the recipients in email notifications, PDF options, and time zone setting.      
   * @param scheduleIdentifier Unique ID or name of the schedule.
   * @param updateScheduleRequest 
   */
  updateSchedule(scheduleIdentifier, updateScheduleRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (scheduleIdentifier === null || scheduleIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateSchedule", "scheduleIdentifier");
      }
      if (updateScheduleRequest === null || updateScheduleRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateSchedule", "updateScheduleRequest");
      }
      const localVarPath = "/api/rest/2.0/schedules/{schedule_identifier}/update".replace("{schedule_identifier}", encodeURIComponent(String(scheduleIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateScheduleRequest, "UpdateScheduleRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Updates the current configuration of the cluster. You must send the configuration data in JSON format.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.      
   * @param updateSystemConfigRequest 
   */
  updateSystemConfig(updateSystemConfigRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateSystemConfigRequest === null || updateSystemConfigRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateSystemConfig", "updateSystemConfigRequest");
      }
      const localVarPath = "/api/rest/2.0/system/config-update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateSystemConfigRequest, "UpdateSystemConfigRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Updates a tag object.  You can modify the `name` and `color` properties of a tag object.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Name or Id of the tag.
   * @param updateTagRequest 
   */
  updateTag(tagIdentifier, updateTagRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (tagIdentifier === null || tagIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateTag", "tagIdentifier");
      }
      if (updateTagRequest === null || updateTagRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateTag", "updateTagRequest");
      }
      const localVarPath = "/api/rest/2.0/tags/{tag_identifier}/update".replace("{tag_identifier}", encodeURIComponent(String(tagIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateTagRequest, "UpdateTagRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a user object.  You can modify user properties such as username, email, and share notification settings. You can also assign new groups and Orgs, remove the user from a group or Org, reset password, and modify user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   * @param updateUserRequest 
   */
  updateUser(userIdentifier, updateUserRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (userIdentifier === null || userIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateUser", "userIdentifier");
      }
      if (updateUserRequest === null || updateUserRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateUser", "updateUserRequest");
      }
      const localVarPath = "/api/rest/2.0/users/{user_identifier}/update".replace("{user_identifier}", encodeURIComponent(String(userIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateUserRequest, "UpdateUserRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### Supported operations  This API endpoint lets you perform the following operations in a single API request:  * Edit [privileges](https://developers.thoughtspot.com/docs/?pageid=api-user-management#group-privileges) * Add or remove users * Change sharing visibility settings * Add or remove sub-groups * Assign a default Liveboard  or update the existing settings      
   * @param groupIdentifier GUID or name of the group.
   * @param updateUserGroupRequest 
   */
  updateUserGroup(groupIdentifier, updateUserGroupRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (groupIdentifier === null || groupIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateUserGroup", "groupIdentifier");
      }
      if (updateUserGroupRequest === null || updateUserGroupRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateUserGroup", "updateUserGroupRequest");
      }
      const localVarPath = "/api/rest/2.0/groups/{group_identifier}/update".replace("{group_identifier}", encodeURIComponent(String(groupIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateUserGroupRequest, "UpdateUserGroupRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Update a variable\'s name   Version: 10.14.0.cl or later   Allows updating a variable\'s name in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows updating: * The variable name     
   * @param identifier Unique id or name of the variable to update.
   * @param updateVariableRequest 
   */
  updateVariable(identifier, updateVariableRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (identifier === null || identifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateVariable", "identifier");
      }
      if (updateVariableRequest === null || updateVariableRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateVariable", "updateVariableRequest");
      }
      const localVarPath = "/api/rest/2.0/template/variables/{identifier}/update".replace("{identifier}", encodeURIComponent(String(identifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateVariableRequest, "UpdateVariableRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Update values for multiple variables   Version: 10.14.0.cl or later   Allows updating values for multiple variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows: * Adding new values to variables * Replacing existing values * Deleting values from variables  When updating variable values, you need to specify: * The variable identifiers * The values to add/replace/remove for each variable * The operation to perform (ADD, REPLACE, REMOVE, RESET)  Behaviour based on operation type: * ADD - Adds values to the variable if this is a list type variable, else same as replace. * REPLACE - Replaces all values of a given set of constraints with the current set of values. * REMOVE - Removes any values which match the set of conditions of the variables if this is a list type variable, else clears value. * RESET - Removes all constrains for a given variable, scope is ignored      
   * @param updateVariableValuesRequest 
   */
  updateVariableValues(updateVariableValuesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateVariableValuesRequest === null || updateVariableValuesRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateVariableValues", "updateVariableValuesRequest");
      }
      const localVarPath = "/api/rest/2.0/template/variables/update-values";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateVariableValuesRequest, "UpdateVariableValuesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.14.0.cl or later   Updates an existing webhook configuration by its unique id or name. Only the provided fields will be updated.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param webhookIdentifier Unique ID or name of the webhook configuration.
   * @param updateWebhookConfigurationRequest 
   */
  updateWebhookConfiguration(webhookIdentifier, updateWebhookConfigurationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (webhookIdentifier === null || webhookIdentifier === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateWebhookConfiguration", "webhookIdentifier");
      }
      if (updateWebhookConfigurationRequest === null || updateWebhookConfigurationRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "updateWebhookConfiguration", "updateWebhookConfigurationRequest");
      }
      const localVarPath = "/api/rest/2.0/webhooks/{webhook_identifier}/update".replace("{webhook_identifier}", encodeURIComponent(String(webhookIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateWebhookConfigurationRequest, "UpdateWebhookConfigurationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.10.0.cl or later   Validates the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   */
  validateEmailCustomization(_options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      const localVarPath = "/api/rest/2.0/customization/email/validate";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Validates the content of your source branch against the objects in your destination environment.  Before merging content from your source branch to the destination branch, run this API operation from your destination environment and ensure that the changes from the source branch function in the destination environment.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param validateMergeRequest 
   */
  validateMerge(validateMergeRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (validateMergeRequest === null || validateMergeRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "validateMerge", "validateMergeRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/branches/validate";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(validateMergeRequest, "ValidateMergeRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.12.0.cl or later    Validates the authentication token specified in the API request.  If your token is not valid, [Get a new token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param validateTokenRequest 
   */
  validateToken(validateTokenRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (validateTokenRequest === null || validateTokenRequest === void 0) {
        throw new RequiredError("ThoughtSpotRestApi", "validateToken", "validateTokenRequest");
      }
      const localVarPath = "/api/rest/2.0/auth/token/validate";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(validateTokenRequest, "ValidateTokenRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var ThoughtSpotRestApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to activateUser
   * @throws ApiException if the response code was not in [200, 299]
   */
  activateUser(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to assignChangeAuthor
   * @throws ApiException if the response code was not in [200, 299]
   */
  assignChangeAuthor(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to assignTag
   * @throws ApiException if the response code was not in [200, 299]
   */
  assignTag(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to changeUserPassword
   * @throws ApiException if the response code was not in [200, 299]
   */
  changeUserPassword(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to commitBranch
   * @throws ApiException if the response code was not in [200, 299]
   */
  commitBranch(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CommitResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CommitResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to configureCommunicationChannelPreferences
   * @throws ApiException if the response code was not in [200, 299]
   */
  configureCommunicationChannelPreferences(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to connectionConfigurationSearch
   * @throws ApiException if the response code was not in [200, 299]
   */
  connectionConfigurationSearch(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ConnectionConfigurationResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ConnectionConfigurationResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to convertWorksheetToModel
   * @throws ApiException if the response code was not in [200, 299]
   */
  convertWorksheetToModel(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseWorksheetToModelConversion",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseWorksheetToModelConversion",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to copyObject
   * @throws ApiException if the response code was not in [200, 299]
   */
  copyObject(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseCopyObject",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("404", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Object not found", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseCopyObject",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createAgentConversation
   * @throws ApiException if the response code was not in [200, 299]
   */
  createAgentConversation(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AgentConversation",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AgentConversation",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AgentConversation",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createCalendar
   * @throws ApiException if the response code was not in [200, 299]
   */
  createCalendar(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CalendarResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CalendarResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  createConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RepoConfigObject",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RepoConfigObject",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  createConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CreateConnectionResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CreateConnectionResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createConnectionConfiguration
   * @throws ApiException if the response code was not in [200, 299]
   */
  createConnectionConfiguration(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ConnectionConfigurationResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ConnectionConfigurationResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createConversation
   * @throws ApiException if the response code was not in [200, 299]
   */
  createConversation(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Conversation",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Conversation",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Conversation",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createCustomAction
   * @throws ApiException if the response code was not in [200, 299]
   */
  createCustomAction(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseCustomAction",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseCustomAction",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  createEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CreateEmailCustomizationResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CreateEmailCustomizationResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createOrg
   * @throws ApiException if the response code was not in [200, 299]
   */
  createOrg(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "OrgResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "OrgResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createRole
   * @throws ApiException if the response code was not in [200, 299]
   */
  createRole(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RoleResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid parameters.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Internal error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RoleResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createSchedule
   * @throws ApiException if the response code was not in [200, 299]
   */
  createSchedule(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseSchedule",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseSchedule",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createTag
   * @throws ApiException if the response code was not in [200, 299]
   */
  createTag(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Tag",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Tag",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createUser
   * @throws ApiException if the response code was not in [200, 299]
   */
  createUser(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createUserGroup
   * @throws ApiException if the response code was not in [200, 299]
   */
  createUserGroup(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "UserGroupResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "UserGroupResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createVariable
   * @throws ApiException if the response code was not in [200, 299]
   */
  createVariable(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Variable",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Variable",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createWebhookConfiguration
   * @throws ApiException if the response code was not in [200, 299]
   */
  createWebhookConfiguration(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to dbtConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  dbtConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to dbtGenerateSyncTml
   * @throws ApiException if the response code was not in [200, 299]
   */
  dbtGenerateSyncTml(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to dbtGenerateTml
   * @throws ApiException if the response code was not in [200, 299]
   */
  dbtGenerateTml(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to dbtSearch
   * @throws ApiException if the response code was not in [200, 299]
   */
  dbtSearch(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DbtSearchResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DbtSearchResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deactivateUser
   * @throws ApiException if the response code was not in [200, 299]
   */
  deactivateUser(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseActivationURL",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseActivationURL",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteCalendar
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteCalendar(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteConnectionConfiguration
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteConnectionConfiguration(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteConnectionV2
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteConnectionV2(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteCustomAction
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteCustomAction(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteDbtConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteDbtConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteOrg
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteOrg(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteOrgEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteOrgEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteRole
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteRole(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Internal error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteSchedule
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteSchedule(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteTag
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteTag(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteUser
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteUser(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteUserGroup
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteUserGroup(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteVariable
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteVariable(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteWebhookConfigurations
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteWebhookConfigurations(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookDeleteResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookDeleteResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deployCommit
   * @throws ApiException if the response code was not in [200, 299]
   */
  deployCommit(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DeployResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DeployResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to downloadConnectionMetadataChanges
   * @throws ApiException if the response code was not in [200, 299]
   */
  downloadConnectionMetadataChanges(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = yield response.getBodyAsFile();
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "HttpFile",
          "binary"
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to exportAnswerReport
   * @throws ApiException if the response code was not in [200, 299]
   */
  exportAnswerReport(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = yield response.getBodyAsFile();
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "HttpFile",
          "binary"
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to exportLiveboardReport
   * @throws ApiException if the response code was not in [200, 299]
   */
  exportLiveboardReport(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = yield response.getBodyAsFile();
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          "binary"
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "HttpFile",
          "binary"
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to exportMetadataTML
   * @throws ApiException if the response code was not in [200, 299]
   */
  exportMetadataTML(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<any>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<any>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to exportMetadataTMLBatched
   * @throws ApiException if the response code was not in [200, 299]
   */
  exportMetadataTMLBatched(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchAnswerData
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchAnswerData(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AnswerDataResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AnswerDataResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchAnswerSqlQuery
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchAnswerSqlQuery(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SqlQueryResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SqlQueryResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchAsyncImportTaskStatus
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchAsyncImportTaskStatus(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "GetAsyncImportStatusResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "GetAsyncImportStatusResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchColumnSecurityRules
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchColumnSecurityRules(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ColumnSecurityRuleResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Bad request - Table not found or invalid parameters", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden - User doesn&#39;t have permission to access security rules for this table", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Internal server error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ColumnSecurityRuleResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchConnectionDiffStatus
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchConnectionDiffStatus(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "FetchConnectionDiffStatusResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "FetchConnectionDiffStatusResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchLiveboardData
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchLiveboardData(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "LiveboardDataResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "LiveboardDataResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchLiveboardSqlQuery
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchLiveboardSqlQuery(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SqlQueryResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SqlQueryResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchLogs
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchLogs(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<LogResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<LogResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchPermissionsOfPrincipals
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchPermissionsOfPrincipals(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "PermissionOfPrincipalsResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "PermissionOfPrincipalsResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to fetchPermissionsOnMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  fetchPermissionsOnMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "PermissionOfMetadataResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "PermissionOfMetadataResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to forceLogoutUsers
   * @throws ApiException if the response code was not in [200, 299]
   */
  forceLogoutUsers(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to generateCSV
   * @throws ApiException if the response code was not in [200, 299]
   */
  generateCSV(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getCurrentUserInfo
   * @throws ApiException if the response code was not in [200, 299]
   */
  getCurrentUserInfo(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getCurrentUserToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  getCurrentUserToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "GetTokenResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "GetTokenResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getCustomAccessToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  getCustomAccessToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AccessToken",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request. This could be due to missing or incorrect parameters.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access. The request could not be authenticated.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access. The user does not have permission to access this resource.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "An unexpected error occurred on the server.", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "AccessToken",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getFullAccessToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  getFullAccessToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Token",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Token",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getObjectAccessToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  getObjectAccessToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Token",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Token",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getRelevantQuestions
   * @throws ApiException if the response code was not in [200, 299]
   */
  getRelevantQuestions(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaGetRelevantQuestionsResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaGetRelevantQuestionsResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaGetRelevantQuestionsResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getSystemConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  getSystemConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemConfig",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemConfig",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getSystemInformation
   * @throws ApiException if the response code was not in [200, 299]
   */
  getSystemInformation(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemInfo",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemInfo",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to getSystemOverrideInfo
   * @throws ApiException if the response code was not in [200, 299]
   */
  getSystemOverrideInfo(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemOverrideInfo",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SystemOverrideInfo",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to importMetadataTML
   * @throws ApiException if the response code was not in [200, 299]
   */
  importMetadataTML(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<any>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<any>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to importMetadataTMLAsync
   * @throws ApiException if the response code was not in [200, 299]
   */
  importMetadataTMLAsync(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportEPackAsyncTaskStatus",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportEPackAsyncTaskStatus",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to importUserGroups
   * @throws ApiException if the response code was not in [200, 299]
   */
  importUserGroups(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportUserGroupsResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportUserGroupsResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to importUsers
   * @throws ApiException if the response code was not in [200, 299]
   */
  importUsers(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportUsersResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportUsersResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to login
   * @throws ApiException if the response code was not in [200, 299]
   */
  login(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to logout
   * @throws ApiException if the response code was not in [200, 299]
   */
  logout(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to parameterizeMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  parameterizeMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to publishMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  publishMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to queryGetDecomposedQuery
   * @throws ApiException if the response code was not in [200, 299]
   */
  queryGetDecomposedQuery(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaDecomposeQueryResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaDecomposeQueryResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "EurekaDecomposeQueryResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to resetUserPassword
   * @throws ApiException if the response code was not in [200, 299]
   */
  resetUserPassword(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to revertCommit
   * @throws ApiException if the response code was not in [200, 299]
   */
  revertCommit(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RevertResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RevertResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to revokeToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  revokeToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchCalendars
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchCalendars(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CalendarResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CalendarResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchCommits
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchCommits(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CommitHistoryResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CommitHistoryResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchCommunicationChannelPreferences
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchCommunicationChannelPreferences(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CommunicationChannelPreferencesResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CommunicationChannelPreferencesResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<RepoConfigObject>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<RepoConfigObject>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<SearchConnectionResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<SearchConnectionResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchCustomActions
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchCustomActions(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseCustomAction>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseCustomAction>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchData
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchData(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SearchDataResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SearchDataResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CreateEmailCustomizationResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CreateEmailCustomizationResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<MetadataSearchResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<MetadataSearchResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchOrgs
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchOrgs(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<OrgResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<OrgResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchRoles
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchRoles(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<SearchRoleResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Internal error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<SearchRoleResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchSchedules
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchSchedules(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseSchedule>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseSchedule>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchTags
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchTags(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<Tag>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<Tag>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchUserGroups
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchUserGroups(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<UserGroupResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<UserGroupResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchUsers
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchUsers(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<User>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<User>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchVariables
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchVariables(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<Variable>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<Variable>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchWebhookConfigurations
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchWebhookConfigurations(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookSearchResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookSearchResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to sendAgentMessageStreaming
   * @throws ApiException if the response code was not in [200, 299]
   */
  sendAgentMessageStreaming(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SendAgentMessageResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SendAgentMessageResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "SendAgentMessageResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to sendMessage
   * @throws ApiException if the response code was not in [200, 299]
   */
  sendMessage(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseMessage>",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseMessage>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<ResponseMessage>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to shareMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  shareMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to singleAnswer
   * @throws ApiException if the response code was not in [200, 299]
   */
  singleAnswer(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseMessage",
          ""
        );
        return body;
      }
      if (isCodeInRange("201", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseMessage",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Operation failed", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseMessage",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to unassignTag
   * @throws ApiException if the response code was not in [200, 299]
   */
  unassignTag(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to unparameterizeMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  unparameterizeMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to unpublishMetadata
   * @throws ApiException if the response code was not in [200, 299]
   */
  unpublishMetadata(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateCalendar
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateCalendar(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateColumnSecurityRules
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateColumnSecurityRules(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Bad request - Invalid parameters or table not found", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden - User doesn&#39;t have permission to modify security rules for this table", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Internal server error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RepoConfigObject",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RepoConfigObject",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateConnectionConfiguration
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateConnectionConfiguration(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateConnectionV2
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateConnectionV2(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateCustomAction
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateCustomAction(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateDbtConnection
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateDbtConnection(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "any",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateMetadataHeader
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateMetadataHeader(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateMetadataObjId
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateMetadataObjId(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateOrg
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateOrg(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateRole
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateRole(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RoleResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RoleResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateSchedule
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateSchedule(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateSystemConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateSystemConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateTag
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateTag(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateUser
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateUser(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateUserGroup
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateUserGroup(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateVariable
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateVariable(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateVariableValues
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateVariableValues(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateWebhookConfiguration
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateWebhookConfiguration(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to validateEmailCustomization
   * @throws ApiException if the response code was not in [200, 299]
   */
  validateEmailCustomization(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to validateMerge
   * @throws ApiException if the response code was not in [200, 299]
   */
  validateMerge(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DeployResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DeployResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to validateToken
   * @throws ApiException if the response code was not in [200, 299]
   */
  validateToken(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "TokenValidationResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "TokenValidationResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/UsersApi.ts
var UsersApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.7.0.cl or later   Activates a deactivated user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To activate an inactive user account, the API request body must include the following information:  - Username or the GUID of the user account. - Auth token generated for the deactivated user. The auth token is sent in the API response when a user is deactivated. - Password for the user account.      
   * @param activateUserRequest 
   */
  activateUser(activateUserRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (activateUserRequest === null || activateUserRequest === void 0) {
        throw new RequiredError("UsersApi", "activateUser", "activateUserRequest");
      }
      const localVarPath = "/api/rest/2.0/users/activate";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(activateUserRequest, "ActivateUserRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the current password of the user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param changeUserPasswordRequest 
   */
  changeUserPassword(changeUserPasswordRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (changeUserPasswordRequest === null || changeUserPasswordRequest === void 0) {
        throw new RequiredError("UsersApi", "changeUserPassword", "changeUserPasswordRequest");
      }
      const localVarPath = "/api/rest/2.0/users/change-password";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(changeUserPasswordRequest, "ChangeUserPasswordRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a user in ThoughtSpot.  The API endpoint allows you to configure several user properties such as email address, account status, share notification preferences, and sharing visibility. You can provision the user to [groups](https://docs.thoughtspot.com/cloud/latest/groups-privileges) and [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview). You can also add Liveboard, Answer, and Worksheet objects to the users favorites list, assign a default Liveboard for the user, and set user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param createUserRequest 
   */
  createUser(createUserRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createUserRequest === null || createUserRequest === void 0) {
        throw new RequiredError("UsersApi", "createUser", "createUserRequest");
      }
      const localVarPath = "/api/rest/2.0/users/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createUserRequest, "CreateUserRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.7.0.cl or later   Deactivates a user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To deactivate a user account, the API request body must include the following information:  - Username or the GUID of the user account - Base URL of the ThoughtSpot instance  If the API request is successful, ThoughtSpot returns the activation URL in the response. The activation URL is valid for 14 days and can be used to re-activate the account and reset the password of the deactivated account.      
   * @param deactivateUserRequest 
   */
  deactivateUser(deactivateUserRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deactivateUserRequest === null || deactivateUserRequest === void 0) {
        throw new RequiredError("UsersApi", "deactivateUser", "deactivateUserRequest");
      }
      const localVarPath = "/api/rest/2.0/users/deactivate";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deactivateUserRequest, "DeactivateUserRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a user from the ThoughtSpot system.  If you want to remove a user from a specific Org but not from ThoughtSpot, update the group and Org mapping properties of the user object via a POST API call to the [/api/rest/2.0/users/{user_identifier}/update](#/http/api-endpoints/users/update-user) endpoint.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   */
  deleteUser(userIdentifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (userIdentifier === null || userIdentifier === void 0) {
        throw new RequiredError("UsersApi", "deleteUser", "userIdentifier");
      }
      const localVarPath = "/api/rest/2.0/users/{user_identifier}/delete".replace("{user_identifier}", encodeURIComponent(String(userIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Enforces logout on current user sessions.    Use this API with caution as it may invalidate active user sessions and force users to re-login. Make sure you specify the usernames or GUIDs. If you pass null values in the API call, all user sessions on your cluster become invalid, and the users are forced to re-login.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param forceLogoutUsersRequest 
   */
  forceLogoutUsers(forceLogoutUsersRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (forceLogoutUsersRequest === null || forceLogoutUsersRequest === void 0) {
        throw new RequiredError("UsersApi", "forceLogoutUsers", "forceLogoutUsersRequest");
      }
      const localVarPath = "/api/rest/2.0/users/force-logout";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(forceLogoutUsersRequest, "ForceLogoutUsersRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Imports user data from external databases into ThoughtSpot. During the user import operation:  * If the specified users are not available in ThoughtSpot, the users are created and assigned a default password. Defining a `default_password` in the API request is optional. * If `delete_unspecified_users` is set to `true`, the users not specified in the API request, excluding the `tsadmin`, `guest`, `system` and `su` users, are deleted. * If the specified user objects are already available in ThoughtSpot, the object properties are updated and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param importUsersRequest 
   */
  importUsers(importUsersRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (importUsersRequest === null || importUsersRequest === void 0) {
        throw new RequiredError("UsersApi", "importUsers", "importUsersRequest");
      }
      const localVarPath = "/api/rest/2.0/users/import";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(importUsersRequest, "ImportUsersRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Resets the password of a user account. Administrators can reset password on behalf of a user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param resetUserPasswordRequest 
   */
  resetUserPassword(resetUserPasswordRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (resetUserPasswordRequest === null || resetUserPasswordRequest === void 0) {
        throw new RequiredError("UsersApi", "resetUserPassword", "resetUserPasswordRequest");
      }
      const localVarPath = "/api/rest/2.0/users/reset-password";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(resetUserPasswordRequest, "ResetUserPasswordRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of users available on the ThoughtSpot system.  To get details of a specific user, specify the user GUID or name. You can also filter the API response based on groups, Org ID, user visibility, account status, user type, and user preference settings and favorites.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  **NOTE**: If the API returns an empty list, consider increasing the value of the `record_size` parameter. To search across all available users, set `record_size` to `-1`.      
   * @param searchUsersRequest 
   */
  searchUsers(searchUsersRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchUsersRequest === null || searchUsersRequest === void 0) {
        throw new RequiredError("UsersApi", "searchUsers", "searchUsersRequest");
      }
      const localVarPath = "/api/rest/2.0/users/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchUsersRequest, "SearchUsersRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a user object.  You can modify user properties such as username, email, and share notification settings. You can also assign new groups and Orgs, remove the user from a group or Org, reset password, and modify user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   * @param updateUserRequest 
   */
  updateUser(userIdentifier, updateUserRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (userIdentifier === null || userIdentifier === void 0) {
        throw new RequiredError("UsersApi", "updateUser", "userIdentifier");
      }
      if (updateUserRequest === null || updateUserRequest === void 0) {
        throw new RequiredError("UsersApi", "updateUser", "updateUserRequest");
      }
      const localVarPath = "/api/rest/2.0/users/{user_identifier}/update".replace("{user_identifier}", encodeURIComponent(String(userIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateUserRequest, "UpdateUserRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var UsersApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to activateUser
   * @throws ApiException if the response code was not in [200, 299]
   */
  activateUser(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to changeUserPassword
   * @throws ApiException if the response code was not in [200, 299]
   */
  changeUserPassword(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createUser
   * @throws ApiException if the response code was not in [200, 299]
   */
  createUser(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "User",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deactivateUser
   * @throws ApiException if the response code was not in [200, 299]
   */
  deactivateUser(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseActivationURL",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ResponseActivationURL",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteUser
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteUser(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to forceLogoutUsers
   * @throws ApiException if the response code was not in [200, 299]
   */
  forceLogoutUsers(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to importUsers
   * @throws ApiException if the response code was not in [200, 299]
   */
  importUsers(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportUsersResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ImportUsersResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to resetUserPassword
   * @throws ApiException if the response code was not in [200, 299]
   */
  resetUserPassword(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchUsers
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchUsers(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<User>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<User>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateUser
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateUser(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/VariableApi.ts
var VariableApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *  Create a variable which can be used for parameterizing metadata objects   Version: 10.14.0.cl or later   Allows creating a variable which can be used for parameterizing metadata objects in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports the following types of variables: * CONNECTION_PROPERTY - For connection properties * TABLE_MAPPING - For table mappings * CONNECTION_PROPERTY_PER_PRINCIPAL - For connection properties per principal. In order to use this please contact support to enable this. * FORMULA_VARIABLE - For Formula variables, introduced in 10.15.0.cl  When creating a variable, you need to specify: * The variable type * A unique name for the variable * Whether the variable contains sensitive values (defaults to false) * The data type of the variable, only specify for formula variables (defaults to null)  The operation will fail if: * The user lacks required permissions * The variable name already exists * The variable type is invalid     
   * @param createVariableRequest 
   */
  createVariable(createVariableRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createVariableRequest === null || createVariableRequest === void 0) {
        throw new RequiredError("VariableApi", "createVariable", "createVariableRequest");
      }
      const localVarPath = "/api/rest/2.0/template/variables/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createVariableRequest, "CreateVariableRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Delete a variable   Version: 10.14.0.cl or later   Allows deleting a variable from ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint requires: * The variable identifier (ID or name)  The operation will fail if: * The user lacks required permissions * The variable doesn\'t exist * The variable is being used by other objects      
   * @param identifier Unique id or name of the variable
   */
  deleteVariable(identifier, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (identifier === null || identifier === void 0) {
        throw new RequiredError("VariableApi", "deleteVariable", "identifier");
      }
      const localVarPath = "/api/rest/2.0/template/variables/{identifier}/delete".replace("{identifier}", encodeURIComponent(String(identifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Search variables   Version: 10.14.0.cl or later   Allows searching for variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports searching variables by: * Variable identifier (ID or name) * Variable type * Name pattern (case-insensitive, supports % for wildcard)  The search results can be formatted in three ways: * METADATA - Returns only variable metadata (default) * METADATA_AND_VALUES - Returns variable metadata and values  The values can be filtered by scope: * org_identifier * principal_identifier * model_identifier      
   * @param searchVariablesRequest 
   */
  searchVariables(searchVariablesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchVariablesRequest === null || searchVariablesRequest === void 0) {
        throw new RequiredError("VariableApi", "searchVariables", "searchVariablesRequest");
      }
      const localVarPath = "/api/rest/2.0/template/variables/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchVariablesRequest, "SearchVariablesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Update a variable\'s name   Version: 10.14.0.cl or later   Allows updating a variable\'s name in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows updating: * The variable name     
   * @param identifier Unique id or name of the variable to update.
   * @param updateVariableRequest 
   */
  updateVariable(identifier, updateVariableRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (identifier === null || identifier === void 0) {
        throw new RequiredError("VariableApi", "updateVariable", "identifier");
      }
      if (updateVariableRequest === null || updateVariableRequest === void 0) {
        throw new RequiredError("VariableApi", "updateVariable", "updateVariableRequest");
      }
      const localVarPath = "/api/rest/2.0/template/variables/{identifier}/update".replace("{identifier}", encodeURIComponent(String(identifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateVariableRequest, "UpdateVariableRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Update values for multiple variables   Version: 10.14.0.cl or later   Allows updating values for multiple variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows: * Adding new values to variables * Replacing existing values * Deleting values from variables  When updating variable values, you need to specify: * The variable identifiers * The values to add/replace/remove for each variable * The operation to perform (ADD, REPLACE, REMOVE, RESET)  Behaviour based on operation type: * ADD - Adds values to the variable if this is a list type variable, else same as replace. * REPLACE - Replaces all values of a given set of constraints with the current set of values. * REMOVE - Removes any values which match the set of conditions of the variables if this is a list type variable, else clears value. * RESET - Removes all constrains for a given variable, scope is ignored      
   * @param updateVariableValuesRequest 
   */
  updateVariableValues(updateVariableValuesRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateVariableValuesRequest === null || updateVariableValuesRequest === void 0) {
        throw new RequiredError("VariableApi", "updateVariableValues", "updateVariableValuesRequest");
      }
      const localVarPath = "/api/rest/2.0/template/variables/update-values";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateVariableValuesRequest, "UpdateVariableValuesRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var VariableApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createVariable
   * @throws ApiException if the response code was not in [200, 299]
   */
  createVariable(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Variable",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Variable",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteVariable
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteVariable(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchVariables
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchVariables(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<Variable>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<Variable>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateVariable
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateVariable(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateVariableValues
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateVariableValues(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/VersionControlApi.ts
var VersionControlApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *   Version: 9.2.0.cl or later   Commits TML files of metadata objects to the Git branch configured on your instance.  Requires at least edit access to objects used in the commit operation.  Before using this endpoint to push your commits:  * Enable Git integration on your instance. * Make sure the Git repository and branch details are configured on your instance.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitBranchRequest 
   */
  commitBranch(commitBranchRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (commitBranchRequest === null || commitBranchRequest === void 0) {
        throw new RequiredError("VersionControlApi", "commitBranch", "commitBranchRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/branches/commit";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(commitBranchRequest, "CommitBranchRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to connect a ThoughtSpot instance to a Git repository.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.  You can use this API endpoint to connect your ThoughtSpot development and production environments to the development and production branches of a Git repository.  Before using this endpoint to connect your ThoughtSpot instance to a Git repository, check the following prerequisites:  * You have a Git repository. If you are using GitHub, make sure you have a valid account and an access token to connect ThoughtSpot to GitHub. For information about generating a token, see [GitHub Documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).  * Your access token has `repo` scope that grants full access to public and private repositories. * Your Git repository has a branch that can be configured as a default branch in ThoughtSpot.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/?pageid=git-integration).  **Note**: ThoughtSpot supports only GitHub / itHub Enterprise for CI/CD.      
   * @param createConfigRequest 
   */
  createConfig(createConfigRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createConfigRequest === null || createConfigRequest === void 0) {
        throw new RequiredError("VersionControlApi", "createConfig", "createConfigRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/config/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createConfigRequest, "CreateConfigRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Deletes Git repository configuration from your ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param deleteConfigRequest 
   */
  deleteConfig(deleteConfigRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteConfigRequest === null || deleteConfigRequest === void 0) {
        throw new RequiredError("VersionControlApi", "deleteConfig", "deleteConfigRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/config/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteConfigRequest, "DeleteConfigRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to deploy a commit and publish TML content to your ThoughtSpot instance.  Requires at least edit access to the objects used in the deploy operation.  The API deploys the head of the branch unless a `commit_id` is specified in the API request. If the branch name is not defined in the request, the default branch is considered for deploying commits.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param deployCommitRequest 
   */
  deployCommit(deployCommitRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deployCommitRequest === null || deployCommitRequest === void 0) {
        throw new RequiredError("VersionControlApi", "deployCommit", "deployCommitRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/commits/deploy";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deployCommitRequest, "DeployCommitRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Reverts TML objects to a previous commit specified in the API request.  Requires at least edit access to objects.  In the API request, specify the `commit_id`. If the branch name is not specified in the request, the API will consider the default branch configured on your instance.  By default, the API reverts all objects. If the revert operation fails for one of the objects provided in the commit, the API returns an error and does not revert any object.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitId Commit id to which the object should be reverted
   * @param revertCommitRequest 
   */
  revertCommit(commitId, revertCommitRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (commitId === null || commitId === void 0) {
        throw new RequiredError("VersionControlApi", "revertCommit", "commitId");
      }
      if (revertCommitRequest === null || revertCommitRequest === void 0) {
        throw new RequiredError("VersionControlApi", "revertCommit", "revertCommitRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/commits/{commit_id}/revert".replace("{commit_id}", encodeURIComponent(String(commitId)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(revertCommitRequest, "RevertCommitRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of commits for a given metadata object.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param searchCommitsRequest 
   */
  searchCommits(searchCommitsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchCommitsRequest === null || searchCommitsRequest === void 0) {
        throw new RequiredError("VersionControlApi", "searchCommits", "searchCommitsRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/commits/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchCommitsRequest, "SearchCommitsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Gets Git repository connections configured on the ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param searchConfigRequest 
   */
  searchConfig(searchConfigRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchConfigRequest === null || searchConfigRequest === void 0) {
        throw new RequiredError("VersionControlApi", "searchConfig", "searchConfigRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/config/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchConfigRequest, "SearchConfigRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Updates Git repository configuration settings.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param updateConfigRequest 
   */
  updateConfig(updateConfigRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (updateConfigRequest === null || updateConfigRequest === void 0) {
        throw new RequiredError("VersionControlApi", "updateConfig", "updateConfigRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/config/update";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateConfigRequest, "UpdateConfigRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *   Version: 9.2.0.cl or later   Validates the content of your source branch against the objects in your destination environment.  Before merging content from your source branch to the destination branch, run this API operation from your destination environment and ensure that the changes from the source branch function in the destination environment.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param validateMergeRequest 
   */
  validateMerge(validateMergeRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (validateMergeRequest === null || validateMergeRequest === void 0) {
        throw new RequiredError("VersionControlApi", "validateMerge", "validateMergeRequest");
      }
      const localVarPath = "/api/rest/2.0/vcs/git/branches/validate";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(validateMergeRequest, "ValidateMergeRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var VersionControlApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to commitBranch
   * @throws ApiException if the response code was not in [200, 299]
   */
  commitBranch(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CommitResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "CommitResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  createConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RepoConfigObject",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RepoConfigObject",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deployCommit
   * @throws ApiException if the response code was not in [200, 299]
   */
  deployCommit(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DeployResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DeployResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to revertCommit
   * @throws ApiException if the response code was not in [200, 299]
   */
  revertCommit(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RevertResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RevertResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchCommits
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchCommits(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CommitHistoryResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<CommitHistoryResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<RepoConfigObject>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<RepoConfigObject>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateConfig
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateConfig(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RepoConfigObject",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "RepoConfigObject",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to validateMerge
   * @throws ApiException if the response code was not in [200, 299]
   */
  validateMerge(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DeployResponse>",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "Array<DeployResponse>",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// apis/WebhooksApi.ts
var WebhooksApiRequestFactory = class extends BaseAPIRequestFactory {
  /**
   *  Version: 10.14.0.cl or later   Creates a new webhook configuration to receive notifications for specified events. The webhook will be triggered when the configured events occur in the system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param createWebhookConfigurationRequest 
   */
  createWebhookConfiguration(createWebhookConfigurationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (createWebhookConfigurationRequest === null || createWebhookConfigurationRequest === void 0) {
        throw new RequiredError("WebhooksApi", "createWebhookConfiguration", "createWebhookConfigurationRequest");
      }
      const localVarPath = "/api/rest/2.0/webhooks/create";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(createWebhookConfigurationRequest, "CreateWebhookConfigurationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.14.0.cl or later   Deletes one or more webhook configurations by their unique id or name. Returns status of each deletion operation, including successfully deleted webhooks and any failures with error details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param deleteWebhookConfigurationsRequest 
   */
  deleteWebhookConfigurations(deleteWebhookConfigurationsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (deleteWebhookConfigurationsRequest === null || deleteWebhookConfigurationsRequest === void 0) {
        throw new RequiredError("WebhooksApi", "deleteWebhookConfigurations", "deleteWebhookConfigurationsRequest");
      }
      const localVarPath = "/api/rest/2.0/webhooks/delete";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(deleteWebhookConfigurationsRequest, "DeleteWebhookConfigurationsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.14.0.cl or later   Searches for webhook configurations based on various criteria such as Org, webhook identifier, event type, with support for pagination and sorting. Returns matching webhook configurations with their complete details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param searchWebhookConfigurationsRequest 
   */
  searchWebhookConfigurations(searchWebhookConfigurationsRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (searchWebhookConfigurationsRequest === null || searchWebhookConfigurationsRequest === void 0) {
        throw new RequiredError("WebhooksApi", "searchWebhookConfigurations", "searchWebhookConfigurationsRequest");
      }
      const localVarPath = "/api/rest/2.0/webhooks/search";
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(searchWebhookConfigurationsRequest, "SearchWebhookConfigurationsRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
  /**
   *  Version: 10.14.0.cl or later   Updates an existing webhook configuration by its unique id or name. Only the provided fields will be updated.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param webhookIdentifier Unique ID or name of the webhook configuration.
   * @param updateWebhookConfigurationRequest 
   */
  updateWebhookConfiguration(webhookIdentifier, updateWebhookConfigurationRequest, _options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      let _config = _options || this.configuration;
      if (webhookIdentifier === null || webhookIdentifier === void 0) {
        throw new RequiredError("WebhooksApi", "updateWebhookConfiguration", "webhookIdentifier");
      }
      if (updateWebhookConfigurationRequest === null || updateWebhookConfigurationRequest === void 0) {
        throw new RequiredError("WebhooksApi", "updateWebhookConfiguration", "updateWebhookConfigurationRequest");
      }
      const localVarPath = "/api/rest/2.0/webhooks/{webhook_identifier}/update".replace("{webhook_identifier}", encodeURIComponent(String(webhookIdentifier)));
      const requestContext = _config.baseServer.makeRequestContext(localVarPath, "POST" /* POST */);
      requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
      requestContext.setHeaderParam("User-Agent", "ThoughtSpot-Client/typescript/2.21.0");
      requestContext.setHeaderParam("X-ThoughtSpot-Client", "ThoughtSpot-ts-client/2.21.0");
      const contentType = ObjectSerializer.getPreferredMediaType([
        "application/json"
      ]);
      requestContext.setHeaderParam("Content-Type", contentType);
      const serializedBody = ObjectSerializer.stringify(
        ObjectSerializer.serialize(updateWebhookConfigurationRequest, "UpdateWebhookConfigurationRequest", ""),
        contentType
      );
      requestContext.setBody(serializedBody);
      let authMethod;
      authMethod = _config.authMethods["bearerAuth"];
      if (authMethod == null ? void 0 : authMethod.applySecurityAuthentication) {
        yield authMethod == null ? void 0 : authMethod.applySecurityAuthentication(requestContext);
      }
      const defaultAuth = ((_a = _options == null ? void 0 : _options.authMethods) == null ? void 0 : _a.default) || ((_c = (_b = this.configuration) == null ? void 0 : _b.authMethods) == null ? void 0 : _c.default);
      if (defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication) {
        yield defaultAuth == null ? void 0 : defaultAuth.applySecurityAuthentication(requestContext);
      }
      return requestContext;
    });
  }
};
var WebhooksApiResponseProcessor = class {
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to createWebhookConfiguration
   * @throws ApiException if the response code was not in [200, 299]
   */
  createWebhookConfiguration(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to deleteWebhookConfigurations
   * @throws ApiException if the response code was not in [200, 299]
   */
  deleteWebhookConfigurations(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookDeleteResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookDeleteResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to searchWebhookConfigurations
   * @throws ApiException if the response code was not in [200, 299]
   */
  searchWebhookConfigurations(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("200", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookSearchResponse",
          ""
        );
        return body;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "WebhookSearchResponse",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
  /**
   * Unwraps the actual response sent by the server from the response context and deserializes the response content
   * to the expected objects
   *
   * @params response Response returned by the server for a request to updateWebhookConfiguration
   * @throws ApiException if the response code was not in [200, 299]
   */
  updateWebhookConfiguration(response) {
    return __async(this, null, function* () {
      const contentType = ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
      if (isCodeInRange("204", response.httpStatusCode)) {
        return;
      }
      if (isCodeInRange("400", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Invalid request.", body, response.headers);
      }
      if (isCodeInRange("401", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unauthorized access.", body, response.headers);
      }
      if (isCodeInRange("403", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Forbidden access.", body, response.headers);
      }
      if (isCodeInRange("500", response.httpStatusCode)) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "ErrorResponse",
          ""
        );
        throw new ApiException(response.httpStatusCode, "Unexpected error", body, response.headers);
      }
      if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
        const body = ObjectSerializer.deserialize(
          ObjectSerializer.parse(yield response.body.text(), contentType),
          "void",
          ""
        );
        return body;
      }
      throw new ApiException(response.httpStatusCode, "Unknown API Status Code!", yield response.getBodyAsAny(), response.headers);
    });
  }
};

// types/ObservableAPI.ts
var ObservableAIApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new AIApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new AIApiResponseProcessor();
  }
  /**
   * Version: 10.13.0.cl or later 
   * @param createAgentConversationRequest 
   */
  createAgentConversation(createAgentConversationRequest, _options) {
    const requestContextPromise = this.requestFactory.createAgentConversation(createAgentConversationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createAgentConversation(rsp)));
    }));
  }
  /**
   *  Version: 10.4.0.cl or later   Creates a Conversation object to start an AI-driven conversation based on a specific data model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  This API requires the `metadata_identifier` parameter to define the context for the conversation.  You can also specify the tokens to initiate the conversation as shown in this example:  `\"tokens\": \"[tea],[sales],[type]\"`  If the API request is successful, ThoughtSpot returns the ID of the conversation.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param createConversationRequest 
   */
  createConversation(createConversationRequest, _options) {
    const requestContextPromise = this.requestFactory.createConversation(createConversationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createConversation(rsp)));
    }));
  }
  /**
   *  Version: 10.13.0.cl or later   Breaks down a user-submitted query into a series of analytical sub-questions using relevant contextual metadata.  To use this API, the user must have at least view-level access to the referenced metadata objects.  #### Usage guidelines  To accurately generate relevant questions, the request must include at least one of the following metadata identifiers within `metadata_context` : `conversation_identifier`, `answer_identifiers`, `liveboard_identifiers`, or `data_source_identifiers`.  You can further enhance the quality and precision of breakdown by providing additional `ai_context` such as:  - `content`: User provided content like text data, csv data as a string message to provide context & potentially improve the quality of the response. - `instructions`: User specific text instructions sent to AI system for processing the query.  Additional optional parameters include:  - `limit_relevant_questions`: Controls the maximum number of relevant questions returned. Defaults to 5 if not specified. - `bypass_cache`: If set to true, forces fresh computation instead of returning cached results.  If the API request is successful, ThoughtSpot returns a list of relevant analytical queries, each aligned with the user\'s original question. Each returned question includes the query string, along with the identifier and name of the corresponding data source.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.     
   * @param getRelevantQuestionsRequest 
   */
  getRelevantQuestions(getRelevantQuestionsRequest, _options) {
    const requestContextPromise = this.requestFactory.getRelevantQuestions(getRelevantQuestionsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getRelevantQuestions(rsp)));
    }));
  }
  /**
   * Version: 10.7.0.cl or later 
   * @param queryGetDecomposedQueryRequest 
   */
  queryGetDecomposedQuery(queryGetDecomposedQueryRequest, _options) {
    const requestContextPromise = this.requestFactory.queryGetDecomposedQuery(queryGetDecomposedQueryRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.queryGetDecomposedQuery(rsp)));
    }));
  }
  /**
   *  Version: 10.13.0.cl or later   This API allows users to initiate or continue an agent (Spotter) conversation by submitting one or more natural language messages.  To use this API, the user must have access to the relevant conversational session (via conversation_identifier) and submit at least one message.   #### Usage guidelines  To initiate or continue a conversation, the request must include: - `conversation_identifier`: a unique session ID for continuity and message tracking - `messages`: an array of one or more text messages, each with a value and type  Additionally, user can specify what tool can be included `conversation_settings` parameter, which supports: - `enable_contextual_change_analysis` (default: false) - `enable_natural_language_answer_generation` (default: true) - `enable_reasoning` (default: false)  If the request is valid, the API returns a stream of messages in real time, including: - `ack`: confirms receipt of the request - `text / text-chunk`: content chunks, optionally formatted (e.g., markdown) - `answer`: the final structured response with metadata and analytics - `error`: if a failure occurs - `notification`: notification messages for operation being performed  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster. > * The streaming protocol uses Server-Sent Events (SSE)     
   * @param sendAgentMessageStreamingRequest 
   */
  sendAgentMessageStreaming(sendAgentMessageStreamingRequest, _options) {
    const requestContextPromise = this.requestFactory.sendAgentMessageStreaming(sendAgentMessageStreamingRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.sendAgentMessageStreaming(rsp)));
    }));
  }
  /**
   *  Version: 10.4.0.cl or later   Allows sending a follow-up message to an ongoing conversation within the context of the metadata model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  The API requires you to specify the `conversation_identifier` in the request path, and a `metadata_identifier` and `message` string in the request body.  If the API request is successful, ThoughtSpot returns the session ID, tokens used in the conversation, and visualization type.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param conversationIdentifier Unique identifier of the conversation.
   * @param sendMessageRequest 
   */
  sendMessage(conversationIdentifier, sendMessageRequest, _options) {
    const requestContextPromise = this.requestFactory.sendMessage(conversationIdentifier, sendMessageRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.sendMessage(rsp)));
    }));
  }
  /**
   *  Version: 10.4.0.cl or later   Processes a natural language query and returns an AI-generated response based on a specified data model.  Requires at least view access to the metadata object specified in the request.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param singleAnswerRequest 
   */
  singleAnswer(singleAnswerRequest, _options) {
    const requestContextPromise = this.requestFactory.singleAnswer(singleAnswerRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.singleAnswer(rsp)));
    }));
  }
};
var ObservableAuthenticationApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new AuthenticationApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new AuthenticationApiResponseProcessor();
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves details of the current user session for the token provided in the request header.  Any ThoughtSpot user can access this endpoint and send an API request. The data returned in the API response varies according to user\'s privilege and object access permissions.     
   */
  getCurrentUserInfo(_options) {
    const requestContextPromise = this.requestFactory.getCurrentUserInfo(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getCurrentUserInfo(rsp)));
    }));
  }
  /**
   *   Version: 9.4.0.cl or later   Retrieves details of the current session token for the bearer token provided in the request header.  This API endpoint does not create a new token. Instead, it returns details about the token, including the token string, creation time, expiration time, and the associated user.  Use this endpoint to introspect your current session token, debug authentication issues, or when a frontend application needs session token details.  Any ThoughtSpot user with a valid bearer token can access this endpoint and send an API request      
   */
  getCurrentUserToken(_options) {
    const requestContextPromise = this.requestFactory.getCurrentUserToken(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getCurrentUserToken(rsp)));
    }));
  }
  /**
   *   Version: 10.4.0.cl or later   Gets an authentication token with custom rules and security attributes and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  To add a new user and assign privileges during auto creation, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  To assign security attributes with filter rules and Parameters to the JWT token, you\'ll need administrator privileges and edit access to the data source (Worksheet or Model). If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  #### Usage guidelines  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key`.  To generate a `secret_key` on your cluster, the administrator must enable [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable) in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  ##### Attribute-Based Access Control (ABAC) with tokens  To implement Attribute-Based Access Control (ABAC) and assign security entitlements to users during session creation, you can generate a token with custom filtering rules and Parameters in the `filter_rules` and `parameter_values` array respectively. These attributes can be configured to persist on a specific set of objects for user sessions initiated using the token. Once defined, the rules are added to the user\'s `access_control_properties` object, after which all sessions will use the persisted values.  Specify the object type as `LOGICAL_TABLE`.   For more information, see [ABAC via tokens Documentation](https://developers.thoughtspot.com/docs/api-authv2#_get_tokens_with_custom_rules_and_filter_conditions).  ##### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `groups`  Set `auto_create` to `true` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true` in the API request, the user properties such as the display name, email, Org and group assignment will not be updated with new values. If `auto_create` is set to `true`, it won\'t create formula variables and hence won\'t be applicable for `variable_values`.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  ##### Important point to note All options in the token creation APIs that define access to the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created. Persist options such as  `APPEND`, `REPLACE`, `RESET` will persist security parameters on the user profile when the token is created, while Persist option `NONE` will not persist anything but will be honoured in the session.  ##### Formula Variables Before using variables_values, variables must be created using Create Variable API with type as Formula_Variable (/api/rest/2.0/template/variables/create) The persist_option RESET and NONE cannot be used when variable_values are provided in the request. If you are working with variable_values, you must use other (APPEND, REPLACE) supported modes. If you want to use RESET or NONE, do not pass any variable_values. In such cases, variable_values will remain unaffected. When using object_id with variable_values, models are supported.      
   * @param getCustomAccessTokenRequest 
   */
  getCustomAccessToken(getCustomAccessTokenRequest, _options) {
    const requestContextPromise = this.requestFactory.getCustomAccessToken(getCustomAccessTokenRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getCustomAccessToken(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page. For more information, see [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable).  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getFullAccessTokenRequest 
   */
  getFullAccessToken(getFullAccessTokenRequest, _options) {
    const requestContextPromise = this.requestFactory.getFullAccessToken(getFullAccessTokenRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getFullAccessToken(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token that provides access to a specific metadata object. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request,  `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getObjectAccessTokenRequest 
   */
  getObjectAccessToken(getObjectAccessTokenRequest, _options) {
    const requestContextPromise = this.requestFactory.getObjectAccessToken(getObjectAccessTokenRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getObjectAccessToken(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a login session for a ThoughtSpot user with Basic authentication.  In Basic authentication method, REST clients log in to ThoughtSpot using `username` and `password` attributes. On a multi-tenant cluster with Orgs, users can pass the ID of the Org in the API request to log in to a specific Org context.  **Note**: If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. Contact ThoughtSpot Support for assistance.  A successful login returns a session cookie that can be used in your subsequent API requests.     
   * @param loginRequest 
   */
  login(loginRequest, _options) {
    const requestContextPromise = this.requestFactory.login(loginRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.login(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later    Logs out a user from their current session.      
   */
  logout(_options) {
    const requestContextPromise = this.requestFactory.logout(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.logout(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later    Revokes the authentication token issued for current user session.  The token of your current session expires when you make a call to the `/api/rest/2.0/auth/token/revoke` endpoint. the users will not be able to access ThoughtSpot objects until a new token is obtained.  To restart your session, request for a new token from ThoughtSpot. See [Get Full Access Token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param revokeTokenRequest 
   */
  revokeToken(revokeTokenRequest, _options) {
    const requestContextPromise = this.requestFactory.revokeToken(revokeTokenRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.revokeToken(rsp)));
    }));
  }
  /**
   *   Version: 9.12.0.cl or later    Validates the authentication token specified in the API request.  If your token is not valid, [Get a new token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param validateTokenRequest 
   */
  validateToken(validateTokenRequest, _options) {
    const requestContextPromise = this.requestFactory.validateToken(validateTokenRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.validateToken(rsp)));
    }));
  }
};
var ObservableConnectionConfigurationsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new ConnectionConfigurationsApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new ConnectionConfigurationsApiResponseProcessor();
  }
  /**
   *   Version: 10.12.0.cl or later   Gets connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines * To get a list of all configurations available in the ThoughtSpot system, send the API request with only the connection name or GUID in the request body. * To fetch details of a configuration object, specify the configuration object name or GUID.      
   * @param connectionConfigurationSearchRequest 
   */
  connectionConfigurationSearch(connectionConfigurationSearchRequest, _options) {
    const requestContextPromise = this.requestFactory.connectionConfigurationSearch(connectionConfigurationSearchRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.connectionConfigurationSearch(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Creates an additional configuration to an existing connection to a data warehouse.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines   * A JSON map of configuration attributes in `configuration`. The following example shows the configuration attributes:   ```    {      \"user\":\"DEV_USER\",      \"password\":\"TestConn123\",      \"role\":\"DEV\",      \"warehouse\":\"DEV_WH\"     }   ```  * If the `policy_type` is `PRINCIPALS`, then `policy_principals` is a required field. * If the `policy_type` is `PROCESSES`, then `policy_processes` is a required field. * If the `policy_type` is `NO_POLICY`, then `policy_principals` and `policy_processes` are not required fields.  #### Parameterized Connection Support For parameterized connections that use OAuth authentication, only the same_as_parent and policy_process_options  attributes are allowed in the API request. These attributes are not applicable to connections that are not parameterized.       
   * @param createConnectionConfigurationRequest 
   */
  createConnectionConfiguration(createConnectionConfigurationRequest, _options) {
    const requestContextPromise = this.requestFactory.createConnectionConfiguration(createConnectionConfigurationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createConnectionConfiguration(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param deleteConnectionConfigurationRequest 
   */
  deleteConnectionConfiguration(deleteConnectionConfigurationRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteConnectionConfiguration(deleteConnectionConfigurationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteConnectionConfiguration(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Updates a connection configuration object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Supported operations This API endpoint lets you perform the following operations in a single API request:   * Edit the name or description of the configuration  * Edit the configuration properties  * Edit the `policy_type`  * Edit the type of authentication  * Enable or disable a configuration  #### Parameterized Connection Support For parameterized oauth based connections, only the `same_as_parent` and `policy_process_options` attributes are allowed. These attributes are not applicable to connections that are not parameterized.   **NOTE**: When updating a configuration where `disabled` is `true`, you must reset `disabled` to `true` in your update request payload. If not explicitly set again, the API will default `disabled` to `false`.      
   * @param configurationIdentifier Unique ID or name of the configuration.
   * @param updateConnectionConfigurationRequest 
   */
  updateConnectionConfiguration(configurationIdentifier, updateConnectionConfigurationRequest, _options) {
    const requestContextPromise = this.requestFactory.updateConnectionConfiguration(configurationIdentifier, updateConnectionConfigurationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateConnectionConfiguration(rsp)));
    }));
  }
};
var ObservableConnectionsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new ConnectionsApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new ConnectionsApiResponseProcessor();
  }
  /**
   *   Version: 9.2.0.cl or later   Creates a connection to a data warehouse for live query services.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Create a connection without tables  To create a connection without tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a SnowFlake connection:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[       ]   }   ``` 2. Set `validate` to `false`.  #### Create a connection with tables  To create a connection with tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[         {            \"name\":\"AllDatatypes\",            \"isAutoCreated\":false,            \"schemas\":[               {                  \"name\":\"alldatatypes\",                  \"tables\":[                     {                        \"name\":\"allDatatypes\",                        \"type\":\"TABLE\",                        \"description\":\"\",                        \"selected\":true,                        \"linked\":true,                        \"columns\":[                           {                              \"name\":\"CNUMBER\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           },                           {                              \"name\":\"CDECIMAL\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           }                        ]                     }                  ]               }            ]         }      ]   }   ``` 2. Set `validate` to `true`.      
   * @param createConnectionRequest 
   */
  createConnection(createConnectionRequest, _options) {
    const requestContextPromise = this.requestFactory.createConnection(createConnectionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createConnection(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later    **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Delete Connection V2](#/http/api-endpoints/connections/delete-connection-v2) endpoint to delete your connection objects.    #### Usage guidelines  Deletes a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.     
   * @param deleteConnectionRequest 
   */
  deleteConnection(deleteConnectionRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteConnection(deleteConnectionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteConnection(rsp)));
    }));
  }
  /**
   *   Version: 10.4.0.cl or later   Deletes a connection object.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param connectionIdentifier Unique ID or name of the connection.
   */
  deleteConnectionV2(connectionIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteConnectionV2(connectionIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteConnectionV2(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Exports the difference in connection metadata between CDW and ThoughtSpot  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:   - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  To download the connection metadata difference between ThoughtSpot and CDW, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  downloadConnectionMetadataChanges(connectionIdentifier, _options) {
    const requestContextPromise = this.requestFactory.downloadConnectionMetadataChanges(connectionIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.downloadConnectionMetadataChanges(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Validates the difference in connection metadata between CDW and ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  Returns a boolean indicating whether there is any difference between the connection metadata at ThoughtSpot and CDW.  To get the connection metadata difference status, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  fetchConnectionDiffStatus(connectionIdentifier, _options) {
    const requestContextPromise = this.requestFactory.fetchConnectionDiffStatus(connectionIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchConnectionDiffStatus(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Gets connection objects. Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  - To get a list of all connections available in the ThoughtSpot system, send the API request without any attributes in the request body. - To get the connection objects for a specific type of data warehouse, specify the type in `data_warehouse_types`. - To fetch details of a connection object, specify the connection object GUID or name. The `name_pattern` attribute allows passing partial text with `%` for a wildcard match. - To get details of the database, schemas, tables, or columns from a data connection object, specify `data_warehouse_object_type`. - To get a specific database, schema, table, or column from a connection object, define the object type in `data_warehouse_object_type` and object properties in the `data_warehouse_objects` array. For example, to search for a column, you must pass the database, schema, and table names in the API request.   Note that in the following example, object properties are set in a hierarchical order (`database` > `schema` > `table` > `column`).  ``` {   \"connections\": [     {       \"identifier\": \"b9d1f2ef-fa65-4a4b-994e-30fa2d57b0c2\",       \"data_warehouse_objects\": [         {           \"database\": \"NEBULADEV\",           \"schema\": \"INFORMATION_SCHEMA\",           \"table\": \"APPLICABLE_ROLES\",           \"column\": \"ROLE_NAME\"         }       ]     }   ],   \"data_warehouse_object_type\": \"COLUMN\" } ```  - To fetch data by `configuration`, specify `data_warehouse_object_type`. For example, to fetch columns from the `DEVELOPMENT` database, specify the `data_warehouse_object_type` as `DATABASE` and define the `configuration` string as `{\"database\":\"DEVELOPMENT\"}`. To get column data for a specific table, specify the table, for example,`{\"database\":\"RETAILAPPAREL\",\"table\":\"PIPES\"}`. - To query connections by `authentication_type`, specify `data_warehouse_object_type`. Supported values for `authentication_type` are:   - `SERVICE_ACCOUNT`: For connections that require service account credentials to authenticate to the Cloud Data Warehouse and fetch data.   - `OAUTH`: For connections that require OAuth credentials to authenticate to the Cloud Data Warehouse and fetch data. Teradata, Oracle, and Presto Cloud Data Warehouses do not support the OAuth authentication type.   - `IAM`: For connections that have the IAM OAuth set up. This authentication type is supported on Amazon Redshift connections only.   - `EXTOAUTH`: For connections that have External OAuth set up. ThoughtSpot supports external [OAuth with Microsoft Azure Active Directory (AD)](https://docs.thoughtspot.com/cloud/latest/ connections-snowflake-azure-ad-oauth) and [Okta for Snowflake data connections](https://docs.thoughtspot.com/cloud/latest/connections-snowflake-okta-oauth).   - `KEY_PAIR`: For connections that require Key Pair account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PKCE`: For connections that require OAuth with PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake, Starburst, Databricks, Denodo  connections only.   - `EXTOAUTH_WITH_PKCE`: For connections that require External OAuth With PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PEZ`: For connections that require OAuth With PEZ account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Amazon Redshift connections only.   - `OAUTH_WITH_SERVICE_PRINCIPAL`: For connections that require OAuth With Service Principal account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `PERSONAL_ACCESS_TOKEN`: For connections that require Personal Access Token account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `OAUTH_CLIENT_CREDENTIALS`: For connections that require OAuth Client Credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only. - To include more details about connection objects in the API response, set `include_details` to `true`. - You can also sort the output by field names and filter connections by tags.  **NOTE**: When filtering connection records by parameters other than `data_warehouse_types` or `tag_identifiers`, ensure that you set `record_size` to `-1` and `record_offset` to `0` for precise results.      
   * @param searchConnectionRequest 
   */
  searchConnection(searchConnectionRequest, _options) {
    const requestContextPromise = this.requestFactory.searchConnection(searchConnectionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchConnection(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Update connection V2](#/http/api-endpoints/connections/update-connection-v2) endpoint to update your connection objects.  #### Usage guidelines  Updates a connection object.    Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`. 3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.      
   * @param updateConnectionRequest 
   */
  updateConnection(updateConnectionRequest, _options) {
    const requestContextPromise = this.requestFactory.updateConnection(updateConnectionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateConnection(rsp)));
    }));
  }
  /**
   *   Version: 10.4.0.cl or later   Updates a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`.        **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.     * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:    * This is an example of updating a single table in a empty connection:           ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"DEMORENAME\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"Col1\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col2\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col3\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col312\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col4\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```        * This is an example of updating a single table in an existing connection with tables:            ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"CUSTOMER\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [],                     \"relationships\": []                   },                   {                     \"name\": \"tpch5k_falcon_default_schema_users\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"user_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"product_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"user_cost\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```  3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.    **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not  specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.    * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a Snowflake connection:    ```    {       \"configuration\":{          \"accountName\":\"thoughtspot_partner\",          \"user\":\"tsadmin\",          \"password\":\"TestConn123\",          \"role\":\"sysadmin\",          \"warehouse\":\"MEDIUM_WH\"       },       \"externalDatabases\":[        ]    }    ```      
   * @param connectionIdentifier Unique ID or name of the connection.
   * @param updateConnectionV2Request 
   */
  updateConnectionV2(connectionIdentifier, updateConnectionV2Request, _options) {
    const requestContextPromise = this.requestFactory.updateConnectionV2(connectionIdentifier, updateConnectionV2Request, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateConnectionV2(rsp)));
    }));
  }
};
var ObservableCustomActionApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new CustomActionApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new CustomActionApiResponseProcessor();
  }
  /**
   *   Version: 9.6.0.cl or later   Creates a custom action that appears as a menu action on a saved Answer or Liveboard visualization.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API lets you create the following types of custom actions:  * URL-based action        Allows pushing data to an external URL. * Callback action           Triggers a callback to the host application and initiates a response payload on an embedded ThoughtSpot instance.  By default, custom actions are visible to only administrator or developer users. To make a custom action available to other users, and specify the groups in `group_identifiers`.  By default, the custom action is set as a _global_ action on all visualizations and saved Answers. To assign a custom action to specific Liveboard visualization, saved Answer, or Worksheet, set `visibility` to `false` in `default_action_config` property and specify the GUID or name of the object in `associate_metadata`.  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param createCustomActionRequest 
   */
  createCustomAction(createCustomActionRequest, _options) {
    const requestContextPromise = this.requestFactory.createCustomAction(createCustomActionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createCustomAction(rsp)));
    }));
  }
  /**
   *   Version: 9.6.0.cl or later   Removes the custom action specified in the API request.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param customActionIdentifier Unique ID or name of the custom action.
   */
  deleteCustomAction(customActionIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteCustomAction(customActionIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteCustomAction(rsp)));
    }));
  }
  /**
   *   Version: 9.6.0.cl or later   Gets custom actions configured on the cluster.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param searchCustomActionsRequest 
   */
  searchCustomActions(searchCustomActionsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchCustomActions(searchCustomActionsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchCustomActions(rsp)));
    }));
  }
  /**
   *   Version: 9.6.0.cl or later   Updates a custom action.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API allows you to modify the following properties:  * Name of the custom action * Action availability to groups * Association to metadata objects * Authentication settings for a URL-based action  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param customActionIdentifier Unique ID or name of the custom action.
   * @param updateCustomActionRequest 
   */
  updateCustomAction(customActionIdentifier, updateCustomActionRequest, _options) {
    const requestContextPromise = this.requestFactory.updateCustomAction(customActionIdentifier, updateCustomActionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateCustomAction(rsp)));
    }));
  }
};
var ObservableCustomCalendarsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new CustomCalendarsApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new CustomCalendarsApiResponseProcessor();
  }
  /**
   *   Version: 10.12.0.cl or later   Creates a new [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.   #### Usage guidelines  You can create a custom calendar from scratch or an existing Table in ThoughtSpot. For both methods of calendar creation, the following parameters are required:  * Name of the custom calendar. * Calendar creation method. To create a calendar from an existing table, specify the method:   - `FROM_EXISTING_TABLE` - Creates calendar from the table reference provided in the API request.  - `FROM_INPUT_PARAMS` - Creates a calendar from the parameters defined in the API request.  * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  **NOTE**: If you are creating a calendar from an existing table, ensure that the referenced table matches the required DDL for custom calendars. If the schema does not match, the API returns an error.  ##### Calendar type The API allows you to create the following types of calendars:  * `MONTH_OFFSET`. The default calendar type. A `MONTH_OFFSET` calendar is offset by a few months from the standard calendar months (January to December) and the year begins with the month defined in the request. For example, if the `month_offset` value is set as `April`, the calendar year begins in April.  * `4-4-5`. Each quarter in the calendar will include two 4-week months followed by one 5-week month. * `4-5-4`. Each quarter in the calendar will include two 4-week months with a 5-week month between. * `5-4-4`. Each quarter begins with a 5-week month, followed by two 4-week months.  To start and end the calendar on a specific date, specify the dates in the `MM/DD/YYYY` format. For `MONTH_OFFSET` calendars, ensure that the `start_date` matches the month specified in the `month_offset` attribute.  You can also set the starting day of the week and customize the prefixes for year and quarter labels.  #### Examples  To create a calendar from an existing table:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_EXISTING_TABLE\", } ```  To create a calendar from scratch:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_INPUT_PARAMS\",   \"calendar_type\": \"MONTH_OFFSET\",   \"month_offset\": \"April\",   \"start_day_of_week\": \"Monday\",   \"quarter_name_prefix\": \"Q\",   \"year_name_prefix\": \"FY\",   \"start_date\": \"04/01/2025\",   \"end_date\": \"04/31/2025\" } ```      
   * @param createCalendarRequest 
   */
  createCalendar(createCalendarRequest, _options) {
    const requestContextPromise = this.requestFactory.createCalendar(createCalendarRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createCalendar(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines To delete a custom calendar, specify the calendar ID as a path parameter in the request URL.        
   * @param calendarIdentifier Unique ID or name of the Calendar.
   */
  deleteCalendar(calendarIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteCalendar(calendarIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteCalendar(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Exports a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal) in the CSV format.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  Use this API to download a custom calendar in the CSV file format. In your API request, specify the following parameters.  * Start and end date of the calendar. For \"month offset\" calendars, the start date must match the month defined in the `month_offset` attribute.  You can also specify optional parameters such as the starting day of the week and prefixes for the quarter and year labels.      
   * @param generateCSVRequest 
   */
  generateCSV(generateCSVRequest, _options) {
    const requestContextPromise = this.requestFactory.generateCSV(generateCSVRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.generateCSV(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Gets a list of [custom calendars](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  By default, the API returns a list of custom calendars for all connection objects. To retrieve custom calendar details for a particular connection, specify the connection ID. You can also use other search parameters such as `name_pattern` and `sort_options` as search filters.  The `name_pattern` parameter filters and returns only those objects that match the specified pattern. Use `%` as a wildcard for pattern matching.      
   * @param searchCalendarsRequest 
   */
  searchCalendars(searchCalendarsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchCalendars(searchCalendarsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchCalendars(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Updates the properties of a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  You can update the properties of a calendar using one of the following methods: * `FROM_INPUT_PARAMS` to update the calendar properties with the values defined in the API request. * `FROM_EXISTING_TABLE` Creates a calendar from the parameters defined in the API request.  To update a custom calendar, specify the calendar ID as a path parameter in the request URL and the following parameters in the request body:    * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  The API allows you to modify the calendar type, month offset value, start and end date, starting day of the week, and prefixes assigned to the year and quarter labels.     #### Examples  Update a custom calendar using an existing Table in ThoughtSpot:  ``` {   \"update_method\": \"FROM_EXISTING_TABLE\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   } } ```  Update a custom calendar with the attributes defined in the API request:  ``` {   \"update_method\": \"FROM_INPUT_PARAMS\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   },   \"month_offset\": \"August\",   \"start_day_of_week\": \"Monday\",   \"start_date\": \"08/01/2025\",   \"end_date\": \"07/31/2026\" } ```      
   * @param calendarIdentifier Unique Id or name of the calendar.
   * @param updateCalendarRequest 
   */
  updateCalendar(calendarIdentifier, updateCalendarRequest, _options) {
    const requestContextPromise = this.requestFactory.updateCalendar(calendarIdentifier, updateCalendarRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateCalendar(rsp)));
    }));
  }
};
var ObservableDBTApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new DBTApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new DBTApiResponseProcessor();
  }
  /**
   *   Version: 9.9.0.cl or later   Creates a DBT connection object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About create DBT connection DBT connection in ThoughtSpot is used by the user to define DBT credentials for cloud . The API needs  embrace connection, embrace database name, DBT url, import type, DBT account identifier, DBT project identifier, DBT access token and environment details (or) embrace connection, embrace database name, import type, file_content to create a connection object. To know more about DBT, see ThoughtSpot Product Documentation.      
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  dbtConnection(connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    const requestContextPromise = this.requestFactory.dbtConnection(connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.dbtConnection(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Resynchronize the existing list of models, tables, worksheet tmls and import them to Thoughtspot based on the DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateSyncTml(dbtConnectionIdentifier, fileContent, _options) {
    const requestContextPromise = this.requestFactory.dbtGenerateSyncTml(dbtConnectionIdentifier, fileContent, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.dbtGenerateSyncTml(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Generate required table and worksheet and import them.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About generate TML Models and Worksheets to be imported can be selected by the user as part of the API.      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param modelTables List of Models and their respective Tables Example: \\\&#39;[{\\\&quot;model_name\\\&quot;: \\\&quot;model_name\\\&quot;, \\\&quot;tables\\\&quot;: [\\\&quot;table_name\\\&quot;]}]\\\&#39;
   * @param importWorksheets Mention the worksheet tmls to import
   * @param worksheets List of worksheets is mandatory when import_Worksheets is type SELECTED Example: [\\\&quot;worksheet_name\\\&quot;]
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateTml(dbtConnectionIdentifier, modelTables, importWorksheets, worksheets, fileContent, _options) {
    const requestContextPromise = this.requestFactory.dbtGenerateTml(dbtConnectionIdentifier, modelTables, importWorksheets, worksheets, fileContent, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.dbtGenerateTml(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Gets a list of DBT connection objects by user and organization, available on the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About search DBT connection To get details of a specific DBT connection identifier, database connection identifier, database connection name, database name, project name, project identifier, environment identifier , import type and author.      
   */
  dbtSearch(_options) {
    const requestContextPromise = this.requestFactory.dbtSearch(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.dbtSearch(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Removes the specified DBT connection object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   */
  deleteDbtConnection(dbtConnectionIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteDbtConnection(dbtConnectionIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteDbtConnection(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Updates a DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About update DBT connection You can modify DBT connection object properties such as embrace connection name, embrace database name, import type, account identifier, access token, project identifier and environment (or) embrace connection, embrace database name, import type, file_content settings.      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  updateDbtConnection(dbtConnectionIdentifier, connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    const requestContextPromise = this.requestFactory.updateDbtConnection(dbtConnectionIdentifier, connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateDbtConnection(rsp)));
    }));
  }
};
var ObservableDataApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new DataApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new DataApiResponseProcessor();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches data from a saved Answer.  Requires at least view access to the saved Answer.  The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_apis).     
   * @param fetchAnswerDataRequest 
   */
  fetchAnswerData(fetchAnswerDataRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchAnswerData(fetchAnswerDataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchAnswerData(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets data from a Liveboard object and its visualization.    Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To get data for specific visualizations, add the GUIDs or names of the visualizations in the API request.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes. If the new Liveboard experience mode, the transient content includes ad hoc changes to visualizations such as sorting, toggling of legends, and data drill down.  For more information, and see [Liveboard data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_fetch_liveboard_data_api).     
   * @param fetchLiveboardDataRequest 
   */
  fetchLiveboardData(fetchLiveboardDataRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchLiveboardData(fetchLiveboardDataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchLiveboardData(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Generates an Answer from a given data source.  Requires at least view access to the data source object (Worksheet or View).  #### Usage guidelines  To search data, specify the data source GUID in `logical_table_identifier`. The data source can be a Worksheet, View, Table, or SQL view.  Pass search tokens in the `query_string` attribute in the API request as shown in the following example:  ``` {   \"query_string\": \"[sales] by [store]\",   \"logical_table_identifier\": \"cd252e5c-b552-49a8-821d-3eadaa049cca\", } ```  For more information about the `query_string` format and data source attribute, see [Search data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_search_data_api).    The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_api).       
   * @param searchDataRequest 
   */
  searchData(searchDataRequest, _options) {
    const requestContextPromise = this.requestFactory.searchData(searchDataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchData(rsp)));
    }));
  }
};
var ObservableEmailCustomizationApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new EmailCustomizationApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new EmailCustomizationApiResponseProcessor();
  }
  /**
   *  Version: 10.10.0.cl or later   Creates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To create a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param createEmailCustomizationRequest 
   */
  createEmailCustomization(createEmailCustomizationRequest, _options) {
    const requestContextPromise = this.requestFactory.createEmailCustomization(createEmailCustomizationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createEmailCustomization(rsp)));
    }));
  }
  /**
   *  Version: 10.10.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `template_identifier` from the response. - Use that `template_identifier` as a parameter in this API request.      
   * @param templateIdentifier Unique ID or name of the email customization.
   */
  deleteEmailCustomization(templateIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteEmailCustomization(templateIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteEmailCustomization(rsp)));
    }));
  }
  /**
   *  Version: 10.12.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `org_identifier` from the response. - Use that `org_identifier` as a parameter in this API request.      
   * @param deleteOrgEmailCustomizationRequest 
   */
  deleteOrgEmailCustomization(deleteOrgEmailCustomizationRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteOrgEmailCustomization(deleteOrgEmailCustomizationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteOrgEmailCustomization(rsp)));
    }));
  }
  /**
   *  Version: 10.10.0.cl or later   Search the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   * @param searchEmailCustomizationRequest 
   */
  searchEmailCustomization(searchEmailCustomizationRequest, _options) {
    const requestContextPromise = this.requestFactory.searchEmailCustomization(searchEmailCustomizationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchEmailCustomization(rsp)));
    }));
  }
  /**
   *  Version: 10.12.0.cl or later   Updates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To update a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param updateEmailCustomizationRequest 
   */
  updateEmailCustomization(updateEmailCustomizationRequest, _options) {
    const requestContextPromise = this.requestFactory.updateEmailCustomization(updateEmailCustomizationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateEmailCustomization(rsp)));
    }));
  }
  /**
   *  Version: 10.10.0.cl or later   Validates the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   */
  validateEmailCustomization(_options) {
    const requestContextPromise = this.requestFactory.validateEmailCustomization(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.validateEmailCustomization(rsp)));
    }));
  }
};
var ObservableGroupsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new GroupsApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new GroupsApiResponseProcessor();
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### About groups Groups in ThoughtSpot are used by the administrators to define privileges and organize users based on their roles and access requirements. To know more about groups and privileges, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/groups-privileges).  #### Supported operations  The API endpoint lets you perform the following operations:  * Assign privileges * Add users * Define sharing visibility * Add sub-groups * Assign a default Liveboard      
   * @param createUserGroupRequest 
   */
  createUserGroup(createUserGroupRequest, _options) {
    const requestContextPromise = this.requestFactory.createUserGroup(createUserGroupRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createUserGroup(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified group object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.      
   * @param groupIdentifier GUID or name of the group.
   */
  deleteUserGroup(groupIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteUserGroup(groupIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteUserGroup(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Imports group objects from external databases into ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  During the import operation:  * If the specified group is not available in ThoughtSpot, it will be added to ThoughtSpot. * If `delete_unspecified_groups` is set to `true`, the groups not specified in the API request, excluding administrator and system user groups, are deleted. * If the specified groups are already available in ThoughtSpot, the object properties of these groups are modified and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.      
   * @param importUserGroupsRequest 
   */
  importUserGroups(importUserGroupsRequest, _options) {
    const requestContextPromise = this.requestFactory.importUserGroups(importUserGroupsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.importUserGroups(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of user group objects from the ThoughtSpot system.  To get details of a specific user group, specify the user group GUID or name. You can also filter the API response based on User ID, Org ID, Role ID, type of group, sharing visibility, privileges assigned to the group, and the Liveboard IDs assigned to the users in the group.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  **NOTE**: If you do not get precise results, try setting `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchUserGroupsRequest 
   */
  searchUserGroups(searchUserGroupsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchUserGroups(searchUserGroupsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchUserGroups(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### Supported operations  This API endpoint lets you perform the following operations in a single API request:  * Edit [privileges](https://developers.thoughtspot.com/docs/?pageid=api-user-management#group-privileges) * Add or remove users * Change sharing visibility settings * Add or remove sub-groups * Assign a default Liveboard  or update the existing settings      
   * @param groupIdentifier GUID or name of the group.
   * @param updateUserGroupRequest 
   */
  updateUserGroup(groupIdentifier, updateUserGroupRequest, _options) {
    const requestContextPromise = this.requestFactory.updateUserGroup(groupIdentifier, updateUserGroupRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateUserGroup(rsp)));
    }));
  }
};
var ObservableLogApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new LogApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new LogApiResponseProcessor();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches security audit logs.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the [Admin Control](https://developers.thoughtspot.com/docs/rbac#_admin_control) privileges are required.   #### Usage guidelines  By default, the API retrieves logs for the last 24 hours. You can set a custom duration in EPOCH time. Make sure the log duration specified in your API request doesnt exceed 24 hours. If you must fetch logs for a longer time range, modify the duration and make multiple sequential API requests.  Upon successful execution, the API returns logs with the following information: * timestamp of the event * event ID * event type * name and GUID of the user * IP address of ThoughtSpot instance  For more information see [Audit logs Documentation](https://developers.thoughtspot.com/docs/audit-logs).      
   * @param fetchLogsRequest 
   */
  fetchLogs(fetchLogsRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchLogs(fetchLogsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchLogs(rsp)));
    }));
  }
};
var ObservableMetadataApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new MetadataApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new MetadataApiResponseProcessor();
  }
  /**
   *  Convert worksheets to models    Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (Can manage data models).  ---  ## Usage Guidelines  ### Parameters  1. **worksheet_ids**      - **Description:** A comma-separated list of GUIDs (Globally Unique Identifiers) specifying the Worksheets to be converted.      - **Usage:**        - Used only when `convert_all` is set to `false`.        - Leave empty or omit when `convert_all` is set to `true`.  2. **exclude_worksheet_ids**      - **Description:** A comma-separated list of GUIDs specifying Worksheets to be excluded from conversion.      - **Usage:**        - Useful when `convert_all` is set to `true` and specific Worksheets should not be converted.  3. **convert_all**      - **Description:** Sets the scope of conversion.    - **Options:**        - `true`: Converts all Worksheets in the system, except those specified in `exclude_worksheet_ids`.        - `false`: Converts only the Worksheets listed in `worksheet_ids`.  4. **apply_changes**      - **Description:** Specifies whether to apply changes directly to ThoughtSpot or to generate a preview before applying any changes.Used for validation of conversion.    - **Options:**        - `true`: Applies conversion changes directly to ThoughtSpot.      - `false`: Generates only a preview of the changes and does not apply any changes to ThoughtSpot  ---  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the conversion process  2. **Partial Conversion for Testing:**      Test the conversion process by setting `convert_all` to `false` and specifying a small number of `worksheet_ids`.  3. **Verify Dependencies:**      Check for dependent objects, such as Tables and Connections, to avoid invalid references.  4. **Review Changes:**      Use `apply_changes: false` to preview the impact of the conversion before applying changes.  ---  ## Examples  ### Convert Specific Worksheets ```json {   \"worksheet_ids\": [\"guid1\", \"guid2\", \"guid3\"],   \"exclude_worksheet_ids\": [],   \"convert_all\": false,   \"apply_changes\": true } ```  ### Convert All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [],   \"convert_all\": true,   \"apply_changes\": true } ```  ### Exclude Specific Worksheets While Converting All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [\"abc\"],   \"convert_all\": true,   \"apply_changes\": true } ```     
   * @param convertWorksheetToModelRequest 
   */
  convertWorksheetToModel(convertWorksheetToModelRequest, _options) {
    const requestContextPromise = this.requestFactory.convertWorksheetToModel(convertWorksheetToModelRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.convertWorksheetToModel(rsp)));
    }));
  }
  /**
   *  Makes a copy of an Answer or Liveboard    Version: 10.3.0.cl or later   Creates a copy of a metadata object.  Requires at least view access to the metadata object being copied.  Upon successful execution, the API creates a copy of the metadata object specified in the API request and returns the ID of the new object.      
   * @param copyObjectRequest 
   */
  copyObject(copyObjectRequest, _options) {
    const requestContextPromise = this.requestFactory.copyObject(copyObjectRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.copyObject(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified metadata object from the ThoughtSpot system.  Requires edit access to the metadata object.       
   * @param deleteMetadataRequest 
   */
  deleteMetadata(deleteMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteMetadata(deleteMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteMetadata(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  Requires `DATADOWNLOADING` (**Can download Data**) and at least view access to the metadata object.  #### Usage guidelines  * You can export one or several objects by passing metadata object GUIDs in the `metadata` array. * When exporting TML content for a Liveboard or Answer object, you can set `export_associated` to `true` to retrieve TML content for underlying Worksheets, Tables, or Views, including the GUID of each object within the headers. When   `export_associated` is set to `true`, consider retrieving one metadata object at a time. * Set `export_fqns` to `true` to add FQNs of the referenced objects in the TML content. For example, if you send an API request to retrieve TML for a Liveboard and its associated objects, the API returns the TML content with FQNs of the referenced Worksheet. Exporting TML with FQNs is useful if ThoughtSpot has multiple objects with the same name and you want to eliminate ambiguity when importing TML files into ThoughtSpot. It eliminates the need for adding FQNs of the referenced objects manually during the import operation. * To export only the TML of feedbacks associated with an object, set the GUID of the object as `identifier`, and set the `type` as `FEEDBACK` in the `metadata` array. * To export the TML of an object along with the feedbacks associated with it, set the GUID of the object as `identifier`, set the `type` as `LOGIAL_TABLE` in the `metadata` array, and set `export_with_associated_feedbacks` in `export_options` to true.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_export_a_tml).  For more information on feedbacks, see [Feedback Documentation](https://docs.thoughtspot.com/cloud/latest/sage-feedback).     
   * @param exportMetadataTMLRequest 
   */
  exportMetadataTML(exportMetadataTMLRequest, _options) {
    const requestContextPromise = this.requestFactory.exportMetadataTML(exportMetadataTMLRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.exportMetadataTML(rsp)));
    }));
  }
  /**
   *   Version: 10.1.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  ### **Permissions Required**  Requires `DATAMANAGEMENT` (**Can manage data**) and `USERMANAGEMENT` (**Can manage users**) privileges.  #### **Usage Guidelines**  This API is only applicable for `USER`, `GROUP`, and `ROLES` metadata types.  - `batch_offset` Indicates the starting position within the complete dataset from which the API should begin returning objects. Useful for paginating results efficiently. - `batch_size` Specifies the number of objects or items to retrieve in a single request. Helps control response size for better performance. - `edoc_format` Defines the format of the TML content. The exported metadata can be in JSON or YAML format. - `export_dependent` Specifies whether to include dependent metadata objects in the export. Ensures related objects are also retrieved if needed. - `all_orgs_override` Indicates whether the export operation applies across all organizations. Useful for multi-tenant environments where cross-org exports are required.      
   * @param exportMetadataTMLBatchedRequest 
   */
  exportMetadataTMLBatched(exportMetadataTMLBatchedRequest, _options) {
    const requestContextPromise = this.requestFactory.exportMetadataTMLBatched(exportMetadataTMLBatchedRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.exportMetadataTMLBatched(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for an Answer object.  Requires at least view access to the Answer object.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {    \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",    \"metadata_name\":\"Total sales\",    \"metadata_type\":\"ANSWER\",    \"sql_queries\":[       {          \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",          \"metadata_name\":\"Total sales -test\",          \"sql_query\":\"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  \\\"ta_2\\\".\\\"PRODUCTNAME\\\" \\\"ca_2\\\", \\n  \\\"ta_1\\\".\\\"STORENAME\\\" \\\"ca_3\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_4\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_5\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_3\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_3\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_PRODUCTS\\\" \\\"ta_2\\\"\\n    ON \\\"ta_3\\\".\\\"PRODUCTID\\\" = \\\"ta_2\\\".\\\"PRODUCTID\\\"\\nGROUP BY \\n  \\\"ca_1\\\", \\n  \\\"ca_2\\\", \\n  \\\"ca_3\\\"\\n\"       }    ] } ```      
   * @param fetchAnswerSqlQueryRequest 
   */
  fetchAnswerSqlQuery(fetchAnswerSqlQueryRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchAnswerSqlQuery(fetchAnswerSqlQueryRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchAnswerSqlQuery(rsp)));
    }));
  }
  /**
   *   Version: 10.4.0.cl or later   Gets information about the status of the TML async import task scheduled using the `/api/rest/2.0/metadata/tml/async/import` API call.  To fetch the task details, specify the ID of the TML async import task.    Requires access to the task ID. The API allows users who initiated the asynchronous TML import via `/api/rest/2.0/metadata/tml/async/import` to view the status of their tasks.  Users with administration privilege can view the status of all import tasks initiated by the users in their Org.  #### Usage guidelines  See [TML API Documentation](https://developers.thoughtspot.com/docs/tml#_fetch_status_of_the_tml_import_task) for usage guidelines.     
   * @param fetchAsyncImportTaskStatusRequest 
   */
  fetchAsyncImportTaskStatus(fetchAsyncImportTaskStatusRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchAsyncImportTaskStatus(fetchAsyncImportTaskStatusRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchAsyncImportTaskStatus(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for a Liveboard object and its visualizations.  Requires at least view access to the Liveboard object.  To get SQL query data for a Liveboard, specify the GUID of the Liveboard. Optionally, you can add an array of visualization GUIDs to retrieve the SQL query data for visualizations in the Liveboard.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {   \"metadata_id\": \"fa68ae91-7588-4136-bacd-d71fb12dda69\",   \"metadata_name\": \"Total Sales\",   \"metadata_type\": \"LIVEBOARD\",   \"sql_queries\": [     {       \"metadata_id\": \"b3b6d2b9-089a-490c-8e16-b144650b7843\",       \"metadata_name\": \"Total quantity purchased, Total sales by region\",       \"sql_query\": \"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_2\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_3\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_2\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_2\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\nGROUP BY \\\"ca_1\\\"\"     }   ] } ```      
   * @param fetchLiveboardSqlQueryRequest 
   */
  fetchLiveboardSqlQuery(fetchLiveboardSqlQueryRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchLiveboardSqlQuery(fetchLiveboardSqlQueryRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchLiveboardSqlQuery(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Imports [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  *  Import all related objects in a single TML Import API call. For example, Tables that use the same Connection object and Worksheets connected to these Tables. * Include the `fqn` property to distinguish objects that have the same name.   For example, if you have multiple Connections or Worksheets with the same name on ThoughtSpot and the Connection or Worksheet referenced in your TML file does not have a unique name to distinguish, it may result in invalid object references.   Adding `fqn` helps ThoughtSpot differentiate a Table from another with the same name.   We recommend [exporting TML with FQNs](#/http/api-endpoints/metadata/export-metadata-tml) and using these during the import operation. * You can upload multiple TML files at a time.   If you import a Worksheet along with Liveboards, Answers, and other dependent objects in a single API call, the imported objects will be immediately available for use.   When you import only a Worksheet object, it may take some time for the Worksheet to become available in the ThoughtSpot system. Please wait for a few minutes, and then proceed to create an Answer and Liveboard from the newly imported Worksheet.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_import_a_tml).      
   * @param importMetadataTMLRequest 
   */
  importMetadataTML(importMetadataTMLRequest, _options) {
    const requestContextPromise = this.requestFactory.importMetadataTML(importMetadataTMLRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.importMetadataTML(rsp)));
    }));
  }
  /**
   *   Version: 10.4.0.cl or later   Schedules a task to import [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot. You can use this API endpoint to process TML objects asynchronously when importing TMLs of large and complex metadata objects into ThoughtSpot. Unlike the synchronous import TML operation, the API processes TML data in the background and returns a task ID, which can be used to check the status of the import task via `/api/rest/2.0/metadata/tml/async/status` API endpoint.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege, and edit access to the TML objects.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  See [Async TML API Documentation](https://developers.thoughtspot.com/docs/tml#_import_tml_objects_asynchronously) for usage guidelines.      
   * @param importMetadataTMLAsyncRequest 
   */
  importMetadataTMLAsync(importMetadataTMLAsyncRequest, _options) {
    const requestContextPromise = this.requestFactory.importMetadataTMLAsync(importMetadataTMLAsyncRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.importMetadataTMLAsync(rsp)));
    }));
  }
  /**
   *  Parameterize fields in metadata objects.   Version: 10.9.0.cl or later   Allows parameterizing fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows parameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be parameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param parameterizeMetadataRequest 
   */
  parameterizeMetadata(parameterizeMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.parameterizeMetadata(parameterizeMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.parameterizeMetadata(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of metadata objects available on the ThoughtSpot system.  This API endpoint is available to all users who have view access to the object. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view data for all metadata objects, including users and groups.  #### Usage guidelines  - To get all metadata objects, send the API request without any attributes. - To get metadata objects of a specific type, set the `type` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE`. - To filter metadata objects within type `LOGICAL_TABLE`, set the `subtypes` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE` & subtypes as `[WORKSHEET]`. - To get a specific metadata object, specify the GUID. - To customize your search and filter the API response, you can use several parameters.   You can search for objects created or modified by specific users, by tags applied to the objects, or by using the include parameters like `include_auto_created_objects`, `include_dependent_objects`, `include_headers`, `include_incomplete_objects`, and so on.   You can also define sorting options to sort the data retrieved in the API response. - To get discoverable objects when linientmodel is enabled you can use `include_discoverable_objects` as true else false. Default value is true. - For liveboard metadata type, to get the newer format, set the `liveboard_response_format` as V2. Default value is V1. - To retrieve only objects that are published, set the `include_only_published_objects` as true. Default value is false.  **NOTE**: The following parameters support pagination of metadata records:  - `tag_identifiers` - `type` - `subtypes` - `created_by_user_identifiers` - `modified_by_user_identifiers` - `owned_by_user_identifiers` - `exclude_objects` - `include_auto_created_objects` - `favorite_object_options` - `include_only_published_objects` If you are using other parameters to search metadata, set `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchMetadataRequest 
   */
  searchMetadata(searchMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.searchMetadata(searchMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchMetadata(rsp)));
    }));
  }
  /**
   *  Remove parameterization from fields in metadata objects.   Version: 10.9.0.cl or later   Allows removing parameterization from fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows unparameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be unparameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param unparameterizeMetadataRequest 
   */
  unparameterizeMetadata(unparameterizeMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.unparameterizeMetadata(unparameterizeMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.unparameterizeMetadata(rsp)));
    }));
  }
  /**
   *  Update header attributes for a given list of header objects.   Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **headers_update**      - **Description:** List of header objects with their attributes to be updated. Each object contains a list of attributes to be updated in the header.    - **Usage:**       - You must provide either `identifier` or `obj_identifier`, but not both. Both fields cannot be empty.       - When `org_identifier` is set to `-1`, only the `identifier` value is accepted; `obj_identifier` is not allowed.  2. **org_identifier**      - **Description:** GUID (Globally Unique Identifier) or name of the organization.      - **Usage:**      - Leaving this field empty assumes that the changes should be applied to the current organization       - Provide `org_guid` or `org_name` to uniquely identify the organization where changes need to be applied. .      - Provide `-1` if changes have to be applied across all the org.  ---  ## Note Currently, this API is enabled only for updating the `obj_identifier` attribute. Only `text` will be allowed in attribute\'s value.  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the update process  ---  ## Examples  ### Only `identifier` is given  ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"obj_identifier\": \"\",       \"type\": \"LOGICAL_COLUMN\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgGuid\" } ```  ### Only `obj_identifier` is given ```json {   \"headers_update\":   [     {       \"obj_identifier\": \"custom_object_id\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgName\" } ```  ### Executing update for all org `-1` ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```  ### Optional `type` is not provided ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```     
   * @param updateMetadataHeaderRequest 
   */
  updateMetadataHeader(updateMetadataHeaderRequest, _options) {
    const requestContextPromise = this.requestFactory.updateMetadataHeader(updateMetadataHeaderRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateMetadataHeader(rsp)));
    }));
  }
  /**
   *  Update object IDs for given metadata objects.   Version: 10.8.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **metadata**      - **Description:** List of metadata objects to update their object IDs.    - **Usage:**       - Use either `current_obj_id` alone OR use `metadata_identifier` with `type` (when needed).       - When using `metadata_identifier`, the `type` field is required if using a name instead of a GUID.       - The `new_obj_id` field is always required.  ---  ## Note This API is specifically designed for updating object IDs of metadata objects. It internally uses the header update mechanism to perform the changes.  ## Best Practices  1. **Backup Before Update:**      Always export metadata as a backup before initiating the update process.  2. **Validation:**    - When using `current_obj_id`, ensure it matches the existing object ID exactly.    - When using `metadata_identifier` with a name, ensure the `type` is specified correctly.    - Verify that the `new_obj_id` follows your naming conventions and is unique within your system.  ---  ## Examples  ### Using current_obj_id ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with GUID ```json {   \"metadata\": [     {       \"metadata_identifier\": \"01234567-89ab-cdef-0123-456789abcdef\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with name and type ```json {   \"metadata\": [     {       \"metadata_identifier\": \"My Answer\",       \"type\": \"ANSWER\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Multiple objects update ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id_1\",       \"new_obj_id\": \"new_object_id_1\"     },     {       \"metadata_identifier\": \"My Worksheet\",       \"type\": \"LOGICAL_TABLE\",       \"new_obj_id\": \"new_object_id_2\"     }   ] } ```      
   * @param updateMetadataObjIdRequest 
   */
  updateMetadataObjId(updateMetadataObjIdRequest, _options) {
    const requestContextPromise = this.requestFactory.updateMetadataObjId(updateMetadataObjIdRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateMetadataObjId(rsp)));
    }));
  }
};
var ObservableOrgsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new OrgsApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new OrgsApiResponseProcessor();
  }
  /**
   *   Version: 9.0.0.cl or later   Creates an Org object.  To use this API, the [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview) feature must be enabled in your cluster.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param createOrgRequest 
   */
  createOrg(createOrgRequest, _options) {
    const requestContextPromise = this.requestFactory.createOrg(createOrgRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createOrg(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes an Org object from the ThoughtSpot system.  Requires cluster administration (**Can administer Org**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.  When you delete an Org, all its users and objects created in that Org context are removed. However, if the users in the deleted Org also exists in other Orgs, they are removed only from the deleted Org.      
   * @param orgIdentifier ID or name of the Org
   */
  deleteOrg(orgIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteOrg(orgIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteOrg(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of Orgs configured on the ThoughtSpot system. To get details of a specific Org, specify the Org ID or name. You can also pass parameters such as status, visibility, and user identifiers to get a specific list of Orgs.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param searchOrgsRequest 
   */
  searchOrgs(searchOrgsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchOrgs(searchOrgsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchOrgs(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Updates an Org object. You can modify Org properties such as name, description, and user associations.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param orgIdentifier ID or name of the Org
   * @param updateOrgRequest 
   */
  updateOrg(orgIdentifier, updateOrgRequest, _options) {
    const requestContextPromise = this.requestFactory.updateOrg(orgIdentifier, updateOrgRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateOrg(rsp)));
    }));
  }
};
var ObservableReportsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new ReportsApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new ReportsApiResponseProcessor();
  }
  /**
   *   Version: 9.0.0.cl or later   Exports an Answer in the given file format. You can download the Answer data as a PDF, PNG, CSV, or XLSX file.  Requires at least view access to the Answer.  #### Usage guidelines  In the request body, the GUID or name of the Answer and set `file_format`. The default file format is CSV.  **NOTE**: * The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension. * HTML rendering is not supported for PDF exports of Answers with tables.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.       
   * @param exportAnswerReportRequest 
   */
  exportAnswerReport(exportAnswerReportRequest, _options) {
    const requestContextPromise = this.requestFactory.exportAnswerReport(exportAnswerReportRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.exportAnswerReport(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Exports a Liveboard and its visualizations in PDF, PNG, CSV, or XLSX file format.  Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To generate a Liveboard report with specific visualizations, add GUIDs or names of the visualizations.  The default `file_format` is CSV. For PDF exports, you can specify additional parameters to customize the page orientation and include or exclude the cover page, logo, footer text, and page numbers. Similar customization options are available for PNG exports. CSV and XLSX exports do not support customization options.  **NOTE**: The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes, including ad hoc changes to visualizations. For more information, see [Liveboard Report API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_liveboard_report_api).    **NOTE**: Starting with ThoughtSpot Cloud 10.9.0.cl release, the Liveboard can be exported in the PNG format in the resolution of your choice. To enable this on your instance, contact ThoughtSpot support. When this feature is enabled, the options `include_cover_page`,`include_filter_page` within the `png_options` will not be available for PNG exports.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in CSV format. All visualizations in the Liveboard can be exported as individual CSV files. If multiple visualizations are selected or if the entire Liveboard is exported, the output is returned as a .zip file containing the CSV files for each visualization.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in XLSX format. All selected visualizations are consolidated into a single Excel workbook (.xlsx), with each visualization placed in its own worksheet (tab). XLSX exports are limited to 255 worksheets (tabs) per workbook.      
   * @param exportLiveboardReportRequest 
   */
  exportLiveboardReport(exportLiveboardReportRequest, _options) {
    const requestContextPromise = this.requestFactory.exportLiveboardReport(exportLiveboardReportRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.exportLiveboardReport(rsp)));
    }));
  }
};
var ObservableRolesApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new RolesApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new RolesApiResponseProcessor();
  }
  /**
   *   Version: 9.5.0.cl or later   Creates a Role object in ThoughtSpot.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To create a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param createRoleRequest 
   */
  createRole(createRoleRequest, _options) {
    const requestContextPromise = this.requestFactory.createRole(createRoleRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createRole(rsp)));
    }));
  }
  /**
   *   Version: 9.5.0.cl or later   Deletes a Role object from the ThoughtSpot system.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To delete a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role. ReadOnly roles cannot be deleted.
   */
  deleteRole(roleIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteRole(roleIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteRole(rsp)));
    }));
  }
  /**
   *   Version: 9.5.0.cl or later   Gets a list of Role objects from the ThoughtSpot system.  Available if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To search for Roles, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.  To get details of a specific Role object, specify the GUID or name. You can also filter the API response based on user group and Org identifiers, privileges assigned to the Role, and deprecation status.      
   * @param searchRolesRequest 
   */
  searchRoles(searchRolesRequest, _options) {
    const requestContextPromise = this.requestFactory.searchRoles(searchRolesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchRoles(rsp)));
    }));
  }
  /**
   *   Version: 9.5.0.cl or later   Updates the properties of a Role object.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To update a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role.
   * @param updateRoleRequest 
   */
  updateRole(roleIdentifier, updateRoleRequest, _options) {
    const requestContextPromise = this.requestFactory.updateRole(roleIdentifier, updateRoleRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateRole(rsp)));
    }));
  }
};
var ObservableSchedulesApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new SchedulesApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new SchedulesApiResponseProcessor();
  }
  /**
   *  Create schedule.    Version: 9.4.0.cl or later   Creates a Liveboard schedule job.  Requires at least edit access to Liveboards. To create a schedule on behalf of another user, you need  `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  #### Usage guidelines  * The description text is mandatory.  The description text appears as **Description: <your content>** in the Liveboard schedule email notifications. * For Liveboards with both charts and tables, schedule creation is only supported in PDF and XLS formats. Schedules created in CSV formats for such Liveboards will fail to run. If `PDF` is set as the `file_format`, enable `pdf_options` to get the correct attachment. Not doing so may cause the attachment to be rendered empty. * To include only specific visualizations, specify the visualization GUIDs in the `visualization_identifiers` array. * You can schedule a Liveboard job to run periodically by setting frequency parameters. You can set the schedule to run daily, weekly, monthly or every n minutes or hours. The scheduled job can also be configured to run at a specific time of the day or on specific days of the week or month. Please ensure that when setting the schedule frequency for _minute of the object_, only values that are multiples of 5 are included. * If the `frequency` parameters are defined, you can set the time zone to a value that matches your server\'s time zone. For example, `US/Central`, `Etc/UTC`, `CET`. The default time zone is `America/Los_Angeles`.  For more information about Liveboard jobs, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/liveboard-schedule).     
   * @param createScheduleRequest 
   */
  createSchedule(createScheduleRequest, _options) {
    const requestContextPromise = this.requestFactory.createSchedule(createScheduleRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createSchedule(rsp)));
    }));
  }
  /**
   *  Deletes a scheduled job.    Version: 9.4.0.cl or later   Deletes a scheduled Liveboard job.  Requires at least edit access to Liveboard or `ADMINISTRATION` (**Can administer Org**) privilege.    If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.      
   * @param scheduleIdentifier Unique ID or name of the scheduled job.
   */
  deleteSchedule(scheduleIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteSchedule(scheduleIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteSchedule(rsp)));
    }));
  }
  /**
   *  Search Schedules    Version: 9.4.0.cl or later   Gets a list of scheduled jobs configured for a Liveboard.  To get details of a specific scheduled job, specify the name or GUID of the scheduled job.  Requires at least view access to Liveboards.  **NOTE**: When filtering schedules by parameters other than `metadata`, set `record_size` to `-1` and `record_offset` to `0` for accurate results.      
   * @param searchSchedulesRequest 
   */
  searchSchedules(searchSchedulesRequest, _options) {
    const requestContextPromise = this.requestFactory.searchSchedules(searchSchedulesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchSchedules(rsp)));
    }));
  }
  /**
   *  Update schedule.    Version: 9.4.0.cl or later   Updates a scheduled Liveboard job.  Requires at least edit access to Liveboards. To update a schedule on behalf of another user, you need `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  The API endpoint allows you to pause a scheduled job, change the status of a paused job. You can also edit the recipients list, frequency of the job, format of the file to send to the recipients in email notifications, PDF options, and time zone setting.      
   * @param scheduleIdentifier Unique ID or name of the schedule.
   * @param updateScheduleRequest 
   */
  updateSchedule(scheduleIdentifier, updateScheduleRequest, _options) {
    const requestContextPromise = this.requestFactory.updateSchedule(scheduleIdentifier, updateScheduleRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateSchedule(rsp)));
    }));
  }
};
var ObservableSecurityApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new SecurityApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new SecurityApiResponseProcessor();
  }
  /**
   *   Version: 9.0.0.cl or later   Transfers the ownership of one or several objects from one user to another.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege and edit access to the objects are required.      
   * @param assignChangeAuthorRequest 
   */
  assignChangeAuthor(assignChangeAuthorRequest, _options) {
    const requestContextPromise = this.requestFactory.assignChangeAuthor(assignChangeAuthorRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.assignChangeAuthor(rsp)));
    }));
  }
  /**
   *  Version: 10.12.0.cl or later   Fetches column security rules for specified tables.  This API endpoint retrieves column-level security rules configured for tables. It returns information about which columns are secured and which groups have access to those columns.  #### Usage guidelines  - Provide an array of table identifiers using either `identifier` (GUID or name) or `obj_identifier` (object ID) - At least one of `identifier` or `obj_identifier` must be provided for each table - The API returns column security rules for all specified tables - Users must have appropriate permissions to access security rules for the specified tables  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables  #### Example request  ```json {   \"tables\": [     {       \"identifier\": \"table-guid\",       \"obj_identifier\": \"table-object-id\"     }   ] } ```  #### Response format  The API returns an array of `ColumnSecurityRuleResponse` objects wrapped in a `data` field. Each `ColumnSecurityRuleResponse` object contains: - Table information (GUID and object ID)   - Array of column security rules with column details, group access, and source table information  #### Example response  ```json {   \"data\": [     {       \"guid\": \"table-guid\",       \"objId\": \"table-object-id\",       \"columnSecurityRules\": [         {           \"column\": {             \"id\": \"col_123\",             \"name\": \"Salary\"           },           \"groups\": [             {               \"id\": \"group_1\",               \"name\": \"HR Department\"             }           ],           \"sourceTableDetails\": {             \"id\": \"source-table-guid\",             \"name\": \"Employee_Data\"           }         }       ]     }   ] } ```     
   * @param fetchColumnSecurityRulesRequest 
   */
  fetchColumnSecurityRules(fetchColumnSecurityRulesRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchColumnSecurityRules(fetchColumnSecurityRulesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchColumnSecurityRules(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches object permission details for a given principal object such as a user and group.  Requires view access to the metadata object.   #### Usage guidelines  * To get a list of all metadata objects that a user or group can access, specify the `type` and GUID or name of the principal. * To get permission details for a specific object, add the `type` and GUID or name of the metadata object to your API request.  Upon successful execution, the API returns a list of metadata objects and permission details for each object.        
   * @param fetchPermissionsOfPrincipalsRequest 
   */
  fetchPermissionsOfPrincipals(fetchPermissionsOfPrincipalsRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchPermissionsOfPrincipals(fetchPermissionsOfPrincipalsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchPermissionsOfPrincipals(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches permission details for a given metadata object.  Requires view access to the metadata object.  #### Usage guidelines  * To fetch a list of users and groups for a metadata object, specify `type` and GUID or name of the metadata object. * To get permission details for a specific user or group, add `type` and GUID or name of the principal object to your API request.  Upon successful execution, the API returns permission details and principal information for the object specified in the API request.      
   * @param fetchPermissionsOnMetadataRequest 
   */
  fetchPermissionsOnMetadata(fetchPermissionsOnMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchPermissionsOnMetadata(fetchPermissionsOnMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchPermissionsOnMetadata(rsp)));
    }));
  }
  /**
   *  Version: 10.9.0.cl or later   Allows publishing metadata objects across organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows publishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  This API will essentially share the objects along with it\'s dependencies to the org admins of the orgs to which it is being published.      
   * @param publishMetadataRequest 
   */
  publishMetadata(publishMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.publishMetadata(publishMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.publishMetadata(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Allows sharing one or several metadata objects with users and groups in ThoughtSpot.  Requires edit access to the metadata object.  The API endpoint allows sharing only the following types of metadata objects: * Liveboards * Visualizations * Answers * Worksheets * Views * Connections  You can provide `READ_ONLY` or `MODIFY` access when sharing an object with another user or group. With `READ_ONLY` access grants view access to the shared object, whereas `MODIFY` provides edit access.  To prevent a user or group from accessing the shared object, specify the GUID or name of the principal and set `shareMode` to `NO_ACCESS`.      
   * @param shareMetadataRequest 
   */
  shareMetadata(shareMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.shareMetadata(shareMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.shareMetadata(rsp)));
    }));
  }
  /**
   *  Version: 10.9.0.cl or later   Allows unpublishing metadata objects from organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows unpublishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  When unpublishing objects, you can: * Include dependencies by setting `include_dependencies` to true - this will unpublish all dependent objects if no other published object is using them * Force unpublish by setting `force` to true - this will break all dependent objects in the unpublished organizations      
   * @param unpublishMetadataRequest 
   */
  unpublishMetadata(unpublishMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.unpublishMetadata(unpublishMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.unpublishMetadata(rsp)));
    }));
  }
  /**
   *  Version: 10.12.0.cl or later   Creates, updates, or deletes column security rules for specified tables.  This API endpoint allows you to create, update, or delete column-level security rules on columns of a table. The operation follows an \"all or none\" policy: if defining security rules for any of the provided columns fails, the entire operation will be rolled back, and no rules will be created.  #### Usage guidelines  - Provide table identifier using either `identifier` (GUID or name) or `obj_identifier` (object ID) - Use `clear_csr: true` to remove all column security rules from the table - For each column, specify the security rule using `column_security_rules` array - Use `is_unsecured: true` to mark a specific column as unprotected - Use `group_access` operations to manage group associations:   - `ADD`: Add groups to the column\'s access list   - `REMOVE`: Remove groups from the column\'s access list   - `REPLACE`: Replace all existing groups with the specified groups  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data (if RBAC is disabled) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables (if RBAC is enabled)  #### Example request  ```json {   \"identifier\": \"table-guid\",   \"obj_identifier\": \"table-object-id\",   \"clear_csr\": false,   \"column_security_rules\": [     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"ADD\",           \"group_identifiers\": [\"hr_group_id\", \"hr_group_name\", \"finance_group_id\"]         }       ]     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": true     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"REPLACE\",           \"group_identifiers\": [\"management_group_id\", \"management_group_name\"]         }       ]     }   ] } ```  #### Request Body Schema  - `identifier` (string, optional): GUID or name of the table for which we want to create column security rules - `obj_identifier` (string, optional): The object ID of the table - `clear_csr` (boolean, optional): If true, then all the secured columns will be marked as unprotected, and all the group associations will be removed - `column_security_rules` (array of objects, required): An array where each object defines the security rule for a specific column  Each column security rule object contains: - `column_identifier` (string, required): Column identifier (col_id or name) - `is_unsecured` (boolean, optional): If true, the column will be marked as unprotected and all groups associated with it will be removed - `group_access` (array of objects, optional): Array of group operation objects  Each group operation object contains: - `operation` (string, required): Operation type - ADD, REMOVE, or REPLACE - `group_identifiers` (array of strings, required): Array of group identifiers (name or GUID) on which the operation will be performed  #### Response  This API does not return any response body. A successful operation returns HTTP 200 status code.  #### Operation Types  - **ADD**: Adds the specified groups to the column\'s access list - **REMOVE**: Removes the specified groups from the column\'s access list   - **REPLACE**: Replaces all existing groups with the specified groups      
   * @param updateColumnSecurityRulesRequest 
   */
  updateColumnSecurityRules(updateColumnSecurityRulesRequest, _options) {
    const requestContextPromise = this.requestFactory.updateColumnSecurityRules(updateColumnSecurityRulesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateColumnSecurityRules(rsp)));
    }));
  }
};
var ObservableSystemApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new SystemApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new SystemApiResponseProcessor();
  }
  /**
   *  Version: 10.14.0.cl or later   Configure communication channel preferences. - Use `cluster_preferences` to update the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to specify Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param configureCommunicationChannelPreferencesRequest 
   */
  configureCommunicationChannelPreferences(configureCommunicationChannelPreferencesRequest, _options) {
    const requestContextPromise = this.requestFactory.configureCommunicationChannelPreferences(configureCommunicationChannelPreferencesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.configureCommunicationChannelPreferences(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves the current configuration details of the cluster. If the request is successful, the API returns a list configuration settings applied on the cluster.  Requires `ADMINISTRATION`(**Can administer ThoughtSpot**) privilege to view these complete configuration settings of the cluster. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.      
   */
  getSystemConfig(_options) {
    const requestContextPromise = this.requestFactory.getSystemConfig(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getSystemConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets system information such as the release version, locale, time zone, deployment environment, date format, and date time format of the cluster.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemInformation(_options) {
    const requestContextPromise = this.requestFactory.getSystemInformation(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getSystemInformation(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of configuration overrides applied on the cluster.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemOverrideInfo(_options) {
    const requestContextPromise = this.requestFactory.getSystemOverrideInfo(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getSystemOverrideInfo(rsp)));
    }));
  }
  /**
   *  Version: 10.14.0.cl or later   Fetch communication channel preferences. - Use `cluster_preferences` to fetch the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to fetch any Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param searchCommunicationChannelPreferencesRequest 
   */
  searchCommunicationChannelPreferences(searchCommunicationChannelPreferencesRequest, _options) {
    const requestContextPromise = this.requestFactory.searchCommunicationChannelPreferences(searchCommunicationChannelPreferencesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchCommunicationChannelPreferences(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Updates the current configuration of the cluster. You must send the configuration data in JSON format.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.      
   * @param updateSystemConfigRequest 
   */
  updateSystemConfig(updateSystemConfigRequest, _options) {
    const requestContextPromise = this.requestFactory.updateSystemConfig(updateSystemConfigRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateSystemConfig(rsp)));
    }));
  }
};
var ObservableTagsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new TagsApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new TagsApiResponseProcessor();
  }
  /**
   *   Version: 9.0.0.cl or later   Assigns tags to Liveboards, Answers, Tables, and Worksheets.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  assignTag(assignTagRequest, _options) {
    const requestContextPromise = this.requestFactory.assignTag(assignTagRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.assignTag(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a tag object.  Tags are labels that identify a metadata object. For example, you can create a tag to designate subject areas, such as sales, HR, marketing, and finance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param createTagRequest 
   */
  createTag(createTagRequest, _options) {
    const requestContextPromise = this.requestFactory.createTag(createTagRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createTag(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a tag object from the ThoughtSpot system  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Tag identifier Tag name or Tag id.
   */
  deleteTag(tagIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteTag(tagIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteTag(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of tag objects available on the ThoughtSpot system. To get details of a specific tag object, specify the GUID or name.  Any authenticated user can search for tag objects.      
   * @param searchTagsRequest 
   */
  searchTags(searchTagsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchTags(searchTagsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchTags(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the tags applied to a Liveboard, Answer, Table, or Worksheet.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  unassignTag(assignTagRequest, _options) {
    const requestContextPromise = this.requestFactory.unassignTag(assignTagRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.unassignTag(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Updates a tag object.  You can modify the `name` and `color` properties of a tag object.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Name or Id of the tag.
   * @param updateTagRequest 
   */
  updateTag(tagIdentifier, updateTagRequest, _options) {
    const requestContextPromise = this.requestFactory.updateTag(tagIdentifier, updateTagRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateTag(rsp)));
    }));
  }
};
var ObservableThoughtSpotRestApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new ThoughtSpotRestApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new ThoughtSpotRestApiResponseProcessor();
  }
  /**
   *   Version: 9.7.0.cl or later   Activates a deactivated user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To activate an inactive user account, the API request body must include the following information:  - Username or the GUID of the user account. - Auth token generated for the deactivated user. The auth token is sent in the API response when a user is deactivated. - Password for the user account.      
   * @param activateUserRequest 
   */
  activateUser(activateUserRequest, _options) {
    const requestContextPromise = this.requestFactory.activateUser(activateUserRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.activateUser(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Transfers the ownership of one or several objects from one user to another.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege and edit access to the objects are required.      
   * @param assignChangeAuthorRequest 
   */
  assignChangeAuthor(assignChangeAuthorRequest, _options) {
    const requestContextPromise = this.requestFactory.assignChangeAuthor(assignChangeAuthorRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.assignChangeAuthor(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Assigns tags to Liveboards, Answers, Tables, and Worksheets.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  assignTag(assignTagRequest, _options) {
    const requestContextPromise = this.requestFactory.assignTag(assignTagRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.assignTag(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the current password of the user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param changeUserPasswordRequest 
   */
  changeUserPassword(changeUserPasswordRequest, _options) {
    const requestContextPromise = this.requestFactory.changeUserPassword(changeUserPasswordRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.changeUserPassword(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Commits TML files of metadata objects to the Git branch configured on your instance.  Requires at least edit access to objects used in the commit operation.  Before using this endpoint to push your commits:  * Enable Git integration on your instance. * Make sure the Git repository and branch details are configured on your instance.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitBranchRequest 
   */
  commitBranch(commitBranchRequest, _options) {
    const requestContextPromise = this.requestFactory.commitBranch(commitBranchRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.commitBranch(rsp)));
    }));
  }
  /**
   *  Version: 10.14.0.cl or later   Configure communication channel preferences. - Use `cluster_preferences` to update the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to specify Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param configureCommunicationChannelPreferencesRequest 
   */
  configureCommunicationChannelPreferences(configureCommunicationChannelPreferencesRequest, _options) {
    const requestContextPromise = this.requestFactory.configureCommunicationChannelPreferences(configureCommunicationChannelPreferencesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.configureCommunicationChannelPreferences(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Gets connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines * To get a list of all configurations available in the ThoughtSpot system, send the API request with only the connection name or GUID in the request body. * To fetch details of a configuration object, specify the configuration object name or GUID.      
   * @param connectionConfigurationSearchRequest 
   */
  connectionConfigurationSearch(connectionConfigurationSearchRequest, _options) {
    const requestContextPromise = this.requestFactory.connectionConfigurationSearch(connectionConfigurationSearchRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.connectionConfigurationSearch(rsp)));
    }));
  }
  /**
   *  Convert worksheets to models    Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (Can manage data models).  ---  ## Usage Guidelines  ### Parameters  1. **worksheet_ids**      - **Description:** A comma-separated list of GUIDs (Globally Unique Identifiers) specifying the Worksheets to be converted.      - **Usage:**        - Used only when `convert_all` is set to `false`.        - Leave empty or omit when `convert_all` is set to `true`.  2. **exclude_worksheet_ids**      - **Description:** A comma-separated list of GUIDs specifying Worksheets to be excluded from conversion.      - **Usage:**        - Useful when `convert_all` is set to `true` and specific Worksheets should not be converted.  3. **convert_all**      - **Description:** Sets the scope of conversion.    - **Options:**        - `true`: Converts all Worksheets in the system, except those specified in `exclude_worksheet_ids`.        - `false`: Converts only the Worksheets listed in `worksheet_ids`.  4. **apply_changes**      - **Description:** Specifies whether to apply changes directly to ThoughtSpot or to generate a preview before applying any changes.Used for validation of conversion.    - **Options:**        - `true`: Applies conversion changes directly to ThoughtSpot.      - `false`: Generates only a preview of the changes and does not apply any changes to ThoughtSpot  ---  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the conversion process  2. **Partial Conversion for Testing:**      Test the conversion process by setting `convert_all` to `false` and specifying a small number of `worksheet_ids`.  3. **Verify Dependencies:**      Check for dependent objects, such as Tables and Connections, to avoid invalid references.  4. **Review Changes:**      Use `apply_changes: false` to preview the impact of the conversion before applying changes.  ---  ## Examples  ### Convert Specific Worksheets ```json {   \"worksheet_ids\": [\"guid1\", \"guid2\", \"guid3\"],   \"exclude_worksheet_ids\": [],   \"convert_all\": false,   \"apply_changes\": true } ```  ### Convert All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [],   \"convert_all\": true,   \"apply_changes\": true } ```  ### Exclude Specific Worksheets While Converting All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [\"abc\"],   \"convert_all\": true,   \"apply_changes\": true } ```     
   * @param convertWorksheetToModelRequest 
   */
  convertWorksheetToModel(convertWorksheetToModelRequest, _options) {
    const requestContextPromise = this.requestFactory.convertWorksheetToModel(convertWorksheetToModelRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.convertWorksheetToModel(rsp)));
    }));
  }
  /**
   *  Makes a copy of an Answer or Liveboard    Version: 10.3.0.cl or later   Creates a copy of a metadata object.  Requires at least view access to the metadata object being copied.  Upon successful execution, the API creates a copy of the metadata object specified in the API request and returns the ID of the new object.      
   * @param copyObjectRequest 
   */
  copyObject(copyObjectRequest, _options) {
    const requestContextPromise = this.requestFactory.copyObject(copyObjectRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.copyObject(rsp)));
    }));
  }
  /**
   * Version: 10.13.0.cl or later 
   * @param createAgentConversationRequest 
   */
  createAgentConversation(createAgentConversationRequest, _options) {
    const requestContextPromise = this.requestFactory.createAgentConversation(createAgentConversationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createAgentConversation(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Creates a new [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.   #### Usage guidelines  You can create a custom calendar from scratch or an existing Table in ThoughtSpot. For both methods of calendar creation, the following parameters are required:  * Name of the custom calendar. * Calendar creation method. To create a calendar from an existing table, specify the method:   - `FROM_EXISTING_TABLE` - Creates calendar from the table reference provided in the API request.  - `FROM_INPUT_PARAMS` - Creates a calendar from the parameters defined in the API request.  * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  **NOTE**: If you are creating a calendar from an existing table, ensure that the referenced table matches the required DDL for custom calendars. If the schema does not match, the API returns an error.  ##### Calendar type The API allows you to create the following types of calendars:  * `MONTH_OFFSET`. The default calendar type. A `MONTH_OFFSET` calendar is offset by a few months from the standard calendar months (January to December) and the year begins with the month defined in the request. For example, if the `month_offset` value is set as `April`, the calendar year begins in April.  * `4-4-5`. Each quarter in the calendar will include two 4-week months followed by one 5-week month. * `4-5-4`. Each quarter in the calendar will include two 4-week months with a 5-week month between. * `5-4-4`. Each quarter begins with a 5-week month, followed by two 4-week months.  To start and end the calendar on a specific date, specify the dates in the `MM/DD/YYYY` format. For `MONTH_OFFSET` calendars, ensure that the `start_date` matches the month specified in the `month_offset` attribute.  You can also set the starting day of the week and customize the prefixes for year and quarter labels.  #### Examples  To create a calendar from an existing table:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_EXISTING_TABLE\", } ```  To create a calendar from scratch:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_INPUT_PARAMS\",   \"calendar_type\": \"MONTH_OFFSET\",   \"month_offset\": \"April\",   \"start_day_of_week\": \"Monday\",   \"quarter_name_prefix\": \"Q\",   \"year_name_prefix\": \"FY\",   \"start_date\": \"04/01/2025\",   \"end_date\": \"04/31/2025\" } ```      
   * @param createCalendarRequest 
   */
  createCalendar(createCalendarRequest, _options) {
    const requestContextPromise = this.requestFactory.createCalendar(createCalendarRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createCalendar(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to connect a ThoughtSpot instance to a Git repository.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.  You can use this API endpoint to connect your ThoughtSpot development and production environments to the development and production branches of a Git repository.  Before using this endpoint to connect your ThoughtSpot instance to a Git repository, check the following prerequisites:  * You have a Git repository. If you are using GitHub, make sure you have a valid account and an access token to connect ThoughtSpot to GitHub. For information about generating a token, see [GitHub Documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).  * Your access token has `repo` scope that grants full access to public and private repositories. * Your Git repository has a branch that can be configured as a default branch in ThoughtSpot.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/?pageid=git-integration).  **Note**: ThoughtSpot supports only GitHub / itHub Enterprise for CI/CD.      
   * @param createConfigRequest 
   */
  createConfig(createConfigRequest, _options) {
    const requestContextPromise = this.requestFactory.createConfig(createConfigRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Creates a connection to a data warehouse for live query services.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Create a connection without tables  To create a connection without tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a SnowFlake connection:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[       ]   }   ``` 2. Set `validate` to `false`.  #### Create a connection with tables  To create a connection with tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[         {            \"name\":\"AllDatatypes\",            \"isAutoCreated\":false,            \"schemas\":[               {                  \"name\":\"alldatatypes\",                  \"tables\":[                     {                        \"name\":\"allDatatypes\",                        \"type\":\"TABLE\",                        \"description\":\"\",                        \"selected\":true,                        \"linked\":true,                        \"columns\":[                           {                              \"name\":\"CNUMBER\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           },                           {                              \"name\":\"CDECIMAL\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           }                        ]                     }                  ]               }            ]         }      ]   }   ``` 2. Set `validate` to `true`.      
   * @param createConnectionRequest 
   */
  createConnection(createConnectionRequest, _options) {
    const requestContextPromise = this.requestFactory.createConnection(createConnectionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createConnection(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Creates an additional configuration to an existing connection to a data warehouse.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines   * A JSON map of configuration attributes in `configuration`. The following example shows the configuration attributes:   ```    {      \"user\":\"DEV_USER\",      \"password\":\"TestConn123\",      \"role\":\"DEV\",      \"warehouse\":\"DEV_WH\"     }   ```  * If the `policy_type` is `PRINCIPALS`, then `policy_principals` is a required field. * If the `policy_type` is `PROCESSES`, then `policy_processes` is a required field. * If the `policy_type` is `NO_POLICY`, then `policy_principals` and `policy_processes` are not required fields.  #### Parameterized Connection Support For parameterized connections that use OAuth authentication, only the same_as_parent and policy_process_options  attributes are allowed in the API request. These attributes are not applicable to connections that are not parameterized.       
   * @param createConnectionConfigurationRequest 
   */
  createConnectionConfiguration(createConnectionConfigurationRequest, _options) {
    const requestContextPromise = this.requestFactory.createConnectionConfiguration(createConnectionConfigurationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createConnectionConfiguration(rsp)));
    }));
  }
  /**
   *  Version: 10.4.0.cl or later   Creates a Conversation object to start an AI-driven conversation based on a specific data model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  This API requires the `metadata_identifier` parameter to define the context for the conversation.  You can also specify the tokens to initiate the conversation as shown in this example:  `\"tokens\": \"[tea],[sales],[type]\"`  If the API request is successful, ThoughtSpot returns the ID of the conversation.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param createConversationRequest 
   */
  createConversation(createConversationRequest, _options) {
    const requestContextPromise = this.requestFactory.createConversation(createConversationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createConversation(rsp)));
    }));
  }
  /**
   *   Version: 9.6.0.cl or later   Creates a custom action that appears as a menu action on a saved Answer or Liveboard visualization.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API lets you create the following types of custom actions:  * URL-based action        Allows pushing data to an external URL. * Callback action           Triggers a callback to the host application and initiates a response payload on an embedded ThoughtSpot instance.  By default, custom actions are visible to only administrator or developer users. To make a custom action available to other users, and specify the groups in `group_identifiers`.  By default, the custom action is set as a _global_ action on all visualizations and saved Answers. To assign a custom action to specific Liveboard visualization, saved Answer, or Worksheet, set `visibility` to `false` in `default_action_config` property and specify the GUID or name of the object in `associate_metadata`.  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param createCustomActionRequest 
   */
  createCustomAction(createCustomActionRequest, _options) {
    const requestContextPromise = this.requestFactory.createCustomAction(createCustomActionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createCustomAction(rsp)));
    }));
  }
  /**
   *  Version: 10.10.0.cl or later   Creates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To create a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param createEmailCustomizationRequest 
   */
  createEmailCustomization(createEmailCustomizationRequest, _options) {
    const requestContextPromise = this.requestFactory.createEmailCustomization(createEmailCustomizationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createEmailCustomization(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Creates an Org object.  To use this API, the [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview) feature must be enabled in your cluster.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param createOrgRequest 
   */
  createOrg(createOrgRequest, _options) {
    const requestContextPromise = this.requestFactory.createOrg(createOrgRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createOrg(rsp)));
    }));
  }
  /**
   *   Version: 9.5.0.cl or later   Creates a Role object in ThoughtSpot.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To create a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param createRoleRequest 
   */
  createRole(createRoleRequest, _options) {
    const requestContextPromise = this.requestFactory.createRole(createRoleRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createRole(rsp)));
    }));
  }
  /**
   *  Create schedule.    Version: 9.4.0.cl or later   Creates a Liveboard schedule job.  Requires at least edit access to Liveboards. To create a schedule on behalf of another user, you need  `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  #### Usage guidelines  * The description text is mandatory.  The description text appears as **Description: <your content>** in the Liveboard schedule email notifications. * For Liveboards with both charts and tables, schedule creation is only supported in PDF and XLS formats. Schedules created in CSV formats for such Liveboards will fail to run. If `PDF` is set as the `file_format`, enable `pdf_options` to get the correct attachment. Not doing so may cause the attachment to be rendered empty. * To include only specific visualizations, specify the visualization GUIDs in the `visualization_identifiers` array. * You can schedule a Liveboard job to run periodically by setting frequency parameters. You can set the schedule to run daily, weekly, monthly or every n minutes or hours. The scheduled job can also be configured to run at a specific time of the day or on specific days of the week or month. Please ensure that when setting the schedule frequency for _minute of the object_, only values that are multiples of 5 are included. * If the `frequency` parameters are defined, you can set the time zone to a value that matches your server\'s time zone. For example, `US/Central`, `Etc/UTC`, `CET`. The default time zone is `America/Los_Angeles`.  For more information about Liveboard jobs, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/liveboard-schedule).     
   * @param createScheduleRequest 
   */
  createSchedule(createScheduleRequest, _options) {
    const requestContextPromise = this.requestFactory.createSchedule(createScheduleRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createSchedule(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a tag object.  Tags are labels that identify a metadata object. For example, you can create a tag to designate subject areas, such as sales, HR, marketing, and finance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param createTagRequest 
   */
  createTag(createTagRequest, _options) {
    const requestContextPromise = this.requestFactory.createTag(createTagRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createTag(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a user in ThoughtSpot.  The API endpoint allows you to configure several user properties such as email address, account status, share notification preferences, and sharing visibility. You can provision the user to [groups](https://docs.thoughtspot.com/cloud/latest/groups-privileges) and [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview). You can also add Liveboard, Answer, and Worksheet objects to the users favorites list, assign a default Liveboard for the user, and set user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param createUserRequest 
   */
  createUser(createUserRequest, _options) {
    const requestContextPromise = this.requestFactory.createUser(createUserRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createUser(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### About groups Groups in ThoughtSpot are used by the administrators to define privileges and organize users based on their roles and access requirements. To know more about groups and privileges, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/groups-privileges).  #### Supported operations  The API endpoint lets you perform the following operations:  * Assign privileges * Add users * Define sharing visibility * Add sub-groups * Assign a default Liveboard      
   * @param createUserGroupRequest 
   */
  createUserGroup(createUserGroupRequest, _options) {
    const requestContextPromise = this.requestFactory.createUserGroup(createUserGroupRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createUserGroup(rsp)));
    }));
  }
  /**
   *  Create a variable which can be used for parameterizing metadata objects   Version: 10.14.0.cl or later   Allows creating a variable which can be used for parameterizing metadata objects in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports the following types of variables: * CONNECTION_PROPERTY - For connection properties * TABLE_MAPPING - For table mappings * CONNECTION_PROPERTY_PER_PRINCIPAL - For connection properties per principal. In order to use this please contact support to enable this. * FORMULA_VARIABLE - For Formula variables, introduced in 10.15.0.cl  When creating a variable, you need to specify: * The variable type * A unique name for the variable * Whether the variable contains sensitive values (defaults to false) * The data type of the variable, only specify for formula variables (defaults to null)  The operation will fail if: * The user lacks required permissions * The variable name already exists * The variable type is invalid     
   * @param createVariableRequest 
   */
  createVariable(createVariableRequest, _options) {
    const requestContextPromise = this.requestFactory.createVariable(createVariableRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createVariable(rsp)));
    }));
  }
  /**
   *  Version: 10.14.0.cl or later   Creates a new webhook configuration to receive notifications for specified events. The webhook will be triggered when the configured events occur in the system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param createWebhookConfigurationRequest 
   */
  createWebhookConfiguration(createWebhookConfigurationRequest, _options) {
    const requestContextPromise = this.requestFactory.createWebhookConfiguration(createWebhookConfigurationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createWebhookConfiguration(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Creates a DBT connection object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About create DBT connection DBT connection in ThoughtSpot is used by the user to define DBT credentials for cloud . The API needs  embrace connection, embrace database name, DBT url, import type, DBT account identifier, DBT project identifier, DBT access token and environment details (or) embrace connection, embrace database name, import type, file_content to create a connection object. To know more about DBT, see ThoughtSpot Product Documentation.      
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  dbtConnection(connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    const requestContextPromise = this.requestFactory.dbtConnection(connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.dbtConnection(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Resynchronize the existing list of models, tables, worksheet tmls and import them to Thoughtspot based on the DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateSyncTml(dbtConnectionIdentifier, fileContent, _options) {
    const requestContextPromise = this.requestFactory.dbtGenerateSyncTml(dbtConnectionIdentifier, fileContent, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.dbtGenerateSyncTml(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Generate required table and worksheet and import them.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About generate TML Models and Worksheets to be imported can be selected by the user as part of the API.      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param modelTables List of Models and their respective Tables Example: \\\&#39;[{\\\&quot;model_name\\\&quot;: \\\&quot;model_name\\\&quot;, \\\&quot;tables\\\&quot;: [\\\&quot;table_name\\\&quot;]}]\\\&#39;
   * @param importWorksheets Mention the worksheet tmls to import
   * @param worksheets List of worksheets is mandatory when import_Worksheets is type SELECTED Example: [\\\&quot;worksheet_name\\\&quot;]
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateTml(dbtConnectionIdentifier, modelTables, importWorksheets, worksheets, fileContent, _options) {
    const requestContextPromise = this.requestFactory.dbtGenerateTml(dbtConnectionIdentifier, modelTables, importWorksheets, worksheets, fileContent, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.dbtGenerateTml(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Gets a list of DBT connection objects by user and organization, available on the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About search DBT connection To get details of a specific DBT connection identifier, database connection identifier, database connection name, database name, project name, project identifier, environment identifier , import type and author.      
   */
  dbtSearch(_options) {
    const requestContextPromise = this.requestFactory.dbtSearch(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.dbtSearch(rsp)));
    }));
  }
  /**
   *   Version: 9.7.0.cl or later   Deactivates a user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To deactivate a user account, the API request body must include the following information:  - Username or the GUID of the user account - Base URL of the ThoughtSpot instance  If the API request is successful, ThoughtSpot returns the activation URL in the response. The activation URL is valid for 14 days and can be used to re-activate the account and reset the password of the deactivated account.      
   * @param deactivateUserRequest 
   */
  deactivateUser(deactivateUserRequest, _options) {
    const requestContextPromise = this.requestFactory.deactivateUser(deactivateUserRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deactivateUser(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines To delete a custom calendar, specify the calendar ID as a path parameter in the request URL.        
   * @param calendarIdentifier Unique ID or name of the Calendar.
   */
  deleteCalendar(calendarIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteCalendar(calendarIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteCalendar(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Deletes Git repository configuration from your ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param deleteConfigRequest 
   */
  deleteConfig(deleteConfigRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteConfig(deleteConfigRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later    **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Delete Connection V2](#/http/api-endpoints/connections/delete-connection-v2) endpoint to delete your connection objects.    #### Usage guidelines  Deletes a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.     
   * @param deleteConnectionRequest 
   */
  deleteConnection(deleteConnectionRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteConnection(deleteConnectionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteConnection(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param deleteConnectionConfigurationRequest 
   */
  deleteConnectionConfiguration(deleteConnectionConfigurationRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteConnectionConfiguration(deleteConnectionConfigurationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteConnectionConfiguration(rsp)));
    }));
  }
  /**
   *   Version: 10.4.0.cl or later   Deletes a connection object.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param connectionIdentifier Unique ID or name of the connection.
   */
  deleteConnectionV2(connectionIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteConnectionV2(connectionIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteConnectionV2(rsp)));
    }));
  }
  /**
   *   Version: 9.6.0.cl or later   Removes the custom action specified in the API request.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param customActionIdentifier Unique ID or name of the custom action.
   */
  deleteCustomAction(customActionIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteCustomAction(customActionIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteCustomAction(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Removes the specified DBT connection object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   */
  deleteDbtConnection(dbtConnectionIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteDbtConnection(dbtConnectionIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteDbtConnection(rsp)));
    }));
  }
  /**
   *  Version: 10.10.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `template_identifier` from the response. - Use that `template_identifier` as a parameter in this API request.      
   * @param templateIdentifier Unique ID or name of the email customization.
   */
  deleteEmailCustomization(templateIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteEmailCustomization(templateIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteEmailCustomization(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified metadata object from the ThoughtSpot system.  Requires edit access to the metadata object.       
   * @param deleteMetadataRequest 
   */
  deleteMetadata(deleteMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteMetadata(deleteMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteMetadata(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes an Org object from the ThoughtSpot system.  Requires cluster administration (**Can administer Org**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.  When you delete an Org, all its users and objects created in that Org context are removed. However, if the users in the deleted Org also exists in other Orgs, they are removed only from the deleted Org.      
   * @param orgIdentifier ID or name of the Org
   */
  deleteOrg(orgIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteOrg(orgIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteOrg(rsp)));
    }));
  }
  /**
   *  Version: 10.12.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `org_identifier` from the response. - Use that `org_identifier` as a parameter in this API request.      
   * @param deleteOrgEmailCustomizationRequest 
   */
  deleteOrgEmailCustomization(deleteOrgEmailCustomizationRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteOrgEmailCustomization(deleteOrgEmailCustomizationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteOrgEmailCustomization(rsp)));
    }));
  }
  /**
   *   Version: 9.5.0.cl or later   Deletes a Role object from the ThoughtSpot system.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To delete a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role. ReadOnly roles cannot be deleted.
   */
  deleteRole(roleIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteRole(roleIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteRole(rsp)));
    }));
  }
  /**
   *  Deletes a scheduled job.    Version: 9.4.0.cl or later   Deletes a scheduled Liveboard job.  Requires at least edit access to Liveboard or `ADMINISTRATION` (**Can administer Org**) privilege.    If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.      
   * @param scheduleIdentifier Unique ID or name of the scheduled job.
   */
  deleteSchedule(scheduleIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteSchedule(scheduleIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteSchedule(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a tag object from the ThoughtSpot system  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Tag identifier Tag name or Tag id.
   */
  deleteTag(tagIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteTag(tagIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteTag(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a user from the ThoughtSpot system.  If you want to remove a user from a specific Org but not from ThoughtSpot, update the group and Org mapping properties of the user object via a POST API call to the [/api/rest/2.0/users/{user_identifier}/update](#/http/api-endpoints/users/update-user) endpoint.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   */
  deleteUser(userIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteUser(userIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteUser(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified group object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.      
   * @param groupIdentifier GUID or name of the group.
   */
  deleteUserGroup(groupIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteUserGroup(groupIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteUserGroup(rsp)));
    }));
  }
  /**
   *  Delete a variable   Version: 10.14.0.cl or later   Allows deleting a variable from ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint requires: * The variable identifier (ID or name)  The operation will fail if: * The user lacks required permissions * The variable doesn\'t exist * The variable is being used by other objects      
   * @param identifier Unique id or name of the variable
   */
  deleteVariable(identifier, _options) {
    const requestContextPromise = this.requestFactory.deleteVariable(identifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteVariable(rsp)));
    }));
  }
  /**
   *  Version: 10.14.0.cl or later   Deletes one or more webhook configurations by their unique id or name. Returns status of each deletion operation, including successfully deleted webhooks and any failures with error details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param deleteWebhookConfigurationsRequest 
   */
  deleteWebhookConfigurations(deleteWebhookConfigurationsRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteWebhookConfigurations(deleteWebhookConfigurationsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteWebhookConfigurations(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to deploy a commit and publish TML content to your ThoughtSpot instance.  Requires at least edit access to the objects used in the deploy operation.  The API deploys the head of the branch unless a `commit_id` is specified in the API request. If the branch name is not defined in the request, the default branch is considered for deploying commits.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param deployCommitRequest 
   */
  deployCommit(deployCommitRequest, _options) {
    const requestContextPromise = this.requestFactory.deployCommit(deployCommitRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deployCommit(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Exports the difference in connection metadata between CDW and ThoughtSpot  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:   - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  To download the connection metadata difference between ThoughtSpot and CDW, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  downloadConnectionMetadataChanges(connectionIdentifier, _options) {
    const requestContextPromise = this.requestFactory.downloadConnectionMetadataChanges(connectionIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.downloadConnectionMetadataChanges(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Exports an Answer in the given file format. You can download the Answer data as a PDF, PNG, CSV, or XLSX file.  Requires at least view access to the Answer.  #### Usage guidelines  In the request body, the GUID or name of the Answer and set `file_format`. The default file format is CSV.  **NOTE**: * The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension. * HTML rendering is not supported for PDF exports of Answers with tables.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.       
   * @param exportAnswerReportRequest 
   */
  exportAnswerReport(exportAnswerReportRequest, _options) {
    const requestContextPromise = this.requestFactory.exportAnswerReport(exportAnswerReportRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.exportAnswerReport(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Exports a Liveboard and its visualizations in PDF, PNG, CSV, or XLSX file format.  Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To generate a Liveboard report with specific visualizations, add GUIDs or names of the visualizations.  The default `file_format` is CSV. For PDF exports, you can specify additional parameters to customize the page orientation and include or exclude the cover page, logo, footer text, and page numbers. Similar customization options are available for PNG exports. CSV and XLSX exports do not support customization options.  **NOTE**: The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes, including ad hoc changes to visualizations. For more information, see [Liveboard Report API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_liveboard_report_api).    **NOTE**: Starting with ThoughtSpot Cloud 10.9.0.cl release, the Liveboard can be exported in the PNG format in the resolution of your choice. To enable this on your instance, contact ThoughtSpot support. When this feature is enabled, the options `include_cover_page`,`include_filter_page` within the `png_options` will not be available for PNG exports.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in CSV format. All visualizations in the Liveboard can be exported as individual CSV files. If multiple visualizations are selected or if the entire Liveboard is exported, the output is returned as a .zip file containing the CSV files for each visualization.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in XLSX format. All selected visualizations are consolidated into a single Excel workbook (.xlsx), with each visualization placed in its own worksheet (tab). XLSX exports are limited to 255 worksheets (tabs) per workbook.      
   * @param exportLiveboardReportRequest 
   */
  exportLiveboardReport(exportLiveboardReportRequest, _options) {
    const requestContextPromise = this.requestFactory.exportLiveboardReport(exportLiveboardReportRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.exportLiveboardReport(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  Requires `DATADOWNLOADING` (**Can download Data**) and at least view access to the metadata object.  #### Usage guidelines  * You can export one or several objects by passing metadata object GUIDs in the `metadata` array. * When exporting TML content for a Liveboard or Answer object, you can set `export_associated` to `true` to retrieve TML content for underlying Worksheets, Tables, or Views, including the GUID of each object within the headers. When   `export_associated` is set to `true`, consider retrieving one metadata object at a time. * Set `export_fqns` to `true` to add FQNs of the referenced objects in the TML content. For example, if you send an API request to retrieve TML for a Liveboard and its associated objects, the API returns the TML content with FQNs of the referenced Worksheet. Exporting TML with FQNs is useful if ThoughtSpot has multiple objects with the same name and you want to eliminate ambiguity when importing TML files into ThoughtSpot. It eliminates the need for adding FQNs of the referenced objects manually during the import operation. * To export only the TML of feedbacks associated with an object, set the GUID of the object as `identifier`, and set the `type` as `FEEDBACK` in the `metadata` array. * To export the TML of an object along with the feedbacks associated with it, set the GUID of the object as `identifier`, set the `type` as `LOGIAL_TABLE` in the `metadata` array, and set `export_with_associated_feedbacks` in `export_options` to true.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_export_a_tml).  For more information on feedbacks, see [Feedback Documentation](https://docs.thoughtspot.com/cloud/latest/sage-feedback).     
   * @param exportMetadataTMLRequest 
   */
  exportMetadataTML(exportMetadataTMLRequest, _options) {
    const requestContextPromise = this.requestFactory.exportMetadataTML(exportMetadataTMLRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.exportMetadataTML(rsp)));
    }));
  }
  /**
   *   Version: 10.1.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  ### **Permissions Required**  Requires `DATAMANAGEMENT` (**Can manage data**) and `USERMANAGEMENT` (**Can manage users**) privileges.  #### **Usage Guidelines**  This API is only applicable for `USER`, `GROUP`, and `ROLES` metadata types.  - `batch_offset` Indicates the starting position within the complete dataset from which the API should begin returning objects. Useful for paginating results efficiently. - `batch_size` Specifies the number of objects or items to retrieve in a single request. Helps control response size for better performance. - `edoc_format` Defines the format of the TML content. The exported metadata can be in JSON or YAML format. - `export_dependent` Specifies whether to include dependent metadata objects in the export. Ensures related objects are also retrieved if needed. - `all_orgs_override` Indicates whether the export operation applies across all organizations. Useful for multi-tenant environments where cross-org exports are required.      
   * @param exportMetadataTMLBatchedRequest 
   */
  exportMetadataTMLBatched(exportMetadataTMLBatchedRequest, _options) {
    const requestContextPromise = this.requestFactory.exportMetadataTMLBatched(exportMetadataTMLBatchedRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.exportMetadataTMLBatched(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches data from a saved Answer.  Requires at least view access to the saved Answer.  The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_apis).     
   * @param fetchAnswerDataRequest 
   */
  fetchAnswerData(fetchAnswerDataRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchAnswerData(fetchAnswerDataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchAnswerData(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for an Answer object.  Requires at least view access to the Answer object.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {    \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",    \"metadata_name\":\"Total sales\",    \"metadata_type\":\"ANSWER\",    \"sql_queries\":[       {          \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",          \"metadata_name\":\"Total sales -test\",          \"sql_query\":\"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  \\\"ta_2\\\".\\\"PRODUCTNAME\\\" \\\"ca_2\\\", \\n  \\\"ta_1\\\".\\\"STORENAME\\\" \\\"ca_3\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_4\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_5\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_3\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_3\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_PRODUCTS\\\" \\\"ta_2\\\"\\n    ON \\\"ta_3\\\".\\\"PRODUCTID\\\" = \\\"ta_2\\\".\\\"PRODUCTID\\\"\\nGROUP BY \\n  \\\"ca_1\\\", \\n  \\\"ca_2\\\", \\n  \\\"ca_3\\\"\\n\"       }    ] } ```      
   * @param fetchAnswerSqlQueryRequest 
   */
  fetchAnswerSqlQuery(fetchAnswerSqlQueryRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchAnswerSqlQuery(fetchAnswerSqlQueryRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchAnswerSqlQuery(rsp)));
    }));
  }
  /**
   *   Version: 10.4.0.cl or later   Gets information about the status of the TML async import task scheduled using the `/api/rest/2.0/metadata/tml/async/import` API call.  To fetch the task details, specify the ID of the TML async import task.    Requires access to the task ID. The API allows users who initiated the asynchronous TML import via `/api/rest/2.0/metadata/tml/async/import` to view the status of their tasks.  Users with administration privilege can view the status of all import tasks initiated by the users in their Org.  #### Usage guidelines  See [TML API Documentation](https://developers.thoughtspot.com/docs/tml#_fetch_status_of_the_tml_import_task) for usage guidelines.     
   * @param fetchAsyncImportTaskStatusRequest 
   */
  fetchAsyncImportTaskStatus(fetchAsyncImportTaskStatusRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchAsyncImportTaskStatus(fetchAsyncImportTaskStatusRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchAsyncImportTaskStatus(rsp)));
    }));
  }
  /**
   *  Version: 10.12.0.cl or later   Fetches column security rules for specified tables.  This API endpoint retrieves column-level security rules configured for tables. It returns information about which columns are secured and which groups have access to those columns.  #### Usage guidelines  - Provide an array of table identifiers using either `identifier` (GUID or name) or `obj_identifier` (object ID) - At least one of `identifier` or `obj_identifier` must be provided for each table - The API returns column security rules for all specified tables - Users must have appropriate permissions to access security rules for the specified tables  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables  #### Example request  ```json {   \"tables\": [     {       \"identifier\": \"table-guid\",       \"obj_identifier\": \"table-object-id\"     }   ] } ```  #### Response format  The API returns an array of `ColumnSecurityRuleResponse` objects wrapped in a `data` field. Each `ColumnSecurityRuleResponse` object contains: - Table information (GUID and object ID)   - Array of column security rules with column details, group access, and source table information  #### Example response  ```json {   \"data\": [     {       \"guid\": \"table-guid\",       \"objId\": \"table-object-id\",       \"columnSecurityRules\": [         {           \"column\": {             \"id\": \"col_123\",             \"name\": \"Salary\"           },           \"groups\": [             {               \"id\": \"group_1\",               \"name\": \"HR Department\"             }           ],           \"sourceTableDetails\": {             \"id\": \"source-table-guid\",             \"name\": \"Employee_Data\"           }         }       ]     }   ] } ```     
   * @param fetchColumnSecurityRulesRequest 
   */
  fetchColumnSecurityRules(fetchColumnSecurityRulesRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchColumnSecurityRules(fetchColumnSecurityRulesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchColumnSecurityRules(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Validates the difference in connection metadata between CDW and ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  Returns a boolean indicating whether there is any difference between the connection metadata at ThoughtSpot and CDW.  To get the connection metadata difference status, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  fetchConnectionDiffStatus(connectionIdentifier, _options) {
    const requestContextPromise = this.requestFactory.fetchConnectionDiffStatus(connectionIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchConnectionDiffStatus(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets data from a Liveboard object and its visualization.    Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To get data for specific visualizations, add the GUIDs or names of the visualizations in the API request.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes. If the new Liveboard experience mode, the transient content includes ad hoc changes to visualizations such as sorting, toggling of legends, and data drill down.  For more information, and see [Liveboard data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_fetch_liveboard_data_api).     
   * @param fetchLiveboardDataRequest 
   */
  fetchLiveboardData(fetchLiveboardDataRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchLiveboardData(fetchLiveboardDataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchLiveboardData(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for a Liveboard object and its visualizations.  Requires at least view access to the Liveboard object.  To get SQL query data for a Liveboard, specify the GUID of the Liveboard. Optionally, you can add an array of visualization GUIDs to retrieve the SQL query data for visualizations in the Liveboard.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {   \"metadata_id\": \"fa68ae91-7588-4136-bacd-d71fb12dda69\",   \"metadata_name\": \"Total Sales\",   \"metadata_type\": \"LIVEBOARD\",   \"sql_queries\": [     {       \"metadata_id\": \"b3b6d2b9-089a-490c-8e16-b144650b7843\",       \"metadata_name\": \"Total quantity purchased, Total sales by region\",       \"sql_query\": \"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_2\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_3\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_2\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_2\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\nGROUP BY \\\"ca_1\\\"\"     }   ] } ```      
   * @param fetchLiveboardSqlQueryRequest 
   */
  fetchLiveboardSqlQuery(fetchLiveboardSqlQueryRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchLiveboardSqlQuery(fetchLiveboardSqlQueryRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchLiveboardSqlQuery(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches security audit logs.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the [Admin Control](https://developers.thoughtspot.com/docs/rbac#_admin_control) privileges are required.   #### Usage guidelines  By default, the API retrieves logs for the last 24 hours. You can set a custom duration in EPOCH time. Make sure the log duration specified in your API request doesnt exceed 24 hours. If you must fetch logs for a longer time range, modify the duration and make multiple sequential API requests.  Upon successful execution, the API returns logs with the following information: * timestamp of the event * event ID * event type * name and GUID of the user * IP address of ThoughtSpot instance  For more information see [Audit logs Documentation](https://developers.thoughtspot.com/docs/audit-logs).      
   * @param fetchLogsRequest 
   */
  fetchLogs(fetchLogsRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchLogs(fetchLogsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchLogs(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches object permission details for a given principal object such as a user and group.  Requires view access to the metadata object.   #### Usage guidelines  * To get a list of all metadata objects that a user or group can access, specify the `type` and GUID or name of the principal. * To get permission details for a specific object, add the `type` and GUID or name of the metadata object to your API request.  Upon successful execution, the API returns a list of metadata objects and permission details for each object.        
   * @param fetchPermissionsOfPrincipalsRequest 
   */
  fetchPermissionsOfPrincipals(fetchPermissionsOfPrincipalsRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchPermissionsOfPrincipals(fetchPermissionsOfPrincipalsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchPermissionsOfPrincipals(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches permission details for a given metadata object.  Requires view access to the metadata object.  #### Usage guidelines  * To fetch a list of users and groups for a metadata object, specify `type` and GUID or name of the metadata object. * To get permission details for a specific user or group, add `type` and GUID or name of the principal object to your API request.  Upon successful execution, the API returns permission details and principal information for the object specified in the API request.      
   * @param fetchPermissionsOnMetadataRequest 
   */
  fetchPermissionsOnMetadata(fetchPermissionsOnMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.fetchPermissionsOnMetadata(fetchPermissionsOnMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.fetchPermissionsOnMetadata(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Enforces logout on current user sessions.    Use this API with caution as it may invalidate active user sessions and force users to re-login. Make sure you specify the usernames or GUIDs. If you pass null values in the API call, all user sessions on your cluster become invalid, and the users are forced to re-login.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param forceLogoutUsersRequest 
   */
  forceLogoutUsers(forceLogoutUsersRequest, _options) {
    const requestContextPromise = this.requestFactory.forceLogoutUsers(forceLogoutUsersRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.forceLogoutUsers(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Exports a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal) in the CSV format.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  Use this API to download a custom calendar in the CSV file format. In your API request, specify the following parameters.  * Start and end date of the calendar. For \"month offset\" calendars, the start date must match the month defined in the `month_offset` attribute.  You can also specify optional parameters such as the starting day of the week and prefixes for the quarter and year labels.      
   * @param generateCSVRequest 
   */
  generateCSV(generateCSVRequest, _options) {
    const requestContextPromise = this.requestFactory.generateCSV(generateCSVRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.generateCSV(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves details of the current user session for the token provided in the request header.  Any ThoughtSpot user can access this endpoint and send an API request. The data returned in the API response varies according to user\'s privilege and object access permissions.     
   */
  getCurrentUserInfo(_options) {
    const requestContextPromise = this.requestFactory.getCurrentUserInfo(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getCurrentUserInfo(rsp)));
    }));
  }
  /**
   *   Version: 9.4.0.cl or later   Retrieves details of the current session token for the bearer token provided in the request header.  This API endpoint does not create a new token. Instead, it returns details about the token, including the token string, creation time, expiration time, and the associated user.  Use this endpoint to introspect your current session token, debug authentication issues, or when a frontend application needs session token details.  Any ThoughtSpot user with a valid bearer token can access this endpoint and send an API request      
   */
  getCurrentUserToken(_options) {
    const requestContextPromise = this.requestFactory.getCurrentUserToken(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getCurrentUserToken(rsp)));
    }));
  }
  /**
   *   Version: 10.4.0.cl or later   Gets an authentication token with custom rules and security attributes and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  To add a new user and assign privileges during auto creation, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  To assign security attributes with filter rules and Parameters to the JWT token, you\'ll need administrator privileges and edit access to the data source (Worksheet or Model). If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  #### Usage guidelines  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key`.  To generate a `secret_key` on your cluster, the administrator must enable [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable) in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  ##### Attribute-Based Access Control (ABAC) with tokens  To implement Attribute-Based Access Control (ABAC) and assign security entitlements to users during session creation, you can generate a token with custom filtering rules and Parameters in the `filter_rules` and `parameter_values` array respectively. These attributes can be configured to persist on a specific set of objects for user sessions initiated using the token. Once defined, the rules are added to the user\'s `access_control_properties` object, after which all sessions will use the persisted values.  Specify the object type as `LOGICAL_TABLE`.   For more information, see [ABAC via tokens Documentation](https://developers.thoughtspot.com/docs/api-authv2#_get_tokens_with_custom_rules_and_filter_conditions).  ##### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `groups`  Set `auto_create` to `true` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true` in the API request, the user properties such as the display name, email, Org and group assignment will not be updated with new values. If `auto_create` is set to `true`, it won\'t create formula variables and hence won\'t be applicable for `variable_values`.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  ##### Important point to note All options in the token creation APIs that define access to the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created. Persist options such as  `APPEND`, `REPLACE`, `RESET` will persist security parameters on the user profile when the token is created, while Persist option `NONE` will not persist anything but will be honoured in the session.  ##### Formula Variables Before using variables_values, variables must be created using Create Variable API with type as Formula_Variable (/api/rest/2.0/template/variables/create) The persist_option RESET and NONE cannot be used when variable_values are provided in the request. If you are working with variable_values, you must use other (APPEND, REPLACE) supported modes. If you want to use RESET or NONE, do not pass any variable_values. In such cases, variable_values will remain unaffected. When using object_id with variable_values, models are supported.      
   * @param getCustomAccessTokenRequest 
   */
  getCustomAccessToken(getCustomAccessTokenRequest, _options) {
    const requestContextPromise = this.requestFactory.getCustomAccessToken(getCustomAccessTokenRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getCustomAccessToken(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page. For more information, see [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable).  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getFullAccessTokenRequest 
   */
  getFullAccessToken(getFullAccessTokenRequest, _options) {
    const requestContextPromise = this.requestFactory.getFullAccessToken(getFullAccessTokenRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getFullAccessToken(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token that provides access to a specific metadata object. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request,  `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getObjectAccessTokenRequest 
   */
  getObjectAccessToken(getObjectAccessTokenRequest, _options) {
    const requestContextPromise = this.requestFactory.getObjectAccessToken(getObjectAccessTokenRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getObjectAccessToken(rsp)));
    }));
  }
  /**
   *  Version: 10.13.0.cl or later   Breaks down a user-submitted query into a series of analytical sub-questions using relevant contextual metadata.  To use this API, the user must have at least view-level access to the referenced metadata objects.  #### Usage guidelines  To accurately generate relevant questions, the request must include at least one of the following metadata identifiers within `metadata_context` : `conversation_identifier`, `answer_identifiers`, `liveboard_identifiers`, or `data_source_identifiers`.  You can further enhance the quality and precision of breakdown by providing additional `ai_context` such as:  - `content`: User provided content like text data, csv data as a string message to provide context & potentially improve the quality of the response. - `instructions`: User specific text instructions sent to AI system for processing the query.  Additional optional parameters include:  - `limit_relevant_questions`: Controls the maximum number of relevant questions returned. Defaults to 5 if not specified. - `bypass_cache`: If set to true, forces fresh computation instead of returning cached results.  If the API request is successful, ThoughtSpot returns a list of relevant analytical queries, each aligned with the user\'s original question. Each returned question includes the query string, along with the identifier and name of the corresponding data source.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.     
   * @param getRelevantQuestionsRequest 
   */
  getRelevantQuestions(getRelevantQuestionsRequest, _options) {
    const requestContextPromise = this.requestFactory.getRelevantQuestions(getRelevantQuestionsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getRelevantQuestions(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves the current configuration details of the cluster. If the request is successful, the API returns a list configuration settings applied on the cluster.  Requires `ADMINISTRATION`(**Can administer ThoughtSpot**) privilege to view these complete configuration settings of the cluster. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.      
   */
  getSystemConfig(_options) {
    const requestContextPromise = this.requestFactory.getSystemConfig(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getSystemConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets system information such as the release version, locale, time zone, deployment environment, date format, and date time format of the cluster.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemInformation(_options) {
    const requestContextPromise = this.requestFactory.getSystemInformation(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getSystemInformation(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of configuration overrides applied on the cluster.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemOverrideInfo(_options) {
    const requestContextPromise = this.requestFactory.getSystemOverrideInfo(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.getSystemOverrideInfo(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Imports [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  *  Import all related objects in a single TML Import API call. For example, Tables that use the same Connection object and Worksheets connected to these Tables. * Include the `fqn` property to distinguish objects that have the same name.   For example, if you have multiple Connections or Worksheets with the same name on ThoughtSpot and the Connection or Worksheet referenced in your TML file does not have a unique name to distinguish, it may result in invalid object references.   Adding `fqn` helps ThoughtSpot differentiate a Table from another with the same name.   We recommend [exporting TML with FQNs](#/http/api-endpoints/metadata/export-metadata-tml) and using these during the import operation. * You can upload multiple TML files at a time.   If you import a Worksheet along with Liveboards, Answers, and other dependent objects in a single API call, the imported objects will be immediately available for use.   When you import only a Worksheet object, it may take some time for the Worksheet to become available in the ThoughtSpot system. Please wait for a few minutes, and then proceed to create an Answer and Liveboard from the newly imported Worksheet.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_import_a_tml).      
   * @param importMetadataTMLRequest 
   */
  importMetadataTML(importMetadataTMLRequest, _options) {
    const requestContextPromise = this.requestFactory.importMetadataTML(importMetadataTMLRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.importMetadataTML(rsp)));
    }));
  }
  /**
   *   Version: 10.4.0.cl or later   Schedules a task to import [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot. You can use this API endpoint to process TML objects asynchronously when importing TMLs of large and complex metadata objects into ThoughtSpot. Unlike the synchronous import TML operation, the API processes TML data in the background and returns a task ID, which can be used to check the status of the import task via `/api/rest/2.0/metadata/tml/async/status` API endpoint.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege, and edit access to the TML objects.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  See [Async TML API Documentation](https://developers.thoughtspot.com/docs/tml#_import_tml_objects_asynchronously) for usage guidelines.      
   * @param importMetadataTMLAsyncRequest 
   */
  importMetadataTMLAsync(importMetadataTMLAsyncRequest, _options) {
    const requestContextPromise = this.requestFactory.importMetadataTMLAsync(importMetadataTMLAsyncRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.importMetadataTMLAsync(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Imports group objects from external databases into ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  During the import operation:  * If the specified group is not available in ThoughtSpot, it will be added to ThoughtSpot. * If `delete_unspecified_groups` is set to `true`, the groups not specified in the API request, excluding administrator and system user groups, are deleted. * If the specified groups are already available in ThoughtSpot, the object properties of these groups are modified and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.      
   * @param importUserGroupsRequest 
   */
  importUserGroups(importUserGroupsRequest, _options) {
    const requestContextPromise = this.requestFactory.importUserGroups(importUserGroupsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.importUserGroups(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Imports user data from external databases into ThoughtSpot. During the user import operation:  * If the specified users are not available in ThoughtSpot, the users are created and assigned a default password. Defining a `default_password` in the API request is optional. * If `delete_unspecified_users` is set to `true`, the users not specified in the API request, excluding the `tsadmin`, `guest`, `system` and `su` users, are deleted. * If the specified user objects are already available in ThoughtSpot, the object properties are updated and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param importUsersRequest 
   */
  importUsers(importUsersRequest, _options) {
    const requestContextPromise = this.requestFactory.importUsers(importUsersRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.importUsers(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a login session for a ThoughtSpot user with Basic authentication.  In Basic authentication method, REST clients log in to ThoughtSpot using `username` and `password` attributes. On a multi-tenant cluster with Orgs, users can pass the ID of the Org in the API request to log in to a specific Org context.  **Note**: If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. Contact ThoughtSpot Support for assistance.  A successful login returns a session cookie that can be used in your subsequent API requests.     
   * @param loginRequest 
   */
  login(loginRequest, _options) {
    const requestContextPromise = this.requestFactory.login(loginRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.login(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later    Logs out a user from their current session.      
   */
  logout(_options) {
    const requestContextPromise = this.requestFactory.logout(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.logout(rsp)));
    }));
  }
  /**
   *  Parameterize fields in metadata objects.   Version: 10.9.0.cl or later   Allows parameterizing fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows parameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be parameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param parameterizeMetadataRequest 
   */
  parameterizeMetadata(parameterizeMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.parameterizeMetadata(parameterizeMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.parameterizeMetadata(rsp)));
    }));
  }
  /**
   *  Version: 10.9.0.cl or later   Allows publishing metadata objects across organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows publishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  This API will essentially share the objects along with it\'s dependencies to the org admins of the orgs to which it is being published.      
   * @param publishMetadataRequest 
   */
  publishMetadata(publishMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.publishMetadata(publishMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.publishMetadata(rsp)));
    }));
  }
  /**
   * Version: 10.7.0.cl or later 
   * @param queryGetDecomposedQueryRequest 
   */
  queryGetDecomposedQuery(queryGetDecomposedQueryRequest, _options) {
    const requestContextPromise = this.requestFactory.queryGetDecomposedQuery(queryGetDecomposedQueryRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.queryGetDecomposedQuery(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Resets the password of a user account. Administrators can reset password on behalf of a user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param resetUserPasswordRequest 
   */
  resetUserPassword(resetUserPasswordRequest, _options) {
    const requestContextPromise = this.requestFactory.resetUserPassword(resetUserPasswordRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.resetUserPassword(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Reverts TML objects to a previous commit specified in the API request.  Requires at least edit access to objects.  In the API request, specify the `commit_id`. If the branch name is not specified in the request, the API will consider the default branch configured on your instance.  By default, the API reverts all objects. If the revert operation fails for one of the objects provided in the commit, the API returns an error and does not revert any object.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitId Commit id to which the object should be reverted
   * @param revertCommitRequest 
   */
  revertCommit(commitId, revertCommitRequest, _options) {
    const requestContextPromise = this.requestFactory.revertCommit(commitId, revertCommitRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.revertCommit(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later    Revokes the authentication token issued for current user session.  The token of your current session expires when you make a call to the `/api/rest/2.0/auth/token/revoke` endpoint. the users will not be able to access ThoughtSpot objects until a new token is obtained.  To restart your session, request for a new token from ThoughtSpot. See [Get Full Access Token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param revokeTokenRequest 
   */
  revokeToken(revokeTokenRequest, _options) {
    const requestContextPromise = this.requestFactory.revokeToken(revokeTokenRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.revokeToken(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Gets a list of [custom calendars](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  By default, the API returns a list of custom calendars for all connection objects. To retrieve custom calendar details for a particular connection, specify the connection ID. You can also use other search parameters such as `name_pattern` and `sort_options` as search filters.  The `name_pattern` parameter filters and returns only those objects that match the specified pattern. Use `%` as a wildcard for pattern matching.      
   * @param searchCalendarsRequest 
   */
  searchCalendars(searchCalendarsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchCalendars(searchCalendarsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchCalendars(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of commits for a given metadata object.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param searchCommitsRequest 
   */
  searchCommits(searchCommitsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchCommits(searchCommitsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchCommits(rsp)));
    }));
  }
  /**
   *  Version: 10.14.0.cl or later   Fetch communication channel preferences. - Use `cluster_preferences` to fetch the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to fetch any Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param searchCommunicationChannelPreferencesRequest 
   */
  searchCommunicationChannelPreferences(searchCommunicationChannelPreferencesRequest, _options) {
    const requestContextPromise = this.requestFactory.searchCommunicationChannelPreferences(searchCommunicationChannelPreferencesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchCommunicationChannelPreferences(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Gets Git repository connections configured on the ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param searchConfigRequest 
   */
  searchConfig(searchConfigRequest, _options) {
    const requestContextPromise = this.requestFactory.searchConfig(searchConfigRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Gets connection objects. Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  - To get a list of all connections available in the ThoughtSpot system, send the API request without any attributes in the request body. - To get the connection objects for a specific type of data warehouse, specify the type in `data_warehouse_types`. - To fetch details of a connection object, specify the connection object GUID or name. The `name_pattern` attribute allows passing partial text with `%` for a wildcard match. - To get details of the database, schemas, tables, or columns from a data connection object, specify `data_warehouse_object_type`. - To get a specific database, schema, table, or column from a connection object, define the object type in `data_warehouse_object_type` and object properties in the `data_warehouse_objects` array. For example, to search for a column, you must pass the database, schema, and table names in the API request.   Note that in the following example, object properties are set in a hierarchical order (`database` > `schema` > `table` > `column`).  ``` {   \"connections\": [     {       \"identifier\": \"b9d1f2ef-fa65-4a4b-994e-30fa2d57b0c2\",       \"data_warehouse_objects\": [         {           \"database\": \"NEBULADEV\",           \"schema\": \"INFORMATION_SCHEMA\",           \"table\": \"APPLICABLE_ROLES\",           \"column\": \"ROLE_NAME\"         }       ]     }   ],   \"data_warehouse_object_type\": \"COLUMN\" } ```  - To fetch data by `configuration`, specify `data_warehouse_object_type`. For example, to fetch columns from the `DEVELOPMENT` database, specify the `data_warehouse_object_type` as `DATABASE` and define the `configuration` string as `{\"database\":\"DEVELOPMENT\"}`. To get column data for a specific table, specify the table, for example,`{\"database\":\"RETAILAPPAREL\",\"table\":\"PIPES\"}`. - To query connections by `authentication_type`, specify `data_warehouse_object_type`. Supported values for `authentication_type` are:   - `SERVICE_ACCOUNT`: For connections that require service account credentials to authenticate to the Cloud Data Warehouse and fetch data.   - `OAUTH`: For connections that require OAuth credentials to authenticate to the Cloud Data Warehouse and fetch data. Teradata, Oracle, and Presto Cloud Data Warehouses do not support the OAuth authentication type.   - `IAM`: For connections that have the IAM OAuth set up. This authentication type is supported on Amazon Redshift connections only.   - `EXTOAUTH`: For connections that have External OAuth set up. ThoughtSpot supports external [OAuth with Microsoft Azure Active Directory (AD)](https://docs.thoughtspot.com/cloud/latest/ connections-snowflake-azure-ad-oauth) and [Okta for Snowflake data connections](https://docs.thoughtspot.com/cloud/latest/connections-snowflake-okta-oauth).   - `KEY_PAIR`: For connections that require Key Pair account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PKCE`: For connections that require OAuth with PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake, Starburst, Databricks, Denodo  connections only.   - `EXTOAUTH_WITH_PKCE`: For connections that require External OAuth With PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PEZ`: For connections that require OAuth With PEZ account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Amazon Redshift connections only.   - `OAUTH_WITH_SERVICE_PRINCIPAL`: For connections that require OAuth With Service Principal account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `PERSONAL_ACCESS_TOKEN`: For connections that require Personal Access Token account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `OAUTH_CLIENT_CREDENTIALS`: For connections that require OAuth Client Credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only. - To include more details about connection objects in the API response, set `include_details` to `true`. - You can also sort the output by field names and filter connections by tags.  **NOTE**: When filtering connection records by parameters other than `data_warehouse_types` or `tag_identifiers`, ensure that you set `record_size` to `-1` and `record_offset` to `0` for precise results.      
   * @param searchConnectionRequest 
   */
  searchConnection(searchConnectionRequest, _options) {
    const requestContextPromise = this.requestFactory.searchConnection(searchConnectionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchConnection(rsp)));
    }));
  }
  /**
   *   Version: 9.6.0.cl or later   Gets custom actions configured on the cluster.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param searchCustomActionsRequest 
   */
  searchCustomActions(searchCustomActionsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchCustomActions(searchCustomActionsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchCustomActions(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Generates an Answer from a given data source.  Requires at least view access to the data source object (Worksheet or View).  #### Usage guidelines  To search data, specify the data source GUID in `logical_table_identifier`. The data source can be a Worksheet, View, Table, or SQL view.  Pass search tokens in the `query_string` attribute in the API request as shown in the following example:  ``` {   \"query_string\": \"[sales] by [store]\",   \"logical_table_identifier\": \"cd252e5c-b552-49a8-821d-3eadaa049cca\", } ```  For more information about the `query_string` format and data source attribute, see [Search data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_search_data_api).    The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_api).       
   * @param searchDataRequest 
   */
  searchData(searchDataRequest, _options) {
    const requestContextPromise = this.requestFactory.searchData(searchDataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchData(rsp)));
    }));
  }
  /**
   *  Version: 10.10.0.cl or later   Search the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   * @param searchEmailCustomizationRequest 
   */
  searchEmailCustomization(searchEmailCustomizationRequest, _options) {
    const requestContextPromise = this.requestFactory.searchEmailCustomization(searchEmailCustomizationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchEmailCustomization(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of metadata objects available on the ThoughtSpot system.  This API endpoint is available to all users who have view access to the object. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view data for all metadata objects, including users and groups.  #### Usage guidelines  - To get all metadata objects, send the API request without any attributes. - To get metadata objects of a specific type, set the `type` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE`. - To filter metadata objects within type `LOGICAL_TABLE`, set the `subtypes` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE` & subtypes as `[WORKSHEET]`. - To get a specific metadata object, specify the GUID. - To customize your search and filter the API response, you can use several parameters.   You can search for objects created or modified by specific users, by tags applied to the objects, or by using the include parameters like `include_auto_created_objects`, `include_dependent_objects`, `include_headers`, `include_incomplete_objects`, and so on.   You can also define sorting options to sort the data retrieved in the API response. - To get discoverable objects when linientmodel is enabled you can use `include_discoverable_objects` as true else false. Default value is true. - For liveboard metadata type, to get the newer format, set the `liveboard_response_format` as V2. Default value is V1. - To retrieve only objects that are published, set the `include_only_published_objects` as true. Default value is false.  **NOTE**: The following parameters support pagination of metadata records:  - `tag_identifiers` - `type` - `subtypes` - `created_by_user_identifiers` - `modified_by_user_identifiers` - `owned_by_user_identifiers` - `exclude_objects` - `include_auto_created_objects` - `favorite_object_options` - `include_only_published_objects` If you are using other parameters to search metadata, set `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchMetadataRequest 
   */
  searchMetadata(searchMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.searchMetadata(searchMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchMetadata(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of Orgs configured on the ThoughtSpot system. To get details of a specific Org, specify the Org ID or name. You can also pass parameters such as status, visibility, and user identifiers to get a specific list of Orgs.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param searchOrgsRequest 
   */
  searchOrgs(searchOrgsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchOrgs(searchOrgsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchOrgs(rsp)));
    }));
  }
  /**
   *   Version: 9.5.0.cl or later   Gets a list of Role objects from the ThoughtSpot system.  Available if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To search for Roles, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.  To get details of a specific Role object, specify the GUID or name. You can also filter the API response based on user group and Org identifiers, privileges assigned to the Role, and deprecation status.      
   * @param searchRolesRequest 
   */
  searchRoles(searchRolesRequest, _options) {
    const requestContextPromise = this.requestFactory.searchRoles(searchRolesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchRoles(rsp)));
    }));
  }
  /**
   *  Search Schedules    Version: 9.4.0.cl or later   Gets a list of scheduled jobs configured for a Liveboard.  To get details of a specific scheduled job, specify the name or GUID of the scheduled job.  Requires at least view access to Liveboards.  **NOTE**: When filtering schedules by parameters other than `metadata`, set `record_size` to `-1` and `record_offset` to `0` for accurate results.      
   * @param searchSchedulesRequest 
   */
  searchSchedules(searchSchedulesRequest, _options) {
    const requestContextPromise = this.requestFactory.searchSchedules(searchSchedulesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchSchedules(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of tag objects available on the ThoughtSpot system. To get details of a specific tag object, specify the GUID or name.  Any authenticated user can search for tag objects.      
   * @param searchTagsRequest 
   */
  searchTags(searchTagsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchTags(searchTagsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchTags(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of user group objects from the ThoughtSpot system.  To get details of a specific user group, specify the user group GUID or name. You can also filter the API response based on User ID, Org ID, Role ID, type of group, sharing visibility, privileges assigned to the group, and the Liveboard IDs assigned to the users in the group.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  **NOTE**: If you do not get precise results, try setting `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchUserGroupsRequest 
   */
  searchUserGroups(searchUserGroupsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchUserGroups(searchUserGroupsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchUserGroups(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of users available on the ThoughtSpot system.  To get details of a specific user, specify the user GUID or name. You can also filter the API response based on groups, Org ID, user visibility, account status, user type, and user preference settings and favorites.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  **NOTE**: If the API returns an empty list, consider increasing the value of the `record_size` parameter. To search across all available users, set `record_size` to `-1`.      
   * @param searchUsersRequest 
   */
  searchUsers(searchUsersRequest, _options) {
    const requestContextPromise = this.requestFactory.searchUsers(searchUsersRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchUsers(rsp)));
    }));
  }
  /**
   *  Search variables   Version: 10.14.0.cl or later   Allows searching for variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports searching variables by: * Variable identifier (ID or name) * Variable type * Name pattern (case-insensitive, supports % for wildcard)  The search results can be formatted in three ways: * METADATA - Returns only variable metadata (default) * METADATA_AND_VALUES - Returns variable metadata and values  The values can be filtered by scope: * org_identifier * principal_identifier * model_identifier      
   * @param searchVariablesRequest 
   */
  searchVariables(searchVariablesRequest, _options) {
    const requestContextPromise = this.requestFactory.searchVariables(searchVariablesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchVariables(rsp)));
    }));
  }
  /**
   *  Version: 10.14.0.cl or later   Searches for webhook configurations based on various criteria such as Org, webhook identifier, event type, with support for pagination and sorting. Returns matching webhook configurations with their complete details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param searchWebhookConfigurationsRequest 
   */
  searchWebhookConfigurations(searchWebhookConfigurationsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchWebhookConfigurations(searchWebhookConfigurationsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchWebhookConfigurations(rsp)));
    }));
  }
  /**
   *  Version: 10.13.0.cl or later   This API allows users to initiate or continue an agent (Spotter) conversation by submitting one or more natural language messages.  To use this API, the user must have access to the relevant conversational session (via conversation_identifier) and submit at least one message.   #### Usage guidelines  To initiate or continue a conversation, the request must include: - `conversation_identifier`: a unique session ID for continuity and message tracking - `messages`: an array of one or more text messages, each with a value and type  Additionally, user can specify what tool can be included `conversation_settings` parameter, which supports: - `enable_contextual_change_analysis` (default: false) - `enable_natural_language_answer_generation` (default: true) - `enable_reasoning` (default: false)  If the request is valid, the API returns a stream of messages in real time, including: - `ack`: confirms receipt of the request - `text / text-chunk`: content chunks, optionally formatted (e.g., markdown) - `answer`: the final structured response with metadata and analytics - `error`: if a failure occurs - `notification`: notification messages for operation being performed  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster. > * The streaming protocol uses Server-Sent Events (SSE)     
   * @param sendAgentMessageStreamingRequest 
   */
  sendAgentMessageStreaming(sendAgentMessageStreamingRequest, _options) {
    const requestContextPromise = this.requestFactory.sendAgentMessageStreaming(sendAgentMessageStreamingRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.sendAgentMessageStreaming(rsp)));
    }));
  }
  /**
   *  Version: 10.4.0.cl or later   Allows sending a follow-up message to an ongoing conversation within the context of the metadata model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  The API requires you to specify the `conversation_identifier` in the request path, and a `metadata_identifier` and `message` string in the request body.  If the API request is successful, ThoughtSpot returns the session ID, tokens used in the conversation, and visualization type.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param conversationIdentifier Unique identifier of the conversation.
   * @param sendMessageRequest 
   */
  sendMessage(conversationIdentifier, sendMessageRequest, _options) {
    const requestContextPromise = this.requestFactory.sendMessage(conversationIdentifier, sendMessageRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.sendMessage(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Allows sharing one or several metadata objects with users and groups in ThoughtSpot.  Requires edit access to the metadata object.  The API endpoint allows sharing only the following types of metadata objects: * Liveboards * Visualizations * Answers * Worksheets * Views * Connections  You can provide `READ_ONLY` or `MODIFY` access when sharing an object with another user or group. With `READ_ONLY` access grants view access to the shared object, whereas `MODIFY` provides edit access.  To prevent a user or group from accessing the shared object, specify the GUID or name of the principal and set `shareMode` to `NO_ACCESS`.      
   * @param shareMetadataRequest 
   */
  shareMetadata(shareMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.shareMetadata(shareMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.shareMetadata(rsp)));
    }));
  }
  /**
   *  Version: 10.4.0.cl or later   Processes a natural language query and returns an AI-generated response based on a specified data model.  Requires at least view access to the metadata object specified in the request.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param singleAnswerRequest 
   */
  singleAnswer(singleAnswerRequest, _options) {
    const requestContextPromise = this.requestFactory.singleAnswer(singleAnswerRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.singleAnswer(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the tags applied to a Liveboard, Answer, Table, or Worksheet.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  unassignTag(assignTagRequest, _options) {
    const requestContextPromise = this.requestFactory.unassignTag(assignTagRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.unassignTag(rsp)));
    }));
  }
  /**
   *  Remove parameterization from fields in metadata objects.   Version: 10.9.0.cl or later   Allows removing parameterization from fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows unparameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be unparameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param unparameterizeMetadataRequest 
   */
  unparameterizeMetadata(unparameterizeMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.unparameterizeMetadata(unparameterizeMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.unparameterizeMetadata(rsp)));
    }));
  }
  /**
   *  Version: 10.9.0.cl or later   Allows unpublishing metadata objects from organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows unpublishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  When unpublishing objects, you can: * Include dependencies by setting `include_dependencies` to true - this will unpublish all dependent objects if no other published object is using them * Force unpublish by setting `force` to true - this will break all dependent objects in the unpublished organizations      
   * @param unpublishMetadataRequest 
   */
  unpublishMetadata(unpublishMetadataRequest, _options) {
    const requestContextPromise = this.requestFactory.unpublishMetadata(unpublishMetadataRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.unpublishMetadata(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Updates the properties of a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  You can update the properties of a calendar using one of the following methods: * `FROM_INPUT_PARAMS` to update the calendar properties with the values defined in the API request. * `FROM_EXISTING_TABLE` Creates a calendar from the parameters defined in the API request.  To update a custom calendar, specify the calendar ID as a path parameter in the request URL and the following parameters in the request body:    * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  The API allows you to modify the calendar type, month offset value, start and end date, starting day of the week, and prefixes assigned to the year and quarter labels.     #### Examples  Update a custom calendar using an existing Table in ThoughtSpot:  ``` {   \"update_method\": \"FROM_EXISTING_TABLE\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   } } ```  Update a custom calendar with the attributes defined in the API request:  ``` {   \"update_method\": \"FROM_INPUT_PARAMS\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   },   \"month_offset\": \"August\",   \"start_day_of_week\": \"Monday\",   \"start_date\": \"08/01/2025\",   \"end_date\": \"07/31/2026\" } ```      
   * @param calendarIdentifier Unique Id or name of the calendar.
   * @param updateCalendarRequest 
   */
  updateCalendar(calendarIdentifier, updateCalendarRequest, _options) {
    const requestContextPromise = this.requestFactory.updateCalendar(calendarIdentifier, updateCalendarRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateCalendar(rsp)));
    }));
  }
  /**
   *  Version: 10.12.0.cl or later   Creates, updates, or deletes column security rules for specified tables.  This API endpoint allows you to create, update, or delete column-level security rules on columns of a table. The operation follows an \"all or none\" policy: if defining security rules for any of the provided columns fails, the entire operation will be rolled back, and no rules will be created.  #### Usage guidelines  - Provide table identifier using either `identifier` (GUID or name) or `obj_identifier` (object ID) - Use `clear_csr: true` to remove all column security rules from the table - For each column, specify the security rule using `column_security_rules` array - Use `is_unsecured: true` to mark a specific column as unprotected - Use `group_access` operations to manage group associations:   - `ADD`: Add groups to the column\'s access list   - `REMOVE`: Remove groups from the column\'s access list   - `REPLACE`: Replace all existing groups with the specified groups  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data (if RBAC is disabled) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables (if RBAC is enabled)  #### Example request  ```json {   \"identifier\": \"table-guid\",   \"obj_identifier\": \"table-object-id\",   \"clear_csr\": false,   \"column_security_rules\": [     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"ADD\",           \"group_identifiers\": [\"hr_group_id\", \"hr_group_name\", \"finance_group_id\"]         }       ]     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": true     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"REPLACE\",           \"group_identifiers\": [\"management_group_id\", \"management_group_name\"]         }       ]     }   ] } ```  #### Request Body Schema  - `identifier` (string, optional): GUID or name of the table for which we want to create column security rules - `obj_identifier` (string, optional): The object ID of the table - `clear_csr` (boolean, optional): If true, then all the secured columns will be marked as unprotected, and all the group associations will be removed - `column_security_rules` (array of objects, required): An array where each object defines the security rule for a specific column  Each column security rule object contains: - `column_identifier` (string, required): Column identifier (col_id or name) - `is_unsecured` (boolean, optional): If true, the column will be marked as unprotected and all groups associated with it will be removed - `group_access` (array of objects, optional): Array of group operation objects  Each group operation object contains: - `operation` (string, required): Operation type - ADD, REMOVE, or REPLACE - `group_identifiers` (array of strings, required): Array of group identifiers (name or GUID) on which the operation will be performed  #### Response  This API does not return any response body. A successful operation returns HTTP 200 status code.  #### Operation Types  - **ADD**: Adds the specified groups to the column\'s access list - **REMOVE**: Removes the specified groups from the column\'s access list   - **REPLACE**: Replaces all existing groups with the specified groups      
   * @param updateColumnSecurityRulesRequest 
   */
  updateColumnSecurityRules(updateColumnSecurityRulesRequest, _options) {
    const requestContextPromise = this.requestFactory.updateColumnSecurityRules(updateColumnSecurityRulesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateColumnSecurityRules(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Updates Git repository configuration settings.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param updateConfigRequest 
   */
  updateConfig(updateConfigRequest, _options) {
    const requestContextPromise = this.requestFactory.updateConfig(updateConfigRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Update connection V2](#/http/api-endpoints/connections/update-connection-v2) endpoint to update your connection objects.  #### Usage guidelines  Updates a connection object.    Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`. 3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.      
   * @param updateConnectionRequest 
   */
  updateConnection(updateConnectionRequest, _options) {
    const requestContextPromise = this.requestFactory.updateConnection(updateConnectionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateConnection(rsp)));
    }));
  }
  /**
   *   Version: 10.12.0.cl or later   Updates a connection configuration object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Supported operations This API endpoint lets you perform the following operations in a single API request:   * Edit the name or description of the configuration  * Edit the configuration properties  * Edit the `policy_type`  * Edit the type of authentication  * Enable or disable a configuration  #### Parameterized Connection Support For parameterized oauth based connections, only the `same_as_parent` and `policy_process_options` attributes are allowed. These attributes are not applicable to connections that are not parameterized.   **NOTE**: When updating a configuration where `disabled` is `true`, you must reset `disabled` to `true` in your update request payload. If not explicitly set again, the API will default `disabled` to `false`.      
   * @param configurationIdentifier Unique ID or name of the configuration.
   * @param updateConnectionConfigurationRequest 
   */
  updateConnectionConfiguration(configurationIdentifier, updateConnectionConfigurationRequest, _options) {
    const requestContextPromise = this.requestFactory.updateConnectionConfiguration(configurationIdentifier, updateConnectionConfigurationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateConnectionConfiguration(rsp)));
    }));
  }
  /**
   *   Version: 10.4.0.cl or later   Updates a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`.        **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.     * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:    * This is an example of updating a single table in a empty connection:           ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"DEMORENAME\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"Col1\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col2\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col3\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col312\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col4\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```        * This is an example of updating a single table in an existing connection with tables:            ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"CUSTOMER\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [],                     \"relationships\": []                   },                   {                     \"name\": \"tpch5k_falcon_default_schema_users\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"user_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"product_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"user_cost\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```  3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.    **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not  specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.    * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a Snowflake connection:    ```    {       \"configuration\":{          \"accountName\":\"thoughtspot_partner\",          \"user\":\"tsadmin\",          \"password\":\"TestConn123\",          \"role\":\"sysadmin\",          \"warehouse\":\"MEDIUM_WH\"       },       \"externalDatabases\":[        ]    }    ```      
   * @param connectionIdentifier Unique ID or name of the connection.
   * @param updateConnectionV2Request 
   */
  updateConnectionV2(connectionIdentifier, updateConnectionV2Request, _options) {
    const requestContextPromise = this.requestFactory.updateConnectionV2(connectionIdentifier, updateConnectionV2Request, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateConnectionV2(rsp)));
    }));
  }
  /**
   *   Version: 9.6.0.cl or later   Updates a custom action.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API allows you to modify the following properties:  * Name of the custom action * Action availability to groups * Association to metadata objects * Authentication settings for a URL-based action  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param customActionIdentifier Unique ID or name of the custom action.
   * @param updateCustomActionRequest 
   */
  updateCustomAction(customActionIdentifier, updateCustomActionRequest, _options) {
    const requestContextPromise = this.requestFactory.updateCustomAction(customActionIdentifier, updateCustomActionRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateCustomAction(rsp)));
    }));
  }
  /**
   *   Version: 9.9.0.cl or later   Updates a DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About update DBT connection You can modify DBT connection object properties such as embrace connection name, embrace database name, import type, account identifier, access token, project identifier and environment (or) embrace connection, embrace database name, import type, file_content settings.      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  updateDbtConnection(dbtConnectionIdentifier, connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    const requestContextPromise = this.requestFactory.updateDbtConnection(dbtConnectionIdentifier, connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateDbtConnection(rsp)));
    }));
  }
  /**
   *  Version: 10.12.0.cl or later   Updates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To update a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param updateEmailCustomizationRequest 
   */
  updateEmailCustomization(updateEmailCustomizationRequest, _options) {
    const requestContextPromise = this.requestFactory.updateEmailCustomization(updateEmailCustomizationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateEmailCustomization(rsp)));
    }));
  }
  /**
   *  Update header attributes for a given list of header objects.   Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **headers_update**      - **Description:** List of header objects with their attributes to be updated. Each object contains a list of attributes to be updated in the header.    - **Usage:**       - You must provide either `identifier` or `obj_identifier`, but not both. Both fields cannot be empty.       - When `org_identifier` is set to `-1`, only the `identifier` value is accepted; `obj_identifier` is not allowed.  2. **org_identifier**      - **Description:** GUID (Globally Unique Identifier) or name of the organization.      - **Usage:**      - Leaving this field empty assumes that the changes should be applied to the current organization       - Provide `org_guid` or `org_name` to uniquely identify the organization where changes need to be applied. .      - Provide `-1` if changes have to be applied across all the org.  ---  ## Note Currently, this API is enabled only for updating the `obj_identifier` attribute. Only `text` will be allowed in attribute\'s value.  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the update process  ---  ## Examples  ### Only `identifier` is given  ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"obj_identifier\": \"\",       \"type\": \"LOGICAL_COLUMN\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgGuid\" } ```  ### Only `obj_identifier` is given ```json {   \"headers_update\":   [     {       \"obj_identifier\": \"custom_object_id\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgName\" } ```  ### Executing update for all org `-1` ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```  ### Optional `type` is not provided ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```     
   * @param updateMetadataHeaderRequest 
   */
  updateMetadataHeader(updateMetadataHeaderRequest, _options) {
    const requestContextPromise = this.requestFactory.updateMetadataHeader(updateMetadataHeaderRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateMetadataHeader(rsp)));
    }));
  }
  /**
   *  Update object IDs for given metadata objects.   Version: 10.8.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **metadata**      - **Description:** List of metadata objects to update their object IDs.    - **Usage:**       - Use either `current_obj_id` alone OR use `metadata_identifier` with `type` (when needed).       - When using `metadata_identifier`, the `type` field is required if using a name instead of a GUID.       - The `new_obj_id` field is always required.  ---  ## Note This API is specifically designed for updating object IDs of metadata objects. It internally uses the header update mechanism to perform the changes.  ## Best Practices  1. **Backup Before Update:**      Always export metadata as a backup before initiating the update process.  2. **Validation:**    - When using `current_obj_id`, ensure it matches the existing object ID exactly.    - When using `metadata_identifier` with a name, ensure the `type` is specified correctly.    - Verify that the `new_obj_id` follows your naming conventions and is unique within your system.  ---  ## Examples  ### Using current_obj_id ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with GUID ```json {   \"metadata\": [     {       \"metadata_identifier\": \"01234567-89ab-cdef-0123-456789abcdef\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with name and type ```json {   \"metadata\": [     {       \"metadata_identifier\": \"My Answer\",       \"type\": \"ANSWER\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Multiple objects update ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id_1\",       \"new_obj_id\": \"new_object_id_1\"     },     {       \"metadata_identifier\": \"My Worksheet\",       \"type\": \"LOGICAL_TABLE\",       \"new_obj_id\": \"new_object_id_2\"     }   ] } ```      
   * @param updateMetadataObjIdRequest 
   */
  updateMetadataObjId(updateMetadataObjIdRequest, _options) {
    const requestContextPromise = this.requestFactory.updateMetadataObjId(updateMetadataObjIdRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateMetadataObjId(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Updates an Org object. You can modify Org properties such as name, description, and user associations.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param orgIdentifier ID or name of the Org
   * @param updateOrgRequest 
   */
  updateOrg(orgIdentifier, updateOrgRequest, _options) {
    const requestContextPromise = this.requestFactory.updateOrg(orgIdentifier, updateOrgRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateOrg(rsp)));
    }));
  }
  /**
   *   Version: 9.5.0.cl or later   Updates the properties of a Role object.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To update a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role.
   * @param updateRoleRequest 
   */
  updateRole(roleIdentifier, updateRoleRequest, _options) {
    const requestContextPromise = this.requestFactory.updateRole(roleIdentifier, updateRoleRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateRole(rsp)));
    }));
  }
  /**
   *  Update schedule.    Version: 9.4.0.cl or later   Updates a scheduled Liveboard job.  Requires at least edit access to Liveboards. To update a schedule on behalf of another user, you need `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  The API endpoint allows you to pause a scheduled job, change the status of a paused job. You can also edit the recipients list, frequency of the job, format of the file to send to the recipients in email notifications, PDF options, and time zone setting.      
   * @param scheduleIdentifier Unique ID or name of the schedule.
   * @param updateScheduleRequest 
   */
  updateSchedule(scheduleIdentifier, updateScheduleRequest, _options) {
    const requestContextPromise = this.requestFactory.updateSchedule(scheduleIdentifier, updateScheduleRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateSchedule(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Updates the current configuration of the cluster. You must send the configuration data in JSON format.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.      
   * @param updateSystemConfigRequest 
   */
  updateSystemConfig(updateSystemConfigRequest, _options) {
    const requestContextPromise = this.requestFactory.updateSystemConfig(updateSystemConfigRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateSystemConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Updates a tag object.  You can modify the `name` and `color` properties of a tag object.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Name or Id of the tag.
   * @param updateTagRequest 
   */
  updateTag(tagIdentifier, updateTagRequest, _options) {
    const requestContextPromise = this.requestFactory.updateTag(tagIdentifier, updateTagRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateTag(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a user object.  You can modify user properties such as username, email, and share notification settings. You can also assign new groups and Orgs, remove the user from a group or Org, reset password, and modify user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   * @param updateUserRequest 
   */
  updateUser(userIdentifier, updateUserRequest, _options) {
    const requestContextPromise = this.requestFactory.updateUser(userIdentifier, updateUserRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateUser(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### Supported operations  This API endpoint lets you perform the following operations in a single API request:  * Edit [privileges](https://developers.thoughtspot.com/docs/?pageid=api-user-management#group-privileges) * Add or remove users * Change sharing visibility settings * Add or remove sub-groups * Assign a default Liveboard  or update the existing settings      
   * @param groupIdentifier GUID or name of the group.
   * @param updateUserGroupRequest 
   */
  updateUserGroup(groupIdentifier, updateUserGroupRequest, _options) {
    const requestContextPromise = this.requestFactory.updateUserGroup(groupIdentifier, updateUserGroupRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateUserGroup(rsp)));
    }));
  }
  /**
   *  Update a variable\'s name   Version: 10.14.0.cl or later   Allows updating a variable\'s name in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows updating: * The variable name     
   * @param identifier Unique id or name of the variable to update.
   * @param updateVariableRequest 
   */
  updateVariable(identifier, updateVariableRequest, _options) {
    const requestContextPromise = this.requestFactory.updateVariable(identifier, updateVariableRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateVariable(rsp)));
    }));
  }
  /**
   *  Update values for multiple variables   Version: 10.14.0.cl or later   Allows updating values for multiple variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows: * Adding new values to variables * Replacing existing values * Deleting values from variables  When updating variable values, you need to specify: * The variable identifiers * The values to add/replace/remove for each variable * The operation to perform (ADD, REPLACE, REMOVE, RESET)  Behaviour based on operation type: * ADD - Adds values to the variable if this is a list type variable, else same as replace. * REPLACE - Replaces all values of a given set of constraints with the current set of values. * REMOVE - Removes any values which match the set of conditions of the variables if this is a list type variable, else clears value. * RESET - Removes all constrains for a given variable, scope is ignored      
   * @param updateVariableValuesRequest 
   */
  updateVariableValues(updateVariableValuesRequest, _options) {
    const requestContextPromise = this.requestFactory.updateVariableValues(updateVariableValuesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateVariableValues(rsp)));
    }));
  }
  /**
   *  Version: 10.14.0.cl or later   Updates an existing webhook configuration by its unique id or name. Only the provided fields will be updated.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param webhookIdentifier Unique ID or name of the webhook configuration.
   * @param updateWebhookConfigurationRequest 
   */
  updateWebhookConfiguration(webhookIdentifier, updateWebhookConfigurationRequest, _options) {
    const requestContextPromise = this.requestFactory.updateWebhookConfiguration(webhookIdentifier, updateWebhookConfigurationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateWebhookConfiguration(rsp)));
    }));
  }
  /**
   *  Version: 10.10.0.cl or later   Validates the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   */
  validateEmailCustomization(_options) {
    const requestContextPromise = this.requestFactory.validateEmailCustomization(_options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.validateEmailCustomization(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Validates the content of your source branch against the objects in your destination environment.  Before merging content from your source branch to the destination branch, run this API operation from your destination environment and ensure that the changes from the source branch function in the destination environment.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param validateMergeRequest 
   */
  validateMerge(validateMergeRequest, _options) {
    const requestContextPromise = this.requestFactory.validateMerge(validateMergeRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.validateMerge(rsp)));
    }));
  }
  /**
   *   Version: 9.12.0.cl or later    Validates the authentication token specified in the API request.  If your token is not valid, [Get a new token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param validateTokenRequest 
   */
  validateToken(validateTokenRequest, _options) {
    const requestContextPromise = this.requestFactory.validateToken(validateTokenRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.validateToken(rsp)));
    }));
  }
};
var ObservableUsersApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new UsersApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new UsersApiResponseProcessor();
  }
  /**
   *   Version: 9.7.0.cl or later   Activates a deactivated user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To activate an inactive user account, the API request body must include the following information:  - Username or the GUID of the user account. - Auth token generated for the deactivated user. The auth token is sent in the API response when a user is deactivated. - Password for the user account.      
   * @param activateUserRequest 
   */
  activateUser(activateUserRequest, _options) {
    const requestContextPromise = this.requestFactory.activateUser(activateUserRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.activateUser(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the current password of the user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param changeUserPasswordRequest 
   */
  changeUserPassword(changeUserPasswordRequest, _options) {
    const requestContextPromise = this.requestFactory.changeUserPassword(changeUserPasswordRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.changeUserPassword(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a user in ThoughtSpot.  The API endpoint allows you to configure several user properties such as email address, account status, share notification preferences, and sharing visibility. You can provision the user to [groups](https://docs.thoughtspot.com/cloud/latest/groups-privileges) and [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview). You can also add Liveboard, Answer, and Worksheet objects to the users favorites list, assign a default Liveboard for the user, and set user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param createUserRequest 
   */
  createUser(createUserRequest, _options) {
    const requestContextPromise = this.requestFactory.createUser(createUserRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createUser(rsp)));
    }));
  }
  /**
   *   Version: 9.7.0.cl or later   Deactivates a user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To deactivate a user account, the API request body must include the following information:  - Username or the GUID of the user account - Base URL of the ThoughtSpot instance  If the API request is successful, ThoughtSpot returns the activation URL in the response. The activation URL is valid for 14 days and can be used to re-activate the account and reset the password of the deactivated account.      
   * @param deactivateUserRequest 
   */
  deactivateUser(deactivateUserRequest, _options) {
    const requestContextPromise = this.requestFactory.deactivateUser(deactivateUserRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deactivateUser(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a user from the ThoughtSpot system.  If you want to remove a user from a specific Org but not from ThoughtSpot, update the group and Org mapping properties of the user object via a POST API call to the [/api/rest/2.0/users/{user_identifier}/update](#/http/api-endpoints/users/update-user) endpoint.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   */
  deleteUser(userIdentifier, _options) {
    const requestContextPromise = this.requestFactory.deleteUser(userIdentifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteUser(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Enforces logout on current user sessions.    Use this API with caution as it may invalidate active user sessions and force users to re-login. Make sure you specify the usernames or GUIDs. If you pass null values in the API call, all user sessions on your cluster become invalid, and the users are forced to re-login.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param forceLogoutUsersRequest 
   */
  forceLogoutUsers(forceLogoutUsersRequest, _options) {
    const requestContextPromise = this.requestFactory.forceLogoutUsers(forceLogoutUsersRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.forceLogoutUsers(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Imports user data from external databases into ThoughtSpot. During the user import operation:  * If the specified users are not available in ThoughtSpot, the users are created and assigned a default password. Defining a `default_password` in the API request is optional. * If `delete_unspecified_users` is set to `true`, the users not specified in the API request, excluding the `tsadmin`, `guest`, `system` and `su` users, are deleted. * If the specified user objects are already available in ThoughtSpot, the object properties are updated and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param importUsersRequest 
   */
  importUsers(importUsersRequest, _options) {
    const requestContextPromise = this.requestFactory.importUsers(importUsersRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.importUsers(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Resets the password of a user account. Administrators can reset password on behalf of a user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param resetUserPasswordRequest 
   */
  resetUserPassword(resetUserPasswordRequest, _options) {
    const requestContextPromise = this.requestFactory.resetUserPassword(resetUserPasswordRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.resetUserPassword(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of users available on the ThoughtSpot system.  To get details of a specific user, specify the user GUID or name. You can also filter the API response based on groups, Org ID, user visibility, account status, user type, and user preference settings and favorites.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  **NOTE**: If the API returns an empty list, consider increasing the value of the `record_size` parameter. To search across all available users, set `record_size` to `-1`.      
   * @param searchUsersRequest 
   */
  searchUsers(searchUsersRequest, _options) {
    const requestContextPromise = this.requestFactory.searchUsers(searchUsersRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchUsers(rsp)));
    }));
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a user object.  You can modify user properties such as username, email, and share notification settings. You can also assign new groups and Orgs, remove the user from a group or Org, reset password, and modify user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   * @param updateUserRequest 
   */
  updateUser(userIdentifier, updateUserRequest, _options) {
    const requestContextPromise = this.requestFactory.updateUser(userIdentifier, updateUserRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateUser(rsp)));
    }));
  }
};
var ObservableVariableApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new VariableApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new VariableApiResponseProcessor();
  }
  /**
   *  Create a variable which can be used for parameterizing metadata objects   Version: 10.14.0.cl or later   Allows creating a variable which can be used for parameterizing metadata objects in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports the following types of variables: * CONNECTION_PROPERTY - For connection properties * TABLE_MAPPING - For table mappings * CONNECTION_PROPERTY_PER_PRINCIPAL - For connection properties per principal. In order to use this please contact support to enable this. * FORMULA_VARIABLE - For Formula variables, introduced in 10.15.0.cl  When creating a variable, you need to specify: * The variable type * A unique name for the variable * Whether the variable contains sensitive values (defaults to false) * The data type of the variable, only specify for formula variables (defaults to null)  The operation will fail if: * The user lacks required permissions * The variable name already exists * The variable type is invalid     
   * @param createVariableRequest 
   */
  createVariable(createVariableRequest, _options) {
    const requestContextPromise = this.requestFactory.createVariable(createVariableRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createVariable(rsp)));
    }));
  }
  /**
   *  Delete a variable   Version: 10.14.0.cl or later   Allows deleting a variable from ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint requires: * The variable identifier (ID or name)  The operation will fail if: * The user lacks required permissions * The variable doesn\'t exist * The variable is being used by other objects      
   * @param identifier Unique id or name of the variable
   */
  deleteVariable(identifier, _options) {
    const requestContextPromise = this.requestFactory.deleteVariable(identifier, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteVariable(rsp)));
    }));
  }
  /**
   *  Search variables   Version: 10.14.0.cl or later   Allows searching for variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports searching variables by: * Variable identifier (ID or name) * Variable type * Name pattern (case-insensitive, supports % for wildcard)  The search results can be formatted in three ways: * METADATA - Returns only variable metadata (default) * METADATA_AND_VALUES - Returns variable metadata and values  The values can be filtered by scope: * org_identifier * principal_identifier * model_identifier      
   * @param searchVariablesRequest 
   */
  searchVariables(searchVariablesRequest, _options) {
    const requestContextPromise = this.requestFactory.searchVariables(searchVariablesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchVariables(rsp)));
    }));
  }
  /**
   *  Update a variable\'s name   Version: 10.14.0.cl or later   Allows updating a variable\'s name in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows updating: * The variable name     
   * @param identifier Unique id or name of the variable to update.
   * @param updateVariableRequest 
   */
  updateVariable(identifier, updateVariableRequest, _options) {
    const requestContextPromise = this.requestFactory.updateVariable(identifier, updateVariableRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateVariable(rsp)));
    }));
  }
  /**
   *  Update values for multiple variables   Version: 10.14.0.cl or later   Allows updating values for multiple variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows: * Adding new values to variables * Replacing existing values * Deleting values from variables  When updating variable values, you need to specify: * The variable identifiers * The values to add/replace/remove for each variable * The operation to perform (ADD, REPLACE, REMOVE, RESET)  Behaviour based on operation type: * ADD - Adds values to the variable if this is a list type variable, else same as replace. * REPLACE - Replaces all values of a given set of constraints with the current set of values. * REMOVE - Removes any values which match the set of conditions of the variables if this is a list type variable, else clears value. * RESET - Removes all constrains for a given variable, scope is ignored      
   * @param updateVariableValuesRequest 
   */
  updateVariableValues(updateVariableValuesRequest, _options) {
    const requestContextPromise = this.requestFactory.updateVariableValues(updateVariableValuesRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateVariableValues(rsp)));
    }));
  }
};
var ObservableVersionControlApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new VersionControlApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new VersionControlApiResponseProcessor();
  }
  /**
   *   Version: 9.2.0.cl or later   Commits TML files of metadata objects to the Git branch configured on your instance.  Requires at least edit access to objects used in the commit operation.  Before using this endpoint to push your commits:  * Enable Git integration on your instance. * Make sure the Git repository and branch details are configured on your instance.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitBranchRequest 
   */
  commitBranch(commitBranchRequest, _options) {
    const requestContextPromise = this.requestFactory.commitBranch(commitBranchRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.commitBranch(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to connect a ThoughtSpot instance to a Git repository.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.  You can use this API endpoint to connect your ThoughtSpot development and production environments to the development and production branches of a Git repository.  Before using this endpoint to connect your ThoughtSpot instance to a Git repository, check the following prerequisites:  * You have a Git repository. If you are using GitHub, make sure you have a valid account and an access token to connect ThoughtSpot to GitHub. For information about generating a token, see [GitHub Documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).  * Your access token has `repo` scope that grants full access to public and private repositories. * Your Git repository has a branch that can be configured as a default branch in ThoughtSpot.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/?pageid=git-integration).  **Note**: ThoughtSpot supports only GitHub / itHub Enterprise for CI/CD.      
   * @param createConfigRequest 
   */
  createConfig(createConfigRequest, _options) {
    const requestContextPromise = this.requestFactory.createConfig(createConfigRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Deletes Git repository configuration from your ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param deleteConfigRequest 
   */
  deleteConfig(deleteConfigRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteConfig(deleteConfigRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to deploy a commit and publish TML content to your ThoughtSpot instance.  Requires at least edit access to the objects used in the deploy operation.  The API deploys the head of the branch unless a `commit_id` is specified in the API request. If the branch name is not defined in the request, the default branch is considered for deploying commits.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param deployCommitRequest 
   */
  deployCommit(deployCommitRequest, _options) {
    const requestContextPromise = this.requestFactory.deployCommit(deployCommitRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deployCommit(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Reverts TML objects to a previous commit specified in the API request.  Requires at least edit access to objects.  In the API request, specify the `commit_id`. If the branch name is not specified in the request, the API will consider the default branch configured on your instance.  By default, the API reverts all objects. If the revert operation fails for one of the objects provided in the commit, the API returns an error and does not revert any object.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitId Commit id to which the object should be reverted
   * @param revertCommitRequest 
   */
  revertCommit(commitId, revertCommitRequest, _options) {
    const requestContextPromise = this.requestFactory.revertCommit(commitId, revertCommitRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.revertCommit(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of commits for a given metadata object.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param searchCommitsRequest 
   */
  searchCommits(searchCommitsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchCommits(searchCommitsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchCommits(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Gets Git repository connections configured on the ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param searchConfigRequest 
   */
  searchConfig(searchConfigRequest, _options) {
    const requestContextPromise = this.requestFactory.searchConfig(searchConfigRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Updates Git repository configuration settings.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param updateConfigRequest 
   */
  updateConfig(updateConfigRequest, _options) {
    const requestContextPromise = this.requestFactory.updateConfig(updateConfigRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateConfig(rsp)));
    }));
  }
  /**
   *   Version: 9.2.0.cl or later   Validates the content of your source branch against the objects in your destination environment.  Before merging content from your source branch to the destination branch, run this API operation from your destination environment and ensure that the changes from the source branch function in the destination environment.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param validateMergeRequest 
   */
  validateMerge(validateMergeRequest, _options) {
    const requestContextPromise = this.requestFactory.validateMerge(validateMergeRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.validateMerge(rsp)));
    }));
  }
};
var ObservableWebhooksApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.configuration = configuration;
    this.requestFactory = requestFactory || new WebhooksApiRequestFactory(configuration);
    this.responseProcessor = responseProcessor || new WebhooksApiResponseProcessor();
  }
  /**
   *  Version: 10.14.0.cl or later   Creates a new webhook configuration to receive notifications for specified events. The webhook will be triggered when the configured events occur in the system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param createWebhookConfigurationRequest 
   */
  createWebhookConfiguration(createWebhookConfigurationRequest, _options) {
    const requestContextPromise = this.requestFactory.createWebhookConfiguration(createWebhookConfigurationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.createWebhookConfiguration(rsp)));
    }));
  }
  /**
   *  Version: 10.14.0.cl or later   Deletes one or more webhook configurations by their unique id or name. Returns status of each deletion operation, including successfully deleted webhooks and any failures with error details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param deleteWebhookConfigurationsRequest 
   */
  deleteWebhookConfigurations(deleteWebhookConfigurationsRequest, _options) {
    const requestContextPromise = this.requestFactory.deleteWebhookConfigurations(deleteWebhookConfigurationsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.deleteWebhookConfigurations(rsp)));
    }));
  }
  /**
   *  Version: 10.14.0.cl or later   Searches for webhook configurations based on various criteria such as Org, webhook identifier, event type, with support for pagination and sorting. Returns matching webhook configurations with their complete details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param searchWebhookConfigurationsRequest 
   */
  searchWebhookConfigurations(searchWebhookConfigurationsRequest, _options) {
    const requestContextPromise = this.requestFactory.searchWebhookConfigurations(searchWebhookConfigurationsRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.searchWebhookConfigurations(rsp)));
    }));
  }
  /**
   *  Version: 10.14.0.cl or later   Updates an existing webhook configuration by its unique id or name. Only the provided fields will be updated.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param webhookIdentifier Unique ID or name of the webhook configuration.
   * @param updateWebhookConfigurationRequest 
   */
  updateWebhookConfiguration(webhookIdentifier, updateWebhookConfigurationRequest, _options) {
    const requestContextPromise = this.requestFactory.updateWebhookConfiguration(webhookIdentifier, updateWebhookConfigurationRequest, _options);
    let middlewarePreObservable = from(requestContextPromise);
    for (let middleware of this.configuration.middleware) {
      middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx) => middleware.pre(ctx)));
    }
    return middlewarePreObservable.pipe(mergeMap((ctx) => this.configuration.httpApi.send(ctx))).pipe(mergeMap((response) => {
      let middlewarePostObservable = of(response);
      for (let middleware of this.configuration.middleware) {
        middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp) => middleware.post(rsp)));
      }
      return middlewarePostObservable.pipe(map((rsp) => this.responseProcessor.updateWebhookConfiguration(rsp)));
    }));
  }
};

// types/PromiseAPI.ts
var PromiseAIApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableAIApi(configuration, requestFactory, responseProcessor);
  }
  /**
   * Version: 10.13.0.cl or later 
   * @param createAgentConversationRequest 
   */
  createAgentConversation(createAgentConversationRequest, _options) {
    const result = this.api.createAgentConversation(createAgentConversationRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.4.0.cl or later   Creates a Conversation object to start an AI-driven conversation based on a specific data model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  This API requires the `metadata_identifier` parameter to define the context for the conversation.  You can also specify the tokens to initiate the conversation as shown in this example:  `\"tokens\": \"[tea],[sales],[type]\"`  If the API request is successful, ThoughtSpot returns the ID of the conversation.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param createConversationRequest 
   */
  createConversation(createConversationRequest, _options) {
    const result = this.api.createConversation(createConversationRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.13.0.cl or later   Breaks down a user-submitted query into a series of analytical sub-questions using relevant contextual metadata.  To use this API, the user must have at least view-level access to the referenced metadata objects.  #### Usage guidelines  To accurately generate relevant questions, the request must include at least one of the following metadata identifiers within `metadata_context` : `conversation_identifier`, `answer_identifiers`, `liveboard_identifiers`, or `data_source_identifiers`.  You can further enhance the quality and precision of breakdown by providing additional `ai_context` such as:  - `content`: User provided content like text data, csv data as a string message to provide context & potentially improve the quality of the response. - `instructions`: User specific text instructions sent to AI system for processing the query.  Additional optional parameters include:  - `limit_relevant_questions`: Controls the maximum number of relevant questions returned. Defaults to 5 if not specified. - `bypass_cache`: If set to true, forces fresh computation instead of returning cached results.  If the API request is successful, ThoughtSpot returns a list of relevant analytical queries, each aligned with the user\'s original question. Each returned question includes the query string, along with the identifier and name of the corresponding data source.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.     
   * @param getRelevantQuestionsRequest 
   */
  getRelevantQuestions(getRelevantQuestionsRequest, _options) {
    const result = this.api.getRelevantQuestions(getRelevantQuestionsRequest, _options);
    return result.toPromise();
  }
  /**
   * Version: 10.7.0.cl or later 
   * @param queryGetDecomposedQueryRequest 
   */
  queryGetDecomposedQuery(queryGetDecomposedQueryRequest, _options) {
    const result = this.api.queryGetDecomposedQuery(queryGetDecomposedQueryRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.13.0.cl or later   This API allows users to initiate or continue an agent (Spotter) conversation by submitting one or more natural language messages.  To use this API, the user must have access to the relevant conversational session (via conversation_identifier) and submit at least one message.   #### Usage guidelines  To initiate or continue a conversation, the request must include: - `conversation_identifier`: a unique session ID for continuity and message tracking - `messages`: an array of one or more text messages, each with a value and type  Additionally, user can specify what tool can be included `conversation_settings` parameter, which supports: - `enable_contextual_change_analysis` (default: false) - `enable_natural_language_answer_generation` (default: true) - `enable_reasoning` (default: false)  If the request is valid, the API returns a stream of messages in real time, including: - `ack`: confirms receipt of the request - `text / text-chunk`: content chunks, optionally formatted (e.g., markdown) - `answer`: the final structured response with metadata and analytics - `error`: if a failure occurs - `notification`: notification messages for operation being performed  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster. > * The streaming protocol uses Server-Sent Events (SSE)     
   * @param sendAgentMessageStreamingRequest 
   */
  sendAgentMessageStreaming(sendAgentMessageStreamingRequest, _options) {
    const result = this.api.sendAgentMessageStreaming(sendAgentMessageStreamingRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.4.0.cl or later   Allows sending a follow-up message to an ongoing conversation within the context of the metadata model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  The API requires you to specify the `conversation_identifier` in the request path, and a `metadata_identifier` and `message` string in the request body.  If the API request is successful, ThoughtSpot returns the session ID, tokens used in the conversation, and visualization type.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param conversationIdentifier Unique identifier of the conversation.
   * @param sendMessageRequest 
   */
  sendMessage(conversationIdentifier, sendMessageRequest, _options) {
    const result = this.api.sendMessage(conversationIdentifier, sendMessageRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.4.0.cl or later   Processes a natural language query and returns an AI-generated response based on a specified data model.  Requires at least view access to the metadata object specified in the request.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param singleAnswerRequest 
   */
  singleAnswer(singleAnswerRequest, _options) {
    const result = this.api.singleAnswer(singleAnswerRequest, _options);
    return result.toPromise();
  }
};
var PromiseAuthenticationApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableAuthenticationApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves details of the current user session for the token provided in the request header.  Any ThoughtSpot user can access this endpoint and send an API request. The data returned in the API response varies according to user\'s privilege and object access permissions.     
   */
  getCurrentUserInfo(_options) {
    const result = this.api.getCurrentUserInfo(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.4.0.cl or later   Retrieves details of the current session token for the bearer token provided in the request header.  This API endpoint does not create a new token. Instead, it returns details about the token, including the token string, creation time, expiration time, and the associated user.  Use this endpoint to introspect your current session token, debug authentication issues, or when a frontend application needs session token details.  Any ThoughtSpot user with a valid bearer token can access this endpoint and send an API request      
   */
  getCurrentUserToken(_options) {
    const result = this.api.getCurrentUserToken(_options);
    return result.toPromise();
  }
  /**
   *   Version: 10.4.0.cl or later   Gets an authentication token with custom rules and security attributes and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  To add a new user and assign privileges during auto creation, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  To assign security attributes with filter rules and Parameters to the JWT token, you\'ll need administrator privileges and edit access to the data source (Worksheet or Model). If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  #### Usage guidelines  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key`.  To generate a `secret_key` on your cluster, the administrator must enable [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable) in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  ##### Attribute-Based Access Control (ABAC) with tokens  To implement Attribute-Based Access Control (ABAC) and assign security entitlements to users during session creation, you can generate a token with custom filtering rules and Parameters in the `filter_rules` and `parameter_values` array respectively. These attributes can be configured to persist on a specific set of objects for user sessions initiated using the token. Once defined, the rules are added to the user\'s `access_control_properties` object, after which all sessions will use the persisted values.  Specify the object type as `LOGICAL_TABLE`.   For more information, see [ABAC via tokens Documentation](https://developers.thoughtspot.com/docs/api-authv2#_get_tokens_with_custom_rules_and_filter_conditions).  ##### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `groups`  Set `auto_create` to `true` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true` in the API request, the user properties such as the display name, email, Org and group assignment will not be updated with new values. If `auto_create` is set to `true`, it won\'t create formula variables and hence won\'t be applicable for `variable_values`.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  ##### Important point to note All options in the token creation APIs that define access to the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created. Persist options such as  `APPEND`, `REPLACE`, `RESET` will persist security parameters on the user profile when the token is created, while Persist option `NONE` will not persist anything but will be honoured in the session.  ##### Formula Variables Before using variables_values, variables must be created using Create Variable API with type as Formula_Variable (/api/rest/2.0/template/variables/create) The persist_option RESET and NONE cannot be used when variable_values are provided in the request. If you are working with variable_values, you must use other (APPEND, REPLACE) supported modes. If you want to use RESET or NONE, do not pass any variable_values. In such cases, variable_values will remain unaffected. When using object_id with variable_values, models are supported.      
   * @param getCustomAccessTokenRequest 
   */
  getCustomAccessToken(getCustomAccessTokenRequest, _options) {
    const result = this.api.getCustomAccessToken(getCustomAccessTokenRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page. For more information, see [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable).  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getFullAccessTokenRequest 
   */
  getFullAccessToken(getFullAccessTokenRequest, _options) {
    const result = this.api.getFullAccessToken(getFullAccessTokenRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token that provides access to a specific metadata object. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request,  `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getObjectAccessTokenRequest 
   */
  getObjectAccessToken(getObjectAccessTokenRequest, _options) {
    const result = this.api.getObjectAccessToken(getObjectAccessTokenRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a login session for a ThoughtSpot user with Basic authentication.  In Basic authentication method, REST clients log in to ThoughtSpot using `username` and `password` attributes. On a multi-tenant cluster with Orgs, users can pass the ID of the Org in the API request to log in to a specific Org context.  **Note**: If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. Contact ThoughtSpot Support for assistance.  A successful login returns a session cookie that can be used in your subsequent API requests.     
   * @param loginRequest 
   */
  login(loginRequest, _options) {
    const result = this.api.login(loginRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later    Logs out a user from their current session.      
   */
  logout(_options) {
    const result = this.api.logout(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later    Revokes the authentication token issued for current user session.  The token of your current session expires when you make a call to the `/api/rest/2.0/auth/token/revoke` endpoint. the users will not be able to access ThoughtSpot objects until a new token is obtained.  To restart your session, request for a new token from ThoughtSpot. See [Get Full Access Token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param revokeTokenRequest 
   */
  revokeToken(revokeTokenRequest, _options) {
    const result = this.api.revokeToken(revokeTokenRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.12.0.cl or later    Validates the authentication token specified in the API request.  If your token is not valid, [Get a new token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param validateTokenRequest 
   */
  validateToken(validateTokenRequest, _options) {
    const result = this.api.validateToken(validateTokenRequest, _options);
    return result.toPromise();
  }
};
var PromiseConnectionConfigurationsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableConnectionConfigurationsApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 10.12.0.cl or later   Gets connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines * To get a list of all configurations available in the ThoughtSpot system, send the API request with only the connection name or GUID in the request body. * To fetch details of a configuration object, specify the configuration object name or GUID.      
   * @param connectionConfigurationSearchRequest 
   */
  connectionConfigurationSearch(connectionConfigurationSearchRequest, _options) {
    const result = this.api.connectionConfigurationSearch(connectionConfigurationSearchRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Creates an additional configuration to an existing connection to a data warehouse.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines   * A JSON map of configuration attributes in `configuration`. The following example shows the configuration attributes:   ```    {      \"user\":\"DEV_USER\",      \"password\":\"TestConn123\",      \"role\":\"DEV\",      \"warehouse\":\"DEV_WH\"     }   ```  * If the `policy_type` is `PRINCIPALS`, then `policy_principals` is a required field. * If the `policy_type` is `PROCESSES`, then `policy_processes` is a required field. * If the `policy_type` is `NO_POLICY`, then `policy_principals` and `policy_processes` are not required fields.  #### Parameterized Connection Support For parameterized connections that use OAuth authentication, only the same_as_parent and policy_process_options  attributes are allowed in the API request. These attributes are not applicable to connections that are not parameterized.       
   * @param createConnectionConfigurationRequest 
   */
  createConnectionConfiguration(createConnectionConfigurationRequest, _options) {
    const result = this.api.createConnectionConfiguration(createConnectionConfigurationRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param deleteConnectionConfigurationRequest 
   */
  deleteConnectionConfiguration(deleteConnectionConfigurationRequest, _options) {
    const result = this.api.deleteConnectionConfiguration(deleteConnectionConfigurationRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Updates a connection configuration object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Supported operations This API endpoint lets you perform the following operations in a single API request:   * Edit the name or description of the configuration  * Edit the configuration properties  * Edit the `policy_type`  * Edit the type of authentication  * Enable or disable a configuration  #### Parameterized Connection Support For parameterized oauth based connections, only the `same_as_parent` and `policy_process_options` attributes are allowed. These attributes are not applicable to connections that are not parameterized.   **NOTE**: When updating a configuration where `disabled` is `true`, you must reset `disabled` to `true` in your update request payload. If not explicitly set again, the API will default `disabled` to `false`.      
   * @param configurationIdentifier Unique ID or name of the configuration.
   * @param updateConnectionConfigurationRequest 
   */
  updateConnectionConfiguration(configurationIdentifier, updateConnectionConfigurationRequest, _options) {
    const result = this.api.updateConnectionConfiguration(configurationIdentifier, updateConnectionConfigurationRequest, _options);
    return result.toPromise();
  }
};
var PromiseConnectionsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableConnectionsApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.2.0.cl or later   Creates a connection to a data warehouse for live query services.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Create a connection without tables  To create a connection without tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a SnowFlake connection:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[       ]   }   ``` 2. Set `validate` to `false`.  #### Create a connection with tables  To create a connection with tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[         {            \"name\":\"AllDatatypes\",            \"isAutoCreated\":false,            \"schemas\":[               {                  \"name\":\"alldatatypes\",                  \"tables\":[                     {                        \"name\":\"allDatatypes\",                        \"type\":\"TABLE\",                        \"description\":\"\",                        \"selected\":true,                        \"linked\":true,                        \"columns\":[                           {                              \"name\":\"CNUMBER\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           },                           {                              \"name\":\"CDECIMAL\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           }                        ]                     }                  ]               }            ]         }      ]   }   ``` 2. Set `validate` to `true`.      
   * @param createConnectionRequest 
   */
  createConnection(createConnectionRequest, _options) {
    const result = this.api.createConnection(createConnectionRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later    **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Delete Connection V2](#/http/api-endpoints/connections/delete-connection-v2) endpoint to delete your connection objects.    #### Usage guidelines  Deletes a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.     
   * @param deleteConnectionRequest 
   */
  deleteConnection(deleteConnectionRequest, _options) {
    const result = this.api.deleteConnection(deleteConnectionRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.4.0.cl or later   Deletes a connection object.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param connectionIdentifier Unique ID or name of the connection.
   */
  deleteConnectionV2(connectionIdentifier, _options) {
    const result = this.api.deleteConnectionV2(connectionIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Exports the difference in connection metadata between CDW and ThoughtSpot  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:   - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  To download the connection metadata difference between ThoughtSpot and CDW, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  downloadConnectionMetadataChanges(connectionIdentifier, _options) {
    const result = this.api.downloadConnectionMetadataChanges(connectionIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Validates the difference in connection metadata between CDW and ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  Returns a boolean indicating whether there is any difference between the connection metadata at ThoughtSpot and CDW.  To get the connection metadata difference status, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  fetchConnectionDiffStatus(connectionIdentifier, _options) {
    const result = this.api.fetchConnectionDiffStatus(connectionIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Gets connection objects. Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  - To get a list of all connections available in the ThoughtSpot system, send the API request without any attributes in the request body. - To get the connection objects for a specific type of data warehouse, specify the type in `data_warehouse_types`. - To fetch details of a connection object, specify the connection object GUID or name. The `name_pattern` attribute allows passing partial text with `%` for a wildcard match. - To get details of the database, schemas, tables, or columns from a data connection object, specify `data_warehouse_object_type`. - To get a specific database, schema, table, or column from a connection object, define the object type in `data_warehouse_object_type` and object properties in the `data_warehouse_objects` array. For example, to search for a column, you must pass the database, schema, and table names in the API request.   Note that in the following example, object properties are set in a hierarchical order (`database` > `schema` > `table` > `column`).  ``` {   \"connections\": [     {       \"identifier\": \"b9d1f2ef-fa65-4a4b-994e-30fa2d57b0c2\",       \"data_warehouse_objects\": [         {           \"database\": \"NEBULADEV\",           \"schema\": \"INFORMATION_SCHEMA\",           \"table\": \"APPLICABLE_ROLES\",           \"column\": \"ROLE_NAME\"         }       ]     }   ],   \"data_warehouse_object_type\": \"COLUMN\" } ```  - To fetch data by `configuration`, specify `data_warehouse_object_type`. For example, to fetch columns from the `DEVELOPMENT` database, specify the `data_warehouse_object_type` as `DATABASE` and define the `configuration` string as `{\"database\":\"DEVELOPMENT\"}`. To get column data for a specific table, specify the table, for example,`{\"database\":\"RETAILAPPAREL\",\"table\":\"PIPES\"}`. - To query connections by `authentication_type`, specify `data_warehouse_object_type`. Supported values for `authentication_type` are:   - `SERVICE_ACCOUNT`: For connections that require service account credentials to authenticate to the Cloud Data Warehouse and fetch data.   - `OAUTH`: For connections that require OAuth credentials to authenticate to the Cloud Data Warehouse and fetch data. Teradata, Oracle, and Presto Cloud Data Warehouses do not support the OAuth authentication type.   - `IAM`: For connections that have the IAM OAuth set up. This authentication type is supported on Amazon Redshift connections only.   - `EXTOAUTH`: For connections that have External OAuth set up. ThoughtSpot supports external [OAuth with Microsoft Azure Active Directory (AD)](https://docs.thoughtspot.com/cloud/latest/ connections-snowflake-azure-ad-oauth) and [Okta for Snowflake data connections](https://docs.thoughtspot.com/cloud/latest/connections-snowflake-okta-oauth).   - `KEY_PAIR`: For connections that require Key Pair account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PKCE`: For connections that require OAuth with PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake, Starburst, Databricks, Denodo  connections only.   - `EXTOAUTH_WITH_PKCE`: For connections that require External OAuth With PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PEZ`: For connections that require OAuth With PEZ account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Amazon Redshift connections only.   - `OAUTH_WITH_SERVICE_PRINCIPAL`: For connections that require OAuth With Service Principal account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `PERSONAL_ACCESS_TOKEN`: For connections that require Personal Access Token account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `OAUTH_CLIENT_CREDENTIALS`: For connections that require OAuth Client Credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only. - To include more details about connection objects in the API response, set `include_details` to `true`. - You can also sort the output by field names and filter connections by tags.  **NOTE**: When filtering connection records by parameters other than `data_warehouse_types` or `tag_identifiers`, ensure that you set `record_size` to `-1` and `record_offset` to `0` for precise results.      
   * @param searchConnectionRequest 
   */
  searchConnection(searchConnectionRequest, _options) {
    const result = this.api.searchConnection(searchConnectionRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Update connection V2](#/http/api-endpoints/connections/update-connection-v2) endpoint to update your connection objects.  #### Usage guidelines  Updates a connection object.    Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`. 3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.      
   * @param updateConnectionRequest 
   */
  updateConnection(updateConnectionRequest, _options) {
    const result = this.api.updateConnection(updateConnectionRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.4.0.cl or later   Updates a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`.        **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.     * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:    * This is an example of updating a single table in a empty connection:           ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"DEMORENAME\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"Col1\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col2\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col3\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col312\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col4\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```        * This is an example of updating a single table in an existing connection with tables:            ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"CUSTOMER\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [],                     \"relationships\": []                   },                   {                     \"name\": \"tpch5k_falcon_default_schema_users\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"user_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"product_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"user_cost\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```  3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.    **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not  specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.    * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a Snowflake connection:    ```    {       \"configuration\":{          \"accountName\":\"thoughtspot_partner\",          \"user\":\"tsadmin\",          \"password\":\"TestConn123\",          \"role\":\"sysadmin\",          \"warehouse\":\"MEDIUM_WH\"       },       \"externalDatabases\":[        ]    }    ```      
   * @param connectionIdentifier Unique ID or name of the connection.
   * @param updateConnectionV2Request 
   */
  updateConnectionV2(connectionIdentifier, updateConnectionV2Request, _options) {
    const result = this.api.updateConnectionV2(connectionIdentifier, updateConnectionV2Request, _options);
    return result.toPromise();
  }
};
var PromiseCustomActionApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableCustomActionApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.6.0.cl or later   Creates a custom action that appears as a menu action on a saved Answer or Liveboard visualization.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API lets you create the following types of custom actions:  * URL-based action        Allows pushing data to an external URL. * Callback action           Triggers a callback to the host application and initiates a response payload on an embedded ThoughtSpot instance.  By default, custom actions are visible to only administrator or developer users. To make a custom action available to other users, and specify the groups in `group_identifiers`.  By default, the custom action is set as a _global_ action on all visualizations and saved Answers. To assign a custom action to specific Liveboard visualization, saved Answer, or Worksheet, set `visibility` to `false` in `default_action_config` property and specify the GUID or name of the object in `associate_metadata`.  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param createCustomActionRequest 
   */
  createCustomAction(createCustomActionRequest, _options) {
    const result = this.api.createCustomAction(createCustomActionRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.6.0.cl or later   Removes the custom action specified in the API request.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param customActionIdentifier Unique ID or name of the custom action.
   */
  deleteCustomAction(customActionIdentifier, _options) {
    const result = this.api.deleteCustomAction(customActionIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.6.0.cl or later   Gets custom actions configured on the cluster.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param searchCustomActionsRequest 
   */
  searchCustomActions(searchCustomActionsRequest, _options) {
    const result = this.api.searchCustomActions(searchCustomActionsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.6.0.cl or later   Updates a custom action.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API allows you to modify the following properties:  * Name of the custom action * Action availability to groups * Association to metadata objects * Authentication settings for a URL-based action  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param customActionIdentifier Unique ID or name of the custom action.
   * @param updateCustomActionRequest 
   */
  updateCustomAction(customActionIdentifier, updateCustomActionRequest, _options) {
    const result = this.api.updateCustomAction(customActionIdentifier, updateCustomActionRequest, _options);
    return result.toPromise();
  }
};
var PromiseCustomCalendarsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableCustomCalendarsApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 10.12.0.cl or later   Creates a new [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.   #### Usage guidelines  You can create a custom calendar from scratch or an existing Table in ThoughtSpot. For both methods of calendar creation, the following parameters are required:  * Name of the custom calendar. * Calendar creation method. To create a calendar from an existing table, specify the method:   - `FROM_EXISTING_TABLE` - Creates calendar from the table reference provided in the API request.  - `FROM_INPUT_PARAMS` - Creates a calendar from the parameters defined in the API request.  * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  **NOTE**: If you are creating a calendar from an existing table, ensure that the referenced table matches the required DDL for custom calendars. If the schema does not match, the API returns an error.  ##### Calendar type The API allows you to create the following types of calendars:  * `MONTH_OFFSET`. The default calendar type. A `MONTH_OFFSET` calendar is offset by a few months from the standard calendar months (January to December) and the year begins with the month defined in the request. For example, if the `month_offset` value is set as `April`, the calendar year begins in April.  * `4-4-5`. Each quarter in the calendar will include two 4-week months followed by one 5-week month. * `4-5-4`. Each quarter in the calendar will include two 4-week months with a 5-week month between. * `5-4-4`. Each quarter begins with a 5-week month, followed by two 4-week months.  To start and end the calendar on a specific date, specify the dates in the `MM/DD/YYYY` format. For `MONTH_OFFSET` calendars, ensure that the `start_date` matches the month specified in the `month_offset` attribute.  You can also set the starting day of the week and customize the prefixes for year and quarter labels.  #### Examples  To create a calendar from an existing table:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_EXISTING_TABLE\", } ```  To create a calendar from scratch:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_INPUT_PARAMS\",   \"calendar_type\": \"MONTH_OFFSET\",   \"month_offset\": \"April\",   \"start_day_of_week\": \"Monday\",   \"quarter_name_prefix\": \"Q\",   \"year_name_prefix\": \"FY\",   \"start_date\": \"04/01/2025\",   \"end_date\": \"04/31/2025\" } ```      
   * @param createCalendarRequest 
   */
  createCalendar(createCalendarRequest, _options) {
    const result = this.api.createCalendar(createCalendarRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines To delete a custom calendar, specify the calendar ID as a path parameter in the request URL.        
   * @param calendarIdentifier Unique ID or name of the Calendar.
   */
  deleteCalendar(calendarIdentifier, _options) {
    const result = this.api.deleteCalendar(calendarIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Exports a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal) in the CSV format.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  Use this API to download a custom calendar in the CSV file format. In your API request, specify the following parameters.  * Start and end date of the calendar. For \"month offset\" calendars, the start date must match the month defined in the `month_offset` attribute.  You can also specify optional parameters such as the starting day of the week and prefixes for the quarter and year labels.      
   * @param generateCSVRequest 
   */
  generateCSV(generateCSVRequest, _options) {
    const result = this.api.generateCSV(generateCSVRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Gets a list of [custom calendars](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  By default, the API returns a list of custom calendars for all connection objects. To retrieve custom calendar details for a particular connection, specify the connection ID. You can also use other search parameters such as `name_pattern` and `sort_options` as search filters.  The `name_pattern` parameter filters and returns only those objects that match the specified pattern. Use `%` as a wildcard for pattern matching.      
   * @param searchCalendarsRequest 
   */
  searchCalendars(searchCalendarsRequest, _options) {
    const result = this.api.searchCalendars(searchCalendarsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Updates the properties of a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  You can update the properties of a calendar using one of the following methods: * `FROM_INPUT_PARAMS` to update the calendar properties with the values defined in the API request. * `FROM_EXISTING_TABLE` Creates a calendar from the parameters defined in the API request.  To update a custom calendar, specify the calendar ID as a path parameter in the request URL and the following parameters in the request body:    * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  The API allows you to modify the calendar type, month offset value, start and end date, starting day of the week, and prefixes assigned to the year and quarter labels.     #### Examples  Update a custom calendar using an existing Table in ThoughtSpot:  ``` {   \"update_method\": \"FROM_EXISTING_TABLE\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   } } ```  Update a custom calendar with the attributes defined in the API request:  ``` {   \"update_method\": \"FROM_INPUT_PARAMS\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   },   \"month_offset\": \"August\",   \"start_day_of_week\": \"Monday\",   \"start_date\": \"08/01/2025\",   \"end_date\": \"07/31/2026\" } ```      
   * @param calendarIdentifier Unique Id or name of the calendar.
   * @param updateCalendarRequest 
   */
  updateCalendar(calendarIdentifier, updateCalendarRequest, _options) {
    const result = this.api.updateCalendar(calendarIdentifier, updateCalendarRequest, _options);
    return result.toPromise();
  }
};
var PromiseDBTApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableDBTApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.9.0.cl or later   Creates a DBT connection object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About create DBT connection DBT connection in ThoughtSpot is used by the user to define DBT credentials for cloud . The API needs  embrace connection, embrace database name, DBT url, import type, DBT account identifier, DBT project identifier, DBT access token and environment details (or) embrace connection, embrace database name, import type, file_content to create a connection object. To know more about DBT, see ThoughtSpot Product Documentation.      
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  dbtConnection(connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    const result = this.api.dbtConnection(connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Resynchronize the existing list of models, tables, worksheet tmls and import them to Thoughtspot based on the DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateSyncTml(dbtConnectionIdentifier, fileContent, _options) {
    const result = this.api.dbtGenerateSyncTml(dbtConnectionIdentifier, fileContent, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Generate required table and worksheet and import them.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About generate TML Models and Worksheets to be imported can be selected by the user as part of the API.      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param modelTables List of Models and their respective Tables Example: \\\&#39;[{\\\&quot;model_name\\\&quot;: \\\&quot;model_name\\\&quot;, \\\&quot;tables\\\&quot;: [\\\&quot;table_name\\\&quot;]}]\\\&#39;
   * @param importWorksheets Mention the worksheet tmls to import
   * @param worksheets List of worksheets is mandatory when import_Worksheets is type SELECTED Example: [\\\&quot;worksheet_name\\\&quot;]
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateTml(dbtConnectionIdentifier, modelTables, importWorksheets, worksheets, fileContent, _options) {
    const result = this.api.dbtGenerateTml(dbtConnectionIdentifier, modelTables, importWorksheets, worksheets, fileContent, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Gets a list of DBT connection objects by user and organization, available on the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About search DBT connection To get details of a specific DBT connection identifier, database connection identifier, database connection name, database name, project name, project identifier, environment identifier , import type and author.      
   */
  dbtSearch(_options) {
    const result = this.api.dbtSearch(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Removes the specified DBT connection object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   */
  deleteDbtConnection(dbtConnectionIdentifier, _options) {
    const result = this.api.deleteDbtConnection(dbtConnectionIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Updates a DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About update DBT connection You can modify DBT connection object properties such as embrace connection name, embrace database name, import type, account identifier, access token, project identifier and environment (or) embrace connection, embrace database name, import type, file_content settings.      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  updateDbtConnection(dbtConnectionIdentifier, connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    const result = this.api.updateDbtConnection(dbtConnectionIdentifier, connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options);
    return result.toPromise();
  }
};
var PromiseDataApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableDataApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches data from a saved Answer.  Requires at least view access to the saved Answer.  The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_apis).     
   * @param fetchAnswerDataRequest 
   */
  fetchAnswerData(fetchAnswerDataRequest, _options) {
    const result = this.api.fetchAnswerData(fetchAnswerDataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets data from a Liveboard object and its visualization.    Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To get data for specific visualizations, add the GUIDs or names of the visualizations in the API request.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes. If the new Liveboard experience mode, the transient content includes ad hoc changes to visualizations such as sorting, toggling of legends, and data drill down.  For more information, and see [Liveboard data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_fetch_liveboard_data_api).     
   * @param fetchLiveboardDataRequest 
   */
  fetchLiveboardData(fetchLiveboardDataRequest, _options) {
    const result = this.api.fetchLiveboardData(fetchLiveboardDataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Generates an Answer from a given data source.  Requires at least view access to the data source object (Worksheet or View).  #### Usage guidelines  To search data, specify the data source GUID in `logical_table_identifier`. The data source can be a Worksheet, View, Table, or SQL view.  Pass search tokens in the `query_string` attribute in the API request as shown in the following example:  ``` {   \"query_string\": \"[sales] by [store]\",   \"logical_table_identifier\": \"cd252e5c-b552-49a8-821d-3eadaa049cca\", } ```  For more information about the `query_string` format and data source attribute, see [Search data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_search_data_api).    The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_api).       
   * @param searchDataRequest 
   */
  searchData(searchDataRequest, _options) {
    const result = this.api.searchData(searchDataRequest, _options);
    return result.toPromise();
  }
};
var PromiseEmailCustomizationApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableEmailCustomizationApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *  Version: 10.10.0.cl or later   Creates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To create a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param createEmailCustomizationRequest 
   */
  createEmailCustomization(createEmailCustomizationRequest, _options) {
    const result = this.api.createEmailCustomization(createEmailCustomizationRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.10.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `template_identifier` from the response. - Use that `template_identifier` as a parameter in this API request.      
   * @param templateIdentifier Unique ID or name of the email customization.
   */
  deleteEmailCustomization(templateIdentifier, _options) {
    const result = this.api.deleteEmailCustomization(templateIdentifier, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.12.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `org_identifier` from the response. - Use that `org_identifier` as a parameter in this API request.      
   * @param deleteOrgEmailCustomizationRequest 
   */
  deleteOrgEmailCustomization(deleteOrgEmailCustomizationRequest, _options) {
    const result = this.api.deleteOrgEmailCustomization(deleteOrgEmailCustomizationRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.10.0.cl or later   Search the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   * @param searchEmailCustomizationRequest 
   */
  searchEmailCustomization(searchEmailCustomizationRequest, _options) {
    const result = this.api.searchEmailCustomization(searchEmailCustomizationRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.12.0.cl or later   Updates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To update a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param updateEmailCustomizationRequest 
   */
  updateEmailCustomization(updateEmailCustomizationRequest, _options) {
    const result = this.api.updateEmailCustomization(updateEmailCustomizationRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.10.0.cl or later   Validates the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   */
  validateEmailCustomization(_options) {
    const result = this.api.validateEmailCustomization(_options);
    return result.toPromise();
  }
};
var PromiseGroupsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableGroupsApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### About groups Groups in ThoughtSpot are used by the administrators to define privileges and organize users based on their roles and access requirements. To know more about groups and privileges, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/groups-privileges).  #### Supported operations  The API endpoint lets you perform the following operations:  * Assign privileges * Add users * Define sharing visibility * Add sub-groups * Assign a default Liveboard      
   * @param createUserGroupRequest 
   */
  createUserGroup(createUserGroupRequest, _options) {
    const result = this.api.createUserGroup(createUserGroupRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified group object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.      
   * @param groupIdentifier GUID or name of the group.
   */
  deleteUserGroup(groupIdentifier, _options) {
    const result = this.api.deleteUserGroup(groupIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Imports group objects from external databases into ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  During the import operation:  * If the specified group is not available in ThoughtSpot, it will be added to ThoughtSpot. * If `delete_unspecified_groups` is set to `true`, the groups not specified in the API request, excluding administrator and system user groups, are deleted. * If the specified groups are already available in ThoughtSpot, the object properties of these groups are modified and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.      
   * @param importUserGroupsRequest 
   */
  importUserGroups(importUserGroupsRequest, _options) {
    const result = this.api.importUserGroups(importUserGroupsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of user group objects from the ThoughtSpot system.  To get details of a specific user group, specify the user group GUID or name. You can also filter the API response based on User ID, Org ID, Role ID, type of group, sharing visibility, privileges assigned to the group, and the Liveboard IDs assigned to the users in the group.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  **NOTE**: If you do not get precise results, try setting `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchUserGroupsRequest 
   */
  searchUserGroups(searchUserGroupsRequest, _options) {
    const result = this.api.searchUserGroups(searchUserGroupsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### Supported operations  This API endpoint lets you perform the following operations in a single API request:  * Edit [privileges](https://developers.thoughtspot.com/docs/?pageid=api-user-management#group-privileges) * Add or remove users * Change sharing visibility settings * Add or remove sub-groups * Assign a default Liveboard  or update the existing settings      
   * @param groupIdentifier GUID or name of the group.
   * @param updateUserGroupRequest 
   */
  updateUserGroup(groupIdentifier, updateUserGroupRequest, _options) {
    const result = this.api.updateUserGroup(groupIdentifier, updateUserGroupRequest, _options);
    return result.toPromise();
  }
};
var PromiseLogApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableLogApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches security audit logs.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the [Admin Control](https://developers.thoughtspot.com/docs/rbac#_admin_control) privileges are required.   #### Usage guidelines  By default, the API retrieves logs for the last 24 hours. You can set a custom duration in EPOCH time. Make sure the log duration specified in your API request doesnt exceed 24 hours. If you must fetch logs for a longer time range, modify the duration and make multiple sequential API requests.  Upon successful execution, the API returns logs with the following information: * timestamp of the event * event ID * event type * name and GUID of the user * IP address of ThoughtSpot instance  For more information see [Audit logs Documentation](https://developers.thoughtspot.com/docs/audit-logs).      
   * @param fetchLogsRequest 
   */
  fetchLogs(fetchLogsRequest, _options) {
    const result = this.api.fetchLogs(fetchLogsRequest, _options);
    return result.toPromise();
  }
};
var PromiseMetadataApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableMetadataApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *  Convert worksheets to models    Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (Can manage data models).  ---  ## Usage Guidelines  ### Parameters  1. **worksheet_ids**      - **Description:** A comma-separated list of GUIDs (Globally Unique Identifiers) specifying the Worksheets to be converted.      - **Usage:**        - Used only when `convert_all` is set to `false`.        - Leave empty or omit when `convert_all` is set to `true`.  2. **exclude_worksheet_ids**      - **Description:** A comma-separated list of GUIDs specifying Worksheets to be excluded from conversion.      - **Usage:**        - Useful when `convert_all` is set to `true` and specific Worksheets should not be converted.  3. **convert_all**      - **Description:** Sets the scope of conversion.    - **Options:**        - `true`: Converts all Worksheets in the system, except those specified in `exclude_worksheet_ids`.        - `false`: Converts only the Worksheets listed in `worksheet_ids`.  4. **apply_changes**      - **Description:** Specifies whether to apply changes directly to ThoughtSpot or to generate a preview before applying any changes.Used for validation of conversion.    - **Options:**        - `true`: Applies conversion changes directly to ThoughtSpot.      - `false`: Generates only a preview of the changes and does not apply any changes to ThoughtSpot  ---  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the conversion process  2. **Partial Conversion for Testing:**      Test the conversion process by setting `convert_all` to `false` and specifying a small number of `worksheet_ids`.  3. **Verify Dependencies:**      Check for dependent objects, such as Tables and Connections, to avoid invalid references.  4. **Review Changes:**      Use `apply_changes: false` to preview the impact of the conversion before applying changes.  ---  ## Examples  ### Convert Specific Worksheets ```json {   \"worksheet_ids\": [\"guid1\", \"guid2\", \"guid3\"],   \"exclude_worksheet_ids\": [],   \"convert_all\": false,   \"apply_changes\": true } ```  ### Convert All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [],   \"convert_all\": true,   \"apply_changes\": true } ```  ### Exclude Specific Worksheets While Converting All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [\"abc\"],   \"convert_all\": true,   \"apply_changes\": true } ```     
   * @param convertWorksheetToModelRequest 
   */
  convertWorksheetToModel(convertWorksheetToModelRequest, _options) {
    const result = this.api.convertWorksheetToModel(convertWorksheetToModelRequest, _options);
    return result.toPromise();
  }
  /**
   *  Makes a copy of an Answer or Liveboard    Version: 10.3.0.cl or later   Creates a copy of a metadata object.  Requires at least view access to the metadata object being copied.  Upon successful execution, the API creates a copy of the metadata object specified in the API request and returns the ID of the new object.      
   * @param copyObjectRequest 
   */
  copyObject(copyObjectRequest, _options) {
    const result = this.api.copyObject(copyObjectRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified metadata object from the ThoughtSpot system.  Requires edit access to the metadata object.       
   * @param deleteMetadataRequest 
   */
  deleteMetadata(deleteMetadataRequest, _options) {
    const result = this.api.deleteMetadata(deleteMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  Requires `DATADOWNLOADING` (**Can download Data**) and at least view access to the metadata object.  #### Usage guidelines  * You can export one or several objects by passing metadata object GUIDs in the `metadata` array. * When exporting TML content for a Liveboard or Answer object, you can set `export_associated` to `true` to retrieve TML content for underlying Worksheets, Tables, or Views, including the GUID of each object within the headers. When   `export_associated` is set to `true`, consider retrieving one metadata object at a time. * Set `export_fqns` to `true` to add FQNs of the referenced objects in the TML content. For example, if you send an API request to retrieve TML for a Liveboard and its associated objects, the API returns the TML content with FQNs of the referenced Worksheet. Exporting TML with FQNs is useful if ThoughtSpot has multiple objects with the same name and you want to eliminate ambiguity when importing TML files into ThoughtSpot. It eliminates the need for adding FQNs of the referenced objects manually during the import operation. * To export only the TML of feedbacks associated with an object, set the GUID of the object as `identifier`, and set the `type` as `FEEDBACK` in the `metadata` array. * To export the TML of an object along with the feedbacks associated with it, set the GUID of the object as `identifier`, set the `type` as `LOGIAL_TABLE` in the `metadata` array, and set `export_with_associated_feedbacks` in `export_options` to true.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_export_a_tml).  For more information on feedbacks, see [Feedback Documentation](https://docs.thoughtspot.com/cloud/latest/sage-feedback).     
   * @param exportMetadataTMLRequest 
   */
  exportMetadataTML(exportMetadataTMLRequest, _options) {
    const result = this.api.exportMetadataTML(exportMetadataTMLRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.1.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  ### **Permissions Required**  Requires `DATAMANAGEMENT` (**Can manage data**) and `USERMANAGEMENT` (**Can manage users**) privileges.  #### **Usage Guidelines**  This API is only applicable for `USER`, `GROUP`, and `ROLES` metadata types.  - `batch_offset` Indicates the starting position within the complete dataset from which the API should begin returning objects. Useful for paginating results efficiently. - `batch_size` Specifies the number of objects or items to retrieve in a single request. Helps control response size for better performance. - `edoc_format` Defines the format of the TML content. The exported metadata can be in JSON or YAML format. - `export_dependent` Specifies whether to include dependent metadata objects in the export. Ensures related objects are also retrieved if needed. - `all_orgs_override` Indicates whether the export operation applies across all organizations. Useful for multi-tenant environments where cross-org exports are required.      
   * @param exportMetadataTMLBatchedRequest 
   */
  exportMetadataTMLBatched(exportMetadataTMLBatchedRequest, _options) {
    const result = this.api.exportMetadataTMLBatched(exportMetadataTMLBatchedRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for an Answer object.  Requires at least view access to the Answer object.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {    \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",    \"metadata_name\":\"Total sales\",    \"metadata_type\":\"ANSWER\",    \"sql_queries\":[       {          \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",          \"metadata_name\":\"Total sales -test\",          \"sql_query\":\"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  \\\"ta_2\\\".\\\"PRODUCTNAME\\\" \\\"ca_2\\\", \\n  \\\"ta_1\\\".\\\"STORENAME\\\" \\\"ca_3\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_4\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_5\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_3\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_3\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_PRODUCTS\\\" \\\"ta_2\\\"\\n    ON \\\"ta_3\\\".\\\"PRODUCTID\\\" = \\\"ta_2\\\".\\\"PRODUCTID\\\"\\nGROUP BY \\n  \\\"ca_1\\\", \\n  \\\"ca_2\\\", \\n  \\\"ca_3\\\"\\n\"       }    ] } ```      
   * @param fetchAnswerSqlQueryRequest 
   */
  fetchAnswerSqlQuery(fetchAnswerSqlQueryRequest, _options) {
    const result = this.api.fetchAnswerSqlQuery(fetchAnswerSqlQueryRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.4.0.cl or later   Gets information about the status of the TML async import task scheduled using the `/api/rest/2.0/metadata/tml/async/import` API call.  To fetch the task details, specify the ID of the TML async import task.    Requires access to the task ID. The API allows users who initiated the asynchronous TML import via `/api/rest/2.0/metadata/tml/async/import` to view the status of their tasks.  Users with administration privilege can view the status of all import tasks initiated by the users in their Org.  #### Usage guidelines  See [TML API Documentation](https://developers.thoughtspot.com/docs/tml#_fetch_status_of_the_tml_import_task) for usage guidelines.     
   * @param fetchAsyncImportTaskStatusRequest 
   */
  fetchAsyncImportTaskStatus(fetchAsyncImportTaskStatusRequest, _options) {
    const result = this.api.fetchAsyncImportTaskStatus(fetchAsyncImportTaskStatusRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for a Liveboard object and its visualizations.  Requires at least view access to the Liveboard object.  To get SQL query data for a Liveboard, specify the GUID of the Liveboard. Optionally, you can add an array of visualization GUIDs to retrieve the SQL query data for visualizations in the Liveboard.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {   \"metadata_id\": \"fa68ae91-7588-4136-bacd-d71fb12dda69\",   \"metadata_name\": \"Total Sales\",   \"metadata_type\": \"LIVEBOARD\",   \"sql_queries\": [     {       \"metadata_id\": \"b3b6d2b9-089a-490c-8e16-b144650b7843\",       \"metadata_name\": \"Total quantity purchased, Total sales by region\",       \"sql_query\": \"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_2\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_3\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_2\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_2\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\nGROUP BY \\\"ca_1\\\"\"     }   ] } ```      
   * @param fetchLiveboardSqlQueryRequest 
   */
  fetchLiveboardSqlQuery(fetchLiveboardSqlQueryRequest, _options) {
    const result = this.api.fetchLiveboardSqlQuery(fetchLiveboardSqlQueryRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Imports [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  *  Import all related objects in a single TML Import API call. For example, Tables that use the same Connection object and Worksheets connected to these Tables. * Include the `fqn` property to distinguish objects that have the same name.   For example, if you have multiple Connections or Worksheets with the same name on ThoughtSpot and the Connection or Worksheet referenced in your TML file does not have a unique name to distinguish, it may result in invalid object references.   Adding `fqn` helps ThoughtSpot differentiate a Table from another with the same name.   We recommend [exporting TML with FQNs](#/http/api-endpoints/metadata/export-metadata-tml) and using these during the import operation. * You can upload multiple TML files at a time.   If you import a Worksheet along with Liveboards, Answers, and other dependent objects in a single API call, the imported objects will be immediately available for use.   When you import only a Worksheet object, it may take some time for the Worksheet to become available in the ThoughtSpot system. Please wait for a few minutes, and then proceed to create an Answer and Liveboard from the newly imported Worksheet.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_import_a_tml).      
   * @param importMetadataTMLRequest 
   */
  importMetadataTML(importMetadataTMLRequest, _options) {
    const result = this.api.importMetadataTML(importMetadataTMLRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.4.0.cl or later   Schedules a task to import [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot. You can use this API endpoint to process TML objects asynchronously when importing TMLs of large and complex metadata objects into ThoughtSpot. Unlike the synchronous import TML operation, the API processes TML data in the background and returns a task ID, which can be used to check the status of the import task via `/api/rest/2.0/metadata/tml/async/status` API endpoint.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege, and edit access to the TML objects.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  See [Async TML API Documentation](https://developers.thoughtspot.com/docs/tml#_import_tml_objects_asynchronously) for usage guidelines.      
   * @param importMetadataTMLAsyncRequest 
   */
  importMetadataTMLAsync(importMetadataTMLAsyncRequest, _options) {
    const result = this.api.importMetadataTMLAsync(importMetadataTMLAsyncRequest, _options);
    return result.toPromise();
  }
  /**
   *  Parameterize fields in metadata objects.   Version: 10.9.0.cl or later   Allows parameterizing fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows parameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be parameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param parameterizeMetadataRequest 
   */
  parameterizeMetadata(parameterizeMetadataRequest, _options) {
    const result = this.api.parameterizeMetadata(parameterizeMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of metadata objects available on the ThoughtSpot system.  This API endpoint is available to all users who have view access to the object. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view data for all metadata objects, including users and groups.  #### Usage guidelines  - To get all metadata objects, send the API request without any attributes. - To get metadata objects of a specific type, set the `type` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE`. - To filter metadata objects within type `LOGICAL_TABLE`, set the `subtypes` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE` & subtypes as `[WORKSHEET]`. - To get a specific metadata object, specify the GUID. - To customize your search and filter the API response, you can use several parameters.   You can search for objects created or modified by specific users, by tags applied to the objects, or by using the include parameters like `include_auto_created_objects`, `include_dependent_objects`, `include_headers`, `include_incomplete_objects`, and so on.   You can also define sorting options to sort the data retrieved in the API response. - To get discoverable objects when linientmodel is enabled you can use `include_discoverable_objects` as true else false. Default value is true. - For liveboard metadata type, to get the newer format, set the `liveboard_response_format` as V2. Default value is V1. - To retrieve only objects that are published, set the `include_only_published_objects` as true. Default value is false.  **NOTE**: The following parameters support pagination of metadata records:  - `tag_identifiers` - `type` - `subtypes` - `created_by_user_identifiers` - `modified_by_user_identifiers` - `owned_by_user_identifiers` - `exclude_objects` - `include_auto_created_objects` - `favorite_object_options` - `include_only_published_objects` If you are using other parameters to search metadata, set `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchMetadataRequest 
   */
  searchMetadata(searchMetadataRequest, _options) {
    const result = this.api.searchMetadata(searchMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *  Remove parameterization from fields in metadata objects.   Version: 10.9.0.cl or later   Allows removing parameterization from fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows unparameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be unparameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param unparameterizeMetadataRequest 
   */
  unparameterizeMetadata(unparameterizeMetadataRequest, _options) {
    const result = this.api.unparameterizeMetadata(unparameterizeMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *  Update header attributes for a given list of header objects.   Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **headers_update**      - **Description:** List of header objects with their attributes to be updated. Each object contains a list of attributes to be updated in the header.    - **Usage:**       - You must provide either `identifier` or `obj_identifier`, but not both. Both fields cannot be empty.       - When `org_identifier` is set to `-1`, only the `identifier` value is accepted; `obj_identifier` is not allowed.  2. **org_identifier**      - **Description:** GUID (Globally Unique Identifier) or name of the organization.      - **Usage:**      - Leaving this field empty assumes that the changes should be applied to the current organization       - Provide `org_guid` or `org_name` to uniquely identify the organization where changes need to be applied. .      - Provide `-1` if changes have to be applied across all the org.  ---  ## Note Currently, this API is enabled only for updating the `obj_identifier` attribute. Only `text` will be allowed in attribute\'s value.  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the update process  ---  ## Examples  ### Only `identifier` is given  ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"obj_identifier\": \"\",       \"type\": \"LOGICAL_COLUMN\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgGuid\" } ```  ### Only `obj_identifier` is given ```json {   \"headers_update\":   [     {       \"obj_identifier\": \"custom_object_id\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgName\" } ```  ### Executing update for all org `-1` ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```  ### Optional `type` is not provided ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```     
   * @param updateMetadataHeaderRequest 
   */
  updateMetadataHeader(updateMetadataHeaderRequest, _options) {
    const result = this.api.updateMetadataHeader(updateMetadataHeaderRequest, _options);
    return result.toPromise();
  }
  /**
   *  Update object IDs for given metadata objects.   Version: 10.8.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **metadata**      - **Description:** List of metadata objects to update their object IDs.    - **Usage:**       - Use either `current_obj_id` alone OR use `metadata_identifier` with `type` (when needed).       - When using `metadata_identifier`, the `type` field is required if using a name instead of a GUID.       - The `new_obj_id` field is always required.  ---  ## Note This API is specifically designed for updating object IDs of metadata objects. It internally uses the header update mechanism to perform the changes.  ## Best Practices  1. **Backup Before Update:**      Always export metadata as a backup before initiating the update process.  2. **Validation:**    - When using `current_obj_id`, ensure it matches the existing object ID exactly.    - When using `metadata_identifier` with a name, ensure the `type` is specified correctly.    - Verify that the `new_obj_id` follows your naming conventions and is unique within your system.  ---  ## Examples  ### Using current_obj_id ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with GUID ```json {   \"metadata\": [     {       \"metadata_identifier\": \"01234567-89ab-cdef-0123-456789abcdef\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with name and type ```json {   \"metadata\": [     {       \"metadata_identifier\": \"My Answer\",       \"type\": \"ANSWER\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Multiple objects update ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id_1\",       \"new_obj_id\": \"new_object_id_1\"     },     {       \"metadata_identifier\": \"My Worksheet\",       \"type\": \"LOGICAL_TABLE\",       \"new_obj_id\": \"new_object_id_2\"     }   ] } ```      
   * @param updateMetadataObjIdRequest 
   */
  updateMetadataObjId(updateMetadataObjIdRequest, _options) {
    const result = this.api.updateMetadataObjId(updateMetadataObjIdRequest, _options);
    return result.toPromise();
  }
};
var PromiseOrgsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableOrgsApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.0.0.cl or later   Creates an Org object.  To use this API, the [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview) feature must be enabled in your cluster.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param createOrgRequest 
   */
  createOrg(createOrgRequest, _options) {
    const result = this.api.createOrg(createOrgRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes an Org object from the ThoughtSpot system.  Requires cluster administration (**Can administer Org**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.  When you delete an Org, all its users and objects created in that Org context are removed. However, if the users in the deleted Org also exists in other Orgs, they are removed only from the deleted Org.      
   * @param orgIdentifier ID or name of the Org
   */
  deleteOrg(orgIdentifier, _options) {
    const result = this.api.deleteOrg(orgIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of Orgs configured on the ThoughtSpot system. To get details of a specific Org, specify the Org ID or name. You can also pass parameters such as status, visibility, and user identifiers to get a specific list of Orgs.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param searchOrgsRequest 
   */
  searchOrgs(searchOrgsRequest, _options) {
    const result = this.api.searchOrgs(searchOrgsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Updates an Org object. You can modify Org properties such as name, description, and user associations.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param orgIdentifier ID or name of the Org
   * @param updateOrgRequest 
   */
  updateOrg(orgIdentifier, updateOrgRequest, _options) {
    const result = this.api.updateOrg(orgIdentifier, updateOrgRequest, _options);
    return result.toPromise();
  }
};
var PromiseReportsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableReportsApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.0.0.cl or later   Exports an Answer in the given file format. You can download the Answer data as a PDF, PNG, CSV, or XLSX file.  Requires at least view access to the Answer.  #### Usage guidelines  In the request body, the GUID or name of the Answer and set `file_format`. The default file format is CSV.  **NOTE**: * The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension. * HTML rendering is not supported for PDF exports of Answers with tables.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.       
   * @param exportAnswerReportRequest 
   */
  exportAnswerReport(exportAnswerReportRequest, _options) {
    const result = this.api.exportAnswerReport(exportAnswerReportRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Exports a Liveboard and its visualizations in PDF, PNG, CSV, or XLSX file format.  Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To generate a Liveboard report with specific visualizations, add GUIDs or names of the visualizations.  The default `file_format` is CSV. For PDF exports, you can specify additional parameters to customize the page orientation and include or exclude the cover page, logo, footer text, and page numbers. Similar customization options are available for PNG exports. CSV and XLSX exports do not support customization options.  **NOTE**: The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes, including ad hoc changes to visualizations. For more information, see [Liveboard Report API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_liveboard_report_api).    **NOTE**: Starting with ThoughtSpot Cloud 10.9.0.cl release, the Liveboard can be exported in the PNG format in the resolution of your choice. To enable this on your instance, contact ThoughtSpot support. When this feature is enabled, the options `include_cover_page`,`include_filter_page` within the `png_options` will not be available for PNG exports.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in CSV format. All visualizations in the Liveboard can be exported as individual CSV files. If multiple visualizations are selected or if the entire Liveboard is exported, the output is returned as a .zip file containing the CSV files for each visualization.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in XLSX format. All selected visualizations are consolidated into a single Excel workbook (.xlsx), with each visualization placed in its own worksheet (tab). XLSX exports are limited to 255 worksheets (tabs) per workbook.      
   * @param exportLiveboardReportRequest 
   */
  exportLiveboardReport(exportLiveboardReportRequest, _options) {
    const result = this.api.exportLiveboardReport(exportLiveboardReportRequest, _options);
    return result.toPromise();
  }
};
var PromiseRolesApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableRolesApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.5.0.cl or later   Creates a Role object in ThoughtSpot.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To create a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param createRoleRequest 
   */
  createRole(createRoleRequest, _options) {
    const result = this.api.createRole(createRoleRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.5.0.cl or later   Deletes a Role object from the ThoughtSpot system.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To delete a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role. ReadOnly roles cannot be deleted.
   */
  deleteRole(roleIdentifier, _options) {
    const result = this.api.deleteRole(roleIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.5.0.cl or later   Gets a list of Role objects from the ThoughtSpot system.  Available if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To search for Roles, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.  To get details of a specific Role object, specify the GUID or name. You can also filter the API response based on user group and Org identifiers, privileges assigned to the Role, and deprecation status.      
   * @param searchRolesRequest 
   */
  searchRoles(searchRolesRequest, _options) {
    const result = this.api.searchRoles(searchRolesRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.5.0.cl or later   Updates the properties of a Role object.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To update a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role.
   * @param updateRoleRequest 
   */
  updateRole(roleIdentifier, updateRoleRequest, _options) {
    const result = this.api.updateRole(roleIdentifier, updateRoleRequest, _options);
    return result.toPromise();
  }
};
var PromiseSchedulesApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableSchedulesApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *  Create schedule.    Version: 9.4.0.cl or later   Creates a Liveboard schedule job.  Requires at least edit access to Liveboards. To create a schedule on behalf of another user, you need  `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  #### Usage guidelines  * The description text is mandatory.  The description text appears as **Description: <your content>** in the Liveboard schedule email notifications. * For Liveboards with both charts and tables, schedule creation is only supported in PDF and XLS formats. Schedules created in CSV formats for such Liveboards will fail to run. If `PDF` is set as the `file_format`, enable `pdf_options` to get the correct attachment. Not doing so may cause the attachment to be rendered empty. * To include only specific visualizations, specify the visualization GUIDs in the `visualization_identifiers` array. * You can schedule a Liveboard job to run periodically by setting frequency parameters. You can set the schedule to run daily, weekly, monthly or every n minutes or hours. The scheduled job can also be configured to run at a specific time of the day or on specific days of the week or month. Please ensure that when setting the schedule frequency for _minute of the object_, only values that are multiples of 5 are included. * If the `frequency` parameters are defined, you can set the time zone to a value that matches your server\'s time zone. For example, `US/Central`, `Etc/UTC`, `CET`. The default time zone is `America/Los_Angeles`.  For more information about Liveboard jobs, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/liveboard-schedule).     
   * @param createScheduleRequest 
   */
  createSchedule(createScheduleRequest, _options) {
    const result = this.api.createSchedule(createScheduleRequest, _options);
    return result.toPromise();
  }
  /**
   *  Deletes a scheduled job.    Version: 9.4.0.cl or later   Deletes a scheduled Liveboard job.  Requires at least edit access to Liveboard or `ADMINISTRATION` (**Can administer Org**) privilege.    If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.      
   * @param scheduleIdentifier Unique ID or name of the scheduled job.
   */
  deleteSchedule(scheduleIdentifier, _options) {
    const result = this.api.deleteSchedule(scheduleIdentifier, _options);
    return result.toPromise();
  }
  /**
   *  Search Schedules    Version: 9.4.0.cl or later   Gets a list of scheduled jobs configured for a Liveboard.  To get details of a specific scheduled job, specify the name or GUID of the scheduled job.  Requires at least view access to Liveboards.  **NOTE**: When filtering schedules by parameters other than `metadata`, set `record_size` to `-1` and `record_offset` to `0` for accurate results.      
   * @param searchSchedulesRequest 
   */
  searchSchedules(searchSchedulesRequest, _options) {
    const result = this.api.searchSchedules(searchSchedulesRequest, _options);
    return result.toPromise();
  }
  /**
   *  Update schedule.    Version: 9.4.0.cl or later   Updates a scheduled Liveboard job.  Requires at least edit access to Liveboards. To update a schedule on behalf of another user, you need `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  The API endpoint allows you to pause a scheduled job, change the status of a paused job. You can also edit the recipients list, frequency of the job, format of the file to send to the recipients in email notifications, PDF options, and time zone setting.      
   * @param scheduleIdentifier Unique ID or name of the schedule.
   * @param updateScheduleRequest 
   */
  updateSchedule(scheduleIdentifier, updateScheduleRequest, _options) {
    const result = this.api.updateSchedule(scheduleIdentifier, updateScheduleRequest, _options);
    return result.toPromise();
  }
};
var PromiseSecurityApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableSecurityApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.0.0.cl or later   Transfers the ownership of one or several objects from one user to another.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege and edit access to the objects are required.      
   * @param assignChangeAuthorRequest 
   */
  assignChangeAuthor(assignChangeAuthorRequest, _options) {
    const result = this.api.assignChangeAuthor(assignChangeAuthorRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.12.0.cl or later   Fetches column security rules for specified tables.  This API endpoint retrieves column-level security rules configured for tables. It returns information about which columns are secured and which groups have access to those columns.  #### Usage guidelines  - Provide an array of table identifiers using either `identifier` (GUID or name) or `obj_identifier` (object ID) - At least one of `identifier` or `obj_identifier` must be provided for each table - The API returns column security rules for all specified tables - Users must have appropriate permissions to access security rules for the specified tables  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables  #### Example request  ```json {   \"tables\": [     {       \"identifier\": \"table-guid\",       \"obj_identifier\": \"table-object-id\"     }   ] } ```  #### Response format  The API returns an array of `ColumnSecurityRuleResponse` objects wrapped in a `data` field. Each `ColumnSecurityRuleResponse` object contains: - Table information (GUID and object ID)   - Array of column security rules with column details, group access, and source table information  #### Example response  ```json {   \"data\": [     {       \"guid\": \"table-guid\",       \"objId\": \"table-object-id\",       \"columnSecurityRules\": [         {           \"column\": {             \"id\": \"col_123\",             \"name\": \"Salary\"           },           \"groups\": [             {               \"id\": \"group_1\",               \"name\": \"HR Department\"             }           ],           \"sourceTableDetails\": {             \"id\": \"source-table-guid\",             \"name\": \"Employee_Data\"           }         }       ]     }   ] } ```     
   * @param fetchColumnSecurityRulesRequest 
   */
  fetchColumnSecurityRules(fetchColumnSecurityRulesRequest, _options) {
    const result = this.api.fetchColumnSecurityRules(fetchColumnSecurityRulesRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches object permission details for a given principal object such as a user and group.  Requires view access to the metadata object.   #### Usage guidelines  * To get a list of all metadata objects that a user or group can access, specify the `type` and GUID or name of the principal. * To get permission details for a specific object, add the `type` and GUID or name of the metadata object to your API request.  Upon successful execution, the API returns a list of metadata objects and permission details for each object.        
   * @param fetchPermissionsOfPrincipalsRequest 
   */
  fetchPermissionsOfPrincipals(fetchPermissionsOfPrincipalsRequest, _options) {
    const result = this.api.fetchPermissionsOfPrincipals(fetchPermissionsOfPrincipalsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches permission details for a given metadata object.  Requires view access to the metadata object.  #### Usage guidelines  * To fetch a list of users and groups for a metadata object, specify `type` and GUID or name of the metadata object. * To get permission details for a specific user or group, add `type` and GUID or name of the principal object to your API request.  Upon successful execution, the API returns permission details and principal information for the object specified in the API request.      
   * @param fetchPermissionsOnMetadataRequest 
   */
  fetchPermissionsOnMetadata(fetchPermissionsOnMetadataRequest, _options) {
    const result = this.api.fetchPermissionsOnMetadata(fetchPermissionsOnMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.9.0.cl or later   Allows publishing metadata objects across organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows publishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  This API will essentially share the objects along with it\'s dependencies to the org admins of the orgs to which it is being published.      
   * @param publishMetadataRequest 
   */
  publishMetadata(publishMetadataRequest, _options) {
    const result = this.api.publishMetadata(publishMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Allows sharing one or several metadata objects with users and groups in ThoughtSpot.  Requires edit access to the metadata object.  The API endpoint allows sharing only the following types of metadata objects: * Liveboards * Visualizations * Answers * Worksheets * Views * Connections  You can provide `READ_ONLY` or `MODIFY` access when sharing an object with another user or group. With `READ_ONLY` access grants view access to the shared object, whereas `MODIFY` provides edit access.  To prevent a user or group from accessing the shared object, specify the GUID or name of the principal and set `shareMode` to `NO_ACCESS`.      
   * @param shareMetadataRequest 
   */
  shareMetadata(shareMetadataRequest, _options) {
    const result = this.api.shareMetadata(shareMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.9.0.cl or later   Allows unpublishing metadata objects from organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows unpublishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  When unpublishing objects, you can: * Include dependencies by setting `include_dependencies` to true - this will unpublish all dependent objects if no other published object is using them * Force unpublish by setting `force` to true - this will break all dependent objects in the unpublished organizations      
   * @param unpublishMetadataRequest 
   */
  unpublishMetadata(unpublishMetadataRequest, _options) {
    const result = this.api.unpublishMetadata(unpublishMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.12.0.cl or later   Creates, updates, or deletes column security rules for specified tables.  This API endpoint allows you to create, update, or delete column-level security rules on columns of a table. The operation follows an \"all or none\" policy: if defining security rules for any of the provided columns fails, the entire operation will be rolled back, and no rules will be created.  #### Usage guidelines  - Provide table identifier using either `identifier` (GUID or name) or `obj_identifier` (object ID) - Use `clear_csr: true` to remove all column security rules from the table - For each column, specify the security rule using `column_security_rules` array - Use `is_unsecured: true` to mark a specific column as unprotected - Use `group_access` operations to manage group associations:   - `ADD`: Add groups to the column\'s access list   - `REMOVE`: Remove groups from the column\'s access list   - `REPLACE`: Replace all existing groups with the specified groups  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data (if RBAC is disabled) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables (if RBAC is enabled)  #### Example request  ```json {   \"identifier\": \"table-guid\",   \"obj_identifier\": \"table-object-id\",   \"clear_csr\": false,   \"column_security_rules\": [     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"ADD\",           \"group_identifiers\": [\"hr_group_id\", \"hr_group_name\", \"finance_group_id\"]         }       ]     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": true     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"REPLACE\",           \"group_identifiers\": [\"management_group_id\", \"management_group_name\"]         }       ]     }   ] } ```  #### Request Body Schema  - `identifier` (string, optional): GUID or name of the table for which we want to create column security rules - `obj_identifier` (string, optional): The object ID of the table - `clear_csr` (boolean, optional): If true, then all the secured columns will be marked as unprotected, and all the group associations will be removed - `column_security_rules` (array of objects, required): An array where each object defines the security rule for a specific column  Each column security rule object contains: - `column_identifier` (string, required): Column identifier (col_id or name) - `is_unsecured` (boolean, optional): If true, the column will be marked as unprotected and all groups associated with it will be removed - `group_access` (array of objects, optional): Array of group operation objects  Each group operation object contains: - `operation` (string, required): Operation type - ADD, REMOVE, or REPLACE - `group_identifiers` (array of strings, required): Array of group identifiers (name or GUID) on which the operation will be performed  #### Response  This API does not return any response body. A successful operation returns HTTP 200 status code.  #### Operation Types  - **ADD**: Adds the specified groups to the column\'s access list - **REMOVE**: Removes the specified groups from the column\'s access list   - **REPLACE**: Replaces all existing groups with the specified groups      
   * @param updateColumnSecurityRulesRequest 
   */
  updateColumnSecurityRules(updateColumnSecurityRulesRequest, _options) {
    const result = this.api.updateColumnSecurityRules(updateColumnSecurityRulesRequest, _options);
    return result.toPromise();
  }
};
var PromiseSystemApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableSystemApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *  Version: 10.14.0.cl or later   Configure communication channel preferences. - Use `cluster_preferences` to update the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to specify Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param configureCommunicationChannelPreferencesRequest 
   */
  configureCommunicationChannelPreferences(configureCommunicationChannelPreferencesRequest, _options) {
    const result = this.api.configureCommunicationChannelPreferences(configureCommunicationChannelPreferencesRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves the current configuration details of the cluster. If the request is successful, the API returns a list configuration settings applied on the cluster.  Requires `ADMINISTRATION`(**Can administer ThoughtSpot**) privilege to view these complete configuration settings of the cluster. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.      
   */
  getSystemConfig(_options) {
    const result = this.api.getSystemConfig(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets system information such as the release version, locale, time zone, deployment environment, date format, and date time format of the cluster.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemInformation(_options) {
    const result = this.api.getSystemInformation(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of configuration overrides applied on the cluster.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemOverrideInfo(_options) {
    const result = this.api.getSystemOverrideInfo(_options);
    return result.toPromise();
  }
  /**
   *  Version: 10.14.0.cl or later   Fetch communication channel preferences. - Use `cluster_preferences` to fetch the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to fetch any Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param searchCommunicationChannelPreferencesRequest 
   */
  searchCommunicationChannelPreferences(searchCommunicationChannelPreferencesRequest, _options) {
    const result = this.api.searchCommunicationChannelPreferences(searchCommunicationChannelPreferencesRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Updates the current configuration of the cluster. You must send the configuration data in JSON format.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.      
   * @param updateSystemConfigRequest 
   */
  updateSystemConfig(updateSystemConfigRequest, _options) {
    const result = this.api.updateSystemConfig(updateSystemConfigRequest, _options);
    return result.toPromise();
  }
};
var PromiseTagsApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableTagsApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.0.0.cl or later   Assigns tags to Liveboards, Answers, Tables, and Worksheets.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  assignTag(assignTagRequest, _options) {
    const result = this.api.assignTag(assignTagRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a tag object.  Tags are labels that identify a metadata object. For example, you can create a tag to designate subject areas, such as sales, HR, marketing, and finance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param createTagRequest 
   */
  createTag(createTagRequest, _options) {
    const result = this.api.createTag(createTagRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a tag object from the ThoughtSpot system  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Tag identifier Tag name or Tag id.
   */
  deleteTag(tagIdentifier, _options) {
    const result = this.api.deleteTag(tagIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of tag objects available on the ThoughtSpot system. To get details of a specific tag object, specify the GUID or name.  Any authenticated user can search for tag objects.      
   * @param searchTagsRequest 
   */
  searchTags(searchTagsRequest, _options) {
    const result = this.api.searchTags(searchTagsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the tags applied to a Liveboard, Answer, Table, or Worksheet.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  unassignTag(assignTagRequest, _options) {
    const result = this.api.unassignTag(assignTagRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Updates a tag object.  You can modify the `name` and `color` properties of a tag object.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Name or Id of the tag.
   * @param updateTagRequest 
   */
  updateTag(tagIdentifier, updateTagRequest, _options) {
    const result = this.api.updateTag(tagIdentifier, updateTagRequest, _options);
    return result.toPromise();
  }
};
var PromiseThoughtSpotRestApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableThoughtSpotRestApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.7.0.cl or later   Activates a deactivated user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To activate an inactive user account, the API request body must include the following information:  - Username or the GUID of the user account. - Auth token generated for the deactivated user. The auth token is sent in the API response when a user is deactivated. - Password for the user account.      
   * @param activateUserRequest 
   */
  activateUser(activateUserRequest, _options) {
    const result = this.api.activateUser(activateUserRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Transfers the ownership of one or several objects from one user to another.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege and edit access to the objects are required.      
   * @param assignChangeAuthorRequest 
   */
  assignChangeAuthor(assignChangeAuthorRequest, _options) {
    const result = this.api.assignChangeAuthor(assignChangeAuthorRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Assigns tags to Liveboards, Answers, Tables, and Worksheets.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  assignTag(assignTagRequest, _options) {
    const result = this.api.assignTag(assignTagRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the current password of the user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param changeUserPasswordRequest 
   */
  changeUserPassword(changeUserPasswordRequest, _options) {
    const result = this.api.changeUserPassword(changeUserPasswordRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Commits TML files of metadata objects to the Git branch configured on your instance.  Requires at least edit access to objects used in the commit operation.  Before using this endpoint to push your commits:  * Enable Git integration on your instance. * Make sure the Git repository and branch details are configured on your instance.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitBranchRequest 
   */
  commitBranch(commitBranchRequest, _options) {
    const result = this.api.commitBranch(commitBranchRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.14.0.cl or later   Configure communication channel preferences. - Use `cluster_preferences` to update the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to specify Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param configureCommunicationChannelPreferencesRequest 
   */
  configureCommunicationChannelPreferences(configureCommunicationChannelPreferencesRequest, _options) {
    const result = this.api.configureCommunicationChannelPreferences(configureCommunicationChannelPreferencesRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Gets connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines * To get a list of all configurations available in the ThoughtSpot system, send the API request with only the connection name or GUID in the request body. * To fetch details of a configuration object, specify the configuration object name or GUID.      
   * @param connectionConfigurationSearchRequest 
   */
  connectionConfigurationSearch(connectionConfigurationSearchRequest, _options) {
    const result = this.api.connectionConfigurationSearch(connectionConfigurationSearchRequest, _options);
    return result.toPromise();
  }
  /**
   *  Convert worksheets to models    Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (Can manage data models).  ---  ## Usage Guidelines  ### Parameters  1. **worksheet_ids**      - **Description:** A comma-separated list of GUIDs (Globally Unique Identifiers) specifying the Worksheets to be converted.      - **Usage:**        - Used only when `convert_all` is set to `false`.        - Leave empty or omit when `convert_all` is set to `true`.  2. **exclude_worksheet_ids**      - **Description:** A comma-separated list of GUIDs specifying Worksheets to be excluded from conversion.      - **Usage:**        - Useful when `convert_all` is set to `true` and specific Worksheets should not be converted.  3. **convert_all**      - **Description:** Sets the scope of conversion.    - **Options:**        - `true`: Converts all Worksheets in the system, except those specified in `exclude_worksheet_ids`.        - `false`: Converts only the Worksheets listed in `worksheet_ids`.  4. **apply_changes**      - **Description:** Specifies whether to apply changes directly to ThoughtSpot or to generate a preview before applying any changes.Used for validation of conversion.    - **Options:**        - `true`: Applies conversion changes directly to ThoughtSpot.      - `false`: Generates only a preview of the changes and does not apply any changes to ThoughtSpot  ---  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the conversion process  2. **Partial Conversion for Testing:**      Test the conversion process by setting `convert_all` to `false` and specifying a small number of `worksheet_ids`.  3. **Verify Dependencies:**      Check for dependent objects, such as Tables and Connections, to avoid invalid references.  4. **Review Changes:**      Use `apply_changes: false` to preview the impact of the conversion before applying changes.  ---  ## Examples  ### Convert Specific Worksheets ```json {   \"worksheet_ids\": [\"guid1\", \"guid2\", \"guid3\"],   \"exclude_worksheet_ids\": [],   \"convert_all\": false,   \"apply_changes\": true } ```  ### Convert All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [],   \"convert_all\": true,   \"apply_changes\": true } ```  ### Exclude Specific Worksheets While Converting All Accessible Worksheets ```json {   \"worksheet_ids\": [],   \"exclude_worksheet_ids\": [\"abc\"],   \"convert_all\": true,   \"apply_changes\": true } ```     
   * @param convertWorksheetToModelRequest 
   */
  convertWorksheetToModel(convertWorksheetToModelRequest, _options) {
    const result = this.api.convertWorksheetToModel(convertWorksheetToModelRequest, _options);
    return result.toPromise();
  }
  /**
   *  Makes a copy of an Answer or Liveboard    Version: 10.3.0.cl or later   Creates a copy of a metadata object.  Requires at least view access to the metadata object being copied.  Upon successful execution, the API creates a copy of the metadata object specified in the API request and returns the ID of the new object.      
   * @param copyObjectRequest 
   */
  copyObject(copyObjectRequest, _options) {
    const result = this.api.copyObject(copyObjectRequest, _options);
    return result.toPromise();
  }
  /**
   * Version: 10.13.0.cl or later 
   * @param createAgentConversationRequest 
   */
  createAgentConversation(createAgentConversationRequest, _options) {
    const result = this.api.createAgentConversation(createAgentConversationRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Creates a new [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.   #### Usage guidelines  You can create a custom calendar from scratch or an existing Table in ThoughtSpot. For both methods of calendar creation, the following parameters are required:  * Name of the custom calendar. * Calendar creation method. To create a calendar from an existing table, specify the method:   - `FROM_EXISTING_TABLE` - Creates calendar from the table reference provided in the API request.  - `FROM_INPUT_PARAMS` - Creates a calendar from the parameters defined in the API request.  * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  **NOTE**: If you are creating a calendar from an existing table, ensure that the referenced table matches the required DDL for custom calendars. If the schema does not match, the API returns an error.  ##### Calendar type The API allows you to create the following types of calendars:  * `MONTH_OFFSET`. The default calendar type. A `MONTH_OFFSET` calendar is offset by a few months from the standard calendar months (January to December) and the year begins with the month defined in the request. For example, if the `month_offset` value is set as `April`, the calendar year begins in April.  * `4-4-5`. Each quarter in the calendar will include two 4-week months followed by one 5-week month. * `4-5-4`. Each quarter in the calendar will include two 4-week months with a 5-week month between. * `5-4-4`. Each quarter begins with a 5-week month, followed by two 4-week months.  To start and end the calendar on a specific date, specify the dates in the `MM/DD/YYYY` format. For `MONTH_OFFSET` calendars, ensure that the `start_date` matches the month specified in the `month_offset` attribute.  You can also set the starting day of the week and customize the prefixes for year and quarter labels.  #### Examples  To create a calendar from an existing table:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_EXISTING_TABLE\", } ```  To create a calendar from scratch:  ``` {   \"name\": \"MyCustomCalendar1\",   \"table_reference\": {     \"connection_identifier\": \"4db8ea22-2ff4-4224-b05a-26674717e468\",     \"table_name\": \"MyCalendarTable\",     \"database_name\": \"RETAILAPPAREL\",     \"schema_name\": \"PUBLIC\"   },   \"creation_method\": \"FROM_INPUT_PARAMS\",   \"calendar_type\": \"MONTH_OFFSET\",   \"month_offset\": \"April\",   \"start_day_of_week\": \"Monday\",   \"quarter_name_prefix\": \"Q\",   \"year_name_prefix\": \"FY\",   \"start_date\": \"04/01/2025\",   \"end_date\": \"04/31/2025\" } ```      
   * @param createCalendarRequest 
   */
  createCalendar(createCalendarRequest, _options) {
    const result = this.api.createCalendar(createCalendarRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to connect a ThoughtSpot instance to a Git repository.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.  You can use this API endpoint to connect your ThoughtSpot development and production environments to the development and production branches of a Git repository.  Before using this endpoint to connect your ThoughtSpot instance to a Git repository, check the following prerequisites:  * You have a Git repository. If you are using GitHub, make sure you have a valid account and an access token to connect ThoughtSpot to GitHub. For information about generating a token, see [GitHub Documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).  * Your access token has `repo` scope that grants full access to public and private repositories. * Your Git repository has a branch that can be configured as a default branch in ThoughtSpot.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/?pageid=git-integration).  **Note**: ThoughtSpot supports only GitHub / itHub Enterprise for CI/CD.      
   * @param createConfigRequest 
   */
  createConfig(createConfigRequest, _options) {
    const result = this.api.createConfig(createConfigRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Creates a connection to a data warehouse for live query services.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Create a connection without tables  To create a connection without tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a SnowFlake connection:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[       ]   }   ``` 2. Set `validate` to `false`.  #### Create a connection with tables  To create a connection with tables:  1. Pass these parameters in your API request.  * Name of the connection.  * Type of the data warehouse to connect to.  * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:   ```   {      \"configuration\":{         \"accountName\":\"thoughtspot_partner\",         \"user\":\"tsadmin\",         \"password\":\"TestConn123\",         \"role\":\"sysadmin\",         \"warehouse\":\"MEDIUM_WH\"      },      \"externalDatabases\":[         {            \"name\":\"AllDatatypes\",            \"isAutoCreated\":false,            \"schemas\":[               {                  \"name\":\"alldatatypes\",                  \"tables\":[                     {                        \"name\":\"allDatatypes\",                        \"type\":\"TABLE\",                        \"description\":\"\",                        \"selected\":true,                        \"linked\":true,                        \"columns\":[                           {                              \"name\":\"CNUMBER\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           },                           {                              \"name\":\"CDECIMAL\",                              \"type\":\"INT64\",                              \"canImport\":true,                              \"selected\":true,                              \"isLinkedActive\":true,                              \"isImported\":false,                              \"tableName\":\"allDatatypes\",                              \"schemaName\":\"alldatatypes\",                              \"dbName\":\"AllDatatypes\"                           }                        ]                     }                  ]               }            ]         }      ]   }   ``` 2. Set `validate` to `true`.      
   * @param createConnectionRequest 
   */
  createConnection(createConnectionRequest, _options) {
    const result = this.api.createConnection(createConnectionRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Creates an additional configuration to an existing connection to a data warehouse.    Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Usage guidelines   * A JSON map of configuration attributes in `configuration`. The following example shows the configuration attributes:   ```    {      \"user\":\"DEV_USER\",      \"password\":\"TestConn123\",      \"role\":\"DEV\",      \"warehouse\":\"DEV_WH\"     }   ```  * If the `policy_type` is `PRINCIPALS`, then `policy_principals` is a required field. * If the `policy_type` is `PROCESSES`, then `policy_processes` is a required field. * If the `policy_type` is `NO_POLICY`, then `policy_principals` and `policy_processes` are not required fields.  #### Parameterized Connection Support For parameterized connections that use OAuth authentication, only the same_as_parent and policy_process_options  attributes are allowed in the API request. These attributes are not applicable to connections that are not parameterized.       
   * @param createConnectionConfigurationRequest 
   */
  createConnectionConfiguration(createConnectionConfigurationRequest, _options) {
    const result = this.api.createConnectionConfiguration(createConnectionConfigurationRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.4.0.cl or later   Creates a Conversation object to start an AI-driven conversation based on a specific data model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  This API requires the `metadata_identifier` parameter to define the context for the conversation.  You can also specify the tokens to initiate the conversation as shown in this example:  `\"tokens\": \"[tea],[sales],[type]\"`  If the API request is successful, ThoughtSpot returns the ID of the conversation.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param createConversationRequest 
   */
  createConversation(createConversationRequest, _options) {
    const result = this.api.createConversation(createConversationRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.6.0.cl or later   Creates a custom action that appears as a menu action on a saved Answer or Liveboard visualization.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API lets you create the following types of custom actions:  * URL-based action        Allows pushing data to an external URL. * Callback action           Triggers a callback to the host application and initiates a response payload on an embedded ThoughtSpot instance.  By default, custom actions are visible to only administrator or developer users. To make a custom action available to other users, and specify the groups in `group_identifiers`.  By default, the custom action is set as a _global_ action on all visualizations and saved Answers. To assign a custom action to specific Liveboard visualization, saved Answer, or Worksheet, set `visibility` to `false` in `default_action_config` property and specify the GUID or name of the object in `associate_metadata`.  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param createCustomActionRequest 
   */
  createCustomAction(createCustomActionRequest, _options) {
    const result = this.api.createCustomAction(createCustomActionRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.10.0.cl or later   Creates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To create a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param createEmailCustomizationRequest 
   */
  createEmailCustomization(createEmailCustomizationRequest, _options) {
    const result = this.api.createEmailCustomization(createEmailCustomizationRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Creates an Org object.  To use this API, the [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview) feature must be enabled in your cluster.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param createOrgRequest 
   */
  createOrg(createOrgRequest, _options) {
    const result = this.api.createOrg(createOrgRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.5.0.cl or later   Creates a Role object in ThoughtSpot.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To create a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param createRoleRequest 
   */
  createRole(createRoleRequest, _options) {
    const result = this.api.createRole(createRoleRequest, _options);
    return result.toPromise();
  }
  /**
   *  Create schedule.    Version: 9.4.0.cl or later   Creates a Liveboard schedule job.  Requires at least edit access to Liveboards. To create a schedule on behalf of another user, you need  `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  #### Usage guidelines  * The description text is mandatory.  The description text appears as **Description: <your content>** in the Liveboard schedule email notifications. * For Liveboards with both charts and tables, schedule creation is only supported in PDF and XLS formats. Schedules created in CSV formats for such Liveboards will fail to run. If `PDF` is set as the `file_format`, enable `pdf_options` to get the correct attachment. Not doing so may cause the attachment to be rendered empty. * To include only specific visualizations, specify the visualization GUIDs in the `visualization_identifiers` array. * You can schedule a Liveboard job to run periodically by setting frequency parameters. You can set the schedule to run daily, weekly, monthly or every n minutes or hours. The scheduled job can also be configured to run at a specific time of the day or on specific days of the week or month. Please ensure that when setting the schedule frequency for _minute of the object_, only values that are multiples of 5 are included. * If the `frequency` parameters are defined, you can set the time zone to a value that matches your server\'s time zone. For example, `US/Central`, `Etc/UTC`, `CET`. The default time zone is `America/Los_Angeles`.  For more information about Liveboard jobs, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/liveboard-schedule).     
   * @param createScheduleRequest 
   */
  createSchedule(createScheduleRequest, _options) {
    const result = this.api.createSchedule(createScheduleRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a tag object.  Tags are labels that identify a metadata object. For example, you can create a tag to designate subject areas, such as sales, HR, marketing, and finance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param createTagRequest 
   */
  createTag(createTagRequest, _options) {
    const result = this.api.createTag(createTagRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a user in ThoughtSpot.  The API endpoint allows you to configure several user properties such as email address, account status, share notification preferences, and sharing visibility. You can provision the user to [groups](https://docs.thoughtspot.com/cloud/latest/groups-privileges) and [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview). You can also add Liveboard, Answer, and Worksheet objects to the users favorites list, assign a default Liveboard for the user, and set user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param createUserRequest 
   */
  createUser(createUserRequest, _options) {
    const result = this.api.createUser(createUserRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### About groups Groups in ThoughtSpot are used by the administrators to define privileges and organize users based on their roles and access requirements. To know more about groups and privileges, see [ThoughtSpot Product Documentation](https://docs.thoughtspot.com/cloud/latest/groups-privileges).  #### Supported operations  The API endpoint lets you perform the following operations:  * Assign privileges * Add users * Define sharing visibility * Add sub-groups * Assign a default Liveboard      
   * @param createUserGroupRequest 
   */
  createUserGroup(createUserGroupRequest, _options) {
    const result = this.api.createUserGroup(createUserGroupRequest, _options);
    return result.toPromise();
  }
  /**
   *  Create a variable which can be used for parameterizing metadata objects   Version: 10.14.0.cl or later   Allows creating a variable which can be used for parameterizing metadata objects in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports the following types of variables: * CONNECTION_PROPERTY - For connection properties * TABLE_MAPPING - For table mappings * CONNECTION_PROPERTY_PER_PRINCIPAL - For connection properties per principal. In order to use this please contact support to enable this. * FORMULA_VARIABLE - For Formula variables, introduced in 10.15.0.cl  When creating a variable, you need to specify: * The variable type * A unique name for the variable * Whether the variable contains sensitive values (defaults to false) * The data type of the variable, only specify for formula variables (defaults to null)  The operation will fail if: * The user lacks required permissions * The variable name already exists * The variable type is invalid     
   * @param createVariableRequest 
   */
  createVariable(createVariableRequest, _options) {
    const result = this.api.createVariable(createVariableRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.14.0.cl or later   Creates a new webhook configuration to receive notifications for specified events. The webhook will be triggered when the configured events occur in the system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param createWebhookConfigurationRequest 
   */
  createWebhookConfiguration(createWebhookConfigurationRequest, _options) {
    const result = this.api.createWebhookConfiguration(createWebhookConfigurationRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Creates a DBT connection object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About create DBT connection DBT connection in ThoughtSpot is used by the user to define DBT credentials for cloud . The API needs  embrace connection, embrace database name, DBT url, import type, DBT account identifier, DBT project identifier, DBT access token and environment details (or) embrace connection, embrace database name, import type, file_content to create a connection object. To know more about DBT, see ThoughtSpot Product Documentation.      
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  dbtConnection(connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    const result = this.api.dbtConnection(connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Resynchronize the existing list of models, tables, worksheet tmls and import them to Thoughtspot based on the DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateSyncTml(dbtConnectionIdentifier, fileContent, _options) {
    const result = this.api.dbtGenerateSyncTml(dbtConnectionIdentifier, fileContent, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Generate required table and worksheet and import them.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About generate TML Models and Worksheets to be imported can be selected by the user as part of the API.      
   * @param dbtConnectionIdentifier Unique ID of the DBT connection.
   * @param modelTables List of Models and their respective Tables Example: \\\&#39;[{\\\&quot;model_name\\\&quot;: \\\&quot;model_name\\\&quot;, \\\&quot;tables\\\&quot;: [\\\&quot;table_name\\\&quot;]}]\\\&#39;
   * @param importWorksheets Mention the worksheet tmls to import
   * @param worksheets List of worksheets is mandatory when import_Worksheets is type SELECTED Example: [\\\&quot;worksheet_name\\\&quot;]
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is mandatory if the connection was created with import_type ZIP_FILE
   */
  dbtGenerateTml(dbtConnectionIdentifier, modelTables, importWorksheets, worksheets, fileContent, _options) {
    const result = this.api.dbtGenerateTml(dbtConnectionIdentifier, modelTables, importWorksheets, worksheets, fileContent, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Gets a list of DBT connection objects by user and organization, available on the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About search DBT connection To get details of a specific DBT connection identifier, database connection identifier, database connection name, database name, project name, project identifier, environment identifier , import type and author.      
   */
  dbtSearch(_options) {
    const result = this.api.dbtSearch(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.7.0.cl or later   Deactivates a user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To deactivate a user account, the API request body must include the following information:  - Username or the GUID of the user account - Base URL of the ThoughtSpot instance  If the API request is successful, ThoughtSpot returns the activation URL in the response. The activation URL is valid for 14 days and can be used to re-activate the account and reset the password of the deactivated account.      
   * @param deactivateUserRequest 
   */
  deactivateUser(deactivateUserRequest, _options) {
    const result = this.api.deactivateUser(deactivateUserRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines To delete a custom calendar, specify the calendar ID as a path parameter in the request URL.        
   * @param calendarIdentifier Unique ID or name of the Calendar.
   */
  deleteCalendar(calendarIdentifier, _options) {
    const result = this.api.deleteCalendar(calendarIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Deletes Git repository configuration from your ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param deleteConfigRequest 
   */
  deleteConfig(deleteConfigRequest, _options) {
    const result = this.api.deleteConfig(deleteConfigRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later    **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Delete Connection V2](#/http/api-endpoints/connections/delete-connection-v2) endpoint to delete your connection objects.    #### Usage guidelines  Deletes a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.     
   * @param deleteConnectionRequest 
   */
  deleteConnection(deleteConnectionRequest, _options) {
    const result = this.api.deleteConnection(deleteConnectionRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Deletes connection configuration objects.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param deleteConnectionConfigurationRequest 
   */
  deleteConnectionConfiguration(deleteConnectionConfigurationRequest, _options) {
    const result = this.api.deleteConnectionConfiguration(deleteConnectionConfigurationRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.4.0.cl or later   Deletes a connection object.  **Note**: If a connection has dependent objects, make sure you remove its associations before the delete operation.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.      
   * @param connectionIdentifier Unique ID or name of the connection.
   */
  deleteConnectionV2(connectionIdentifier, _options) {
    const result = this.api.deleteConnectionV2(connectionIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.6.0.cl or later   Removes the custom action specified in the API request.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param customActionIdentifier Unique ID or name of the custom action.
   */
  deleteCustomAction(customActionIdentifier, _options) {
    const result = this.api.deleteCustomAction(customActionIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Removes the specified DBT connection object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   */
  deleteDbtConnection(dbtConnectionIdentifier, _options) {
    const result = this.api.deleteDbtConnection(dbtConnectionIdentifier, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.10.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `template_identifier` from the response. - Use that `template_identifier` as a parameter in this API request.      
   * @param templateIdentifier Unique ID or name of the email customization.
   */
  deleteEmailCustomization(templateIdentifier, _options) {
    const result = this.api.deleteEmailCustomization(templateIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified metadata object from the ThoughtSpot system.  Requires edit access to the metadata object.       
   * @param deleteMetadataRequest 
   */
  deleteMetadata(deleteMetadataRequest, _options) {
    const result = this.api.deleteMetadata(deleteMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes an Org object from the ThoughtSpot system.  Requires cluster administration (**Can administer Org**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.  When you delete an Org, all its users and objects created in that Org context are removed. However, if the users in the deleted Org also exists in other Orgs, they are removed only from the deleted Org.      
   * @param orgIdentifier ID or name of the Org
   */
  deleteOrg(orgIdentifier, _options) {
    const result = this.api.deleteOrg(orgIdentifier, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.12.0.cl or later   Deletes the configuration for the email customization.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  - Call the search API endpoint to get the `org_identifier` from the response. - Use that `org_identifier` as a parameter in this API request.      
   * @param deleteOrgEmailCustomizationRequest 
   */
  deleteOrgEmailCustomization(deleteOrgEmailCustomizationRequest, _options) {
    const result = this.api.deleteOrgEmailCustomization(deleteOrgEmailCustomizationRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.5.0.cl or later   Deletes a Role object from the ThoughtSpot system.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To delete a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role. ReadOnly roles cannot be deleted.
   */
  deleteRole(roleIdentifier, _options) {
    const result = this.api.deleteRole(roleIdentifier, _options);
    return result.toPromise();
  }
  /**
   *  Deletes a scheduled job.    Version: 9.4.0.cl or later   Deletes a scheduled Liveboard job.  Requires at least edit access to Liveboard or `ADMINISTRATION` (**Can administer Org**) privilege.    If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.      
   * @param scheduleIdentifier Unique ID or name of the scheduled job.
   */
  deleteSchedule(scheduleIdentifier, _options) {
    const result = this.api.deleteSchedule(scheduleIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a tag object from the ThoughtSpot system  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Tag identifier Tag name or Tag id.
   */
  deleteTag(tagIdentifier, _options) {
    const result = this.api.deleteTag(tagIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a user from the ThoughtSpot system.  If you want to remove a user from a specific Org but not from ThoughtSpot, update the group and Org mapping properties of the user object via a POST API call to the [/api/rest/2.0/users/{user_identifier}/update](#/http/api-endpoints/users/update-user) endpoint.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   */
  deleteUser(userIdentifier, _options) {
    const result = this.api.deleteUser(userIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the specified group object from the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.      
   * @param groupIdentifier GUID or name of the group.
   */
  deleteUserGroup(groupIdentifier, _options) {
    const result = this.api.deleteUserGroup(groupIdentifier, _options);
    return result.toPromise();
  }
  /**
   *  Delete a variable   Version: 10.14.0.cl or later   Allows deleting a variable from ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint requires: * The variable identifier (ID or name)  The operation will fail if: * The user lacks required permissions * The variable doesn\'t exist * The variable is being used by other objects      
   * @param identifier Unique id or name of the variable
   */
  deleteVariable(identifier, _options) {
    const result = this.api.deleteVariable(identifier, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.14.0.cl or later   Deletes one or more webhook configurations by their unique id or name. Returns status of each deletion operation, including successfully deleted webhooks and any failures with error details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param deleteWebhookConfigurationsRequest 
   */
  deleteWebhookConfigurations(deleteWebhookConfigurationsRequest, _options) {
    const result = this.api.deleteWebhookConfigurations(deleteWebhookConfigurationsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to deploy a commit and publish TML content to your ThoughtSpot instance.  Requires at least edit access to the objects used in the deploy operation.  The API deploys the head of the branch unless a `commit_id` is specified in the API request. If the branch name is not defined in the request, the default branch is considered for deploying commits.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param deployCommitRequest 
   */
  deployCommit(deployCommitRequest, _options) {
    const result = this.api.deployCommit(deployCommitRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Exports the difference in connection metadata between CDW and ThoughtSpot  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:   - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  To download the connection metadata difference between ThoughtSpot and CDW, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  downloadConnectionMetadataChanges(connectionIdentifier, _options) {
    const result = this.api.downloadConnectionMetadataChanges(connectionIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Exports an Answer in the given file format. You can download the Answer data as a PDF, PNG, CSV, or XLSX file.  Requires at least view access to the Answer.  #### Usage guidelines  In the request body, the GUID or name of the Answer and set `file_format`. The default file format is CSV.  **NOTE**: * The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension. * HTML rendering is not supported for PDF exports of Answers with tables.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.       
   * @param exportAnswerReportRequest 
   */
  exportAnswerReport(exportAnswerReportRequest, _options) {
    const result = this.api.exportAnswerReport(exportAnswerReportRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Exports a Liveboard and its visualizations in PDF, PNG, CSV, or XLSX file format.  Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To generate a Liveboard report with specific visualizations, add GUIDs or names of the visualizations.  The default `file_format` is CSV. For PDF exports, you can specify additional parameters to customize the page orientation and include or exclude the cover page, logo, footer text, and page numbers. Similar customization options are available for PNG exports. CSV and XLSX exports do not support customization options.  **NOTE**: The downloadable file returned in API response file is extensionless. Please rename the downloaded file by typing in the relevant extension.  Optionally, you can define [runtime overrides](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_runtime_overrides) to apply to the Answer data.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes, including ad hoc changes to visualizations. For more information, see [Liveboard Report API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_liveboard_report_api).    **NOTE**: Starting with ThoughtSpot Cloud 10.9.0.cl release, the Liveboard can be exported in the PNG format in the resolution of your choice. To enable this on your instance, contact ThoughtSpot support. When this feature is enabled, the options `include_cover_page`,`include_filter_page` within the `png_options` will not be available for PNG exports.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in CSV format. All visualizations in the Liveboard can be exported as individual CSV files. If multiple visualizations are selected or if the entire Liveboard is exported, the output is returned as a .zip file containing the CSV files for each visualization.  **NOTE**: Starting with the ThoughtSpot Cloud 26.2.0.cl release, Liveboards can be exported in XLSX format. All selected visualizations are consolidated into a single Excel workbook (.xlsx), with each visualization placed in its own worksheet (tab). XLSX exports are limited to 255 worksheets (tabs) per workbook.      
   * @param exportLiveboardReportRequest 
   */
  exportLiveboardReport(exportLiveboardReportRequest, _options) {
    const result = this.api.exportLiveboardReport(exportLiveboardReportRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  Requires `DATADOWNLOADING` (**Can download Data**) and at least view access to the metadata object.  #### Usage guidelines  * You can export one or several objects by passing metadata object GUIDs in the `metadata` array. * When exporting TML content for a Liveboard or Answer object, you can set `export_associated` to `true` to retrieve TML content for underlying Worksheets, Tables, or Views, including the GUID of each object within the headers. When   `export_associated` is set to `true`, consider retrieving one metadata object at a time. * Set `export_fqns` to `true` to add FQNs of the referenced objects in the TML content. For example, if you send an API request to retrieve TML for a Liveboard and its associated objects, the API returns the TML content with FQNs of the referenced Worksheet. Exporting TML with FQNs is useful if ThoughtSpot has multiple objects with the same name and you want to eliminate ambiguity when importing TML files into ThoughtSpot. It eliminates the need for adding FQNs of the referenced objects manually during the import operation. * To export only the TML of feedbacks associated with an object, set the GUID of the object as `identifier`, and set the `type` as `FEEDBACK` in the `metadata` array. * To export the TML of an object along with the feedbacks associated with it, set the GUID of the object as `identifier`, set the `type` as `LOGIAL_TABLE` in the `metadata` array, and set `export_with_associated_feedbacks` in `export_options` to true.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_export_a_tml).  For more information on feedbacks, see [Feedback Documentation](https://docs.thoughtspot.com/cloud/latest/sage-feedback).     
   * @param exportMetadataTMLRequest 
   */
  exportMetadataTML(exportMetadataTMLRequest, _options) {
    const result = this.api.exportMetadataTML(exportMetadataTMLRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.1.0.cl or later   Exports the [TML](https://docs.thoughtspot.com/cloud/latest/tml) representation of metadata objects in JSON or YAML format.  ### **Permissions Required**  Requires `DATAMANAGEMENT` (**Can manage data**) and `USERMANAGEMENT` (**Can manage users**) privileges.  #### **Usage Guidelines**  This API is only applicable for `USER`, `GROUP`, and `ROLES` metadata types.  - `batch_offset` Indicates the starting position within the complete dataset from which the API should begin returning objects. Useful for paginating results efficiently. - `batch_size` Specifies the number of objects or items to retrieve in a single request. Helps control response size for better performance. - `edoc_format` Defines the format of the TML content. The exported metadata can be in JSON or YAML format. - `export_dependent` Specifies whether to include dependent metadata objects in the export. Ensures related objects are also retrieved if needed. - `all_orgs_override` Indicates whether the export operation applies across all organizations. Useful for multi-tenant environments where cross-org exports are required.      
   * @param exportMetadataTMLBatchedRequest 
   */
  exportMetadataTMLBatched(exportMetadataTMLBatchedRequest, _options) {
    const result = this.api.exportMetadataTMLBatched(exportMetadataTMLBatchedRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches data from a saved Answer.  Requires at least view access to the saved Answer.  The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_apis).     
   * @param fetchAnswerDataRequest 
   */
  fetchAnswerData(fetchAnswerDataRequest, _options) {
    const result = this.api.fetchAnswerData(fetchAnswerDataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for an Answer object.  Requires at least view access to the Answer object.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {    \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",    \"metadata_name\":\"Total sales\",    \"metadata_type\":\"ANSWER\",    \"sql_queries\":[       {          \"metadata_id\":\"8fbe44a8-46ad-4b16-8d39-184b2fada490\",          \"metadata_name\":\"Total sales -test\",          \"sql_query\":\"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  \\\"ta_2\\\".\\\"PRODUCTNAME\\\" \\\"ca_2\\\", \\n  \\\"ta_1\\\".\\\"STORENAME\\\" \\\"ca_3\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_4\\\", \\n  CASE\\n    WHEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_3\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_5\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_3\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_3\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_PRODUCTS\\\" \\\"ta_2\\\"\\n    ON \\\"ta_3\\\".\\\"PRODUCTID\\\" = \\\"ta_2\\\".\\\"PRODUCTID\\\"\\nGROUP BY \\n  \\\"ca_1\\\", \\n  \\\"ca_2\\\", \\n  \\\"ca_3\\\"\\n\"       }    ] } ```      
   * @param fetchAnswerSqlQueryRequest 
   */
  fetchAnswerSqlQuery(fetchAnswerSqlQueryRequest, _options) {
    const result = this.api.fetchAnswerSqlQuery(fetchAnswerSqlQueryRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.4.0.cl or later   Gets information about the status of the TML async import task scheduled using the `/api/rest/2.0/metadata/tml/async/import` API call.  To fetch the task details, specify the ID of the TML async import task.    Requires access to the task ID. The API allows users who initiated the asynchronous TML import via `/api/rest/2.0/metadata/tml/async/import` to view the status of their tasks.  Users with administration privilege can view the status of all import tasks initiated by the users in their Org.  #### Usage guidelines  See [TML API Documentation](https://developers.thoughtspot.com/docs/tml#_fetch_status_of_the_tml_import_task) for usage guidelines.     
   * @param fetchAsyncImportTaskStatusRequest 
   */
  fetchAsyncImportTaskStatus(fetchAsyncImportTaskStatusRequest, _options) {
    const result = this.api.fetchAsyncImportTaskStatus(fetchAsyncImportTaskStatusRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.12.0.cl or later   Fetches column security rules for specified tables.  This API endpoint retrieves column-level security rules configured for tables. It returns information about which columns are secured and which groups have access to those columns.  #### Usage guidelines  - Provide an array of table identifiers using either `identifier` (GUID or name) or `obj_identifier` (object ID) - At least one of `identifier` or `obj_identifier` must be provided for each table - The API returns column security rules for all specified tables - Users must have appropriate permissions to access security rules for the specified tables  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables  #### Example request  ```json {   \"tables\": [     {       \"identifier\": \"table-guid\",       \"obj_identifier\": \"table-object-id\"     }   ] } ```  #### Response format  The API returns an array of `ColumnSecurityRuleResponse` objects wrapped in a `data` field. Each `ColumnSecurityRuleResponse` object contains: - Table information (GUID and object ID)   - Array of column security rules with column details, group access, and source table information  #### Example response  ```json {   \"data\": [     {       \"guid\": \"table-guid\",       \"objId\": \"table-object-id\",       \"columnSecurityRules\": [         {           \"column\": {             \"id\": \"col_123\",             \"name\": \"Salary\"           },           \"groups\": [             {               \"id\": \"group_1\",               \"name\": \"HR Department\"             }           ],           \"sourceTableDetails\": {             \"id\": \"source-table-guid\",             \"name\": \"Employee_Data\"           }         }       ]     }   ] } ```     
   * @param fetchColumnSecurityRulesRequest 
   */
  fetchColumnSecurityRules(fetchColumnSecurityRulesRequest, _options) {
    const result = this.api.fetchColumnSecurityRules(fetchColumnSecurityRulesRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Validates the difference in connection metadata between CDW and ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  Returns a boolean indicating whether there is any difference between the connection metadata at ThoughtSpot and CDW.  To get the connection metadata difference status, pass the connection GUID as `connection_identifier` in the API request.      
   * @param connectionIdentifier GUID of the connection
   */
  fetchConnectionDiffStatus(connectionIdentifier, _options) {
    const result = this.api.fetchConnectionDiffStatus(connectionIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets data from a Liveboard object and its visualization.    Requires at least view access to the Liveboard.  #### Usage guidelines  In the request body, specify the GUID or name of the Liveboard. To get data for specific visualizations, add the GUIDs or names of the visualizations in the API request.  To include unsaved changes in the report, pass the `transient_pinboard_content` script generated from the `getExportRequestForCurrentPinboard` method in the Visual Embed SDK. Upon successful execution, the API returns the report with unsaved changes. If the new Liveboard experience mode, the transient content includes ad hoc changes to visualizations such as sorting, toggling of legends, and data drill down.  For more information, and see [Liveboard data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_fetch_liveboard_data_api).     
   * @param fetchLiveboardDataRequest 
   */
  fetchLiveboardData(fetchLiveboardDataRequest, _options) {
    const result = this.api.fetchLiveboardData(fetchLiveboardDataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches the underlying SQL query data for a Liveboard object and its visualizations.  Requires at least view access to the Liveboard object.  To get SQL query data for a Liveboard, specify the GUID of the Liveboard. Optionally, you can add an array of visualization GUIDs to retrieve the SQL query data for visualizations in the Liveboard.  Upon successful execution, the API returns the SQL queries for the specified object as shown in this example: ``` {   \"metadata_id\": \"fa68ae91-7588-4136-bacd-d71fb12dda69\",   \"metadata_name\": \"Total Sales\",   \"metadata_type\": \"LIVEBOARD\",   \"sql_queries\": [     {       \"metadata_id\": \"b3b6d2b9-089a-490c-8e16-b144650b7843\",       \"metadata_name\": \"Total quantity purchased, Total sales by region\",       \"sql_query\": \"SELECT \\n  \\\"ta_1\\\".\\\"REGION\\\" \\\"ca_1\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"QUANTITYPURCHASED\\\")\\n    ELSE 0\\n  END \\\"ca_2\\\", \\n  CASE\\n    WHEN sum(\\\"ta_2\\\".\\\"SALES\\\") IS NOT NULL THEN sum(\\\"ta_2\\\".\\\"SALES\\\")\\n    ELSE 0\\n  END \\\"ca_3\\\"\\nFROM \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"FACT_RETAPP_SALES\\\" \\\"ta_2\\\"\\n  JOIN \\\"RETAILAPPAREL\\\".\\\"PUBLIC\\\".\\\"DIM_RETAPP_STORES\\\" \\\"ta_1\\\"\\n    ON \\\"ta_2\\\".\\\"STOREID\\\" = \\\"ta_1\\\".\\\"STOREID\\\"\\nGROUP BY \\\"ca_1\\\"\"     }   ] } ```      
   * @param fetchLiveboardSqlQueryRequest 
   */
  fetchLiveboardSqlQuery(fetchLiveboardSqlQueryRequest, _options) {
    const result = this.api.fetchLiveboardSqlQuery(fetchLiveboardSqlQueryRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches security audit logs.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the [Admin Control](https://developers.thoughtspot.com/docs/rbac#_admin_control) privileges are required.   #### Usage guidelines  By default, the API retrieves logs for the last 24 hours. You can set a custom duration in EPOCH time. Make sure the log duration specified in your API request doesnt exceed 24 hours. If you must fetch logs for a longer time range, modify the duration and make multiple sequential API requests.  Upon successful execution, the API returns logs with the following information: * timestamp of the event * event ID * event type * name and GUID of the user * IP address of ThoughtSpot instance  For more information see [Audit logs Documentation](https://developers.thoughtspot.com/docs/audit-logs).      
   * @param fetchLogsRequest 
   */
  fetchLogs(fetchLogsRequest, _options) {
    const result = this.api.fetchLogs(fetchLogsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches object permission details for a given principal object such as a user and group.  Requires view access to the metadata object.   #### Usage guidelines  * To get a list of all metadata objects that a user or group can access, specify the `type` and GUID or name of the principal. * To get permission details for a specific object, add the `type` and GUID or name of the metadata object to your API request.  Upon successful execution, the API returns a list of metadata objects and permission details for each object.        
   * @param fetchPermissionsOfPrincipalsRequest 
   */
  fetchPermissionsOfPrincipals(fetchPermissionsOfPrincipalsRequest, _options) {
    const result = this.api.fetchPermissionsOfPrincipals(fetchPermissionsOfPrincipalsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Fetches permission details for a given metadata object.  Requires view access to the metadata object.  #### Usage guidelines  * To fetch a list of users and groups for a metadata object, specify `type` and GUID or name of the metadata object. * To get permission details for a specific user or group, add `type` and GUID or name of the principal object to your API request.  Upon successful execution, the API returns permission details and principal information for the object specified in the API request.      
   * @param fetchPermissionsOnMetadataRequest 
   */
  fetchPermissionsOnMetadata(fetchPermissionsOnMetadataRequest, _options) {
    const result = this.api.fetchPermissionsOnMetadata(fetchPermissionsOnMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Enforces logout on current user sessions.    Use this API with caution as it may invalidate active user sessions and force users to re-login. Make sure you specify the usernames or GUIDs. If you pass null values in the API call, all user sessions on your cluster become invalid, and the users are forced to re-login.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param forceLogoutUsersRequest 
   */
  forceLogoutUsers(forceLogoutUsersRequest, _options) {
    const result = this.api.forceLogoutUsers(forceLogoutUsersRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Exports a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal) in the CSV format.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  Use this API to download a custom calendar in the CSV file format. In your API request, specify the following parameters.  * Start and end date of the calendar. For \"month offset\" calendars, the start date must match the month defined in the `month_offset` attribute.  You can also specify optional parameters such as the starting day of the week and prefixes for the quarter and year labels.      
   * @param generateCSVRequest 
   */
  generateCSV(generateCSVRequest, _options) {
    const result = this.api.generateCSV(generateCSVRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves details of the current user session for the token provided in the request header.  Any ThoughtSpot user can access this endpoint and send an API request. The data returned in the API response varies according to user\'s privilege and object access permissions.     
   */
  getCurrentUserInfo(_options) {
    const result = this.api.getCurrentUserInfo(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.4.0.cl or later   Retrieves details of the current session token for the bearer token provided in the request header.  This API endpoint does not create a new token. Instead, it returns details about the token, including the token string, creation time, expiration time, and the associated user.  Use this endpoint to introspect your current session token, debug authentication issues, or when a frontend application needs session token details.  Any ThoughtSpot user with a valid bearer token can access this endpoint and send an API request      
   */
  getCurrentUserToken(_options) {
    const result = this.api.getCurrentUserToken(_options);
    return result.toPromise();
  }
  /**
   *   Version: 10.4.0.cl or later   Gets an authentication token with custom rules and security attributes and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  To add a new user and assign privileges during auto creation, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  To assign security attributes with filter rules and Parameters to the JWT token, you\'ll need administrator privileges and edit access to the data source (Worksheet or Model). If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege and edit access to the data source is required.  #### Usage guidelines  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key`.  To generate a `secret_key` on your cluster, the administrator must enable [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable) in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  ##### Attribute-Based Access Control (ABAC) with tokens  To implement Attribute-Based Access Control (ABAC) and assign security entitlements to users during session creation, you can generate a token with custom filtering rules and Parameters in the `filter_rules` and `parameter_values` array respectively. These attributes can be configured to persist on a specific set of objects for user sessions initiated using the token. Once defined, the rules are added to the user\'s `access_control_properties` object, after which all sessions will use the persisted values.  Specify the object type as `LOGICAL_TABLE`.   For more information, see [ABAC via tokens Documentation](https://developers.thoughtspot.com/docs/api-authv2#_get_tokens_with_custom_rules_and_filter_conditions).  ##### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `groups`  Set `auto_create` to `true` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true` in the API request, the user properties such as the display name, email, Org and group assignment will not be updated with new values. If `auto_create` is set to `true`, it won\'t create formula variables and hence won\'t be applicable for `variable_values`.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  ##### Important point to note All options in the token creation APIs that define access to the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created. Persist options such as  `APPEND`, `REPLACE`, `RESET` will persist security parameters on the user profile when the token is created, while Persist option `NONE` will not persist anything but will be honoured in the session.  ##### Formula Variables Before using variables_values, variables must be created using Create Variable API with type as Formula_Variable (/api/rest/2.0/template/variables/create) The persist_option RESET and NONE cannot be used when variable_values are provided in the request. If you are working with variable_values, you must use other (APPEND, REPLACE) supported modes. If you want to use RESET or NONE, do not pass any variable_values. In such cases, variable_values will remain unaffected. When using object_id with variable_values, models are supported.      
   * @param getCustomAccessTokenRequest 
   */
  getCustomAccessToken(getCustomAccessTokenRequest, _options) {
    const result = this.api.getCustomAccessToken(getCustomAccessTokenRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token and creates a full session in ThoughtSpot for a given user. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret_key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page. For more information, see [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable).  **Note**: When both `password` and `secret_key` are included in the API request, `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getFullAccessTokenRequest 
   */
  getFullAccessToken(getFullAccessTokenRequest, _options) {
    const result = this.api.getFullAccessToken(getFullAccessTokenRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets an authentication token that provides access to a specific metadata object. By default, the token obtained from ThoughtSpot remains valid for 5 mins.  You can generate the token for a user by providing a `username` and `password`, or by using the clusters `secret key` (for [Trusted authentication](https://developers.thoughtspot.com/docs/?pageid=trusted-auth#trusted-auth-enable)).  To generate a `secret_key` on your cluster, the administrator must enable **Trusted authentication** in the **Develop** > **Customizations** > **Security Settings** page.  **Note**: When both `password` and `secret_key` are included in the API request,  `password` takes precedence.  If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. You can switch to token-based authentication with  `secret_key`  or contact ThoughtSpot Support for assistance.  #### Just-in-time provisioning  For just-in-time user creation and provisioning, define the following attributes:  * `auto_create` * `username` * `display_name` * `email` * `group_identifiers`  Set `auto_create` to `True` if the user is not available in ThoughtSpot. If the user already exists in ThoughtSpot and the `auto_create` parameter is set to `true`, the API call will update user properties like display name, email and group assignment.  For more information, see [Just-in-time provisioning](https://developers.thoughtspot.com/docs/just-in-time-provisioning).  To add a new user and assign privileges, you need `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled, the `CONTROL_TRUSTED_AUTH`(**Can Enable or Disable Trusted Authentication**) privilege is required.  #### Important point to note All options in the token creation APIs changing the content in ThoughtSpot will do so during the token creation and not when the token is being used for authentication. For example, `auto_create:true` will create the user when the authentication token is created.      
   * @param getObjectAccessTokenRequest 
   */
  getObjectAccessToken(getObjectAccessTokenRequest, _options) {
    const result = this.api.getObjectAccessToken(getObjectAccessTokenRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.13.0.cl or later   Breaks down a user-submitted query into a series of analytical sub-questions using relevant contextual metadata.  To use this API, the user must have at least view-level access to the referenced metadata objects.  #### Usage guidelines  To accurately generate relevant questions, the request must include at least one of the following metadata identifiers within `metadata_context` : `conversation_identifier`, `answer_identifiers`, `liveboard_identifiers`, or `data_source_identifiers`.  You can further enhance the quality and precision of breakdown by providing additional `ai_context` such as:  - `content`: User provided content like text data, csv data as a string message to provide context & potentially improve the quality of the response. - `instructions`: User specific text instructions sent to AI system for processing the query.  Additional optional parameters include:  - `limit_relevant_questions`: Controls the maximum number of relevant questions returned. Defaults to 5 if not specified. - `bypass_cache`: If set to true, forces fresh computation instead of returning cached results.  If the API request is successful, ThoughtSpot returns a list of relevant analytical queries, each aligned with the user\'s original question. Each returned question includes the query string, along with the identifier and name of the corresponding data source.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.     
   * @param getRelevantQuestionsRequest 
   */
  getRelevantQuestions(getRelevantQuestionsRequest, _options) {
    const result = this.api.getRelevantQuestions(getRelevantQuestionsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Retrieves the current configuration details of the cluster. If the request is successful, the API returns a list configuration settings applied on the cluster.  Requires `ADMINISTRATION`(**Can administer ThoughtSpot**) privilege to view these complete configuration settings of the cluster. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.      
   */
  getSystemConfig(_options) {
    const result = this.api.getSystemConfig(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets system information such as the release version, locale, time zone, deployment environment, date format, and date time format of the cluster.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `SYSTEM_INFO_ADMINISTRATION` (**Can view system activities**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemInformation(_options) {
    const result = this.api.getSystemInformation(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of configuration overrides applied on the cluster.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.  This API does not require any parameters to be passed in the request.        
   */
  getSystemOverrideInfo(_options) {
    const result = this.api.getSystemOverrideInfo(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Imports [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  *  Import all related objects in a single TML Import API call. For example, Tables that use the same Connection object and Worksheets connected to these Tables. * Include the `fqn` property to distinguish objects that have the same name.   For example, if you have multiple Connections or Worksheets with the same name on ThoughtSpot and the Connection or Worksheet referenced in your TML file does not have a unique name to distinguish, it may result in invalid object references.   Adding `fqn` helps ThoughtSpot differentiate a Table from another with the same name.   We recommend [exporting TML with FQNs](#/http/api-endpoints/metadata/export-metadata-tml) and using these during the import operation. * You can upload multiple TML files at a time.   If you import a Worksheet along with Liveboards, Answers, and other dependent objects in a single API call, the imported objects will be immediately available for use.   When you import only a Worksheet object, it may take some time for the Worksheet to become available in the ThoughtSpot system. Please wait for a few minutes, and then proceed to create an Answer and Liveboard from the newly imported Worksheet.  For more information, see [TML Documentation](https://developers.thoughtspot.com/docs/tml#_import_a_tml).      
   * @param importMetadataTMLRequest 
   */
  importMetadataTML(importMetadataTMLRequest, _options) {
    const result = this.api.importMetadataTML(importMetadataTMLRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.4.0.cl or later   Schedules a task to import [TML](https://docs.thoughtspot.com/cloud/latest/tml) files into ThoughtSpot. You can use this API endpoint to process TML objects asynchronously when importing TMLs of large and complex metadata objects into ThoughtSpot. Unlike the synchronous import TML operation, the API processes TML data in the background and returns a task ID, which can be used to check the status of the import task via `/api/rest/2.0/metadata/tml/async/status` API endpoint.  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtsSpot**) privilege, and edit access to the TML objects.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following Data control privileges may be required: - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### Usage guidelines  See [Async TML API Documentation](https://developers.thoughtspot.com/docs/tml#_import_tml_objects_asynchronously) for usage guidelines.      
   * @param importMetadataTMLAsyncRequest 
   */
  importMetadataTMLAsync(importMetadataTMLAsyncRequest, _options) {
    const result = this.api.importMetadataTMLAsync(importMetadataTMLAsyncRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Imports group objects from external databases into ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  During the import operation:  * If the specified group is not available in ThoughtSpot, it will be added to ThoughtSpot. * If `delete_unspecified_groups` is set to `true`, the groups not specified in the API request, excluding administrator and system user groups, are deleted. * If the specified groups are already available in ThoughtSpot, the object properties of these groups are modified and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.      
   * @param importUserGroupsRequest 
   */
  importUserGroups(importUserGroupsRequest, _options) {
    const result = this.api.importUserGroups(importUserGroupsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Imports user data from external databases into ThoughtSpot. During the user import operation:  * If the specified users are not available in ThoughtSpot, the users are created and assigned a default password. Defining a `default_password` in the API request is optional. * If `delete_unspecified_users` is set to `true`, the users not specified in the API request, excluding the `tsadmin`, `guest`, `system` and `su` users, are deleted. * If the specified user objects are already available in ThoughtSpot, the object properties are updated and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param importUsersRequest 
   */
  importUsers(importUsersRequest, _options) {
    const result = this.api.importUsers(importUsersRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a login session for a ThoughtSpot user with Basic authentication.  In Basic authentication method, REST clients log in to ThoughtSpot using `username` and `password` attributes. On a multi-tenant cluster with Orgs, users can pass the ID of the Org in the API request to log in to a specific Org context.  **Note**: If Multi-Factor Authentication (MFA) is enabled on your instance, the API login request with basic authentication (`username`  and `password` ) returns an error. Contact ThoughtSpot Support for assistance.  A successful login returns a session cookie that can be used in your subsequent API requests.     
   * @param loginRequest 
   */
  login(loginRequest, _options) {
    const result = this.api.login(loginRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later    Logs out a user from their current session.      
   */
  logout(_options) {
    const result = this.api.logout(_options);
    return result.toPromise();
  }
  /**
   *  Parameterize fields in metadata objects.   Version: 10.9.0.cl or later   Allows parameterizing fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows parameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be parameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param parameterizeMetadataRequest 
   */
  parameterizeMetadata(parameterizeMetadataRequest, _options) {
    const result = this.api.parameterizeMetadata(parameterizeMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.9.0.cl or later   Allows publishing metadata objects across organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows publishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  This API will essentially share the objects along with it\'s dependencies to the org admins of the orgs to which it is being published.      
   * @param publishMetadataRequest 
   */
  publishMetadata(publishMetadataRequest, _options) {
    const result = this.api.publishMetadata(publishMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   * Version: 10.7.0.cl or later 
   * @param queryGetDecomposedQueryRequest 
   */
  queryGetDecomposedQuery(queryGetDecomposedQueryRequest, _options) {
    const result = this.api.queryGetDecomposedQuery(queryGetDecomposedQueryRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Resets the password of a user account. Administrators can reset password on behalf of a user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param resetUserPasswordRequest 
   */
  resetUserPassword(resetUserPasswordRequest, _options) {
    const result = this.api.resetUserPassword(resetUserPasswordRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Reverts TML objects to a previous commit specified in the API request.  Requires at least edit access to objects.  In the API request, specify the `commit_id`. If the branch name is not specified in the request, the API will consider the default branch configured on your instance.  By default, the API reverts all objects. If the revert operation fails for one of the objects provided in the commit, the API returns an error and does not revert any object.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitId Commit id to which the object should be reverted
   * @param revertCommitRequest 
   */
  revertCommit(commitId, revertCommitRequest, _options) {
    const result = this.api.revertCommit(commitId, revertCommitRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later    Revokes the authentication token issued for current user session.  The token of your current session expires when you make a call to the `/api/rest/2.0/auth/token/revoke` endpoint. the users will not be able to access ThoughtSpot objects until a new token is obtained.  To restart your session, request for a new token from ThoughtSpot. See [Get Full Access Token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param revokeTokenRequest 
   */
  revokeToken(revokeTokenRequest, _options) {
    const result = this.api.revokeToken(revokeTokenRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Gets a list of [custom calendars](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  By default, the API returns a list of custom calendars for all connection objects. To retrieve custom calendar details for a particular connection, specify the connection ID. You can also use other search parameters such as `name_pattern` and `sort_options` as search filters.  The `name_pattern` parameter filters and returns only those objects that match the specified pattern. Use `%` as a wildcard for pattern matching.      
   * @param searchCalendarsRequest 
   */
  searchCalendars(searchCalendarsRequest, _options) {
    const result = this.api.searchCalendars(searchCalendarsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of commits for a given metadata object.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param searchCommitsRequest 
   */
  searchCommits(searchCommitsRequest, _options) {
    const result = this.api.searchCommits(searchCommitsRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.14.0.cl or later   Fetch communication channel preferences. - Use `cluster_preferences` to fetch the default preferences for your ThoughtSpot application instance. - If your instance has [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview), use `org_preferences` to fetch any Org-specific preferences that override the defaults.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege are also authorized to perform this action.      
   * @param searchCommunicationChannelPreferencesRequest 
   */
  searchCommunicationChannelPreferences(searchCommunicationChannelPreferencesRequest, _options) {
    const result = this.api.searchCommunicationChannelPreferences(searchCommunicationChannelPreferencesRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Gets Git repository connections configured on the ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param searchConfigRequest 
   */
  searchConfig(searchConfigRequest, _options) {
    const result = this.api.searchConfig(searchConfigRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Gets connection objects. Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  - To get a list of all connections available in the ThoughtSpot system, send the API request without any attributes in the request body. - To get the connection objects for a specific type of data warehouse, specify the type in `data_warehouse_types`. - To fetch details of a connection object, specify the connection object GUID or name. The `name_pattern` attribute allows passing partial text with `%` for a wildcard match. - To get details of the database, schemas, tables, or columns from a data connection object, specify `data_warehouse_object_type`. - To get a specific database, schema, table, or column from a connection object, define the object type in `data_warehouse_object_type` and object properties in the `data_warehouse_objects` array. For example, to search for a column, you must pass the database, schema, and table names in the API request.   Note that in the following example, object properties are set in a hierarchical order (`database` > `schema` > `table` > `column`).  ``` {   \"connections\": [     {       \"identifier\": \"b9d1f2ef-fa65-4a4b-994e-30fa2d57b0c2\",       \"data_warehouse_objects\": [         {           \"database\": \"NEBULADEV\",           \"schema\": \"INFORMATION_SCHEMA\",           \"table\": \"APPLICABLE_ROLES\",           \"column\": \"ROLE_NAME\"         }       ]     }   ],   \"data_warehouse_object_type\": \"COLUMN\" } ```  - To fetch data by `configuration`, specify `data_warehouse_object_type`. For example, to fetch columns from the `DEVELOPMENT` database, specify the `data_warehouse_object_type` as `DATABASE` and define the `configuration` string as `{\"database\":\"DEVELOPMENT\"}`. To get column data for a specific table, specify the table, for example,`{\"database\":\"RETAILAPPAREL\",\"table\":\"PIPES\"}`. - To query connections by `authentication_type`, specify `data_warehouse_object_type`. Supported values for `authentication_type` are:   - `SERVICE_ACCOUNT`: For connections that require service account credentials to authenticate to the Cloud Data Warehouse and fetch data.   - `OAUTH`: For connections that require OAuth credentials to authenticate to the Cloud Data Warehouse and fetch data. Teradata, Oracle, and Presto Cloud Data Warehouses do not support the OAuth authentication type.   - `IAM`: For connections that have the IAM OAuth set up. This authentication type is supported on Amazon Redshift connections only.   - `EXTOAUTH`: For connections that have External OAuth set up. ThoughtSpot supports external [OAuth with Microsoft Azure Active Directory (AD)](https://docs.thoughtspot.com/cloud/latest/ connections-snowflake-azure-ad-oauth) and [Okta for Snowflake data connections](https://docs.thoughtspot.com/cloud/latest/connections-snowflake-okta-oauth).   - `KEY_PAIR`: For connections that require Key Pair account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PKCE`: For connections that require OAuth with PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake, Starburst, Databricks, Denodo  connections only.   - `EXTOAUTH_WITH_PKCE`: For connections that require External OAuth With PKCE account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only.   - `OAUTH_WITH_PEZ`: For connections that require OAuth With PEZ account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Amazon Redshift connections only.   - `OAUTH_WITH_SERVICE_PRINCIPAL`: For connections that require OAuth With Service Principal account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `PERSONAL_ACCESS_TOKEN`: For connections that require Personal Access Token account credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Databricks connections only.   - `OAUTH_CLIENT_CREDENTIALS`: For connections that require OAuth Client Credentials to authenticate to the Cloud Data Warehouse and fetch data. This authentication type is supported on Snowflake connections only. - To include more details about connection objects in the API response, set `include_details` to `true`. - You can also sort the output by field names and filter connections by tags.  **NOTE**: When filtering connection records by parameters other than `data_warehouse_types` or `tag_identifiers`, ensure that you set `record_size` to `-1` and `record_offset` to `0` for precise results.      
   * @param searchConnectionRequest 
   */
  searchConnection(searchConnectionRequest, _options) {
    const result = this.api.searchConnection(searchConnectionRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.6.0.cl or later   Gets custom actions configured on the cluster.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.      
   * @param searchCustomActionsRequest 
   */
  searchCustomActions(searchCustomActionsRequest, _options) {
    const result = this.api.searchCustomActions(searchCustomActionsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Generates an Answer from a given data source.  Requires at least view access to the data source object (Worksheet or View).  #### Usage guidelines  To search data, specify the data source GUID in `logical_table_identifier`. The data source can be a Worksheet, View, Table, or SQL view.  Pass search tokens in the `query_string` attribute in the API request as shown in the following example:  ``` {   \"query_string\": \"[sales] by [store]\",   \"logical_table_identifier\": \"cd252e5c-b552-49a8-821d-3eadaa049cca\", } ```  For more information about the `query_string` format and data source attribute, see [Search data API](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_search_data_api).    The `record_size` attribute determines the number of records to retrieve in an API call. For more information about pagination, record size, and maximum row limit, see [Pagination and record size settings](https://developers.thoughtspot.com/docs/fetch-data-and-report-apis#_pagination_settings_for_data_and_report_api).       
   * @param searchDataRequest 
   */
  searchData(searchDataRequest, _options) {
    const result = this.api.searchData(searchDataRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.10.0.cl or later   Search the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   * @param searchEmailCustomizationRequest 
   */
  searchEmailCustomization(searchEmailCustomizationRequest, _options) {
    const result = this.api.searchEmailCustomization(searchEmailCustomizationRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of metadata objects available on the ThoughtSpot system.  This API endpoint is available to all users who have view access to the object. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view data for all metadata objects, including users and groups.  #### Usage guidelines  - To get all metadata objects, send the API request without any attributes. - To get metadata objects of a specific type, set the `type` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE`. - To filter metadata objects within type `LOGICAL_TABLE`, set the `subtypes` attribute. For example, to fetch a Worksheet, set the type as `LOGICAL_TABLE` & subtypes as `[WORKSHEET]`. - To get a specific metadata object, specify the GUID. - To customize your search and filter the API response, you can use several parameters.   You can search for objects created or modified by specific users, by tags applied to the objects, or by using the include parameters like `include_auto_created_objects`, `include_dependent_objects`, `include_headers`, `include_incomplete_objects`, and so on.   You can also define sorting options to sort the data retrieved in the API response. - To get discoverable objects when linientmodel is enabled you can use `include_discoverable_objects` as true else false. Default value is true. - For liveboard metadata type, to get the newer format, set the `liveboard_response_format` as V2. Default value is V1. - To retrieve only objects that are published, set the `include_only_published_objects` as true. Default value is false.  **NOTE**: The following parameters support pagination of metadata records:  - `tag_identifiers` - `type` - `subtypes` - `created_by_user_identifiers` - `modified_by_user_identifiers` - `owned_by_user_identifiers` - `exclude_objects` - `include_auto_created_objects` - `favorite_object_options` - `include_only_published_objects` If you are using other parameters to search metadata, set `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchMetadataRequest 
   */
  searchMetadata(searchMetadataRequest, _options) {
    const result = this.api.searchMetadata(searchMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of Orgs configured on the ThoughtSpot system. To get details of a specific Org, specify the Org ID or name. You can also pass parameters such as status, visibility, and user identifiers to get a specific list of Orgs.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param searchOrgsRequest 
   */
  searchOrgs(searchOrgsRequest, _options) {
    const result = this.api.searchOrgs(searchOrgsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.5.0.cl or later   Gets a list of Role objects from the ThoughtSpot system.  Available if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To search for Roles, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.  To get details of a specific Role object, specify the GUID or name. You can also filter the API response based on user group and Org identifiers, privileges assigned to the Role, and deprecation status.      
   * @param searchRolesRequest 
   */
  searchRoles(searchRolesRequest, _options) {
    const result = this.api.searchRoles(searchRolesRequest, _options);
    return result.toPromise();
  }
  /**
   *  Search Schedules    Version: 9.4.0.cl or later   Gets a list of scheduled jobs configured for a Liveboard.  To get details of a specific scheduled job, specify the name or GUID of the scheduled job.  Requires at least view access to Liveboards.  **NOTE**: When filtering schedules by parameters other than `metadata`, set `record_size` to `-1` and `record_offset` to `0` for accurate results.      
   * @param searchSchedulesRequest 
   */
  searchSchedules(searchSchedulesRequest, _options) {
    const result = this.api.searchSchedules(searchSchedulesRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of tag objects available on the ThoughtSpot system. To get details of a specific tag object, specify the GUID or name.  Any authenticated user can search for tag objects.      
   * @param searchTagsRequest 
   */
  searchTags(searchTagsRequest, _options) {
    const result = this.api.searchTags(searchTagsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of user group objects from the ThoughtSpot system.  To get details of a specific user group, specify the user group GUID or name. You can also filter the API response based on User ID, Org ID, Role ID, type of group, sharing visibility, privileges assigned to the group, and the Liveboard IDs assigned to the users in the group.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  **NOTE**: If you do not get precise results, try setting `record_size` to `-1` and `record_offset` to `0`.      
   * @param searchUserGroupsRequest 
   */
  searchUserGroups(searchUserGroupsRequest, _options) {
    const result = this.api.searchUserGroups(searchUserGroupsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of users available on the ThoughtSpot system.  To get details of a specific user, specify the user GUID or name. You can also filter the API response based on groups, Org ID, user visibility, account status, user type, and user preference settings and favorites.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  **NOTE**: If the API returns an empty list, consider increasing the value of the `record_size` parameter. To search across all available users, set `record_size` to `-1`.      
   * @param searchUsersRequest 
   */
  searchUsers(searchUsersRequest, _options) {
    const result = this.api.searchUsers(searchUsersRequest, _options);
    return result.toPromise();
  }
  /**
   *  Search variables   Version: 10.14.0.cl or later   Allows searching for variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports searching variables by: * Variable identifier (ID or name) * Variable type * Name pattern (case-insensitive, supports % for wildcard)  The search results can be formatted in three ways: * METADATA - Returns only variable metadata (default) * METADATA_AND_VALUES - Returns variable metadata and values  The values can be filtered by scope: * org_identifier * principal_identifier * model_identifier      
   * @param searchVariablesRequest 
   */
  searchVariables(searchVariablesRequest, _options) {
    const result = this.api.searchVariables(searchVariablesRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.14.0.cl or later   Searches for webhook configurations based on various criteria such as Org, webhook identifier, event type, with support for pagination and sorting. Returns matching webhook configurations with their complete details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param searchWebhookConfigurationsRequest 
   */
  searchWebhookConfigurations(searchWebhookConfigurationsRequest, _options) {
    const result = this.api.searchWebhookConfigurations(searchWebhookConfigurationsRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.13.0.cl or later   This API allows users to initiate or continue an agent (Spotter) conversation by submitting one or more natural language messages.  To use this API, the user must have access to the relevant conversational session (via conversation_identifier) and submit at least one message.   #### Usage guidelines  To initiate or continue a conversation, the request must include: - `conversation_identifier`: a unique session ID for continuity and message tracking - `messages`: an array of one or more text messages, each with a value and type  Additionally, user can specify what tool can be included `conversation_settings` parameter, which supports: - `enable_contextual_change_analysis` (default: false) - `enable_natural_language_answer_generation` (default: true) - `enable_reasoning` (default: false)  If the request is valid, the API returns a stream of messages in real time, including: - `ack`: confirms receipt of the request - `text / text-chunk`: content chunks, optionally formatted (e.g., markdown) - `answer`: the final structured response with metadata and analytics - `error`: if a failure occurs - `notification`: notification messages for operation being performed  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster. > * The streaming protocol uses Server-Sent Events (SSE)     
   * @param sendAgentMessageStreamingRequest 
   */
  sendAgentMessageStreaming(sendAgentMessageStreamingRequest, _options) {
    const result = this.api.sendAgentMessageStreaming(sendAgentMessageStreamingRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.4.0.cl or later   Allows sending a follow-up message to an ongoing conversation within the context of the metadata model.  Requires at least view access to the metadata object specified in the request.  #### Usage guidelines  The API requires you to specify the `conversation_identifier` in the request path, and a `metadata_identifier` and `message` string in the request body.  If the API request is successful, ThoughtSpot returns the session ID, tokens used in the conversation, and visualization type.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param conversationIdentifier Unique identifier of the conversation.
   * @param sendMessageRequest 
   */
  sendMessage(conversationIdentifier, sendMessageRequest, _options) {
    const result = this.api.sendMessage(conversationIdentifier, sendMessageRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Allows sharing one or several metadata objects with users and groups in ThoughtSpot.  Requires edit access to the metadata object.  The API endpoint allows sharing only the following types of metadata objects: * Liveboards * Visualizations * Answers * Worksheets * Views * Connections  You can provide `READ_ONLY` or `MODIFY` access when sharing an object with another user or group. With `READ_ONLY` access grants view access to the shared object, whereas `MODIFY` provides edit access.  To prevent a user or group from accessing the shared object, specify the GUID or name of the principal and set `shareMode` to `NO_ACCESS`.      
   * @param shareMetadataRequest 
   */
  shareMetadata(shareMetadataRequest, _options) {
    const result = this.api.shareMetadata(shareMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.4.0.cl or later   Processes a natural language query and returns an AI-generated response based on a specified data model.  Requires at least view access to the metadata object specified in the request.  > ###### Note: > * This endpoint is currently in Beta. Breaking changes may be introduced before the endpoint is made Generally Available. > * This endpoint requires Spotter - please contact ThoughtSpot support to enable Spotter on your cluster.      
   * @param singleAnswerRequest 
   */
  singleAnswer(singleAnswerRequest, _options) {
    const result = this.api.singleAnswer(singleAnswerRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Removes the tags applied to a Liveboard, Answer, Table, or Worksheet.  Requires edit access to the metadata object.      
   * @param assignTagRequest 
   */
  unassignTag(assignTagRequest, _options) {
    const result = this.api.unassignTag(assignTagRequest, _options);
    return result.toPromise();
  }
  /**
   *  Remove parameterization from fields in metadata objects.   Version: 10.9.0.cl or later   Allows removing parameterization from fields in metadata objects in ThoughtSpot.  Requires appropriate permissions to modify the metadata object.  The API endpoint allows unparameterizing the following types of metadata objects: * Logical Tables * Connections * Connection Configs  For a Logical Table the field type must be `ATTRIBUTE` and field name can be one of: * databaseName * schemaName * tableName  For a Connection or Connection Config, the field type is always `CONNECTION_PROPERTY`. In this case, field_name specifies the exact property of the Connection or Connection Config that needs to be unparameterized.  For Connection Config, the only supported field name is: * impersonate_user      
   * @param unparameterizeMetadataRequest 
   */
  unparameterizeMetadata(unparameterizeMetadataRequest, _options) {
    const result = this.api.unparameterizeMetadata(unparameterizeMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.9.0.cl or later   Allows unpublishing metadata objects from organizations in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope.  The API endpoint allows unpublishing the following types of metadata objects: * Liveboards * Answers * Logical Tables  When unpublishing objects, you can: * Include dependencies by setting `include_dependencies` to true - this will unpublish all dependent objects if no other published object is using them * Force unpublish by setting `force` to true - this will break all dependent objects in the unpublished organizations      
   * @param unpublishMetadataRequest 
   */
  unpublishMetadata(unpublishMetadataRequest, _options) {
    const result = this.api.unpublishMetadata(unpublishMetadataRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Updates the properties of a [custom calendar](https://docs.thoughtspot.com/cloud/latest/connections-cust-cal).  Requires `DATAMANAGEMENT` (**Can manage data**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your ThoughtSpot instance, the `CAN_MANAGE_CUSTOM_CALENDAR` (**Can manage custom calendars**) privilege is required.  #### Usage guidelines  You can update the properties of a calendar using one of the following methods: * `FROM_INPUT_PARAMS` to update the calendar properties with the values defined in the API request. * `FROM_EXISTING_TABLE` Creates a calendar from the parameters defined in the API request.  To update a custom calendar, specify the calendar ID as a path parameter in the request URL and the following parameters in the request body:    * Connection ID and Table name * Database and schema name attributes:   For most Cloud Data Warehouse (CDW) connectors, both `database_name` and `schema_name` attributes are required.     However, the attribute requirements are conditional and vary based on the connector type and its metadata structure. For example, for connectors such as Teradata, MySQL, SingleSore, Amazon Aurora MySQL, Amazon RDS MySQL, Oracle, and GCP_MYSQL, the `schema_name` is required, whereas the `database_name` attribute is not.   Similarly, connectors such as ClickHouse require you to specify the `database_name` and the schema specification in such cases is optional.  The API allows you to modify the calendar type, month offset value, start and end date, starting day of the week, and prefixes assigned to the year and quarter labels.     #### Examples  Update a custom calendar using an existing Table in ThoughtSpot:  ``` {   \"update_method\": \"FROM_EXISTING_TABLE\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   } } ```  Update a custom calendar with the attributes defined in the API request:  ``` {   \"update_method\": \"FROM_INPUT_PARAMS\",   \"table_reference\": {     \"connection_identifier\": \"Connection1\",     \"database_name\": \"db1\",     \"table_name\": \"custom_calendar_2025\",     \"schame_name\": \"schemaVar\"   },   \"month_offset\": \"August\",   \"start_day_of_week\": \"Monday\",   \"start_date\": \"08/01/2025\",   \"end_date\": \"07/31/2026\" } ```      
   * @param calendarIdentifier Unique Id or name of the calendar.
   * @param updateCalendarRequest 
   */
  updateCalendar(calendarIdentifier, updateCalendarRequest, _options) {
    const result = this.api.updateCalendar(calendarIdentifier, updateCalendarRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.12.0.cl or later   Creates, updates, or deletes column security rules for specified tables.  This API endpoint allows you to create, update, or delete column-level security rules on columns of a table. The operation follows an \"all or none\" policy: if defining security rules for any of the provided columns fails, the entire operation will be rolled back, and no rules will be created.  #### Usage guidelines  - Provide table identifier using either `identifier` (GUID or name) or `obj_identifier` (object ID) - Use `clear_csr: true` to remove all column security rules from the table - For each column, specify the security rule using `column_security_rules` array - Use `is_unsecured: true` to mark a specific column as unprotected - Use `group_access` operations to manage group associations:   - `ADD`: Add groups to the column\'s access list   - `REMOVE`: Remove groups from the column\'s access list   - `REPLACE`: Replace all existing groups with the specified groups  #### Required permissions  - `ADMINISTRATION` - Can administer ThoughtSpot - `DATAMANAGEMENT` - Can manage data (if RBAC is disabled) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` - Can manage worksheet views and tables (if RBAC is enabled)  #### Example request  ```json {   \"identifier\": \"table-guid\",   \"obj_identifier\": \"table-object-id\",   \"clear_csr\": false,   \"column_security_rules\": [     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"ADD\",           \"group_identifiers\": [\"hr_group_id\", \"hr_group_name\", \"finance_group_id\"]         }       ]     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": true     },     {       \"column_identifier\": \"col id or col name\",       \"is_unsecured\": false,       \"group_access\": [         {           \"operation\": \"REPLACE\",           \"group_identifiers\": [\"management_group_id\", \"management_group_name\"]         }       ]     }   ] } ```  #### Request Body Schema  - `identifier` (string, optional): GUID or name of the table for which we want to create column security rules - `obj_identifier` (string, optional): The object ID of the table - `clear_csr` (boolean, optional): If true, then all the secured columns will be marked as unprotected, and all the group associations will be removed - `column_security_rules` (array of objects, required): An array where each object defines the security rule for a specific column  Each column security rule object contains: - `column_identifier` (string, required): Column identifier (col_id or name) - `is_unsecured` (boolean, optional): If true, the column will be marked as unprotected and all groups associated with it will be removed - `group_access` (array of objects, optional): Array of group operation objects  Each group operation object contains: - `operation` (string, required): Operation type - ADD, REMOVE, or REPLACE - `group_identifiers` (array of strings, required): Array of group identifiers (name or GUID) on which the operation will be performed  #### Response  This API does not return any response body. A successful operation returns HTTP 200 status code.  #### Operation Types  - **ADD**: Adds the specified groups to the column\'s access list - **REMOVE**: Removes the specified groups from the column\'s access list   - **REPLACE**: Replaces all existing groups with the specified groups      
   * @param updateColumnSecurityRulesRequest 
   */
  updateColumnSecurityRules(updateColumnSecurityRulesRequest, _options) {
    const result = this.api.updateColumnSecurityRules(updateColumnSecurityRulesRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Updates Git repository configuration settings.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param updateConfigRequest 
   */
  updateConfig(updateConfigRequest, _options) {
    const result = this.api.updateConfig(updateConfigRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   **Important**: This endpoint is deprecated and will be removed from ThoughtSpot in September 2025. ThoughtSpot strongly recommends using the [Update connection V2](#/http/api-endpoints/connections/update-connection-v2) endpoint to update your connection objects.  #### Usage guidelines  Updates a connection object.    Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`. 3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.      
   * @param updateConnectionRequest 
   */
  updateConnection(updateConnectionRequest, _options) {
    const result = this.api.updateConnection(updateConnectionRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.12.0.cl or later   Updates a connection configuration object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  #### Supported operations This API endpoint lets you perform the following operations in a single API request:   * Edit the name or description of the configuration  * Edit the configuration properties  * Edit the `policy_type`  * Edit the type of authentication  * Enable or disable a configuration  #### Parameterized Connection Support For parameterized oauth based connections, only the `same_as_parent` and `policy_process_options` attributes are allowed. These attributes are not applicable to connections that are not parameterized.   **NOTE**: When updating a configuration where `disabled` is `true`, you must reset `disabled` to `true` in your update request payload. If not explicitly set again, the API will default `disabled` to `false`.      
   * @param configurationIdentifier Unique ID or name of the configuration.
   * @param updateConnectionConfigurationRequest 
   */
  updateConnectionConfiguration(configurationIdentifier, updateConnectionConfigurationRequest, _options) {
    const result = this.api.updateConnectionConfiguration(configurationIdentifier, updateConnectionConfigurationRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 10.4.0.cl or later   Updates a connection object.  Requires `DATAMANAGEMENT` (**Can manage data**) and edit permissions to the connection object, or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) privilege is required.  To update a connection object, pass these parameters in your API request:  1. GUID of the connection object. 2. If you are updating tables or database schema of a connection object:    a. Add the updated JSON map of metadata with database, schema, and tables in `data_warehouse_config`.    b. Set `validate` to `true`.        **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.     * A JSON map of configuration attributes, database details, and table properties in `data_warehouse_config` as shown in the following example:    * This is an example of updating a single table in a empty connection:           ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"DEMORENAME\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"Col1\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col2\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col3\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col312\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"Col4\",                         \"type\": \"VARCHAR\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```        * This is an example of updating a single table in an existing connection with tables:            ```       {         \"authenticationType\": \"SERVICE_ACCOUNT\",         \"externalDatabases\": [           {             \"name\": \"DEVELOPMENT\",             \"isAutoCreated\": false,             \"schemas\": [               {                 \"name\": \"TS_dataset\",                 \"tables\": [                   {                     \"name\": \"CUSTOMER\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [],                     \"relationships\": []                   },                   {                     \"name\": \"tpch5k_falcon_default_schema_users\",                     \"type\": \"TABLE\",                     \"description\": \"\",                     \"selected\": true,                     \"linked\": true,                     \"gid\": 0,                     \"datasetId\": \"-1\",                     \"subType\": \"\",                     \"reportId\": \"\",                     \"viewId\": \"\",                     \"columns\": [                       {                         \"name\": \"user_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"product_id\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       },                       {                         \"name\": \"user_cost\",                         \"type\": \"INT64\",                         \"canImport\": true,                         \"selected\": true,                         \"description\": \"\",                         \"isLinkedActive\": true,                         \"isAggregate\": false                       }                     ],                     \"relationships\": []                   }                 ]               }             ]           }         ],         \"configuration\": {           \"password\": \"\",           \"database\": \"DEVELOPMENT\",           \"role\": \"DEV\",           \"accountName\": \"thoughtspot_partner\",           \"warehouse\": \"DEMO_WH\",           \"user\": \"DEV_USER\"         }       }       ```  3. If you are updating a configuration attribute, connection name, or description, you can set `validate` to `false`.    **NOTE:** If the `authentication_type` is anything other than SERVICE_ACCOUNT, you must explicitly provide the authenticationType property in the payload. If you do not  specify authenticationType, the API will default to SERVICE_ACCOUNT as the authentication type.    * A JSON map of configuration attributes in `data_warehouse_config`. The following example shows the configuration attributes for a Snowflake connection:    ```    {       \"configuration\":{          \"accountName\":\"thoughtspot_partner\",          \"user\":\"tsadmin\",          \"password\":\"TestConn123\",          \"role\":\"sysadmin\",          \"warehouse\":\"MEDIUM_WH\"       },       \"externalDatabases\":[        ]    }    ```      
   * @param connectionIdentifier Unique ID or name of the connection.
   * @param updateConnectionV2Request 
   */
  updateConnectionV2(connectionIdentifier, updateConnectionV2Request, _options) {
    const result = this.api.updateConnectionV2(connectionIdentifier, updateConnectionV2Request, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.6.0.cl or later   Updates a custom action.  Requires `DEVELOPER` (**Has Developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  #### Usage Guidelines  The API allows you to modify the following properties:  * Name of the custom action * Action availability to groups * Association to metadata objects * Authentication settings for a URL-based action  For more information, see [Custom actions](https://developers.thoughtspot.com/docs/custom-action-intro).      
   * @param customActionIdentifier Unique ID or name of the custom action.
   * @param updateCustomActionRequest 
   */
  updateCustomAction(customActionIdentifier, updateCustomActionRequest, _options) {
    const result = this.api.updateCustomAction(customActionIdentifier, updateCustomActionRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.9.0.cl or later   Updates a DBT connection object.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege or `DATAMANAGEMENT` (**Can manage data ThoughtSpot**) privilege, along with an existing DBT connection. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the following data control privileges may be required:  - `CAN_MANAGE_CUSTOM_CALENDAR`(**Can manage custom calendars**) - `CAN_CREATE_OR_EDIT_CONNECTIONS` (**Can create/edit Connections**) - `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**)  #### About update DBT connection You can modify DBT connection object properties such as embrace connection name, embrace database name, import type, account identifier, access token, project identifier and environment (or) embrace connection, embrace database name, import type, file_content settings.      
   * @param dbtConnectionIdentifier Unique ID of the DBT Connection.
   * @param connectionName Name of the connection.
   * @param databaseName Name of the Database.
   * @param importType Mention type of Import
   * @param accessToken Access token is mandatory when Import_Type is DBT_CLOUD.
   * @param dbtUrl DBT URL is mandatory when Import_Type is DBT_CLOUD.
   * @param accountId Account ID is mandatory when Import_Type is DBT_CLOUD
   * @param projectId Project ID is mandatory when Import_Type is DBT_CLOUD
   * @param dbtEnvId DBT Environment ID\\\&quot;
   * @param projectName Name of the project
   * @param fileContent Upload DBT Manifest and Catalog artifact files as a ZIP file. This field is Mandatory when Import Type is \\\&#39;ZIP_FILE\\\&#39;
   */
  updateDbtConnection(dbtConnectionIdentifier, connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options) {
    const result = this.api.updateDbtConnection(dbtConnectionIdentifier, connectionName, databaseName, importType, accessToken, dbtUrl, accountId, projectId, dbtEnvId, projectName, fileContent, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.12.0.cl or later   Updates a customization configuration for the notification email.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.  #### Usage guidelines  To update a custom configuration pass these parameters in your API request:  - A JSON map of configuration attributes `template_properties`. The following example shows a sample set of customization configuration:  ``` {   {       \"cta_button_bg_color\": \"#444DEA\",      \"cta_text_font_color\": \"#FFFFFF\",      \"primary_bg_color\": \"#D3DEF0\",       \"logo_url\": \"https://storage.pardot.com/710713/1642089901EbkRibJq/TS_fullworkmark_darkmode.png\",      \"font_family\": \"\",      \"product_name\": \"ThoughtSpot\",      \"footer_address\": \"444 Castro St, Suite 1000 Mountain View, CA 94041\",      \"footer_phone\": \"(800) 508-7008\",       \"replacement_value_for_liveboard\": \"Dashboard\",      \"replacement_value_for_answer\": \"Chart\",      \"replacement_value_for_spot_iq\": \"AI Insights\",       \"hide_footer_phone\": false,       \"hide_footer_address\": false,       \"hide_product_name\": false,      \"hide_manage_notification\": false,      \"hide_mobile_app_nudge\": false,      \"hide_privacy_policy\": false,      \"hide_ts_vocabulary_definitions\": false,      \"hide_error_message\": false,      \"hide_unsubscribe_link\": false,       \"hide_notification_status\": false,      \"hide_modify_alert\": false,      \"company_website_url\": \"https://your-website.com/\",      \"company_privacy_policy_url\" : \"https://link-to-privacy-policy.com/\",       \"contact_support_url\": \"https://link-to-contact-support.com/\",       \"hide_contact_support_url\": false   } } ```      
   * @param updateEmailCustomizationRequest 
   */
  updateEmailCustomization(updateEmailCustomizationRequest, _options) {
    const result = this.api.updateEmailCustomization(updateEmailCustomizationRequest, _options);
    return result.toPromise();
  }
  /**
   *  Update header attributes for a given list of header objects.   Version: 10.6.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **headers_update**      - **Description:** List of header objects with their attributes to be updated. Each object contains a list of attributes to be updated in the header.    - **Usage:**       - You must provide either `identifier` or `obj_identifier`, but not both. Both fields cannot be empty.       - When `org_identifier` is set to `-1`, only the `identifier` value is accepted; `obj_identifier` is not allowed.  2. **org_identifier**      - **Description:** GUID (Globally Unique Identifier) or name of the organization.      - **Usage:**      - Leaving this field empty assumes that the changes should be applied to the current organization       - Provide `org_guid` or `org_name` to uniquely identify the organization where changes need to be applied. .      - Provide `-1` if changes have to be applied across all the org.  ---  ## Note Currently, this API is enabled only for updating the `obj_identifier` attribute. Only `text` will be allowed in attribute\'s value.  ## Best Practices  1. **Backup Before Conversion:**      Always export metadata as a backup before initiating the update process  ---  ## Examples  ### Only `identifier` is given  ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"obj_identifier\": \"\",       \"type\": \"LOGICAL_COLUMN\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgGuid\" } ```  ### Only `obj_identifier` is given ```json {   \"headers_update\":   [     {       \"obj_identifier\": \"custom_object_id\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": \"orgName\" } ```  ### Executing update for all org `-1` ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"type\": \"ANSWER\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```  ### Optional `type` is not provided ```json {   \"headers_update\":   [     {       \"identifier\": \"guid_1\",       \"attributes\":       [         {           \"name\": \"obj_id\",           \"value\": \"custom_object_id\"         }       ]     }   ],   \"org_identifier\": -1 } ```     
   * @param updateMetadataHeaderRequest 
   */
  updateMetadataHeader(updateMetadataHeaderRequest, _options) {
    const result = this.api.updateMetadataHeader(updateMetadataHeaderRequest, _options);
    return result.toPromise();
  }
  /**
   *  Update object IDs for given metadata objects.   Version: 10.8.0.cl or later   ## Prerequisites - **Privileges Required:**   - `DATAMANAGEMENT` (Can manage data) or `ADMINISTRATION` (Can administer ThoughtSpot). - **Additional Privileges (if RBAC is enabled):**   - `ORG_ADMINISTRATION` (Can manage orgs).  ---  ## Usage Guidelines  ### Parameters  1. **metadata**      - **Description:** List of metadata objects to update their object IDs.    - **Usage:**       - Use either `current_obj_id` alone OR use `metadata_identifier` with `type` (when needed).       - When using `metadata_identifier`, the `type` field is required if using a name instead of a GUID.       - The `new_obj_id` field is always required.  ---  ## Note This API is specifically designed for updating object IDs of metadata objects. It internally uses the header update mechanism to perform the changes.  ## Best Practices  1. **Backup Before Update:**      Always export metadata as a backup before initiating the update process.  2. **Validation:**    - When using `current_obj_id`, ensure it matches the existing object ID exactly.    - When using `metadata_identifier` with a name, ensure the `type` is specified correctly.    - Verify that the `new_obj_id` follows your naming conventions and is unique within your system.  ---  ## Examples  ### Using current_obj_id ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with GUID ```json {   \"metadata\": [     {       \"metadata_identifier\": \"01234567-89ab-cdef-0123-456789abcdef\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Using metadata_identifier with name and type ```json {   \"metadata\": [     {       \"metadata_identifier\": \"My Answer\",       \"type\": \"ANSWER\",       \"new_obj_id\": \"new_object_id\"     }   ] } ```  ### Multiple objects update ```json {   \"metadata\": [     {       \"current_obj_id\": \"existing_object_id_1\",       \"new_obj_id\": \"new_object_id_1\"     },     {       \"metadata_identifier\": \"My Worksheet\",       \"type\": \"LOGICAL_TABLE\",       \"new_obj_id\": \"new_object_id_2\"     }   ] } ```      
   * @param updateMetadataObjIdRequest 
   */
  updateMetadataObjId(updateMetadataObjIdRequest, _options) {
    const result = this.api.updateMetadataObjId(updateMetadataObjIdRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Updates an Org object. You can modify Org properties such as name, description, and user associations.  Requires cluster administration (**Can administer Org**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `ORG_ADMINISTRATION` (**Can manage Orgs**) privilege is required.      
   * @param orgIdentifier ID or name of the Org
   * @param updateOrgRequest 
   */
  updateOrg(orgIdentifier, updateOrgRequest, _options) {
    const result = this.api.updateOrg(orgIdentifier, updateOrgRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.5.0.cl or later   Updates the properties of a Role object.  Available only if [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance. To update a Role, the `ROLE_ADMINISTRATION` (**Can manage roles**) privilege is required.      
   * @param roleIdentifier Unique ID or name of the Role.
   * @param updateRoleRequest 
   */
  updateRole(roleIdentifier, updateRoleRequest, _options) {
    const result = this.api.updateRole(roleIdentifier, updateRoleRequest, _options);
    return result.toPromise();
  }
  /**
   *  Update schedule.    Version: 9.4.0.cl or later   Updates a scheduled Liveboard job.  Requires at least edit access to Liveboards. To update a schedule on behalf of another user, you need `ADMINISTRATION` (**Can administer Org**) or `JOBSCHEDULING` (**Can schedule for others**) privilege and edit access to the Liveboard. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `JOBSCHEDULING` (**Can schedule for others**) privilege is required.  The API endpoint allows you to pause a scheduled job, change the status of a paused job. You can also edit the recipients list, frequency of the job, format of the file to send to the recipients in email notifications, PDF options, and time zone setting.      
   * @param scheduleIdentifier Unique ID or name of the schedule.
   * @param updateScheduleRequest 
   */
  updateSchedule(scheduleIdentifier, updateScheduleRequest, _options) {
    const result = this.api.updateSchedule(scheduleIdentifier, updateScheduleRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Updates the current configuration of the cluster. You must send the configuration data in JSON format.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `APPLICATION_ADMINISTRATION` (**Can manage application settings**) privilege is required.      
   * @param updateSystemConfigRequest 
   */
  updateSystemConfig(updateSystemConfigRequest, _options) {
    const result = this.api.updateSystemConfig(updateSystemConfigRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Updates a tag object.  You can modify the `name` and `color` properties of a tag object.    Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `TAGMANAGEMENT` (**Can manage tags**) privilege is required to create, edit, and delete tags.      
   * @param tagIdentifier Name or Id of the tag.
   * @param updateTagRequest 
   */
  updateTag(tagIdentifier, updateTagRequest, _options) {
    const result = this.api.updateTag(tagIdentifier, updateTagRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a user object.  You can modify user properties such as username, email, and share notification settings. You can also assign new groups and Orgs, remove the user from a group or Org, reset password, and modify user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   * @param updateUserRequest 
   */
  updateUser(userIdentifier, updateUserRequest, _options) {
    const result = this.api.updateUser(userIdentifier, updateUserRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a group object in ThoughtSpot.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `GROUP_ADMINISTRATION` (**Can manage groups**) privilege is required.  #### Supported operations  This API endpoint lets you perform the following operations in a single API request:  * Edit [privileges](https://developers.thoughtspot.com/docs/?pageid=api-user-management#group-privileges) * Add or remove users * Change sharing visibility settings * Add or remove sub-groups * Assign a default Liveboard  or update the existing settings      
   * @param groupIdentifier GUID or name of the group.
   * @param updateUserGroupRequest 
   */
  updateUserGroup(groupIdentifier, updateUserGroupRequest, _options) {
    const result = this.api.updateUserGroup(groupIdentifier, updateUserGroupRequest, _options);
    return result.toPromise();
  }
  /**
   *  Update a variable\'s name   Version: 10.14.0.cl or later   Allows updating a variable\'s name in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows updating: * The variable name     
   * @param identifier Unique id or name of the variable to update.
   * @param updateVariableRequest 
   */
  updateVariable(identifier, updateVariableRequest, _options) {
    const result = this.api.updateVariable(identifier, updateVariableRequest, _options);
    return result.toPromise();
  }
  /**
   *  Update values for multiple variables   Version: 10.14.0.cl or later   Allows updating values for multiple variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows: * Adding new values to variables * Replacing existing values * Deleting values from variables  When updating variable values, you need to specify: * The variable identifiers * The values to add/replace/remove for each variable * The operation to perform (ADD, REPLACE, REMOVE, RESET)  Behaviour based on operation type: * ADD - Adds values to the variable if this is a list type variable, else same as replace. * REPLACE - Replaces all values of a given set of constraints with the current set of values. * REMOVE - Removes any values which match the set of conditions of the variables if this is a list type variable, else clears value. * RESET - Removes all constrains for a given variable, scope is ignored      
   * @param updateVariableValuesRequest 
   */
  updateVariableValues(updateVariableValuesRequest, _options) {
    const result = this.api.updateVariableValues(updateVariableValuesRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.14.0.cl or later   Updates an existing webhook configuration by its unique id or name. Only the provided fields will be updated.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param webhookIdentifier Unique ID or name of the webhook configuration.
   * @param updateWebhookConfigurationRequest 
   */
  updateWebhookConfiguration(webhookIdentifier, updateWebhookConfigurationRequest, _options) {
    const result = this.api.updateWebhookConfiguration(webhookIdentifier, updateWebhookConfigurationRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.10.0.cl or later   Validates the email customization configuration if any set for the ThoughtSpot system.  #### Pre-requisites  Requires `DEVELOPER` (**has developer privilege**) or `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `DEVELOPER` (**Has developer privilege**) privilege is required.  **NOTE**:This endpoint in currently in beta. Contact ThoughtSpot support to enable this on your instance.      
   */
  validateEmailCustomization(_options) {
    const result = this.api.validateEmailCustomization(_options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Validates the content of your source branch against the objects in your destination environment.  Before merging content from your source branch to the destination branch, run this API operation from your destination environment and ensure that the changes from the source branch function in the destination environment.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param validateMergeRequest 
   */
  validateMerge(validateMergeRequest, _options) {
    const result = this.api.validateMerge(validateMergeRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.12.0.cl or later    Validates the authentication token specified in the API request.  If your token is not valid, [Get a new token](#/http/api-endpoints/authentication/get-full-access-token).      
   * @param validateTokenRequest 
   */
  validateToken(validateTokenRequest, _options) {
    const result = this.api.validateToken(validateTokenRequest, _options);
    return result.toPromise();
  }
};
var PromiseUsersApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableUsersApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.7.0.cl or later   Activates a deactivated user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To activate an inactive user account, the API request body must include the following information:  - Username or the GUID of the user account. - Auth token generated for the deactivated user. The auth token is sent in the API response when a user is deactivated. - Password for the user account.      
   * @param activateUserRequest 
   */
  activateUser(activateUserRequest, _options) {
    const result = this.api.activateUser(activateUserRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the current password of the user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param changeUserPasswordRequest 
   */
  changeUserPassword(changeUserPasswordRequest, _options) {
    const result = this.api.changeUserPassword(changeUserPasswordRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Creates a user in ThoughtSpot.  The API endpoint allows you to configure several user properties such as email address, account status, share notification preferences, and sharing visibility. You can provision the user to [groups](https://docs.thoughtspot.com/cloud/latest/groups-privileges) and [Orgs](https://docs.thoughtspot.com/cloud/latest/orgs-overview). You can also add Liveboard, Answer, and Worksheet objects to the users favorites list, assign a default Liveboard for the user, and set user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param createUserRequest 
   */
  createUser(createUserRequest, _options) {
    const result = this.api.createUser(createUserRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.7.0.cl or later   Deactivates a user account.  Requires `ADMINISTRATION` (**Can administer Thoughtspot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  To deactivate a user account, the API request body must include the following information:  - Username or the GUID of the user account - Base URL of the ThoughtSpot instance  If the API request is successful, ThoughtSpot returns the activation URL in the response. The activation URL is valid for 14 days and can be used to re-activate the account and reset the password of the deactivated account.      
   * @param deactivateUserRequest 
   */
  deactivateUser(deactivateUserRequest, _options) {
    const result = this.api.deactivateUser(deactivateUserRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Deletes a user from the ThoughtSpot system.  If you want to remove a user from a specific Org but not from ThoughtSpot, update the group and Org mapping properties of the user object via a POST API call to the [/api/rest/2.0/users/{user_identifier}/update](#/http/api-endpoints/users/update-user) endpoint.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   */
  deleteUser(userIdentifier, _options) {
    const result = this.api.deleteUser(userIdentifier, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Enforces logout on current user sessions.    Use this API with caution as it may invalidate active user sessions and force users to re-login. Make sure you specify the usernames or GUIDs. If you pass null values in the API call, all user sessions on your cluster become invalid, and the users are forced to re-login.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param forceLogoutUsersRequest 
   */
  forceLogoutUsers(forceLogoutUsersRequest, _options) {
    const result = this.api.forceLogoutUsers(forceLogoutUsersRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Imports user data from external databases into ThoughtSpot. During the user import operation:  * If the specified users are not available in ThoughtSpot, the users are created and assigned a default password. Defining a `default_password` in the API request is optional. * If `delete_unspecified_users` is set to `true`, the users not specified in the API request, excluding the `tsadmin`, `guest`, `system` and `su` users, are deleted. * If the specified user objects are already available in ThoughtSpot, the object properties are updated and synchronized as per the input data in the API request.  A successful API call returns the object that represents the changes made in the ThoughtSpot system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param importUsersRequest 
   */
  importUsers(importUsersRequest, _options) {
    const result = this.api.importUsers(importUsersRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Resets the password of a user account. Administrators can reset password on behalf of a user.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param resetUserPasswordRequest 
   */
  resetUserPassword(resetUserPasswordRequest, _options) {
    const result = this.api.resetUserPassword(resetUserPasswordRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Gets a list of users available on the ThoughtSpot system.  To get details of a specific user, specify the user GUID or name. You can also filter the API response based on groups, Org ID, user visibility, account status, user type, and user preference settings and favorites.  Available to all users. Users with `ADMINISTRATION` (**Can administer ThoughtSpot**) privileges can view all users properties. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.  **NOTE**: If the API returns an empty list, consider increasing the value of the `record_size` parameter. To search across all available users, set `record_size` to `-1`.      
   * @param searchUsersRequest 
   */
  searchUsers(searchUsersRequest, _options) {
    const result = this.api.searchUsers(searchUsersRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.0.0.cl or later   Updates the properties of a user object.  You can modify user properties such as username, email, and share notification settings. You can also assign new groups and Orgs, remove the user from a group or Org, reset password, and modify user preferences.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, the `USER_ADMINISTRATION` (**Can manage users**) privilege is required.      
   * @param userIdentifier GUID / name of the user
   * @param updateUserRequest 
   */
  updateUser(userIdentifier, updateUserRequest, _options) {
    const result = this.api.updateUser(userIdentifier, updateUserRequest, _options);
    return result.toPromise();
  }
};
var PromiseVariableApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableVariableApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *  Create a variable which can be used for parameterizing metadata objects   Version: 10.14.0.cl or later   Allows creating a variable which can be used for parameterizing metadata objects in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports the following types of variables: * CONNECTION_PROPERTY - For connection properties * TABLE_MAPPING - For table mappings * CONNECTION_PROPERTY_PER_PRINCIPAL - For connection properties per principal. In order to use this please contact support to enable this. * FORMULA_VARIABLE - For Formula variables, introduced in 10.15.0.cl  When creating a variable, you need to specify: * The variable type * A unique name for the variable * Whether the variable contains sensitive values (defaults to false) * The data type of the variable, only specify for formula variables (defaults to null)  The operation will fail if: * The user lacks required permissions * The variable name already exists * The variable type is invalid     
   * @param createVariableRequest 
   */
  createVariable(createVariableRequest, _options) {
    const result = this.api.createVariable(createVariableRequest, _options);
    return result.toPromise();
  }
  /**
   *  Delete a variable   Version: 10.14.0.cl or later   Allows deleting a variable from ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint requires: * The variable identifier (ID or name)  The operation will fail if: * The user lacks required permissions * The variable doesn\'t exist * The variable is being used by other objects      
   * @param identifier Unique id or name of the variable
   */
  deleteVariable(identifier, _options) {
    const result = this.api.deleteVariable(identifier, _options);
    return result.toPromise();
  }
  /**
   *  Search variables   Version: 10.14.0.cl or later   Allows searching for variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint supports searching variables by: * Variable identifier (ID or name) * Variable type * Name pattern (case-insensitive, supports % for wildcard)  The search results can be formatted in three ways: * METADATA - Returns only variable metadata (default) * METADATA_AND_VALUES - Returns variable metadata and values  The values can be filtered by scope: * org_identifier * principal_identifier * model_identifier      
   * @param searchVariablesRequest 
   */
  searchVariables(searchVariablesRequest, _options) {
    const result = this.api.searchVariables(searchVariablesRequest, _options);
    return result.toPromise();
  }
  /**
   *  Update a variable\'s name   Version: 10.14.0.cl or later   Allows updating a variable\'s name in ThoughtSpot.  Requires ADMINISTRATION role and TENANT scope. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows updating: * The variable name     
   * @param identifier Unique id or name of the variable to update.
   * @param updateVariableRequest 
   */
  updateVariable(identifier, updateVariableRequest, _options) {
    const result = this.api.updateVariable(identifier, updateVariableRequest, _options);
    return result.toPromise();
  }
  /**
   *  Update values for multiple variables   Version: 10.14.0.cl or later   Allows updating values for multiple variables in ThoughtSpot.  Requires ADMINISTRATION role. The CAN_MANAGE_VARIABLES permission allows you to manage Formula Variables in the current organization scope.  The API endpoint allows: * Adding new values to variables * Replacing existing values * Deleting values from variables  When updating variable values, you need to specify: * The variable identifiers * The values to add/replace/remove for each variable * The operation to perform (ADD, REPLACE, REMOVE, RESET)  Behaviour based on operation type: * ADD - Adds values to the variable if this is a list type variable, else same as replace. * REPLACE - Replaces all values of a given set of constraints with the current set of values. * REMOVE - Removes any values which match the set of conditions of the variables if this is a list type variable, else clears value. * RESET - Removes all constrains for a given variable, scope is ignored      
   * @param updateVariableValuesRequest 
   */
  updateVariableValues(updateVariableValuesRequest, _options) {
    const result = this.api.updateVariableValues(updateVariableValuesRequest, _options);
    return result.toPromise();
  }
};
var PromiseVersionControlApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableVersionControlApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *   Version: 9.2.0.cl or later   Commits TML files of metadata objects to the Git branch configured on your instance.  Requires at least edit access to objects used in the commit operation.  Before using this endpoint to push your commits:  * Enable Git integration on your instance. * Make sure the Git repository and branch details are configured on your instance.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitBranchRequest 
   */
  commitBranch(commitBranchRequest, _options) {
    const result = this.api.commitBranch(commitBranchRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to connect a ThoughtSpot instance to a Git repository.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.  You can use this API endpoint to connect your ThoughtSpot development and production environments to the development and production branches of a Git repository.  Before using this endpoint to connect your ThoughtSpot instance to a Git repository, check the following prerequisites:  * You have a Git repository. If you are using GitHub, make sure you have a valid account and an access token to connect ThoughtSpot to GitHub. For information about generating a token, see [GitHub Documentation](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).  * Your access token has `repo` scope that grants full access to public and private repositories. * Your Git repository has a branch that can be configured as a default branch in ThoughtSpot.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/?pageid=git-integration).  **Note**: ThoughtSpot supports only GitHub / itHub Enterprise for CI/CD.      
   * @param createConfigRequest 
   */
  createConfig(createConfigRequest, _options) {
    const result = this.api.createConfig(createConfigRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Deletes Git repository configuration from your ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param deleteConfigRequest 
   */
  deleteConfig(deleteConfigRequest, _options) {
    const result = this.api.deleteConfig(deleteConfigRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Allows you to deploy a commit and publish TML content to your ThoughtSpot instance.  Requires at least edit access to the objects used in the deploy operation.  The API deploys the head of the branch unless a `commit_id` is specified in the API request. If the branch name is not defined in the request, the default branch is considered for deploying commits.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param deployCommitRequest 
   */
  deployCommit(deployCommitRequest, _options) {
    const result = this.api.deployCommit(deployCommitRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Reverts TML objects to a previous commit specified in the API request.  Requires at least edit access to objects.  In the API request, specify the `commit_id`. If the branch name is not specified in the request, the API will consider the default branch configured on your instance.  By default, the API reverts all objects. If the revert operation fails for one of the objects provided in the commit, the API returns an error and does not revert any object.  For more information, see [Git integration documentation](https://developers.thoughtspot.com/docs/git-integration).      
   * @param commitId Commit id to which the object should be reverted
   * @param revertCommitRequest 
   */
  revertCommit(commitId, revertCommitRequest, _options) {
    const result = this.api.revertCommit(commitId, revertCommitRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Gets a list of commits for a given metadata object.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param searchCommitsRequest 
   */
  searchCommits(searchCommitsRequest, _options) {
    const result = this.api.searchCommits(searchCommitsRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Gets Git repository connections configured on the ThoughtSpot instance.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param searchConfigRequest 
   */
  searchConfig(searchConfigRequest, _options) {
    const result = this.api.searchConfig(searchConfigRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Updates Git repository configuration settings.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_SETUP_VERSION_CONTROL` (**Can set up version control**) privilege.      
   * @param updateConfigRequest 
   */
  updateConfig(updateConfigRequest, _options) {
    const result = this.api.updateConfig(updateConfigRequest, _options);
    return result.toPromise();
  }
  /**
   *   Version: 9.2.0.cl or later   Validates the content of your source branch against the objects in your destination environment.  Before merging content from your source branch to the destination branch, run this API operation from your destination environment and ensure that the changes from the source branch function in the destination environment.  Requires `DATAMANAGEMENT` (**Can manage data**) privilege.  If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance on your instance, the `CAN_MANAGE_WORKSHEET_VIEWS_TABLES` (**Can manage data models**) privilege and edit access to the metadata objects.      
   * @param validateMergeRequest 
   */
  validateMerge(validateMergeRequest, _options) {
    const result = this.api.validateMerge(validateMergeRequest, _options);
    return result.toPromise();
  }
};
var PromiseWebhooksApi = class {
  constructor(configuration, requestFactory, responseProcessor) {
    this.api = new ObservableWebhooksApi(configuration, requestFactory, responseProcessor);
  }
  /**
   *  Version: 10.14.0.cl or later   Creates a new webhook configuration to receive notifications for specified events. The webhook will be triggered when the configured events occur in the system.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param createWebhookConfigurationRequest 
   */
  createWebhookConfiguration(createWebhookConfigurationRequest, _options) {
    const result = this.api.createWebhookConfiguration(createWebhookConfigurationRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.14.0.cl or later   Deletes one or more webhook configurations by their unique id or name. Returns status of each deletion operation, including successfully deleted webhooks and any failures with error details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param deleteWebhookConfigurationsRequest 
   */
  deleteWebhookConfigurations(deleteWebhookConfigurationsRequest, _options) {
    const result = this.api.deleteWebhookConfigurations(deleteWebhookConfigurationsRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.14.0.cl or later   Searches for webhook configurations based on various criteria such as Org, webhook identifier, event type, with support for pagination and sorting. Returns matching webhook configurations with their complete details.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param searchWebhookConfigurationsRequest 
   */
  searchWebhookConfigurations(searchWebhookConfigurationsRequest, _options) {
    const result = this.api.searchWebhookConfigurations(searchWebhookConfigurationsRequest, _options);
    return result.toPromise();
  }
  /**
   *  Version: 10.14.0.cl or later   Updates an existing webhook configuration by its unique id or name. Only the provided fields will be updated.  Requires `ADMINISTRATION` (**Can administer ThoughtSpot**) or `DEVELOPER` (**Has developer privilege**) privilege. If [Role-Based Access Control (RBAC)](https://developers.thoughtspot.com/docs/rbac) is enabled on your instance, users with `CAN_MANAGE_WEBHOOKS` (**Can manage webhooks**) privilege are also authorized to perform this action.      
   * @param webhookIdentifier Unique ID or name of the webhook configuration.
   * @param updateWebhookConfigurationRequest 
   */
  updateWebhookConfiguration(webhookIdentifier, updateWebhookConfigurationRequest, _options) {
    const result = this.api.updateWebhookConfiguration(webhookIdentifier, updateWebhookConfigurationRequest, _options);
    return result.toPromise();
  }
};

// utils/config.ts
var createAdditionalHeadersMiddleware = (additionalHeaders) => {
  return {
    /**
     * Pre-request middleware to add custom headers to every API call
     * @param requestContext - The request context to modify
     */
    pre: (requestContext) => {
      Object.entries(additionalHeaders).forEach(([headerName, headerValue]) => {
        requestContext.setHeaderParam(headerName, headerValue);
      });
      return Promise.resolve(requestContext);
    },
    /**
     * Post-request middleware for response processing
     * @param responseContext - The response context
     */
    post: (responseContext) => Promise.resolve(responseContext)
  };
};
var createBearerAuthenticationConfig = (thoughtSpotHost, paramOrTokenProvider, options) => {
  const serverConfig = new ServerConfiguration(
    thoughtSpotHost,
    {}
  );
  const additionalHeaders = options == null ? void 0 : options.additionalHeaders;
  let middleware = [];
  if (additionalHeaders && Object.keys(additionalHeaders).length > 0) {
    middleware.push(createAdditionalHeadersMiddleware(additionalHeaders));
  }
  const config = createConfiguration({
    baseServer: serverConfig,
    promiseMiddleware: middleware
  });
  const authApiClient = new PromiseAuthenticationApi(config);
  let configTokenProvider;
  if (paramOrTokenProvider.hasOwnProperty("username")) {
    configTokenProvider = {
      getToken: () => __async(void 0, null, function* () {
        const token = (yield authApiClient.getFullAccessToken(paramOrTokenProvider)).token;
        return token;
      })
    };
  } else if (typeof paramOrTokenProvider === "function") {
    configTokenProvider = {
      getToken: paramOrTokenProvider
    };
  } else {
    throw new Error("Pass a proper GetFullAccessTokenRequest or a function which returns a token");
  }
  const authConfig = {
    bearerAuth: {
      tokenProvider: configTokenProvider
    }
  };
  const globalConfig = createConfiguration({
    authMethods: authConfig,
    baseServer: serverConfig,
    promiseMiddleware: middleware
  });
  return globalConfig;
};
var createBasicConfig = (thoughtSpotHost, options) => {
  const thoughtSpotServer = new ServerConfiguration(thoughtSpotHost, {});
  const additionalHeaders = options == null ? void 0 : options.additionalHeaders;
  let middleware = [];
  if (additionalHeaders && Object.keys(additionalHeaders).length > 0) {
    middleware.push(createAdditionalHeadersMiddleware(additionalHeaders));
  }
  const basicClientConfig = createConfiguration({
    baseServer: thoughtSpotServer,
    promiseMiddleware: middleware
  });
  return basicClientConfig;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AIApi,
  AIContext,
  APIKey,
  APIKeyInput,
  AccessToken,
  ActionConfig,
  ActionConfigInput,
  ActionConfigInputCreate,
  ActionDetails,
  ActionDetailsInput,
  ActionDetailsInputCreate,
  ActivateUserRequest,
  AgentConversation,
  AnswerContent,
  AnswerContextInput,
  AnswerDataResponse,
  ApiException,
  AssignChangeAuthorRequest,
  AssignTagRequest,
  AssociateMetadataInput,
  AssociateMetadataInputCreate,
  Authentication,
  AuthenticationApi,
  AuthenticationInput,
  Author,
  AuthorMetadataTypeInput,
  AuthorType,
  BasicAuth,
  BasicAuthInput,
  BearerAuthAuthentication,
  CALLBACK,
  CALLBACKInput,
  CALLBACKInputMandatory,
  CalendarResponse,
  ChangeUserPasswordRequest,
  ClusterNonEmbedAccess,
  ClusterNonEmbedAccessInput,
  Column,
  ColumnSecurityRule,
  ColumnSecurityRuleColumn,
  ColumnSecurityRuleGroup,
  ColumnSecurityRuleGroupOperation,
  ColumnSecurityRuleResponse,
  ColumnSecurityRuleSourceTable,
  ColumnSecurityRuleTableInput,
  ColumnSecurityRuleUpdate,
  CommitBranchRequest,
  CommitFileType,
  CommitHistoryResponse,
  CommitResponse,
  CommiterType,
  CommunicationChannelPreferencesResponse,
  ConfigureCommunicationChannelPreferencesRequest,
  ConnectionConfigurationResponse,
  ConnectionConfigurationSearchRequest,
  ConnectionConfigurationsApi,
  ConnectionInput,
  ConnectionsApi,
  ContextPayloadV2Input,
  Conversation,
  ConversationSettingsInput,
  ConvertWorksheetToModelRequest,
  CopyObjectRequest,
  CreateAgentConversationRequest,
  CreateAgentConversationRequestConversationSettings,
  CreateAgentConversationRequestMetadataContext,
  CreateCalendarRequest,
  CreateCalendarRequestTableReference,
  CreateConfigRequest,
  CreateConnectionConfigurationRequest,
  CreateConnectionConfigurationRequestPolicyProcessOptions,
  CreateConnectionRequest,
  CreateConnectionResponse,
  CreateConversationRequest,
  CreateCustomActionRequest,
  CreateCustomActionRequestActionDetails,
  CreateCustomActionRequestDefaultActionConfig,
  CreateEmailCustomizationRequest,
  CreateEmailCustomizationRequestTemplateProperties,
  CreateEmailCustomizationResponse,
  CreateOrgRequest,
  CreateRoleRequest,
  CreateScheduleRequest,
  CreateScheduleRequestFrequency,
  CreateScheduleRequestLiveboardOptions,
  CreateScheduleRequestPdfOptions,
  CreateScheduleRequestRecipientDetails,
  CreateTagRequest,
  CreateUserGroupRequest,
  CreateUserRequest,
  CreateVariableRequest,
  CreateWebhookConfigurationRequest,
  CreateWebhookConfigurationRequestAuthentication,
  CreateWebhookConfigurationRequestSignatureVerification,
  CronExpression,
  CronExpressionInput,
  CspSettings,
  CspSettingsInput,
  CustomActionApi,
  CustomActionMetadataTypeInput,
  CustomCalendarsApi,
  DBTApi,
  DataApi,
  DataSource,
  DataSourceContextInput,
  DataWarehouseObjectInput,
  DataWarehouseObjects,
  Database,
  DbtSearchResponse,
  DeactivateUserRequest,
  DefaultActionConfig,
  DefaultActionConfigInput,
  DefaultActionConfigInputCreate,
  DefaultActionConfigSearchInput,
  DeleteConfigRequest,
  DeleteConnectionConfigurationRequest,
  DeleteConnectionRequest,
  DeleteMetadataRequest,
  DeleteMetadataTypeInput,
  DeleteOrgEmailCustomizationRequest,
  DeleteWebhookConfigurationsRequest,
  DeployCommitRequest,
  DeployResponse,
  EmailCustomizationApi,
  EntityHeader,
  ErrorResponse,
  EurekaDataSourceSuggestionResponse,
  EurekaDecomposeQueryResponse,
  EurekaGetNLInstructionsResponse,
  EurekaGetRelevantQuestionsResponse,
  EurekaLLMDecomposeQueryResponse,
  EurekaLLMSuggestedQuery,
  EurekaRelevantQuestion,
  EurekaSetNLInstructionsResponse,
  EventChannelConfig,
  EventChannelConfigInput,
  ExcludeMetadataListItemInput,
  ExportAnswerReportRequest,
  ExportAnswerReportRequestRegionalSettings,
  ExportLiveboardReportRequest,
  ExportLiveboardReportRequestPdfOptions,
  ExportLiveboardReportRequestPngOptions,
  ExportMetadataTMLBatchedRequest,
  ExportMetadataTMLRequest,
  ExportMetadataTMLRequestExportOptions,
  ExportMetadataTypeInput,
  ExportOptions,
  ExternalTableInput,
  FavoriteMetadataInput,
  FavoriteMetadataItem,
  FavoriteObjectOptionsInput,
  FetchAnswerDataRequest,
  FetchAnswerSqlQueryRequest,
  FetchAsyncImportTaskStatusRequest,
  FetchColumnSecurityRulesRequest,
  FetchConnectionDiffStatusResponse,
  FetchLiveboardDataRequest,
  FetchLiveboardSqlQueryRequest,
  FetchLogsRequest,
  FetchPermissionsOfPrincipalsRequest,
  FetchPermissionsOnMetadataRequest,
  FilterRules,
  ForceLogoutUsersRequest,
  Frequency,
  FrequencyInput,
  GenerateCSVRequest,
  GenericInfo,
  GetAsyncImportStatusResponse,
  GetCustomAccessTokenRequest,
  GetFullAccessTokenRequest,
  GetFullAccessTokenRequestUserParameters,
  GetObjectAccessTokenRequest,
  GetRelevantQuestionsRequest,
  GetRelevantQuestionsRequestAiContext,
  GetRelevantQuestionsRequestMetadataContext,
  GetTokenResponse,
  GroupInfo,
  GroupObject,
  GroupsApi,
  GroupsImportListInput,
  HeaderAttributeInput,
  HeaderUpdateInput,
  HttpException,
  HttpMethod,
  ImportEPackAsyncTaskStatus,
  ImportMetadataTMLAsyncRequest,
  ImportMetadataTMLRequest,
  ImportUser,
  ImportUserGroupsRequest,
  ImportUserGroupsResponse,
  ImportUserType,
  ImportUsersRequest,
  ImportUsersResponse,
  InputEurekaNLSRequest,
  IsomorphicFetchHttpLibrary,
  JWTMetadataObject,
  JWTParameter,
  JWTUserOptions,
  JWTUserOptionsFull,
  LBContextInput,
  LiveboardContent,
  LiveboardDataResponse,
  LiveboardOptions,
  LiveboardOptionsInput,
  LogApi,
  LogResponse,
  LoginRequest,
  MetadataApi,
  MetadataAssociationItem,
  MetadataContext,
  MetadataInput,
  MetadataListItemInput,
  MetadataObject,
  MetadataResponse,
  MetadataSearchResponse,
  MetadataSearchSortOptions,
  ModelTableList,
  NLInstructionsInfo,
  NLInstructionsInfoInput,
  ObjectIDAndName,
  Org,
  OrgChannelConfigInput,
  OrgChannelConfigResponse,
  OrgDetails,
  OrgInfo,
  OrgNonEmbedAccess,
  OrgNonEmbedAccessInput,
  OrgPreferenceSearchCriteriaInput,
  OrgResponse,
  OrgType,
  OrgsApi,
  ParameterValues,
  ParameterizeMetadataRequest,
  ParametersListItem,
  ParametersListItemInput,
  PdfOptions,
  PdfOptionsInput,
  PermissionInput,
  PermissionOfMetadataResponse,
  PermissionOfPrincipalsResponse,
  PermissionsMetadataTypeInput,
  PngOptionsInput,
  PolicyProcessOptions,
  PolicyProcessOptionsInput,
  PrincipalsInput,
  PrincipalsListItem,
  PrincipalsListItemInput,
  PublishMetadataListItem,
  PublishMetadataRequest,
  QueryGetDecomposedQueryRequest,
  QueryGetDecomposedQueryRequestNlsRequest,
  RecipientDetails,
  RecipientDetailsInput,
  RegionalSettingsInput,
  RepoConfigObject,
  ReportsApi,
  RequestContext,
  RequiredError,
  ResetUserPasswordRequest,
  ResponseActivationURL,
  ResponseContext,
  ResponseCopyObject,
  ResponseCustomAction,
  ResponseFailedEntities,
  ResponseFailedEntity,
  ResponseIncompleteEntities,
  ResponseIncompleteEntity,
  ResponseMessage,
  ResponsePostUpgradeFailedEntities,
  ResponsePostUpgradeFailedEntity,
  ResponseSchedule,
  ResponseScheduleRun,
  ResponseSuccessfulEntities,
  ResponseSuccessfulEntity,
  ResponseWorksheetToModelConversion,
  RevertCommitRequest,
  RevertResponse,
  RevertedMetadata,
  RevokeRefreshTokensResponse,
  RevokeTokenRequest,
  RiseGQLArgWrapper,
  RiseSetter,
  Role,
  RoleResponse,
  RolesApi,
  RuntimeFilter,
  RuntimeFilters,
  RuntimeParamOverride,
  RuntimeParameters,
  RuntimeSort,
  RuntimeSorts,
  ScheduleHistoryRunsOptionsInput,
  SchedulesApi,
  SchedulesPdfOptionsInput,
  SchemaObject,
  Scope,
  ScriptSrcUrls,
  ScriptSrcUrlsInput,
  SearchCalendarsRequest,
  SearchCalendarsRequestSortOptions,
  SearchCommitsRequest,
  SearchCommunicationChannelPreferencesRequest,
  SearchConfigRequest,
  SearchConnectionRequest,
  SearchConnectionRequestSortOptions,
  SearchConnectionResponse,
  SearchCustomActionsRequest,
  SearchCustomActionsRequestDefaultActionConfig,
  SearchDataRequest,
  SearchDataResponse,
  SearchEmailCustomizationRequest,
  SearchMetadataRequest,
  SearchMetadataRequestFavoriteObjectOptions,
  SearchMetadataRequestSortOptions,
  SearchOrgsRequest,
  SearchRoleResponse,
  SearchRolesRequest,
  SearchSchedulesRequest,
  SearchSchedulesRequestHistoryRunsOptions,
  SearchSchedulesRequestSortOptions,
  SearchTagsRequest,
  SearchUserGroupsRequest,
  SearchUserGroupsRequestSortOptions,
  SearchUsersRequest,
  SearchUsersRequestSortOptions,
  SearchVariablesRequest,
  SearchWebhookConfigurationsRequest,
  SearchWebhookConfigurationsRequestSortOptions,
  SecurityApi,
  SecuritySettingsClusterPreferences,
  SecuritySettingsClusterPreferencesInput,
  SecuritySettingsOrgDetails,
  SecuritySettingsOrgPreferences,
  SecuritySettingsOrgPreferencesInput,
  SecuritySettingsResponse,
  SelfDecodingBody,
  SendAgentMessageResponse,
  SendAgentMessageStreamingRequest,
  SendMessageRequest,
  ServerConfiguration,
  ShareMetadataRequest,
  ShareMetadataTypeInput,
  SharePermissionsInput,
  SingleAnswerRequest,
  SortOption,
  SortOptionInput,
  SortOptions,
  SortingOptions,
  SqlQuery,
  SqlQueryResponse,
  SystemApi,
  SystemConfig,
  SystemInfo,
  SystemOverrideInfo,
  Table,
  Tag,
  TagMetadataTypeInput,
  TagsApi,
  TemplatePropertiesInputCreate,
  ThoughtSpotRestApi,
  Token,
  TokenAccessScopeObject,
  TokenValidationResponse,
  URL,
  URLInput,
  URLInputMandatory,
  UnparameterizeMetadataRequest,
  UnpublishMetadataRequest,
  UpdateCalendarRequest,
  UpdateCalendarRequestTableReference,
  UpdateColumnSecurityRulesRequest,
  UpdateConfigRequest,
  UpdateConnectionConfigurationRequest,
  UpdateConnectionRequest,
  UpdateConnectionV2Request,
  UpdateCustomActionRequest,
  UpdateCustomActionRequestActionDetails,
  UpdateCustomActionRequestDefaultActionConfig,
  UpdateEmailCustomizationRequest,
  UpdateMetadataHeaderRequest,
  UpdateMetadataObjIdRequest,
  UpdateObjIdInput,
  UpdateOrgRequest,
  UpdateRoleRequest,
  UpdateScheduleRequest,
  UpdateScheduleRequestFrequency,
  UpdateScheduleRequestLiveboardOptions,
  UpdateScheduleRequestPdfOptions,
  UpdateScheduleRequestRecipientDetails,
  UpdateSystemConfigRequest,
  UpdateTagRequest,
  UpdateUserGroupRequest,
  UpdateUserRequest,
  UpdateVariableRequest,
  UpdateVariableValuesRequest,
  UpdateWebhookConfigurationRequest,
  User,
  UserGroup,
  UserGroupResponse,
  UserInfo,
  UserObject,
  UserParameterOptions,
  UserPrincipal,
  UsersApi,
  ValidateMergeRequest,
  ValidateTokenRequest,
  ValueScopeInput,
  Variable,
  VariableApi,
  VariableDetailInput,
  VariableUpdateAssignmentInput,
  VariableUpdateScopeInput,
  VariableValue,
  VariableValues,
  VersionControlApi,
  WebhookAuthApiKey,
  WebhookAuthApiKeyInput,
  WebhookAuthBasicAuth,
  WebhookAuthBasicAuthInput,
  WebhookAuthOAuth2,
  WebhookAuthOAuth2Input,
  WebhookAuthentication,
  WebhookAuthenticationInput,
  WebhookDeleteFailure,
  WebhookDeleteResponse,
  WebhookOrg,
  WebhookPagination,
  WebhookResponse,
  WebhookSearchResponse,
  WebhookSignatureVerification,
  WebhookSignatureVerificationInput,
  WebhookSortOptionsInput,
  WebhookUser,
  WebhooksApi,
  configureAuthMethods,
  createBasicConfig,
  createBearerAuthenticationConfig,
  createConfiguration,
  server1,
  servers,
  wrapHttpLibrary
});
