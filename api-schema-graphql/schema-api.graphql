directive @callosum(path: String!, method: String, headers: JSON, setters: [RiseSetter], resultroot: String, postbody: String, forwardheaders: [String], contenttype: String) on FIELD_DEFINITION

directive @rest(
  """Path for the method"""
  path: String = "/v2/"

  """REST Method to use GET|POST|PUT"""
  method: String = "GET"

  """Hide the method from the generated swagger spec"""
  hidden: Boolean = false

  """The category for this API"""
  category: String = ""
) on FIELD_DEFINITION

scalar JSON

scalar JSONObject

scalar Long

scalar GUID

scalar Void

type Query {
  """Get Session object information"""
  getCurrentUserInfo: User!

  """
  To programmatically search a user account in the ThoughtSpot system use this API endpoint.
  Using this API, you can search a user with GUID / name.
  """
  searchUsers(
    """GUID / name of the user to be updated"""
    user_identifier: String

    """
    A unique display name string for the user account, usually their first and last name
    """
    display_name: String

    """Visibility of the user."""
    visibility: Visibility

    """Email of the user account"""
    email: String

    """List of user-group to be associated with"""
    group_identifiers: [String]

    """List of privileges to be associated with"""
    privileges: [Privileges]

    """Type of the account."""
    account_type: AccountType

    """Current status of the user account."""
    account_status: AccountStatus

    """
    User preference for receiving email notifications when another ThoughtSpot user shares answers or pinboards.
    """
    notify_on_share: Boolean

    """The user preference for revisiting the onboarding experience."""
    show_onboarding_experience: Boolean

    """flag to get the on-boarding experience is completed or not."""
    onboarding_experience_completed: Boolean

    """List of Unique Org Identifiers to be associated with"""
    org_identifiers: [String]
  ): [User]

  """Get system details"""
  getSystemInfo: SystemInfo!

  """Get system config information"""
  getSystemConfig: SystemConfig!

  """
  To programmatically search an Org in the ThoughtSpot system use this API endpoint.
  """
  searchOrgs(
    """identifier for the Org: Either unique id or unique name of the Org."""
    org_identifier: String

    """Description of the Org."""
    description: String

    """Visibility of the Org."""
    visibility: OrgVisibility

    """Status of the Org."""
    status: OrgStatus

    """
    User identifier for the Org: Either unique id or unique name of the user.
    """
    user_identifiers: [String]
  ): [OrgResponse]!

  """
  To programmatically search tags in the ThoughtSpot system use this API endpoint.
  Provide any of tag attributes. Matching tags will be returned.
  """
  searchTags(
    """Name or Id of the tag."""
    tag_identifier: String

    """Color of the tag."""
    color: String
  ): [Tag]!

  """Search User Groups from the current org"""
  searchUserGroups(
    """
    Unique ID of liveboards which will be assigned as default liveboards to the user group.
    """
    default_liveboard_identifiers: [String]

    """Description for the user group."""
    description: String

    """Unique display name for the user group."""
    display_name: String

    """Unique ID or name of the user group."""
    group_identifier: String

    """
    Unique ID or name of the org where the user group will be created. 
    If not specified then group will be created in the current logged in org. 
    Note that only tenant admins are allowed to create group across org.
    """
    org_identifiers: [String]

    """Privileges which will be assigned to the user group."""
    privileges: [Privileges]

    """
    Unique ID or name of the User Groups who will be part of the user group.
    """
    sub_group_identifiers: [String]

    """Type of the user group."""
    type: GroupType

    """Unique ID or name of the Users who will be part of the user group."""
    user_identifiers: [String]

    """
    Visibility of the user group. The SHARABLE makes a user group visible to other users and user groups, 
    and thus allows them to share objects.
    """
    visibility: Visibility
  ): [UserGroupResponse]!

  """Search Metadata"""
  searchMetadata(
    """Metadata objects."""
    metadata: [MetadataListItemInput]!

    """Permission details for searching the objects."""
    permissions: [PermissionInput]!

    """Unique ID or name of users who has created the metadata object."""
    created_by_user_identifiers: [String]

    """Version of the dependent metadata object."""
    dependent_object_version: DependentObjectVersion

    """Exclude Metadata objects."""
    exclude_objects: [ExcludeMetadataListItemInput]

    """Favorite object options."""
    favorite_object_options: FavoriteObjectOptionsInput

    """Indicates whether to include auto created metadata objects."""
    include_auto_created_objects: Boolean = false

    """
    Indicates whether to include dependent objects of the metadata objects.
    """
    include_dependent_objects: Boolean = false

    """Indicates whether to include complete details of the metadata objects."""
    include_details: Boolean = false

    """
    Indicates whether to include expert requests information of metadata objects.
    """
    include_expert_request: Boolean

    """Indicates whether to include headers of the metadata objects."""
    include_headers: Boolean = false

    """Indicates whether to include hidden metadata objects."""
    include_hidden_objects: Boolean = false

    """
    Indicates whether to include details of incomplete information of the metadata objects if any present.
    """
    include_incomplete_objects: Boolean = false

    """
    Indicates whether to include visualization headers of the Liveboard metadata objects.
    """
    include_visualization_headers: Boolean = false

    """
    Indicates whether to include search assist data of the worksheet objects.
    """
    include_worksheet_search_assist_data: Boolean

    """Unique ID or name of users who has modified the metadata object."""
    modified_by_user_identifiers: [String]

    """Unique ID or name of users who is the owner of the metadata object."""
    owned_by_user_identifiers: [String]

    """The starting record number from where the records should be included."""
    record_offset: Int = 0

    """The number of records that should be included."""
    record_size: Int = 10

    """Sort options."""
    sort_options: SortOptions

    """Unique ID or name of tags."""
    tag_identifiers: [String]

    """Version of the metadata object."""
    version: Int
  ): [MetadataSearchResponse]!

  """Fetch SQL query for Liveboard visualizations."""
  fetchLiveboardSqlQuery(
    """Unique ID or name of the metadata."""
    metadata_identifier: String!

    """Unique ID or name of visualizations."""
    visualization_identifiers: [String]
  ): [SqlQueryResponse]!

  """Fetch SQL query for Answer."""
  fetchAnswerSqlQuery(
    """Unique ID or name of the metadata."""
    metadata_identifier: String!
  ): [SqlQueryResponse]!

  """Fetch data of Liveboard visualizations."""
  fetchLiveboardData(
    """Unique ID or name of the metadata."""
    metadata_identifier: String!

    """List of unique ID or name of visualizations."""
    visualization_identifiers: [String]

    """Transient content of the Liveboard."""
    transient_content: String

    """JSON output data format."""
    data_format: DataFormat = COMPACT

    """The starting record number from where the records should be included."""
    record_offset: Int = 0

    """The number of records that should be included."""
    record_size: Int = -1

    """JSON object representing filter condition to filter the data."""
    runtime_filter: JSON = ""

    """JSON object representing columns to sort the data."""
    runtime_sort: JSON = ""
  ): LiveboardDataResponse!

  """Fetch data of Answer."""
  fetchAnswerData(
    """Unique ID or name of the metadata."""
    metadata_identifier: String!

    """JSON output data format."""
    data_format: DataFormat = COMPACT

    """The starting record number from where the records should be included."""
    record_offset: Int = 0

    """The number of records that should be included."""
    record_size: Int = 10

    """JSON object representing filter condition to filter the data."""
    runtime_filter: JSON = ""

    """JSON object representing columns to sort the data."""
    runtime_sort: JSON = ""
  ): AnswerDataResponse!

  """Export report file for Liveboard visualization data."""
  exportLiveboardReport(
    """Unique ID or name of the metadata."""
    metadata_identifier: String!

    """Unique ID or name of visualizations."""
    visualization_identifiers: [String]!

    """Transient content of the Liveboard."""
    transient_content: String

    """Export file format."""
    file_format: FileFormat

    """JSON string representing runtime filter."""
    runtime_filter: JSON

    """JSON string representing runtime sort."""
    runtime_sort: JSON

    """Options for PDF export."""
    pdf_options: PdfOptionsInput
  ): Void

  """Export report file for Answer data."""
  exportAnswerReport(
    """Unique ID or name of the metadata."""
    metadata_identifier: String!

    """Export file format."""
    file_format: FileFormat = CSV

    """JSON string representing runtime filter."""
    runtime_filter: JSON

    """JSON string representing runtime sort."""
    runtime_sort: JSON

    """Options for PDF export."""
    pdf_options: PdfOptionsInput
  ): Void

  """Fetch permissions of principals (Users or Usergroups)."""
  fetchPermissionsOfPrincipals(
    """Principal details."""
    principals: [PrincipalsInput]!

    """
    Metadata objects considered while fetching permission of specified principals.
    If not provided then all applicable metadata objects are considered.
    """
    metadata: [MetadataTypeInput]
  ): JSON!

  """Fetch permissions on metadata objects."""
  fetchPermissionsOnMetadata(
    """Metadata objects."""
    metadata: [MetadataTypeInput]!

    """
    Principal details considered while fetching permission on metadata objects.
    If not provided then all applicable principals are considered.
    """
    principals: [PrincipalsInput]

    """Indicates whether to fetch permissions of depedent metadata objects."""
    include_dependent_objects: Boolean
  ): JSON!
  searchData(
    """Data search query string."""
    query_string: String!

    """Unique ID of data object (worksheet, view, or a table)"""
    logical_table_identifier: String!

    """JSON output data format."""
    data_format: DataFormat

    """The starting record number from where the records should be included."""
    record_offset: Int = 0

    """The number of records that should be included."""
    record_size: Int = 10
  ): LiveboardDataResponse!

  """Fetch Log details"""
  fetchLogs(
    """Name of the log type."""
    log_type: LogType!

    """Start epoc time in milli seconds."""
    start_epoc_time_in_millis: Float

    """End epoc time in milli seconds."""
    end_epoc_time_in_millis: Float
  ): [LogResponse]!
}

type Mutation {
  """
  You can programmatically create login session for a user in ThoughtSpot using this endpoint. 
  
  You can create session by either providing userName and password as inputs in this request body or by including "Authorization" header with the token generated through the endpoint /tspublic/rest/v2/session/gettoken. 
  
  userName and password input is given precedence over "Authorization" header, when both are included in the request.
  """
  login(
    """Username of the user account"""
    username: String

    """The password of the user account"""
    password: String

    """
    A flag to remember the user session. When set to true, sets a session cookie that persists in subsequent API calls.
    """
    remember_me: Boolean
  ): Void

  """
   To programmatically create session token for a user in ThoughtSpot, use this endpoint. 
  
  You can generate the token for a user by providing password or secret key from the cluster. 
  
  You need to enable trusted authentication to generate secret key. To generate secret key, follow below steps. 
  
  
   1. Click the Develop tab. 
  
  
   2. Under Customizations, click Settings. 
  
  
   3. To enable trusted authentication, turn on the toggle. 
  
  
   4. A secret_key for trusted authentication is generated. 
  
  
   5. Click the clipboard icon to copy the token. 
  
  
   
  
  Password is given precedence over secretKey input, when both are included in the request.
  """
  getObjectAccessToken(
    """Username of the user account"""
    username: String!

    """
    GUID of the ThoughtSpot object. If set, the bearer will only have access to the specified Liveboard or another object.
    """
    object_id: String!

    """The password of the user account"""
    password: String = ""

    """
    The secret key string provided by the ThoughtSpot application server. ThoughtSpot generates this secret key when you enable trusted authentication.
    """
    secret_key: String = ""

    """Duration in seconds after which the token expires"""
    validity_time_in_sec: Int = 300

    """
    Id of the Org to be associated with the user login. If no input is provided then last logged in Org will be considered
    """
    org_id: Int = 0

    """
    “user_options” attribute is added as an optional attribute which will allow JIT token support
    """
    auto_create: Boolean = false

    """
    Unique ID or name of the User Groups to which newly created user to be added.
    """
    group_identifiers: [String]
  ): Token!

  """
   To programmatically create session token for a user in ThoughtSpot, use this endpoint. 
  
  You can generate the token for a user by providing password or secret key from the cluster. 
  
  You need to enable trusted authentication to generate secret key. To generate secret key, follow below steps. 
  
  
   1. Click the Develop tab. 
  
  
   2. Under Customizations, click Settings. 
  
  
   3. To enable trusted authentication, turn on the toggle. 
  
  
   4. A secret_key for trusted authentication is generated. 
  
  
   5. Click the clipboard icon to copy the token. 
  
  
   
  
  Password is given precedence over secretKey input, when both are included in the request.
  """
  getFullAccessToken(
    """Username of the user account"""
    username: String!

    """The password of the user account"""
    password: String = ""

    """
    The secret key string provided by the ThoughtSpot application server. ThoughtSpot generates this secret key when you enable trusted authentication.
    """
    secret_key: String = ""

    """Duration in seconds after which the token expires"""
    validity_time_in_sec: Int = 300

    """
    Id of the Org to be associated with the user login. If no input is provided then last logged in Org will be considered
    """
    org_id: Int = 0

    """
    user_options attribute is added as an optional attribute which will allow JIT token support
    """
    auto_create: Boolean = false

    """
    Unique ID or name of the User Groups to which newly created user to be added.
    """
    group_identifiers: [String]
  ): Token!

  """To log a user out of the current session, use this endpoint"""
  logout: Void

  """To expire or revoke a token for a user, use this endpoint"""
  revokeToken(user_identifier: String, token: String): Void

  """
  To programmatically create a user account in the ThoughtSpot system use this API endpoint. Using this API, you can create a user and assign groups.
  To create a user, you require admin user privileges.
  """
  createUser(
    """Name of the user. The username string must be unique."""
    name: String!

    """
    A unique display name string for the user account, usually their first and last name
    """
    display_name: String!

    """Password for the user account."""
    password: String!

    """Email of the user account"""
    email: String!

    """Type of the account."""
    account_type: AccountType = LOCAL_USER

    """Current status of the user account."""
    account_status: AccountStatus = ACTIVE

    """List of Unique Org Identifiers to be associated with"""
    org_identifiers: [String]

    """List of user-group to be associated with"""
    group_identifiers: [String]

    """
    Visibility of the user. The visibility attribute is set to DEFAULT when creating a user. The DEFAULT attribute makes a user visible to other users and user groups, and this allows them to share objects
    """
    visibility: Visibility = SHARABLE

    """
    User preference for receiving email notifications when another ThoughtSpot user shares answers or pinboards.
    """
    notify_on_share: Boolean = true

    """The user preference for revisiting the onboarding experience."""
    show_onboarding_experience: Boolean = true

    """flag to get the on-boarding experience is completed or not."""
    onboarding_experience_completed: Boolean = false

    """to set GUID for home live board."""
    home_liveboard_identifier: String

    """Metadata objects to be assigned as favorites for the imported user."""
    favorite_metadata: [FavoriteMetadataInput]
  ): User!

  """
  To programmatically update a user account in the ThoughtSpot system use this API endpoint.
  Using this API, you can update a user and assign groups.
  To update a user, you require admin user privileges.
  """
  updateUser(
    """GUID / name of the user to be updated"""
    user_identifier: String!

    """Name of the user. The username string must be unique."""
    name: String

    """
    A unique display name string for the user account, usually their first and last name
    """
    display_name: String

    """
    Visibility of the user. The visibility attribute is set to DEFAULT when creating a user. The DEFAULT attribute makes a user visible to other users and user groups, and this allows them to share objects
    """
    visibility: Visibility

    """Email of the user account"""
    email: String

    """Current status of the user account."""
    account_status: AccountStatus

    """
    User preference for receiving email notifications when another ThoughtSpot user shares answers or pinboards.
    """
    notify_on_share: Boolean

    """The user preference for revisiting the onboarding experience."""
    show_onboarding_experience: Boolean

    """flag to get the on-boarding experience is completed or not."""
    onboarding_experience_completed: Boolean

    """Type of the account."""
    account_type: AccountType

    """List of user-group to be associated with"""
    group_identifiers: [String]

    """to set GUID for home live board."""
    home_liveboard_identifier: String

    """Metadata objects to be assigned as favorites for the imported user."""
    favorite_metadata: [FavoriteMetadataInput]

    """List of Unique Org Identifiers to be associated with"""
    org_identifiers: [String]
  ): Void

  """
  To programmatically delete a user account in the ThoughtSpot system use this API endpoint.
  Using this API, you can delete by passing GUID / name of the user.
  To delete a user, you require admin user privileges.
  """
  deleteUser(
    """GUID / name of the user to be deleted"""
    user_identifier: String!
  ): Void

  """
  To programmatically import users accounts in the ThoughtSpot system use this API endpoint.
  Using this API, you can import multiple users.
  """
  importUsers(
    """List of users needs to be imported."""
    users: [ImportUser]!

    """
    Default password to be set if password field not present in above import user like first one
    """
    default_password: String

    """
    If true, This will preview the impacted users, but changes won't applied into the system
    """
    dry_run: Boolean = true

    """
    if true, this api will delete all other users specified in above users list. Some important users like tsadmin, guest, system and su will be ignored.
    """
    delete_unspecified_users: Boolean = false
  ): ImportUsersResponse

  """Change user password"""
  changeUserPassword(
    """Current password of the user."""
    current_password: String!

    """New password for the user."""
    new_password: String!

    """Unique ID or name of the user."""
    user_identifier: String!
  ): Void

  """Reset user password"""
  resetUserPassword(
    """New password for the user."""
    new_password: String!

    """Unique ID or name of the user."""
    user_identifier: String!
  ): Void

  """Force logout users session"""
  forceLogoutUsers(
    """Unique ID or name of the users for force logging out their sessions."""
    user_identifiers: [String]!
  ): Void

  """
  To programmatically create an Org in the ThoughtSpot system use this API endpoint.
  """
  createOrg(
    """Name of the Org."""
    name: String!

    """Description of the Org."""
    description: String
  ): OrgResponse!

  """
  To programmatically update an Org in the ThoughtSpot system use this API endpoint.
  """
  updateOrg(
    """identifier for the Org: Either unique id or unique name of the Org."""
    org_identifier: String!

    """Name of the Org."""
    name: String

    """Description of the Org."""
    description: String

    """Add Users to an Org."""
    user_identifiers: [String]
  ): Void

  """
  To programmatically delete an Org in the ThoughtSpot system use this API endpoint.
  """
  deleteOrg(
    """
    Org identifier for the Org: Either unique id or unique name of the Org.
    """
    org_identifier: String!
  ): Void

  """
  To programmatically create a tag in the ThoughtSpot system, use this API endpoint.
  """
  createTag(
    """Name of the tag."""
    name: String!

    """Hex color code to be assigned to the tag. Example, Input: #ff78a9."""
    color: String!
  ): Tag

  """
  To programmatically update tags, use this endpoint. Specify either tag id or tag name
  """
  updateTag(
    """Name or Id of the tag."""
    tag_identifier: String!

    """Name of the tag."""
    name: String

    """Hex color code to be assigned to the tag. Example, Input: #ff78a9"""
    color: String
  ): Void

  """
  To programmatically delete tags, use this endpoint. Specify either tag id or tag name
  """
  deleteTag(
    """Tag identifier Tag name or Tag id."""
    tag_identifier: String!
  ): Void

  """Assign tags to metadata objects"""
  assignTag(
    """Metadata objects."""
    metadata: [TagMetadataTypeInput]!

    """Unique ID or name of tags."""
    tag_identifiers: [String]!
  ): Void

  """Unassign tags to metadata objects"""
  unassignTag(
    """Metadata objects."""
    metadata: [TagMetadataTypeInput]!

    """Unique ID or name of tags."""
    tag_identifiers: [String]!
  ): Void

  """Create a User Group from the current org"""
  createUserGroup(
    """Name of the user group. The user group name must be unique."""
    name: String!

    """Unique display name for the user group."""
    display_name: String!

    """
    Unique ID of liveboards which will be assigned as default liveboards to the user group.
    """
    default_liveboard_identifiers: [String]

    """Description for the user group."""
    description: String

    """Privileges which will be assigned to the user group."""
    privileges: [Privileges]

    """
    Unique ID or name of the User Groups who will be part of the user group.
    """
    sub_group_identifiers: [String]

    """Type of the user group."""
    type: GroupType = LOCAL_GROUP

    """Unique ID or name of the Users who will be part of the user group."""
    user_identifiers: [String]

    """
    Visibility of the user group. The SHARABLE makes a user group visible to other users and user groups, and thus 
    allows them to share objects.
    """
    visibility: Visibility = SHARABLE
  ): UserGroupResponse!

  """Update the user group"""
  updateUserGroup(
    """Unique ID or name of the user group."""
    group_identifier: String!

    """Name of the user group. The user group name must be unique."""
    name: String

    """
    Unique ID of liveboards which will be assigned as default liveboards to the user group.
    """
    default_liveboard_identifiers: [String]

    """Description for the user group."""
    description: String

    """Unique display name for the user group."""
    display_name: String

    """Privileges which will be assigned to the user group."""
    privileges: [Privileges]

    """
    Unique ID or name of the User Groups who will be part of the user group.
    """
    sub_group_identifiers: [String]

    """Type of the user group."""
    type: GroupType

    """Unique ID or name of the Users who will be part of the user group."""
    user_identifiers: [String]

    """
    Visibility of the user group. The SHARABLE makes a user group visible to other users and user groups, and thus 
    allows them to share objects.
    """
    visibility: Visibility
  ): Void

  """Deletes a user group from the current org"""
  deleteUserGroup(
    """Unique ID or name of the user group."""
    group_identifier: String!
  ): Void

  """Import user groups to the current org"""
  importUserGroups(
    """Details of user groups which are to be imported"""
    groups: [GroupsImportListInput]

    """
    Option to remove any existing groups from system which are not specified in the input request.
    """
    delete_unspecified_groups: Boolean

    """Option to dry or mock run of operation without importing any objects."""
    dry_run: Boolean
  ): ImportUserGroupsResponse

  """Import metadata objects using specified TMLs"""
  importMetadata(
    """Details of metadata object TMLs."""
    metadata_tmls: [String]!

    """Import policy."""
    import_policy: ImportPolicy

    """Indicates whether object represented in TMLs to be newly created."""
    create_new: Boolean = false
  ): Void

  """Export metadata objects TMLs"""
  exportMetadata(
    """Metadata objects."""
    metadata: [MetadataTypeInput]!

    """TML EDOC content format."""
    edoc_format: EdocFormat = YAML

    """
    Indicates whether to export associated metadata objects of specified metadata objects.
    """
    export_associated: Boolean = false

    """Indicates whether to include GUID (FQN) of specified metadata objects."""
    export_fqn: Boolean = false
  ): [JSON]!

  """Deletes metadata objects"""
  deleteMetadata(
    """Metadata objects."""
    metadata: [MetadataTypeInput]!

    """Indicates whether to delete disabled metadata objects."""
    delete_disabled_objects: Boolean = false
  ): Void

  """Assign new or change existing authors of metadata objects."""
  assignChangeAuthor(
    """Metadata objects."""
    metadata: [MetadataTypeInput]!

    """
    Unique ID or name of the user who will be new author of the metadata objects.
    """
    user_identifier: String!

    """
    Unique ID or name of the current owner of metadata objects.
    Metadata objects matching specified current owner will be considered.
    """
    current_owner_identifier: String
  ): Void

  """Share metadata objects with users or user groups."""
  shareMetadata(
    """Type of metadata."""
    metadata_type: MetadataType!

    """Unique ID or name of metadata objects."""
    metadata_identifiers: [String]!

    """Permission details for sharing the objects."""
    permissions: [SharePermissionsInput]!

    """Options to specify details of Liveboard."""
    visualization_identifiers: [String]

    """Email IDs to which notifications will be sent."""
    emails: [String]

    """Message to be included in notification."""
    message: String

    """Indicates whether to customize the URLs in the notification content."""
    enable_custom_url: Boolean = false
  ): Void
}

type User {
  """Unique identifier of the user."""
  id: String!

  """Name of the user."""
  name: String!

  """Display name of the user."""
  display_name: String!

  """
  Visibility of the users. The SHARABLE makes a users visible to other users and user groups, and thus allows them to share objects.
  """
  visibility: Visibility!

  """Unique identifier of author of the user."""
  author_id: String

  """Indicates whether the user can change their password."""
  can_change_password: Boolean

  """Indicates whether the response has complete detail of the user."""
  complete_detail: Boolean

  """Creation time of the user in milliseconds."""
  creation_time_in_millis: Float

  """Current logged in Organizations of the user."""
  current_org: Org

  """Indicates whether the user is deleted."""
  deleted: Boolean

  """Indicates whether the user is deprecated."""
  deprecated: Boolean

  """Type of the user account."""
  account_type: AccountType

  """Status of the user account."""
  account_status: AccountStatus

  """Email of the user."""
  email: String

  """Expiration time of the user in milliseconds."""
  expiration_time_in_millis: Float

  """Indicates whether the user is external."""
  external: Boolean

  """Metadata objects to be assigned as favorites for the imported user."""
  favorite_metadata: [FavoriteMetadataItem]

  """First login time of the user in milliseconds."""
  first_login_time_in_millis: Float

  """Group mask of the user."""
  group_mask: Int

  """Indicates whether the user is hidden."""
  hidden: Boolean

  """Unique ID or name of the users home liveboard."""
  home_liveboard: Object_ID_And_Name

  """Incomplete details of user if any present."""
  incomplete_details: JSON

  """Indicates whether it is first login of the user."""
  is_first_login: Boolean

  """Last modified time of the user in milliseconds."""
  modification_time_in_millis: Float

  """Unique identifier of modifier of the user."""
  modifier_id: String

  """
  User preference for receiving email notifications on shared answers or liveboard.
  """
  notify_on_share: Boolean

  """The user preference for turning off the onboarding experience."""
  onboarding_experience_completed: Boolean

  """Organizations in which user exists."""
  orgs: [Org]

  """Unique identifier of owner of the user."""
  owner_id: String

  """Parent type of the user."""
  parent_type: ParentType

  """Privileges which are assigned to the user."""
  privileges: [Privileges]

  """The user preference for revisiting the onboarding experience."""
  show_onboarding_experience: Boolean

  """Indicates whether the user is a super user."""
  super_user: Boolean

  """Indicates whether the user is a system user."""
  system_user: Boolean

  """Tags associated with the user."""
  tags: [Object_ID_And_Name]

  """Unique identifier of tenant of the user."""
  tenant_id: String

  """User Groups which the user is part of."""
  user_groups: [Object_ID_And_Name]

  """Inherited User Groups which the user is part of."""
  user_inherited_groups: [Object_ID_And_Name]

  """Indicates whether welcome email is sent for the user."""
  welcome_email_sent: Boolean
}

enum Privileges {
  ADMINISTRATION
  AUTHORING
  USERDATAUPLOADING
  DATADOWNLOADING
  USERMANAGEMENT
  SECURITYMANAGEMENT
  LOGICALMODELING
  DATAMANAGEMENT
  TAGMANAGEMENT
  SHAREWITHALL
  SYSTEMMANAGEMENT
  JOBSCHEDULING
  A3ANALYSIS
  EXPERIMENTALFEATUREPRIVILEGE
  BYPASSRLS
  RANALYSIS
  DISABLE_PINBOARD_CREATION
  DEVELOPER
  APPLICATION_ADMINISTRATION
  USER_ADMINISTRATION
  GROUP_ADMINISTRATION
  BACKUP_ADMINISTRATION
  SYSTEM_INFO_ADMINISTRATION
  ENABLESPOTAPPCREATION
  SYNCMANAGEMENT
}

enum AccountType {
  LOCAL_USER
  LDAP_USER
  SAML_USER
  OIDC_USER
  REMOTE_USER
}

enum AccountStatus {
  ACTIVE
  INACTIVE
  EXPIRED
  LOCKED
  PENDING
}

input FavoriteMetadataInput {
  type: FavoriteMetadata
  identifier: String
}

input ImportUser {
  name: String!
  display_name: String!
  password: String!
  account_type: AccountType
  account_status: AccountStatus
  email: String!
  org_identifiers: [String]
  group_identifiers: [String]
  visibility: Visibility
  notify_on_share: Boolean
  show_onboarding_experience: Boolean
  onboarding_experience_completed: Boolean
  home_liveboard_identifier: String
  favorite_metadata: [FavoriteMetadataInput]
}

type ImportUsersResponse {
  users_added: [ImportUserType]
  users_updated: [ImportUserType]
  users_deleted: [ImportUserType]
}

enum OrgScope {
  ALL
}

enum Visibility {
  SHARABLE
  NON_SHARABLE
}

enum GroupType {
  LOCAL_GROUP
  LDAP_GROUP
}

type UserGroup {
  id: String
  name: String
}

enum ParentType {
  USER
  GROUP
}

input VisualizationIdentifiersInput {
  """Unique ID or name of the visualization."""
  identifier: String
}

enum MetadataType {
  LIVEBOARD
  ANSWER
  LOGICAL_TABLE
  LOGICAL_COLUMN
  CONNECTION
  TAG
  USER
  USER_GROUP
  LOGICAL_RELATIONSHIP
}

input MetadataTypeInput {
  """Type of metadata."""
  type: MetadataType!

  """Unique ID or name of the metadata."""
  identifier: String!
}

enum ImportPolicy {
  PARTIAL
  ALL_OR_NONE
  VALIDATE_ONLY
}

enum ShareMode {
  READ_ONLY
  MODIFY
  NO_ACCESS
}

input PrincipalsInput {
  """Unique ID or name of the principal."""
  identifier: String!

  """Principal type."""
  type: Principals!
}

enum Principals {
  USER
  USER_GROUP
}

input SharePermissionsInput {
  """Details of users or user groups."""
  principal: PrincipalsInput!

  """Object share mode."""
  share_mode: ShareMode!
}

enum DataFormat {
  COMPACT
  FULL
}

input RiseSetter {
  field: String!
  path: String!
}

type SystemInfo {
  """The unique identifier of the object"""
  id: String

  """Name of the cluster."""
  name: String

  """The release version of the cluster."""
  release_version: String

  """The timezone of the cluster."""
  time_zone: String

  """The default locale of the cluster."""
  locale: String

  """The default date format representation of the cluster."""
  date_format: String

  """The API version of the cluster."""
  api_version: String

  """The deployment type of the cluster."""
  type: String

  """The deployed environment of the cluster."""
  environment: String

  """The license applied to the cluster."""
  license: String

  """The default date time format representation of the cluster."""
  date_time_format: String

  """The default time format representation of the cluster."""
  time_format: String

  """The unique identifier of system user."""
  system_user_id: String

  """The unique identifier of super user."""
  super_user_id: String

  """The unique identifier of hidden object."""
  hidden_object_id: String

  """The unique identifier of system group."""
  system_group_id: String

  """The unique identifier of tsadmin user."""
  tsadmin_user_id: String

  """The unique identifier of admin group."""
  admin_group_id: String

  """The unique identifier of all tables connection."""
  all_tables_connection_id: String

  """The unique identifier of ALL user group."""
  all_user_group_id: String

  """The count of users of ALL user group."""
  all_user_group_member_user_count: Int

  """The supported accept language by the cluster."""
  accept_language: String

  """The version number of logical model of the cluster."""
  logical_model_version: Int
}

type SystemConfig {
  getStartedLink: String
}

type OrgResponse {
  """Unique identifier of the organization."""
  id: Int

  """Name of the organization."""
  name: String

  """Status of the organization."""
  status: OrgStatus

  """Description of the organization."""
  description: String

  """Visibility of the organization."""
  visibility: OrgVisibility
}

enum OrgVisibility {
  SHOW
  HIDDEN
}

enum OrgStatus {
  ACTIVE
  IN_ACTIVE
}

type Tag {
  name: String!
  id: String!
  color: String!
  deleted: Boolean
  hidden: Boolean
  external: Boolean
  deprecated: Boolean
  creation_time_in_millis: Float
  modification_time_in_millis: Float
  author_id: String
  modifier_id: String
  owner_id: String
}

type UserGroupResponse {
  """The unique identifier of the object"""
  author_id: String

  """Indicates whether the response has complete detail of the user group."""
  complete_detail: Boolean

  """Content details of the user group."""
  content: JSON

  """Creation time of the user group in milliseconds."""
  creation_time_in_millis: Float

  """Liveboards which are assigned as default liveboards to the user group."""
  default_liveboards: [UserGroup]

  """Indicates whether the user group is deleted."""
  deleted: Boolean

  """Indicates whether the user group is deprecated."""
  deprecated: Boolean

  """Description of the user group."""
  description: String

  """Display name of the user group."""
  display_name: String!

  """Indicates whether the user group is external."""
  external: Boolean

  """Generation number of the user group."""
  generation_number: Int

  """Indicates whether the user group is hidden."""
  hidden: Boolean

  """The unique identifier of the object"""
  id: String!

  """Index number of the user group."""
  index: Int

  """Index version number of the user group."""
  index_version: Int

  """Metadata version number of the user group."""
  metadata_version: Int

  """Last modified time of the user group in milliseconds."""
  modification_time_in_millis: Float

  """The unique identifier of the object"""
  modifier_id: String

  """Name of the user group."""
  name: String!

  """Orgs in which user group exists."""
  orgs: [UserGroup]

  """The unique identifier of the object"""
  owner_id: String

  """Parent type of the user group."""
  parent_type: ParentType

  """Privileges which are assigned to the user group."""
  privileges: [Privileges]

  """User Groups who are part of the user group."""
  sub_groups: [UserGroup]

  """Indicates whether the user group is a system group."""
  system_group: Boolean

  """Tags associated with the user group."""
  tags: [UserGroup]

  """Type of the user group."""
  type: GroupType

  """Users who are part of the user group."""
  users: [UserGroup]

  """
  Visibility of the user group. The SHARABLE makes a user group visible to other users and user groups, and thus allows them to share objects.
  """
  visibility: Visibility!
}

"""Metadata Search Response Object."""
type MetadataSearchResponse {
  """Unique identifier of the metadata."""
  metadata_id: String!

  """Name of the metadata."""
  metadata_name: String!

  """Type of the metadata."""
  metadata_type: MetadataType!

  """Details of dependent objects of the metadata objects."""
  dependent_objects: JSON

  """Details of incomplete information of the metadata objects if any."""
  incomplete_objects: [JSON]

  """Complete details of the metadata objects."""
  metadata_detail: JSON

  """Header information of the metadata objects."""
  metadata_header: JSON

  """Visualization header information of the metadata objects."""
  visualization_headers: [JSON]
}

input MetadataListItemInput {
  """Unique ID or name of the metadata."""
  identifier: String

  """
  A pattern to match case-insensitive name of the metadata object. User % for a wildcard match.
  """
  name_pattern: String

  """Type of metadata."""
  type: MetadataType
}

"""Details of users or user groups."""
input PermissionInput {
  """Details of users or user groups."""
  principal: PrincipalsInput

  """Object share mode."""
  share_mode: ShareMode
}

enum DependentObjectVersion {
  V1
  V2
}

input ExcludeMetadataListItemInput {
  """Unique ID or name of the metadata."""
  identifier: String

  """Type of metadata."""
  type: MetadataType
}

"""Favorite object options."""
input FavoriteObjectOptionsInput {
  """Only include object marked as favorite."""
  include: Boolean

  """Unique ID or name of the users."""
  user_identifiers: String
}

"""Sort options."""
input SortOptions {
  """Name of the field to apply the sort on."""
  field_name: FieldName

  """Sort order : ASC(Ascending) or DESC(Descending)."""
  order: Order
}

"""Response format associated with fetch SQL query api"""
type SqlQueryResponse {
  id: String!
  name: String!
  sql_queries: String!
}

type LiveboardDataResponse {
  """The unique identifier of the object"""
  metadata_id: String!

  """Name of the metadata."""
  metadata_name: String!

  """Data content of metadata objects."""
  contents: [LiveboardContent]!
}

"""Response format associated with fetch data api"""
type AnswerDataResponse {
  """The unique identifier of the object"""
  metadata_id: String!

  """Name of the metadata."""
  metadata_name: String!

  """Data content of metadata objects."""
  contents: [AnswerContent]!
}

enum FileFormat {
  CSV
  PDF
  PNG
  XLSX
}

input PdfOptionsInput {
  """Indicates whether to include cover page with the Liveboard title."""
  include_cover_page: Boolean

  """
  Indicates whether to include customized wide logo in the footer if available.
  """
  include_custom_logo: Boolean

  """Indicates whether to include a page with all applied filters."""
  include_filter_page: Boolean

  """Indicates whether to include page number in the footer of each page."""
  include_page_number: Boolean

  """Text to include in the footer of each page."""
  page_footer_text: String

  """Page orientation of the PDF."""
  page_orientation: PageOrientation

  """Indicates whether to include only first page of the tables."""
  truncate_table: Boolean
}

type LogResponse {
  """Date timestamp of the log entry"""
  date: String!

  """Log data"""
  log: String!
}

enum LogType {
  SECURITY_AUDIT
}

type Token {
  """Bearer auth token."""
  token: String!

  """Token creation time in milliseconds."""
  creation_time_in_millis: Float!

  """Token expiration time in milliseconds."""
  expiration_time_in_millis: Float!

  """Token access scope details"""
  scope: Scope!

  """Username to whom the token is issued."""
  valid_for_user_id: String!

  """Unique identifier of the user to whom the token is issued."""
  valid_for_username: String!
}

input TagMetadataTypeInput {
  """Type of metadata."""
  type: TagMetadataType!

  """Unique ID or name of the metadata."""
  identifier: String!
}

type ImportUserGroupsResponse {
  """The user groups which are added into the system."""
  groups_added: [UserGroup]!

  """The user groups which are deleted from the system."""
  groups_deleted: [UserGroup]!

  """The user groups which are updated in the system."""
  groups_updated: [UserGroup]!
}

input GroupsImportListInput {
  """Unique display name of the user group."""
  display_name: String!

  """Unique ID or name of the User Group."""
  group_identifier: String!

  """
  Unique ID of liveboards which will be assigned as default liveboards to the user group.
  """
  default_liveboard_identifiers: [String]

  """Description of the user group."""
  description: String

  """Privileges which will be assigned to the user group."""
  privileges: [Privileges]

  """
  Unique ID or name of the User Groups who will be part of the user group.
  """
  sub_group_identifiers: [String]

  """Type of the user group."""
  type: GroupType

  """Unique ID or name of the Users who will be part of the user group."""
  user_identifiers: [String]

  """
  Visibility of the user group. The SHARABLE makes a user group visible to other users and user groups, and thus allows them to share objects.
  """
  visibility: Visibility
}

enum EdocFormat {
  JSON
  YAML
}

"""Current logged in Organizations of the user."""
type Org {
  """The ID of the object."""
  id: Int!

  """Name of the object."""
  name: String!
}

type FavoriteMetadataItem {
  """Unique ID of the metadata."""
  id: String!

  """name of the metadata."""
  name: String!

  """Type of metadata."""
  type: MetadataType!
}

"""The object representation with ID and Name."""
type Object_ID_And_Name {
  """The unique identifier of the object."""
  id: String

  """Name of the object."""
  name: String
}

enum FavoriteMetadata {
  LIVEBOARD
  ANSWER
  LOGICAL_TABLE
  CONNECTION
  DATA_SOURCE
}

type ImportUserType {
  """Unique identifier of the user."""
  id: String!

  """Name of the user."""
  name: String!
}

enum FieldName {
  NAME
  DISPLAY_NAME
  AUTHOR
  CREATED
  MODIFIED
  LAST_ACCESSED
  SYNCED
  VIEWS
  NONE
  USER_STATE
  ROW_COUNT
}

enum Order {
  ASC
  DESC
}

type LiveboardContent {
  """Total available data row count."""
  available_data_row_count: Int!

  """Name of the columns."""
  column_names: [String]!

  """Rows of data set."""
  data_rows: [JSON]!

  """The starting record number from where the records should be included."""
  record_offset: Int!

  """The number of records that should be included."""
  record_size: Int!

  """Total returned data row count."""
  returned_data_row_count: Int!

  """
  Sampling ratio (0 to 1). If the query was sampled, it is the ratio of keys returned in the data set to the total number of keys expected in the query. If the value is 1.0, this means that the complete result is returned.
  """
  sampling_ratio: Float!

  """Unique ID of the visualization."""
  visualization_id: String

  """Name of the visualization."""
  visualization_name: String
}

type AnswerContent {
  """Total available data row count."""
  available_data_row_count: Int!

  """Name of the columns."""
  column_names: [String]!

  """Rows of data set."""
  data_rows: [JSON]!

  """The starting record number from where the records should be included."""
  record_offset: Int!

  """The number of records that should be included."""
  record_size: Int!

  """Total returned data row count."""
  returned_data_row_count: Int!

  """
  Sampling ratio (0 to 1). If the query was sampled, it is the ratio of keys returned in the data set to the total number of keys expected in the query. If the value is 1.0, this means that the complete result is returned.
  """
  sampling_ratio: Float!
}

enum PageOrientation {
  PORTRAIT
  LANDSCAPE
}

type Scope {
  """Object access scope type."""
  access_type: String!

  """Unique identifier of the metadata."""
  org_id: Int

  """Unique identifier of the organization."""
  metadata_id: String
}

enum TagMetadataType {
  LIVEBOARD
  ANSWER
  LOGICAL_TABLE
  LOGICAL_COLUMN
}
